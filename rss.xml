<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Kotlin Programming Language]]></title><description><![CDATA[News, blog posts, projects, podcasts, videos and other. All information about Kotlin.]]></description><link>http://kotlin.link/</link><image><url>http://kotlin.link/favicon.ico</url><title>Kotlin Programming Language</title><link>http://kotlin.link/</link></image><generator>node-rss</generator><lastBuildDate>Fri, 02 Sep 2016 12:44:30 GMT</lastBuildDate><atom:link href="http://kotlin.link/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Fri, 02 Sep 2016 12:44:24 GMT</pubDate><copyright><![CDATA[CC0 1.0 Universal (CC0 1.0)]]></copyright><language><![CDATA[en]]></language><managingEditor><![CDATA[ruslan@ibragimov.by (Ruslan Ibragimov)]]></managingEditor><webMaster><![CDATA[ruslan@ibragimov.by (Ruslan Ibragimov)]]></webMaster><docs>https://validator.w3.org/feed/docs/rss2.html</docs><ttl>30</ttl><category><![CDATA[Kotlin]]></category><category><![CDATA[Programming]]></category><category><![CDATA[JVM]]></category><item><title><![CDATA[Building DSL Instead of an IDE Plugin]]></title><description><![CDATA[<p>An alternative way of doing IDE support without any IDE plugin code for not yet supported and specific languages.</p>
<h1>Problem Statement</h1>
<p>Most of us use quite smart IDEs daily with languages we use for development. IDE helps us not only
to highlight keywords. It is able to check types, show errors, do refactoring, complete and analyze code.</p>
<p>Of course we spent some time working with languages that are not (or weakly) supported by an IDE. Those languages
could be used for configurations files, logger settings, business rules, scripts, text files and so on.
This is a specific domain where a language is used. It can be hard to read code on that language, it can
be also hard to write it too. One may easily waste time writing incorrect code.</p>
<p>It's the lack of decent IDE support for such languages. Let's see how we can solve it</p>
<p>I will use \(Original Language\) term to refer to an unsupported language. </p>
<h1>A Trivial Solution</h1>
<p>Say we have an \(Original Language\) we use, and there is no decent support for it in IDE. </p>
<p>The very first solution is to replace the \(Original Language\) with some other language. </p>
<p>Suppose the \(Original Language\) cannot be thrown away. And it's likely there is a code on that language.
There has to be a system that accepts it too.</p>
<p>Okay. We may implement a plugin for our an IDE to support it.</p>
<p>Writing a plugin is a complicated task. One needs to know IDE API. Moreover, you'll implement a parsing
so that it'd be fast enough to play well in IDE. The parser should also support invalid text input too, e.g.
incorrect code that is being entered. That can be tricky.</p>
<p>Well, a parser may not be necessary, if, say IDE support some base language, e.g. <code>.properties</code> or <code>.xml</code> format.
But in that case a deep IDE APIs has to be used.</p>
<p>Finally, a plugin will depend on IDE. Meaning it has to be updated to work with newer IDE versions. It's not in
our control to lock an IDE version.</p>
<p>This can be done, but, there's an <strong>alternative way</strong>.</p>
<h1>The DSL Way</h1>
<p>Everyone uses their IDE. And of course there is a language we use daily. For example, it could be
<a href="http://www.oracle.com/technetwork/java/index.html">Java</a>,
<a href="http://www.scala-lang.org/">Scala</a>,
<a href="https://kotlinlang.org">Kotlin</a>,
<a href="https://golang.org/">Go</a>,
<a href="http://www.groovy-lang.org/">Groovy</a>.
We know for sure, an IDE is smart on those languages.</p>
<p>My idea is to an \(Original Language\), which is unsupported by an IDE, into a code in a supported language.
I will use a \(Target Language \) term for it. Next, run the
code to have a code in a \(Original Language\) back. As shown on the diagram below:</p>
<p><img src="https://i.imgur.com/w5a5xx5.png"></p>
<p>To implement it we need </p>
<ul>
<li>\(generator\), a program that reads a valid code in the \(Original Language\) and generates a code in the \(Target Language \)</li>
<li>\(API Library\), a peace of code that includes all definition required for a generated code to be more readable</li>
<li>\(execute\), a peace of code that makes compiled generated code in the \(Target Language \) to emit a code in the \(Original Language\)</li>
</ul>
<p>The goal of those transformations is to have a readable \(Generated Code \). Refactorings for \(Generated Code \)
in \(Target Language \) are projected to the \(Original Language\). </p>
<h1>Selecting a Target Language</h1>
<p>Most we need from a \( Target Language \) is a decent IDE support.</p>
<p>We shall select a \( Target Language \) with a good readability for everyone.
Languages with better DSL or fluent APIs capabilities are likely to play better.</p>
<p>Static typing is a nice to have. It makes it harder to make a error. Moreover,
it's likely to require no setup for an IDE to work. For some dynamic languages
an additional <a href="https://confluence.jetbrains.com/display/GRVY/Scripting+IDE+for+DSL+awareness">helper</a> may be required.</p>
<h1>The DSL Way Benefits</h1>
<p>The DSL Way approach projects all features from an \( Target Language \) into a \(Original Language\).
We can say an \(Original Language\) is extended with all possible high-level features of a \( Target Language \).
For example, we can use functions, loops, conditions, libraries and so on. There is no need to
have a support for such constructs in the \(Original Language\).
One may also tune a \(generator\) to say fold duplicates in the input into a loops or functions.</p>
<p>Thanks to \(API Library\) we have good readability. It's a creativity part here. But if implemented correctly,
it improves readability drastically.</p>
<p>The parsing is easier to implement for The DSL Way approach. We only need to have it supporting valid inputs. By induction,
we start with a valid code and generate a valid code. It's way more complex for The IDE Plugin case. </p>
<p>Refactorings and code analysis features for a \(Target Language \) are projected to a \(Original Language\). All
what is needed is to design \(API Library\) and \(generator\) in the right way. Say you need a <em>find usages</em>
for some domain object. To have it, you may make a \(generator\) declare and use a variable for such entities.
Once variables are used, rename feature is implemented for free.</p>
<h1>Example</h1>
<p>Let's consider <a href="http://logging.apache.org/log4j/1.2/">Log4j</a> configuration in <code>.properties</code> file as \(Original Language\).</p>
<pre><code class="hljs language-properties">log4j.rootLogger=ERROR,stdout
log4j.logger.corp.mega=INFO,stdout
# meaningful comment goes here
log4j.logger.corp.mega.itl.web.metrics=INFO

log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.<span class="hljs-keyword">layout</span>=org.apache.log4j.PatternLayout
log4j.appender.stdout.<span class="hljs-keyword">layout</span>.ConversionPattern=%p\t%d{ISO8601}\t%r\t%c\t[%t]\t%m%n</code></pre>
<p>I decided to use <a href="https://www.jetbrains.com/idea/">IntelliJ IDEA</a> as IDE
and <a href="https://kotlinlang.org">Kotlin</a> as \(Target Language \).</p>
<p>The configuration below can be turned into the following Kotlin code.</p>
<pre><code class="hljs language-kotlin">log4j {
  <span class="hljs-keyword">val</span> stdout = appender&#x3C;ConsoleAppender>(<span class="hljs-string">"stdout"</span>) {
    layout&#x3C;PatternLayout> {
      conversionPattern = <span class="hljs-string">"%p\t%d{ISO8601}\t%r\t%c\t[%t]\t%m%n"</span>
    }
  }

  rootLogger {
    level = ERROR
    appenders += stdout
  }

  logger(<span class="hljs-string">"corp.mega.itl.web.metrics"</span>) {
    level = INFO
  }

  logger(<span class="hljs-string">"corp.mega"</span>) {
    level = INFO
    appenders += stdout
  }
}</code></pre>
<p>The evaluation of this Kotlin program yields the similar <code>.properties</code> file back. </p>
<p>The DSL code is way easier to read and to write.</p>
<p>Thanks to Kotlin static typed DSLs, IntelliJ IDEA understands the code well, warns all incorrect usages,
code complete all possibilities. </p>
<p>Moreover, using such DSL is the way to implement automatic tests for your log4j configurations.
One may easily setup automatic tests task as a part of their continuous integration, since the code has no dependency on
an IDE part. </p>
<p>It opens the way to reuse common configuration files as well as to run. </p>
<h1>Conclusion</h1>
<p>In the post we discussed The DSL Way of doing an IDE support <strong>without</strong> writing any IDE related code.
The created DSL can be used not only with IDE. It can easily be re-used in any possible applications like code sharing,
automatic test, continuous integration and so on.</p>
<p>You may follow to <a href="http://jonnyzzz.com/blog/2016/03/08/gradle-for-dsl/">this post</a> for details on how to create decent package
for The DSL Way toolset</p>
<p><em>PS</em>. Do you have more examples for \(Original Language\)? Please share in comments below</p>
]]></description><link>http://jonnyzzz.com/blog/2016/09/02/dsl-building/</link><guid isPermaLink="true">http://jonnyzzz.com/blog/2016/09/02/dsl-building/</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[DSL]]></category><dc:creator><![CDATA[Eugene Petrenko]]></dc:creator><pubDate>Fri, 02 Sep 2016 03:04:00 GMT</pubDate></item><item><title><![CDATA[Kotlin census: call to action]]></title><description><![CDATA[<p>Many times we’re asked by people working with or planning to work with Kotlin, what our adoption rate is and who’s using Kotlin and what for.</p>
<p>While we do accept <a href="https://github.com/JetBrains/kotlin-web-site/blob/master/_data/companies-using-kotlin.yml">pull requests</a> and run into an occasional <em>tweet</em> we would really like to know first-hand from you, whether you’re using Kotlin in production and if so, how, and what issues you have faced. This not only helps us answer the question when someone asks about our adoption, but learn more about our community. With close to 4000 people on our <a href="http://kotlinslackin.herokuapp.com/">Kotlin Slack</a> alone, it’s hard to keep track of every piece of feedback!</p>
<p>As such, we’re asking you if you could kindly give us two minutes of your time and fill out the following survey. Please note that by providing us your details, you are not automatically giving us consent to use your name, application or company name. We would ask for written confirmation from you before doing so.</p>
<p>Thank you!</p>
<h3><a href="https://blog.jetbrains.com/kotlin/2016/09/kotlin-census-call-to-action/">Fill Out Survey</a></h3>
]]></description><link>https://blog.jetbrains.com/kotlin/2016/09/kotlin-census-call-to-action/</link><guid isPermaLink="true">https://blog.jetbrains.com/kotlin/2016/09/kotlin-census-call-to-action/</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Roman Belov]]></dc:creator><pubDate>Thu, 01 Sep 2016 04:14:00 GMT</pubDate></item><item><title><![CDATA[Natural testing with Kotlin]]></title><description><![CDATA[<p>There are dozens of programming languages that are used to build a software which runs on JVM. Languages like Groovy, Scala and Clojure are the well known already and now the new cool kid <a href="https://kotlinlang.org/">Kotlin</a> brings some more disruption into the Java world.</p>
<p>Kotlin is a statically typed, open source language from JetBrains. It has been around since 2011, but wasn't heavily used until last years. We have seen constant updates within 1.0.* versions and JetBrains has already announced the new 1.1 (EAP) version which brings more tools, such as type aliases, inline properties and coroutines. </p>
<p>The great thing about Kotlin is that it is 100% compatible with Java, you can mix Java and Kotlin with no extra effort! </p>
<p>After reading <a href="http://tengio.com/blog/more-readable-tests-with-kotlin/">the post</a> from @tengio I've tried to use Kotlin in writing <a href="https://github.com/vtorosyan/kotlin-spring-data-neo4j/tree/master/src/test/kotlin/com/examples/kotlin">tests</a> and found it suprisingely effective and natural. </p>
<p>To illustrate how Kotlin can be used to make testing easy and natural let's write some class which validates given password and write unit tests for it.</p>
<p>The requirements for the password are rather simple</p>
<ul>
<li>Password should contain only numbers and letters</li>
<li>Password should have more than 5 and less than 10 characters</li>
</ul>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PasswordValidator</span> </span>{
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">validate</span><span class="hljs-params">(String password)</span> </span>{ <span class="hljs-comment">/** ... */</span> }
}</code></pre>
<p>We don't need implementation details as we are doing TDD, so everything is ready to write some tests now!
There is an unofficial naming convention from <a href="http://osherove.com/blog/2005/4/3/naming-standards-for-unit-tests.html">R. Osherove</a> for unit tests which I've been using for a lot of years. Basically, the convention says that the name of the method should describe the unit of work, state under which the test is done, and expected behaviour.</p>
<pre><code>[UnitOfWork_StateUnderTest_ExpectedBehavior]
</code></pre>
<p>I've seen this convention in many projects and I believe that it is really human-driven, simply makes sense and the best one so far in Java(e.g. compared to standard given-when-then approach). Having that convention, we can have the following test specifications</p>
<pre><code class="hljs language-java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">validate_PasswordWith6CharsContainingNumbersAndDigits_ReturnTrue</span><span class="hljs-params">()</span> </span>{}

<span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">validate_PasswordWith5CharsContainingNumbersAndDigits_ReturnFalse</span><span class="hljs-params">()</span> </span>{}

<span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">validate_PasswordWith6CharsContainingBrackets_ReturnFalse</span><span class="hljs-params">()</span> </span>{}

<span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">validate_PasswordWith5CharsContainingBrackets_ReturnFalse</span><span class="hljs-params">()</span> </span>{}</code></pre>
<p>Now let's write the same test specifications using Kotlin. In Kotlin, you can use backticks(<code></code>) to name your methods or classes as you like. For example if we transform our <code>PasswordValidator</code> class from Java to Kotlin, it can look like</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> `<span class="hljs-title">Password</span> <span class="hljs-title">Validator</span>`</span>() {
	<span class="hljs-function"><span class="hljs-keyword">fun</span> `validate given password`<span class="hljs-params">()</span></span> { <span class="hljs-comment">/** ... */</span> }
} </code></pre>
<p>Obviously, this is not something convenient and we won't do it, but we'll use it in our test specifications.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> `Validate password and return <span class="hljs-literal">true</span> <span class="hljs-keyword">when</span> the parameter has 6 chars and contains only numbers and digits`<span class="hljs-params">()</span></span> {}

<span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> `Validate password and return <span class="hljs-literal">false</span> <span class="hljs-keyword">when</span> the parameter has 5 chars and contains only numbers and digits`<span class="hljs-params">()</span></span> {}

<span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> `Validate password and return <span class="hljs-literal">false</span> <span class="hljs-keyword">when</span> the parameter has 6 chars and contains brackets`<span class="hljs-params">()</span></span> {}

<span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> `Validate password and return <span class="hljs-literal">false</span> <span class="hljs-keyword">when</span> the parameter has 5 chars and contains brackets`<span class="hljs-params">()</span></span> {}</code></pre>
<p>As you can see the test is 100% human readable, even someone who has no idea what test or class is doing can read the method name and understand the purpose. Even more, if you have already somewhere test cases/scenarios written, they can be easily transformed to the unit tests by copy pasting the titles of your test scenarios.</p>
<p>Luckily, it does not end here. We want to have tests as executable, behaviour driven specifications. Having some context about the functionality only in the test method name is not behaviour driven at all. The new <a href="https://jetbrains.github.io/spek/">Spek</a> framework comes for a help. Here is our tests in Spek</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PasswordValidatorTest</span> : <span class="hljs-type">Spek</span></span>({
    describe(<span class="hljs-string">"A password validator"</span>) {
        <span class="hljs-keyword">val</span> validator = PasswordValidator()

        it(<span class="hljs-string">"should return true when the parameter has 6 chars and contains only numbers and digits"</span>) {
            <span class="hljs-keyword">val</span> result = validator.validate(<span class="hljs-string">"qazwsx123"</span>)
            assertTrue(result)
        }

        it(<span class="hljs-string">"should return false when the parameter has 5 chars and contains only numbers and digits"</span>) {
            <span class="hljs-keyword">val</span> result = validator.validate(<span class="hljs-string">"qazw2"</span>)
            assertFalse(result)
        }

        it(<span class="hljs-string">"should return false when the parameter has 6 chars and contains brackets"</span>) {
            <span class="hljs-keyword">val</span> result = validator.validate(<span class="hljs-string">"qazws}"</span>)
            assertFalse(result)
        }

        it(<span class="hljs-string">"should return false when the parameter has 5 chars and contains brackets"</span>) {
            <span class="hljs-keyword">val</span> result = validator.validate(<span class="hljs-string">"qaw2}"</span>)
            assertFalse(result)
        }
    }
})</code></pre>
<p>Although it's not really convenient to put the specification in the initialization block of Spek, but we have purely behaviour driven, human readable and machine executable test. </p>
<p>Spek is the most used framework in Kotlin world now, but not the only one. If you are coming from Scala world you may find interesting the <a href="https://github.com/kotlintest/kotlintest">KotlinTest</a>, which is highly inspired by <a href="http://www.scalatest.org/">ScalaTest</a>.</p>
<p>If you want to experiment more, check out the list below for some other frameworks/libraries for Kotlin/JVM </p>
<ul>
<li><a href="https://github.com/jetbrains/spek">spek</a> - A specification framework for JVM.</li>
<li><a href="https://github.com/nhaarman/mockito-kotlin">mockito-kotlin</a> - A small library that provides helper functions to work with Mockito in Kotlin.</li>
<li><a href="https://github.com/kotlintest/kotlintest">kotlintest</a> - Flexible and comprehensive testing tool for the Kotlin ecosystem based on and heavily inspired by the superb Scalatest.</li>
<li><a href="https://github.com/npryce/hamkrest">hamkrest</a> - A reimplementation of Hamcrest to take advantage of Kotlin language features.</li>
<li><a href="https://github.com/winterbe/expekt">expekt</a> - Expekt is a BDD assertion library for Kotlin, inspired by Chai.js. It works with your favorite test runner such as JUnit and Spek.</li>
<li><a href="https://github.com/MarkusAmshove/Kluent">Kluent</a> - Kluent is a "Fluent Assertions" library written specifically for Kotlin.</li>
<li><a href="https://github.com/raniejade/kspec">kspec</a> -Specifications for Kotlin.</li>
<li><a href="https://github.com/EPadronU/balin">balin</a> - Balin is a browser automation library for Kotlin. It's basically a Selenium-WebDriver wrapper library inspired by Geb.</li>
<li><a href="https://github.com/dmcg/konsent">konsent</a> - An acceptance testing library for Kotlin.</li>
</ul>
]]></description><link>http://vtorosyan.github.io/natural-testing/</link><guid isPermaLink="true">http://vtorosyan.github.io/natural-testing/</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Testing]]></category><dc:creator><![CDATA[Vardan Torosyan]]></dc:creator><pubDate>Wed, 31 Aug 2016 11:38:00 GMT</pubDate></item><item><title><![CDATA[Writing Kotlin Idiomatic Code]]></title><description><![CDATA[<h1>Writing Kotlin Idiomatic Code</h1>
<p><a href="http://kotlinlang.org/">Kotlin</a>, a new JVM language created by Jetbrains, is quickly becoming the go-to programming  language used for Android development at Hootsuite. Its many features and Java interoperability make writing code much faster, cleaner, and less verbose. However, without being aware of language idioms it can be easy to fall back to old Java patterns. In order to maximize the utility of this new language, it is important to familiarize yourself with writing idiomatic Kotlin code. Kotlin’s features, such as the nullable types, lambdas, and delegates, differentiate the language from Java and are useful for writing effective code.</p>
<p><a href="https://kotlinlang.org/"><img src="http://code.hootsuite.com/wp-content/uploads/2016/08/Kotlin-500x111.png" alt="Kotlin"></a></p>
<p><strong>Null Checks and Safe Casts</strong></p>
<p>Null references, called a <a href="https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare">“billion-dollar mistake”</a> by their creator, are a major problem in Java. Null checks are possible in Java, but they are cumbersome, verbose, and easy to miss. In Kotlin, nullability is part of the type system and the language forces null checks for nullable types. The Java way of performing a null check in Kotlin would look like this:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> school : School = <span class="hljs-literal">null</span>

<span class="hljs-keyword">if</span> (school != <span class="hljs-literal">null</span> &#x26;&#x26; school.students != <span class="hljs-literal">null</span>){
	doSomething(school.students.<span class="hljs-keyword">get</span>(“billy”))	
}</code></pre>
<p>Fortunately, Kotlin provides a number of easy ways of dealing with this cleanly. The safe call operator “?” provides a simple way of dealing with nullability. When combined with the let{} method, it allows for chained operations like this:</p>
<pre><code class="hljs language-kotlin">school?.students?.let { doSomething(it.<span class="hljs-keyword">get</span>(“billy”)) }</code></pre>
<p>In the above line of code, the null safety operator used on x and y prevents the code in the let block from being executed if either value is null. When the code in the let block runs it represents the non-null value of y. let blocks can also be useful when needing to access a nullable mutable variable several times since it makes a copy of the variable when it is executed. let blocks can also be used with the safe cast operator in order to replace type checks in if blocks like this:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">if</span> (x <span class="hljs-keyword">is</span> String){
   println(x)
}
<span class="hljs-comment">// can be replaced with</span>
(x <span class="hljs-keyword">as</span>? String)?.let { println(x) }</code></pre>
<p>Finally, the safe elvis operator that allows you to return an alternative value or throw an error in the case of null:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> parent = node.getParent() ?: <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
<span class="hljs-keyword">val</span> name = node.getName() ?: <span class="hljs-keyword">throw</span> IllegalArgumentException(<span class="hljs-string">"..."</span>)</code></pre>
<p><strong>Lambdas, Closures, and Higher Order Operators</strong></p>
<p>Some other key features that Kotlin has over Java 7 are lambdas and closures, which allow your code to be more concise and functional. In Kotlin, functions are treated as first class citizens, which means means you can easily pass function parameters without needing to create an interface. For example, the Java way of setting an OnClickListener would look like this:</p>
<pre><code class="hljs language-kotlin">some_view.setOnClickListener(<span class="hljs-keyword">object</span> : View.OnClickListener {
   <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onClick</span><span class="hljs-params">(view: <span class="hljs-type">View</span>)</span></span> {
       println(<span class="hljs-string">"clicked!"</span>)
   }
})</code></pre>
<p>Using lambdas, this can be shorted like this:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> listener: (View) -> <span class="hljs-built_in">Unit</span> = { println(“clicked!”) }
some_view.setOnClickListener (listener)

<span class="hljs-comment">// Or you can use closures </span>

some_view.setOnClickListener {doSomething()}</code></pre>
<p>Using higher order operators and closures, you can remove many loops that you would otherwise need in Java. For example, if one wished to sentence from a list of words with spaces in between one could do the following:</p>
<pre><code class="hljs language-kotlin">listOf(<span class="hljs-string">"This"</span>, <span class="hljs-string">"is"</span>,<span class="hljs-string">"a"</span>, <span class="hljs-string">"sentence"</span>).reduce { accumulator, s -> accumulator +<span class="hljs-string">" "</span> + s }</code></pre>
<p>In the above example listOf is used to create an immutable list of words. Then, the reduce operator is used to concat all of the words by accumulating them and appending a space to the end of each word to produce the string “This is a sentence”.</p>
<p>Kotlin also allows for higher order operators to be chained. In this more advanced example, this code finds the first perfect square that contains the numbers 123:</p>
<pre><code class="hljs language-kotlin">(<span class="hljs-number">1.</span><span class="hljs-number">.100000</span>).map { it * it }.find { it.toString().contains(Regex(<span class="hljs-string">".*123.*"</span>)) }</code></pre>
<p>In this example we use the range operator to get a list of numbers, then we map that list to their squares. Afterwards, we use the find operator to find the first number that matches the regular expression. There many more higher order operators that you can read about <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/index.html#functions">here</a>.</p>
<p><strong>Delegates</strong></p>
<p>In Java, if you wish to expose an encapsulated property for a class, you need to write a getter and setter. For example, if you are in a custom view and wish to expose the value of a checkbox, you would need to expose property through a getter and setter. In Kotlin, properties automatically generate getters and setters, so this step is unnecessary. You can delegate out the property of the enclosed checkbox object like this:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">var</span> isChecked: <span class="hljs-built_in">Boolean</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">object</span> {
   <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">Any</span>?, property: <span class="hljs-type">KProperty</span>&#x3C;*>)</span></span>: <span class="hljs-built_in">Boolean</span> {
       <span class="hljs-keyword">return</span> checkbox.checked
   }

   <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">Any</span>?, property: <span class="hljs-type">KProperty</span>&#x3C;*>, value: <span class="hljs-type">Boolean</span>)</span></span> {
       checkbox.checked = value
   }
}</code></pre>
<p>This uses two interesting features of Kotlin: object expressions and property delegates. An anonymous object is created which this property is delegated out to, meaning you can still access it using property access syntax and getters and setters are generated.</p>
<p>Another problem that delegates can solve is composition. It is often convenient when building a model that depends on views to allow each view to build it’s own component. If you wish to abstract away direct access to the views in this situation, property delegates provide a clean solution. Here’s an example of a class with an EditText view inside it:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EditTextDelegate</span> </span>{
   <span class="hljs-comment">// represents some editable text view</span>
   <span class="hljs-keyword">var</span> editText: EditText = EditText();

 <span class="hljs-keyword">operator</span>  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">Any</span>?, property: <span class="hljs-type">KProperty</span>&#x3C;*>)</span></span>: String? {
       <span class="hljs-keyword">return</span> editText.text
   }

 <span class="hljs-keyword">operator</span>  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">Any</span>?, property: <span class="hljs-type">KProperty</span>&#x3C;*>, value: <span class="hljs-type">String</span>?)</span></span> {
       editText.text = value
   }
}</code></pre>
<p>You can then use your view class as a delegate like this:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ComposedObject</span></span>(textDelegate: EditTextDelegate){
  <span class="hljs-keyword">var</span> text: String? <span class="hljs-keyword">by</span> textDelegate
}</code></pre>
<p>This allows you to ask each of the views that compose this model for their properties without needing to deal with getters and setters. Additionally, you can now access all of these abstracted view properties as if they are normal properties.</p>
<p><strong>Functions and Functional Programming</strong></p>
<p>Many of these new Kotlin features mean that functional programming is now an option when solving problems. One of the most important features that Kotlin provides for functional programming is immutability in both default lists and and objects, with it’s val type. In Effective Java Second Edition Joshua Bloch states “Classes should be immutable unless there’s a very good reason to make them mutable.” Many of these same arguments for immutability apply to Kotlin including thread safety, easy shareability, and simplicity. In Kotlin one can define an immutable class like this:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>(<span class="hljs-keyword">val</span> name: String, <span class="hljs-keyword">val</span> city: String)</code></pre>
<p>When functional programming, recursion is key to solving problems without changing state. Recursive functions, however, can be expensive if they aren’t tail recursive because of the stack space required. Kotlin solves this problems with the tailrec operator which optimizes a tail recursive function (a function where the the the last call is recursive) to reuse the stack. For example:</p>
<pre><code class="hljs language-kotlin">tailrec <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fib</span><span class="hljs-params">(count: <span class="hljs-type">Long</span>, seq: <span class="hljs-type">List</span>&#x3C;<span class="hljs-type">Int</span>> = listOf(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)</span></span>): List&#x3C;<span class="hljs-built_in">Int</span>> =
<span class="hljs-keyword">if</span> (seq.size >= count) seq <span class="hljs-keyword">else</span> fib(count, seq + (seq.last() + seq[seq.lastIndex - <span class="hljs-number">1</span>]))</code></pre>
<p>Here we see that the last call in this function is a recursive call, which means that it is able to be optimized. Additionally, in the above function we can see that using operator overloading we are able to use the + operator on the list. This allows for more terse syntax because it returns a new list, not a boolean like List.add() and allows for immutable lists to be used.</p>
<p>Many of the the other parts of the this post such as lambdas and nullable types can be used to enhance functional programming. For more information on functional programming in Kotlin read Mike Hearn’s excellent <a href="https://medium.com/@octskyward/kotlin-fp-3bf63a17d64a#.geo4mq2nx">blog post</a> goes into more detail.</p>
<p><strong>Conclusion</strong></p>
<p>Kotlin is language fast growing language, and there are still new practices being developed. Hopefully this blog post provides a clear set of examples of using Kotlin’s feature set more effectively.</p>
<p>Thank you to the Android team and Kimli for helping me write and edit this blog post.</p>
]]></description><link>http://code.hootsuite.com/writing-kotlin-idiomatic-code/</link><guid isPermaLink="true">http://code.hootsuite.com/writing-kotlin-idiomatic-code/</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Denis Trailin]]></dc:creator><pubDate>Wed, 31 Aug 2016 02:38:00 GMT</pubDate></item><item><title><![CDATA[Ten Kotlin Features To Boost Android Development ]]></title><description><![CDATA[<h2>Introduction</h2>
<p>A while ago, <a href="https://www.toptal.com/software/kotlin-android-language">Tomasz introduced Kotlin development on Android</a>. To remind you: Kotlin is a new programming language developed by <a href="https://www.jetbrains.com/">Jetbrains</a>, the company behind one of the most popular Java IDEs, <a href="https://www.jetbrains.com/idea/">IntelliJ IDEA</a>. Like Java, Kotlin is a general-purpose language. Since it complies to the Java Virtual Machine (JVM) bytecode, it can be used side-by-side with Java, and it doesn’t come with a performance overhead.</p>
<p>In this article, I will cover the top ten useful features to boost your Android development.</p>
<p><em>Note</em>: at the time of writing this article, actual versions were Android Studio 2.1.1. and Kotlin 1.0.2.</p>
<p><img src="https://assets.toptal.io/uploads/blog/image/121111/toptal-blog-image-1472553848441-616cb981fb163d64c2d9d18a7e109d73.jpg" alt="Kotlin"></p>
<p><em>Tired of never ending Java code? Try Kotlin, and save your time and sanity.</em></p>
<h2>Kotlin Setup</h2>
<p>Since Kotlin is developed by JetBrains, it is well-supported in both Android Studio and IntelliJ.</p>
<p>The first step is to <a href="https://plugins.jetbrains.com/plugin/6954?pr=androidstudio">install Kotlin plugin</a>. After successfully doing so, new actions will be available for converting your Java to Kotlin. Two new options are:</p>
<ol>
<li>Create a new Android project and setup Kotlin in the project.</li>
<li>Add Kotlin support to an existing Android project.</li>
</ol>
<p>To learn how to create a new Android project, check the <a href="https://kotlinlang.org/docs/tutorials/kotlin-android.html">official step by step guide</a>. To add Kotlin support to a newly created or an existing project, open the <a href="https://www.jetbrains.com/help/idea/2016.1/navigating-to-action.html?origin=old_help"><em>find action dialog</em></a> using <code>Command + Shift + A</code> on Mac or <code>Ctrl + Shift + A</code> on Windows/Linux, and invoke the <code>Configure Kotlin in Project</code> action.</p>
<p>To create a new Kotlin class, select:</p>
<ul>
<li><code>File</code> > <code>New</code> > <code>Kotlin file/class</code>, or</li>
<li><code>File</code> > <code>New</code> > <code>Kotlin activity</code></li>
</ul>
<p>Alternatively, you can create a Java class and convert it to Kotlin using the action mentioned above. Remember, you can use it to convert any class, interface, enum or annotation, and this can be used to compare Java easily to Kotlin code.</p>
<p>Another useful element that saves a lot of typing are Kotlin extensions. To use them you have to apply another plugin in your module <code>build.gradle</code> file:</p>
<pre><code class="hljs language-gradle">apply plugin: <span class="hljs-string">'kotlin-android-extensions'</span></code></pre>
<p><strong>Caveat</strong>: if you are using the Kotlin plugin action to set up your project, it will put the following code in your top level <code>build.gradle</code> file:</p>
<pre><code class="hljs language-gradle"><span class="hljs-keyword">buildscript</span> {
   ext.kotlin_version = <span class="hljs-string">'1.0.2'</span>
   <span class="hljs-keyword">repositories</span> {
       jcenter()
   }
   <span class="hljs-keyword">dependencies</span> {
       <span class="hljs-keyword">classpath</span> <span class="hljs-string">"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"</span>

       <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> Do not place your application dependencies here; they belong</span>
       <span class="hljs-comment">// in the individual module build.gradle files</span>
   }
}</code></pre>
<p>This will cause the extension not to work. To fix that, simply copy that code to each of the project modules in which you wish to use Kotlin.</p>
<p>If you setup everything correctly, you should be able to run and test your application the same way you would in a standard Android project, but now using Kotlin.</p>
<h2>Saving Time with Kotlin</h2>
<p>So, let’s start with describing some key aspects of Kotlin language and by providing tips on how you can save time by using it instead of Java.</p>
<h2>Feature #1: Static Layout Import</h2>
<p>One of the most common boilerplate codes in Android is using the <code>findViewById()</code> function to obtain references to your views in Activities or Fragments.</p>
<p>There are solutions, such as the <a href="http://jakewharton.github.io/butterknife/">Butterknife</a> library, that save some typing, but Kotlin takes this another step by allowing you to import all references to views from the layout with one import.</p>
<p>For example, consider the following activity XML layout:</p>
<pre><code class="hljs language-xml"><span class="php"><span class="hljs-meta">&#x3C;?</span>xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"utf-8"</span><span class="hljs-meta">?></span></span>
<span class="hljs-tag">&#x3C;<span class="hljs-name">RelativeLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>
    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">"http://schemas.android.com/tools"</span>
    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span>
    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"match_parent"</span>
    <span class="hljs-attr">android:paddingBottom</span>=<span class="hljs-string">"@dimen/activity_vertical_margin"</span>
    <span class="hljs-attr">android:paddingLeft</span>=<span class="hljs-string">"@dimen/activity_horizontal_margin"</span>
    <span class="hljs-attr">android:paddingRight</span>=<span class="hljs-string">"@dimen/activity_horizontal_margin"</span>
    <span class="hljs-attr">android:paddingTop</span>=<span class="hljs-string">"@dimen/activity_vertical_margin"</span>
    <span class="hljs-attr">tools:context</span>=<span class="hljs-string">"co.ikust.kotlintest.MainActivity"</span>></span>

    <span class="hljs-tag">&#x3C;<span class="hljs-name">TextView</span>
        <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/helloWorldTextView"</span>
        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"wrap_content"</span>
        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span>/></span>
<span class="hljs-tag">&#x3C;/<span class="hljs-name">RelativeLayout</span>></span></code></pre>
<p>And the accompanying activity code:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">package</span> co.ikust.kotlintest

<span class="hljs-keyword">import</span> android.support.v7.app.AppCompatActivity
<span class="hljs-keyword">import</span> android.os.Bundle

<span class="hljs-keyword">import</span> kotlinx.android.synthetic.main.activity_main.*

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span></span>() {

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> {
        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        helloWorldTextView.text = <span class="hljs-string">"Hello World!"</span>
    }
}</code></pre>
<p>To get the references for all the views in the layout with a defined ID, use the Android Kotlin extension <a href="https://github.com/Kotlin/anko">Anko</a>. Remember to type in this import statement:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">import</span> kotlinx.android.synthetic.main.activity_main.*</code></pre>
<p>Note you don’t need to write semicolons at the end of the lines in Kotlin because they are optional.</p>
<p>The <code>TextView</code> from layout is imported as a <code>TextView</code> instance with the name equal to the ID of the view. Don’t be confused by the syntax, which is used to set the label:</p>
<pre><code class="hljs language-kotlin">helloWorldTextView.text = <span class="hljs-string">"Hello World!"</span></code></pre>
<p>We will cover that shortly.</p>
<p><strong>Caveats</strong>:</p>
<ul>
<li>Make sure you import the correct layout, otherwise imported View references will have a <code>null</code> value.</li>
<li>When using fragments, make sure imported View references are used <strong>after</strong> the <code>onCreateView()</code> function call. Import the layout in <code>onCreateView()</code> function and use the View references to setup the UI in <code>onViewCreated()</code>. The references won’t be assigned before the <code>onCreateView()</code> method has finished.</li>
</ul>
<h2>Feature #2: Writing POJO Classes with Kotlin</h2>
<p>Something that will save the most time with Kotlin is writing the POJO (Plain Old Java Object) classes used to hold data. For example, in the request and response body of a RESTful API. In applications that rely on RESTful API, there will be many classes like that.</p>
<p>In Kotlin, much is done for you, and the syntax is concise. For example, consider the following class in Java:</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{
   <span class="hljs-keyword">private</span> String firstName;

   <span class="hljs-keyword">private</span> String lastName;

   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getFirstName</span><span class="hljs-params">()</span> </span>{
       <span class="hljs-keyword">return</span> firstName;
   }

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFirstName</span><span class="hljs-params">(String firstName)</span> </span>{
       <span class="hljs-keyword">this</span>.firstName = firstName;
   }

   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getLastName</span><span class="hljs-params">()</span> </span>{
       <span class="hljs-keyword">return</span> lastName;
   }

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLastName</span><span class="hljs-params">(String lastName)</span> </span>{
       <span class="hljs-keyword">this</span>.lastName = lastName;
   }
}</code></pre>
<p>When working with Kotlin, you don’t have to write public keyword again. By default, everything is of public scope. For example, if you want to declare a class, you simply write:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>{
}</code></pre>
<p>The equivalent of the Java code above in Kotlin:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{
   <span class="hljs-keyword">var</span> firstName: String? = <span class="hljs-literal">null</span>

   <span class="hljs-keyword">var</span> lastName: String? = <span class="hljs-literal">null</span>
}</code></pre>
<p>Well, that saves a lot of typing, doesn’t it? Let’s walk through the Kotlin code.</p>
<p><img src="https://assets.toptal.io/uploads/blog/image/121112/toptal-blog-image-1472553996024-d91273edb8c1031b8747a2810f25dc7c.jpg" alt="Kotlin saves a lot of typing"></p>
<p>When defining variables in Kotlin, there are two options:</p>
<ul>
<li>Mutable variables, defined by <code>var</code> keyword.</li>
<li>Immutable variables, defined by <code>val</code> keyword.</li>
</ul>
<p>The next thing to note is the syntax differs a bit from Java; first, you declare the variable name and then follow with type. Also, by default, properties are non-null types, meaning that they can’t accept <code>null</code> value. To define a variable to accept a <code>null</code> value, a question mark must be added after the type. We will talk about this and null-safety in Kotlin later.</p>
<p>Another important thing to note is that Kotlin doesn’t have the ability to declare fields for the class; only properties can be defined. So, in this case, <code>firstName</code> and <code>lastName</code> are properties that have been assigned default getter/setter methods. As mentioned, in Kotlin, they are both public by default.</p>
<p>Custom accessors can be written, for example:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{
   <span class="hljs-keyword">var</span> firstName: String? = <span class="hljs-literal">null</span>

   <span class="hljs-keyword">var</span> lastName: String? = <span class="hljs-literal">null</span>

   <span class="hljs-keyword">val</span> fullName: String?
        <span class="hljs-keyword">get</span>() firstName + <span class="hljs-string">" "</span> + lastName
}</code></pre>
<p>From the outside, when it comes to syntax, properties behave like public fields in Java:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> userName = user.firstName
user.firstName = <span class="hljs-string">"John"</span></code></pre>
<p>Note that the new property <code>fullName</code> is read only (defined by <code>val</code> keyword) and has a custom getter; it simply appends first and last name.</p>
<p>All properties in Kotlin must be assigned when declared or are in a constructor. There are some cases when that isn’t convenient; for example, for properties that will be initialized via dependency injection. In that case, a <code>lateinit</code> modifier can be used. Here is an example:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>{
    lateinit <span class="hljs-keyword">var</span> firstName : String;

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">inject</span><span class="hljs-params">()</span></span> {
        firstName = <span class="hljs-string">"John"</span>;
    }
}</code></pre>
<p>More details about properties can be found in the <a href="https://kotlinlang.org/docs/reference/properties.html">official documentation</a>.</p>
<h2>Feature #3: Class Inheritance and Constructors</h2>
<p>Kotlin has a more concise syntax when it comes to constructors, as well.</p>
<h3>Constructors</h3>
<p>Kotlin classes have a primary constructor and one or more secondary constructors. An example of defining a primary constructor:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">constructor</span></span>(firstName: String, lastName: String) {
}</code></pre>
<p>The primary constructor goes after the class name in the class definition. If the primary constructor doesn’t have any annotations or visibility modifiers, the constructor keyword can be omitted:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>(firstName: String) {
}</code></pre>
<p>Note that a primary constructor cannot have any code; any initialization must be done in the <code>init</code> code block:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>(firstName: String) {
    init {
         <span class="hljs-comment">//perform primary constructor initialization here</span>
    }
}</code></pre>
<p>Furthermore, a primary constructor can be used to define and initialize properties:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span></span>(<span class="hljs-keyword">var</span> firstName: String, <span class="hljs-keyword">var</span> lastName: String) {
  <span class="hljs-comment">// ...</span>
}</code></pre>
<p>Just like regular ones, properties defined from a primary constructor can be immutable (<code>val</code>) or mutable (<code>var</code>).</p>
<p>Classes may have secondary constructors as well; the syntax for defining one is as follows:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span></span>(<span class="hljs-keyword">var</span> firstName: String, <span class="hljs-keyword">var</span> lastName) {
    <span class="hljs-keyword">constructor</span>(name: String, parent: Person) : <span class="hljs-keyword">this</span>(name) {
        parent.children.add(<span class="hljs-keyword">this</span>)
    }
}</code></pre>
<p>Note that every secondary constructor must delegate to a primary constructor. This is similar to Java, which uses <code>this</code> keyword:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span></span>(<span class="hljs-keyword">val</span> firstName: String, <span class="hljs-keyword">val</span> lastName: String) {
    <span class="hljs-keyword">constructor</span>(firstName: String) : <span class="hljs-keyword">this</span>(firstName, <span class="hljs-string">""</span>) {
       <span class="hljs-comment">//...</span>
    }
}</code></pre>
<p>When instantiating classes, note that Kotlin doesn’t have <code>new</code> keywords, as does Java. To instantiate the aforementioned <code>User</code> class, use:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> user = User(<span class="hljs-string">"John"</span>, <span class="hljs-string">"Doe)</span></code></pre>
<h3>Introducing Inheritance</h3>
<p>In Kotlin, all classes extend from <code>Any</code>, which is similar to <code>Object</code> in Java. By default, classes are closed, like final classes in Java. So, in order to extend a class, it has to be declared as <code>open</code> or <code>abstract</code>:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span></span>(<span class="hljs-keyword">val</span> firstName, <span class="hljs-keyword">val</span> lastName)
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Administrator</span></span>(<span class="hljs-keyword">val</span> firstName, <span class="hljs-keyword">val</span> lastName) : User(firstName, lastName)</code></pre>
<p>Note that you have to delegate to the default constructor of the extended class, which is similar to calling <code>super()</code> method in the constructor of a new class in Java.</p>
<p>For more details about classes, check <a href="https://kotlinlang.org/docs/reference/classes.html">the official documentation</a>.</p>
<h2>Feature #4: Lambda Expressions</h2>
<p>Lambda expressions, introduced with Java 8, are one its favorite features. However, things are not so bright on Android, as it still only supports Java 7, and looks like Java 8 won’t be supported anytime soon. So, workarounds, such as <a href="https://github.com/orfjackal/retrolambda">Retrolambda</a>, bring lambda expressions to Android.</p>
<p>With Kotlin, no additional libraries or workarounds are required.</p>
<h3>Functions in Kotlin</h3>
<p>Let’s start by quickly going over the function syntax in Kotlin:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">add</span><span class="hljs-params">(x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>)</span></span> : <span class="hljs-built_in">Int</span> {
    <span class="hljs-keyword">return</span> x + y
}</code></pre>
<p>The return value of the function can be omitted, and in that case, the function will return <code>Int</code>. It’s worth repeating that everything in Kotlin is an object, extended from <code>Any</code>, and there are no primitive types.</p>
<p>An argument of the function can have a default value, for example:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">add</span><span class="hljs-params">(x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>  = <span class="hljs-number">1</span>)</span></span> : <span class="hljs-built_in">Int</span> {
    <span class="hljs-keyword">return</span> x + y;
}</code></pre>
<p>In that case, the <code>add()</code> function can be invoked by passing only the <code>x</code> argument. The equivalent Java code would be:</p>
<pre><code class="hljs language-java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{
   <span class="hljs-keyword">return</span> add(x, <span class="hljs-number">1</span>);
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>{
    <span class="hljs-keyword">return</span> x + y;
}</code></pre>
<p>Another nice thing when calling a function is that named arguments can be used. For example:</p>
<pre><code class="hljs language-kotlin">add(y = <span class="hljs-number">12</span>, x = <span class="hljs-number">5</span>)</code></pre>
<p>For more details about functions, check the <a href="https://kotlinlang.org/docs/reference/functions.html">official documentation</a>.</p>
<h3>Using Lambda Expressions in Kotlin</h3>
<p>Lambda expressions in Kotlin can be viewed as anonymous functions in Java, but with a more concise syntax. As an example, let’s show how to implement click listener in Java and Kotlin.</p>
<p>In Java:</p>
<pre><code class="hljs language-java">view.setOnClickListener(<span class="hljs-keyword">new</span> OnClickListener() {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>{
        Toast.makeText(v.getContext(), <span class="hljs-string">"Clicked on view"</span>, Toast.LENGTH_SHORT).show();
    }
};</code></pre>
<p>In Kotlin:</p>
<pre><code class="hljs language-kotlin">view.setOnClickListener({ view -> toast(<span class="hljs-string">"Click"</span>) })</code></pre>
<p>Wow! Just one line of code! We can see that the lambda expression is surrounded by curly braces. Parameters are declared first, and the body goes after the <code>-></code> sign. With click listener, type for the view parameter isn’t specified since it can be inferred. The body is simply a call to <code>toast()</code> function for showing toast, which Kotlin provides.</p>
<p>Also, if parameters aren’t used, we can leave them out:</p>
<pre><code class="hljs language-kotlin">view.setOnClickListener({ toast(<span class="hljs-string">"Click"</span>) })</code></pre>
<p>Kotlin has optimized Java libraries, and any function that receives an interface with one method for an argument can be called with a function argument (instead of Interface).</p>
<p>Furthermore, if the function is the last parameter, it can be moved out of the parentheses:</p>
<pre><code class="hljs language-kotlin">view.setOnClickListener() { toast(<span class="hljs-string">"Click"</span>) }</code></pre>
<p>Finally, if the function has only one parameter that is a function, parentheses can be left out:</p>
<pre><code class="hljs language-kotlin"></code></pre>
<p>For more information, check <a href="https://leanpub.com/kotlin-for-android-developers">Kotlin for Android developers book</a> by Antonio Leiva and the <a href="https://kotlinlang.org/docs/reference/lambdas.html">official documentation</a>.</p>
<h3>Extension Functions</h3>
<p>Kotlin, similar to C#, provides the ability to extend existing classes with new functionality by using extension functions. For example, an extension method that would calculate the MD5 hash of a <code>String</code>:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">md5</span><span class="hljs-params">()</span></span>: ByteArray {
    <span class="hljs-keyword">val</span> digester = MessageDigest.getInstance(<span class="hljs-string">"MD5"</span>)
    digester.update(<span class="hljs-keyword">this</span>.toByteArray(Charset.defaultCharset()))
    <span class="hljs-keyword">return</span> digester.digest()
}</code></pre>
<p>Note that the function name is preceded by the name of the extended class (in this case, <code>String</code>), and that the instance of the extended class is available via <code>this</code> keyword.</p>
<p>Extension functions are the equivalent of Java utility functions. The example function in Java would look like:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">public</span> static int toNumber(String instance) {
    <span class="hljs-keyword">return</span> Integer.valueOf(instance);
}</code></pre>
<p>The example function must be placed in a Utility class. What that means is that extension functions don’t modify the original extended class, but are a convenient way of writing utility methods.</p>
<h2>Feature #5: Null-Safety</h2>
<p>One of the things you hustle the most in Java is probably <code>NullPointerException</code>. Null-safety is a feature that has been integrated into the Kotlin language and is so implicit you usually won’t have to worry about. The <a href="https://kotlinlang.org/docs/reference/null-safety.html">official documentation</a> states that the only possible causes of <code>NullPointerExceptions</code> are:</p>
<ul>
<li>An explicit call to throw <code>NullPointerException</code>.</li>
<li>Using the <code>!!</code> operator (which I will explain later).</li>
<li>External Java code.</li>
<li>If the <code>lateinit</code> property is accessed in the constructor before it is initialized, an<code>UninitializedPropertyAccessException</code> will be thrown.</li>
</ul>
<p>By default, all variables and properties in Kotlin are considered <code>non-null</code> (unable to hold a <code>null</code> value) if they are not explicitly declared as nullable. As already mentioned, to define a variable to accept a <code>null</code> value, a question mark must be added after the type. For example:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> number: <span class="hljs-built_in">Int</span>? = <span class="hljs-literal">null</span></code></pre>
<p>However, note that the following code won’t compile:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> number: <span class="hljs-built_in">Int</span>? = <span class="hljs-literal">null</span>
number.toString()</code></pre>
<p>This is because the compiler performs <code>null</code> checks. To compile, a <code>null</code> check must be added:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> number: <span class="hljs-built_in">Int</span>? = <span class="hljs-literal">null</span>

<span class="hljs-keyword">if</span>(number != <span class="hljs-literal">null</span>) {
    number.toString();
}</code></pre>
<p>This code will compile successfully. What Kotlin does in the background, in this case, is that <code>number</code> becomes <code>nun-null</code> (<code>Int</code> instead of <code>Int?</code>) inside the if block.</p>
<p>The <code>null</code> check can be simplified using <strong>safe call operator</strong> (<code>?.</code>):</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> number: <span class="hljs-built_in">Int</span>? = <span class="hljs-literal">null</span>
number?.toString()</code></pre>
<p>The second line will be executed only if the number is not <code>null</code>. You can even use the famous <strong>Elvis operator</strong> (<code>?:</code>):</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> number <span class="hljs-built_in">Int</span>? = <span class="hljs-literal">null</span>
<span class="hljs-keyword">val</span> stringNumber = number?.toString() ?: <span class="hljs-string">"Number is null"</span></code></pre>
<p>If the expression on the left of <code>?:</code> is not <code>null</code>, it is evaluated and returned. Otherwise, the result of the expression on the right is returned. Another neat thing is that you can use <code>throw</code> or <code>return</code> on the right-hand side of the Elvis operator since they are expressions in Kotlin. For example:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sendMailToUser</span><span class="hljs-params">(user: <span class="hljs-type">User</span>)</span></span> {
    <span class="hljs-keyword">val</span> email = user?.email ?: <span class="hljs-keyword">throw</span> new IllegalArgumentException(<span class="hljs-string">"User email is null"</span>)
    <span class="hljs-comment">//...</span>
}</code></pre>
<h3>The !! Operator</h3>
<p>If you want a <code>NullPointerException</code> thrown the same way as in Java, you can do that with the <code>!!</code> operator. The following code will throw a <code>NullPointerException</code>:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> number: <span class="hljs-built_in">Int</span>? = <span class="hljs-literal">null</span>
number!!.toString()</code></pre>
<h3>Casting</h3>
<p>Casting in done by using an <code>as</code> keyword:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> x: String = y <span class="hljs-keyword">as</span> String</code></pre>
<p>This is considered “Unsafe” casting, as it will throw <code>ClassCastException</code> if the cast is not possible, as Java does. There is a “Safe” cast operator that returns the <code>null</code> value instead of throwing an exception:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> x: String = y <span class="hljs-keyword">as</span>? String</code></pre>
<p>For more details on casting, check the <a href="https://kotlinlang.org/docs/reference/typecasts.html">Type Casts and Casts</a> section of the official documentation, and for more details on <code>null</code> safety check the <a href="https://kotlinlang.org/docs/reference/null-safety.html">Null-Safety</a> section.</p>
<h3><code>lateinit</code> properties</h3>
<p>There is a case in which using <code>lateinit</code> properties can cause an exception similar to <code>NullPointerException</code>. Consider the following class:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InitTest</span> </span>{
    lateinit <span class="hljs-keyword">var</span> s: String;

    init {
        <span class="hljs-keyword">val</span> len = <span class="hljs-keyword">this</span>.s.length
    }

}</code></pre>
<p>This code will compile without warning. However, as soon as an instance of <code>TestClass</code> is created, an <code>UninitializedPropertyAccessException</code> will be thrown because property <code>s</code> is accessed before it is initialized.</p>
<h2>Feature #6: Function <code>with()</code></h2>
<p>Function <code>with()</code> is useful and comes with the Kotlin standard library. It can be used to save some typing if you need to access many properties of an object. For example:</p>
<pre><code class="hljs language-kotlin">with(helloWorldTextView) {
    text = <span class="hljs-string">"Hello World!"</span>
    visibility = View.VISIBLE
}</code></pre>
<p>It receives an object and an extension function as parameters. The code block (in the curly braces) is a lambda expression for the extension function of the object specified as the first parameter.</p>
<h2>Feature #7: Operator Overloading</h2>
<p>With Kotlin, custom implementations can be provided for a predefined set of operators. To implement an operator, a member function or an extension function with the given name must be provided.</p>
<p>For example, to implement the multiplication operator, a member function or extension function, with the name <code>times(argument)</code>, must be provided:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">times</span><span class="hljs-params">(b: <span class="hljs-type">Int</span>)</span></span>: String {
    <span class="hljs-keyword">val</span> buffer = StringBuffer()

    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span>.b) {
        buffer.append(<span class="hljs-keyword">this</span>)
    }

    <span class="hljs-keyword">return</span> buffer.toString()
}</code></pre>
<p>The example above shows an implementation of binary <code>*</code> operator on the <code>String</code>. For example, the following expression will assign value “TestTestTestTest” to a <code>newString</code> variable:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> newString = <span class="hljs-string">"Test"</span> * <span class="hljs-number">4</span></code></pre>
<p>Since extension functions can be used, it means the default behavior of the operators for all the objects can be changed. This is a double-edged sword and should be used with caution. For a list of function names for all operators that can be overloaded, check the <a href="https://kotlinlang.org/docs/reference/operator-overloading.html">official documentation</a>.</p>
<p>Another big difference compared to Java are <code>==</code> and <code>!=</code> operators. Operator <code>==</code> translates to:</p>
<pre><code class="hljs language-kotlin">a?.equals(b) ?: b === <span class="hljs-literal">null</span> </code></pre>
<p>While operator <code>!=</code> translates to:</p>
<pre><code class="hljs language-kotlin">!(a?.equals(b) ?:</code></pre>
<p>What that means, is that using <code>==</code> doesn’t make an identity check as in Java (compare if instances of an object are the same), but behaves the same way as <code>equals()</code> method along with <code>null</code> checks.</p>
<p>To perform identity check, operators <code>===</code> and <code>!==</code> must be used in Kotlin.</p>
<h2>Feature #8: Delegated Properties</h2>
<p>Certain properties share some common behaviors. For instance:</p>
<ul>
<li>Lazy-initialized properties that are initialized upon first access.</li>
<li>Properties that implement Observable in Observer pattern.</li>
<li>Properties that are stored in a map instead as separate fields.</li>
</ul>
<p>To make cases like this easier to implement, Kotlin supports <strong>Delegated Properties</strong>:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeClass</span> </span>{
    <span class="hljs-keyword">var</span> p: String <span class="hljs-keyword">by</span> Delegate()
}</code></pre>
<p>This means that getter and setter functions for the property <code>p</code> are handled by an instance of another class, <code>Delegate</code>.</p>
<p>An example of a delegate for the <code>String</code> property:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Delegate</span> </span>{
  <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">Any</span>?, property: <span class="hljs-type">KProperty</span>&#x3C;*>)</span></span>: String {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"<span class="hljs-subst">$thisRef</span>, thank you for delegating '<span class="hljs-subst">${property.name}</span>' to me!"</span>
  }

  <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">Any</span>?, property: <span class="hljs-type">KProperty</span>&#x3C;*>, value: <span class="hljs-type">String</span>)</span></span> {
    println(<span class="hljs-string">"<span class="hljs-subst">$value</span> has been assigned to '<span class="hljs-subst">${property.name}</span> in <span class="hljs-subst">$thisRef</span>.'"</span>)
  }
}</code></pre>
<p>The example above prints a message when a property is assigned or read.</p>
<p>Delegates can be created for both mutable (<code>var</code>) and read-only (<code>val</code>) properties.</p>
<p>For a read-only property, <code>getValue</code> method must be implemented. It takes two parameters (taken from the <a href="https://kotlinlang.org/docs/reference/delegated-properties.html">offical documentation</a>):</p>
<ul>
<li>receiver - must be the same or a supertype of the property owner (for extension properties, it is the type being extended).</li>
<li>metadata - must be of type <code>KProperty&#x3C;*></code> or its supertype.</li>
</ul>
<p>This function must return the same type as property, or its subtype.</p>
<p>For a mutable property, a delegate has to provide additionally a function named <code>setValue</code> that takes the following parameters:</p>
<ul>
<li>receiver - same as for <code>getValue()</code>.</li>
<li>metadata - same as for <code>getValue()</code>.</li>
<li>new value - must be of the same type as a property or its supertype.</li>
</ul>
<p>There are a few standard delegates that come with Kotlin that cover the most common situations:</p>
<ul>
<li>Lazy</li>
<li>Observable</li>
<li>Vetoable</li>
</ul>
<h3>Lazy</h3>
<p>Lazy is a standard delegate that takes a lambda expression as a parameter. The lambda expression passed is executed the first time <code>getValue()</code> method is called.</p>
<p>By default, the evaluation of lazy properties is synchronized. If you are not concerned with multi-threading, you can use <code>lazy(LazyThreadSafetyMode.NONE) { ... }</code> to get extra performance.</p>
<h3>Observable</h3>
<p>The <code>Delegates.observable()</code> is for properties that should behave as Observables in Observer pattern. It accepts two parameters, the initial value and a function that has three arguments (property, old value, and new value).</p>
<p>The given lambda expression will be executed every time <code>setValue()</code> method is called:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{
    <span class="hljs-keyword">var</span> email: String <span class="hljs-keyword">by</span> Delegates.observable(<span class="hljs-string">""</span>) {
        prop, old, new ->
        <span class="hljs-comment">//handle the change from old to new value</span>
    }
}</code></pre>
<h3>Vetoable</h3>
<p>This standard delegate is a special kind of Observable that lets you decide whether a new value assigned to a property will be stored or not. It can be used to check some conditions before assigning a value. As with <code>Delegates.observable()</code>, it accepts two parameters: the initial value, and a function.</p>
<p>The difference is that the function returns a Boolean value. If it returns <code>true</code>, the new value assigned to the property will be stored, or otherwise discarded.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">var</span> positiveNumber = Delegates.vetoable(<span class="hljs-number">0</span>) {
    d, old, new ->
    new >= <span class="hljs-number">0</span>
}</code></pre>
<p>The given example will store only positive numbers that are assigned to the property.</p>
<p>For more details, check the <a href="https://kotlinlang.org/docs/reference/delegated-properties.html">official documentation</a>.</p>
<h2>Feature #9: Mapping an Object to a Map</h2>
<p>A common use case is to store values of the properties inside a map. This often happens in applications that work with RESTful APIs and parses JSON objects. In this case, a map instance can be used as a delegate for a delegated property. An example from the <a href="https://kotlinlang.org/docs/reference/delegated-properties.html">official documentation</a>:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span></span>(<span class="hljs-keyword">val</span> map: Map&#x3C;String, Any?>) {
    <span class="hljs-keyword">val</span> name: String <span class="hljs-keyword">by</span> map
    <span class="hljs-keyword">val</span> age: <span class="hljs-built_in">Int</span>     <span class="hljs-keyword">by</span> map
}</code></pre>
<p>In this example, <code>User</code> has a primary constructor that takes a map. The two properties will take the values from the map that are mapped under keys that are equal to property names:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> user = User(mapOf(
    <span class="hljs-string">"name"</span> to <span class="hljs-string">"John Doe"</span>,
    <span class="hljs-string">"age"</span>  to <span class="hljs-number">25</span>
))</code></pre>
<p>The name property of the new user instance will be assigned the value of “John Doe” and age property the value 25.</p>
<p>This works for var properties in combination with <code>MutableMap</code> as well:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MutableUser</span></span>(<span class="hljs-keyword">val</span> map: MutableMap&#x3C;String, Any?>) {
    <span class="hljs-keyword">var</span> name: String <span class="hljs-keyword">by</span> map
    <span class="hljs-keyword">var</span> age: <span class="hljs-built_in">Int</span>     <span class="hljs-keyword">by</span> map
}</code></pre>
<h2>Feature #10: Collections and Functional Operations</h2>
<p>With the support for lambdas in Kotlin, collections can be leveraged to a new level.</p>
<p>First of all, Kotlin distinguishes between mutable and immutable collections. For example, there are two versions of <strong>Iterable</strong> interface:</p>
<ul>
<li>Iterable</li>
<li>MutableIterable</li>
</ul>
<p>The same goes for <strong>Collection</strong>, <strong>List</strong>, <strong>Set</strong> and <strong>Map</strong> interfaces.</p>
<p>For example, this <code>any</code> operation returns <code>true</code> if at least one element matches the given predicate:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> list = listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)
assertTrue(list.any { it % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> })</code></pre>
<p>For an extensive list of functional operations that can be done on collections, check this <a href="http://antonioleiva.com/collection-operations-kotlin/">blog post</a>.</p>
<h2>Conclusion</h2>
<p>We have just scratched the surface of what Kotlin offers. For those interested in further reading and learning more, check:</p>
<ul>
<li><a href="http://antonioleiva.com/kotlin/">Antonio Leiva’s Kotlin blog posts and book</a>.</li>
<li><a href="https://kotlinlang.org/docs/reference/">Official documentation</a> and <a href="https://kotlinlang.org/docs/tutorials/">tutorials</a> from JetBrains.</li>
</ul>
<p>To sum up, Kotlin offers you the ability to save time when writing native <a href="https://www.toptal.com/android">Android</a> applications by using an intuitive and concise syntax. It is still a young programming language, but in my opinion, it is now stable enough to be used for building production apps.</p>
<p>The benefits of using Kotlin:</p>
<ul>
<li>Support by Android Studio is seamless and excellent.</li>
<li>It is easy to convert an existing Java project to Kotlin.</li>
<li>Java and Kotlin code may coexist in the same project.</li>
<li>There is no speed overhead in the application.</li>
</ul>
<p>The downsides:</p>
<ul>
<li>Kotlin will add its libraries to the generated <code>.apk</code>, so the final <code>.apk</code> size will be about 300KB larger.</li>
<li>If abused, operator overloading can lead to unreadable code.</li>
<li>IDE and Autocomplete behaves a little slower when working with Kotlin than it does with pure Java Android projects.</li>
<li>Compilation times can be a bit longer.</li>
</ul>
]]></description><link>https://www.toptal.com/android/kotlin-boost-android-development</link><guid isPermaLink="true">https://www.toptal.com/android/kotlin-boost-android-development</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Android]]></category><dc:creator><![CDATA[Ivan Kušt]]></dc:creator><pubDate>Tue, 30 Aug 2016 12:04:00 GMT</pubDate></item><item><title><![CDATA[Getting started with Kotlin in Android development]]></title><description><![CDATA[<p>Kotlin programming language now on everyone's lips. Some people seriously considered it as a full-fledged replacement of Java in Android development. It is a modern, statically-typed language aimed at trying to make the code simpler and clearer for everyone and bring long-awaited Java features to Android developers. Let's look at the history of that language, sort out the pros and cons of the language, as well as a look at an example and how you can start using Kotlin in current projects.</p>
<h2>Why Kotlin was created and by whom?</h2>
<p>Creating of language began in 2010 at Jetbrains by two talented programmers - Andrew Breslav and Dmitry Zhemerov. These guys dreamed about removing those restrictions which are imposed on developers in Java 6: no streams, no lambda functions, no try-with-resources and etc. Kotlin creators wanted to invent null-safety language that could be more flexible and friendlier than Java. They provided a solution of so-called ‘one billion problem’: null by default. Many of these features have appeared only in the latest versions of Java but were implemented by Kotlin creators.</p>
<h2>A slight dive into Kotlin syntax</h2>
<p>Starting to develop an Android application on Kotlin is not very difficult. Let's see how the declaration of variables looks.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">var</span> explicitName : String = <span class="hljs-string">"Kotlin"</span> <span class="hljs-comment">// Here we declare the type</span>

<span class="hljs-keyword">var</span> implicitName = <span class="hljs-string">"Kotlin"</span> <span class="hljs-comment">// In that case we declare a variable implicitly</span></code></pre>
<p>Kotlin also allows you to declare immutable objects with keyword ‘val’.</p>
<p>It's time to tell you how null-safety in Kotlin works. In Java, when we need to check variable for null, we usually write block.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">if</span> (name != <span class="hljs-literal">null</span>) {
   name.length
}</code></pre>
<p>In Kotlin, we can do the same thing in one line.</p>
<pre><code class="hljs language-kotlin">Name?.length</code></pre>
<p>Let’s define the variable this way:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> name : String = <span class="hljs-literal">null</span></code></pre>
<p>The compiler will generate an error - there should be at least some value. Since Kotlin considers itself as null-safety language, that makes a bet on prevention of such situations during compilation.</p>
<p>If you're a fan of hardcore, it’s possible to compile the code, but I would not recommend to do it this way:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> name: String!! = <span class="hljs-literal">null</span></code></pre>
<h2>Collections</h2>
<p>If you had an experience with developing on Java, there is nothing special in Kotlin. I would say that Kotlin simplified everything for us again. Instead of LinkedLists and ArrayLists, we have  Lists, Maps, etc.</p>
<p>Kotlin allows us to define immutable lists.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> list: List&#x3C;String> = listOf(<span class="hljs-string">"Kotlin"</span>, <span class="hljs-string">"is"</span>, <span class="hljs-string">"awesome"</span>)
list.add(<span class="hljs-string">"though"</span>) <span class="hljs-comment">// No such method, guys!</span></code></pre>
<p>If you decided to use mutable list, you can use generic MutableList<T>:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> mutableList: MutableList&#x3C;String> = mutableListOf(<span class="hljs-string">"Kotlin"</span>, <span class="hljs-string">"is"</span>,<span class="hljs-string">"awesome"</span>)
mutableList.add(<span class="hljs-string">"though"</span>)</code></pre>
<h2>Methods</h2>
<p>Let’s write a simple method:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">summarize</span><span class="hljs-params">(a: <span class="hljs-type">Int</span>, b: <span class="hljs-type">Int</span>)</span></span> : <span class="hljs-built_in">Int</span> {
    <span class="hljs-keyword">return</span> a + b
}</code></pre>
<p>The first argument is the name of the parameter, and then type. After the colon, we specify the return type, if required. Do not forget that Kotlin is very, very friendly, so with this elementary function, we can write it in one line.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">summarize</span><span class="hljs-params">(a: <span class="hljs-type">Int</span>, b: <span class="hljs-type">Int</span>)</span></span> : <span class="hljs-built_in">Int</span> = a + b</code></pre>
<p>Kotlin also provides an ability to use default parameters:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">summarize</span><span class="hljs-params">(a: <span class="hljs-type">Int</span>, b: <span class="hljs-type">Int</span> = <span class="hljs-number">20</span>)</span></span> : <span class="hljs-built_in">Int</span> {
    <span class="hljs-keyword">return</span> a + b
}</code></pre>
<p>And yeah, you can write lambda-expressions.</p>
<h2>Classes</h2>
<p>Classes and methods in Kotlin are final by default. We can construct classes in two ways: with primary and secondary constructors. The primary class constructor is a part of header. Also, it doesn’t have any code to execute. If we need to do some operations, we can use ‘init’ block.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span></span>(<span class="hljs-keyword">val</span> name: String)  {
    init {
        println(<span class="hljs-string">"We've just initialized Cat with <span class="hljs-subst">${name}</span>"</span>)
    }
}</code></pre>
<p>Secondary constructor works, like in Java, without any difference.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span>: <span class="hljs-type">Animal {</span></span>
    <span class="hljs-keyword">constructor</span>(name: String) {
    }
}</code></pre>
<p>As you can see, super method works like inheritance and it’s absolutely incredible.  </p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> : <span class="hljs-type">Animal {</span></span>
    <span class="hljs-keyword">constructor</span>(name: String) : <span class="hljs-keyword">super</span>(name) {
    }
}</code></pre>
<h2>Data-classes</h2>
<p>I’m sure, during development, you’re using POJO-objects that don’t contain any specific logic. Kotlin creators decided to make developers satisfied and now you can submit your model as a data-class.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>(
    <span class="hljs-keyword">val</span> firstName: String,
    <span class="hljs-keyword">val</span> lastName: String
)</code></pre>
<p>That’s all. All the necessary getters and setters are there by default.</p>
<p>If you want to use data class, just make an instance by this construction:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> person = Person(<span class="hljs-string">"Paul"</span>, <span class="hljs-string">"Johnson"</span>)</code></pre>
<p>We can also make changes based on initialized instance of data class using ‘copy’ method.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> newPerson = person.copy(first_name=<span class="hljs-string">"Carl"</span>)</code></pre>
<h2>Extension functions</h2>
<p>Extension functions is an incredible replacement of many Utils classes which may have been in the separate package. Are you familiar with monkey-patching in Ruby? In Kotlin, that feature is called “extension functions” and it provides an ability to shorten your code the easiest way. Let’s see an example:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> Context.<span class="hljs-title">showMeToast</span><span class="hljs-params">(text: <span class="hljs-type">String</span>)</span></span> {
    Toast.makeText(<span class="hljs-keyword">this</span>, text, Toast.LENGTH_SHORT).show()
}</code></pre>
<p>We have just replaced this ugly boilerplate construction with an elegant and short method.</p>
<h2>Enough of these tutorial-like snippets! Let’s get to the real code!</h2>
<p>In March, within a few weeks, I wrote Munchkin Level Counter for use in the world-famous game. I decided to build an application with the usage of pattern proposed by Android-developer and Kotlin-lover, Antoine Leiva, who demonstrated how to build an application in the MVP architecture. It is even more reminiscent of VIPER popular architecture for developing iOS, which, in our version, deleted the letter R (Router).</p>
<p>We are constantly improving our application to provide the best user experience. We added dependency injection to Dagger and transferred all the code on Kotlin. We plan to use RxJava to eliminate the heaps of the implementation of interfaces that do not make the code  elegant nor beautiful for the perception of any developer.</p>
<p>Let's see how on the presenter class Toad on Kotlin.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DashboardPresenterImpl</span> <span class="hljs-title">implements</span> <span class="hljs-title">DashboardPresenter</span>, <span class="hljs-type">DashboardInteractor.OnLoadPlayerListener {</span></span>

   <span class="hljs-keyword">private</span> DashboardView dashboardView;
   <span class="hljs-keyword">private</span> DashboardInteractor interactor;

   <span class="hljs-keyword">public</span> DashboardPresenterImpl(DashboardView dashboardView, DashboardInteractor interactor) {
       <span class="hljs-keyword">this</span>.dashboardView = dashboardView;
       <span class="hljs-keyword">this</span>.interactor = interactor;
   }

   <span class="hljs-meta">@Override</span>
   <span class="hljs-keyword">public</span> void updatePlayerListItem(Player player, int position) {
       <span class="hljs-keyword">if</span> (dashboardView != <span class="hljs-literal">null</span>) {
           interactor.updatePlayer(player, position, <span class="hljs-keyword">this</span>);
       }
   }

   <span class="hljs-meta">@Override</span>
   <span class="hljs-keyword">public</span> void onResume() {
       <span class="hljs-keyword">if</span> (dashboardView != <span class="hljs-literal">null</span>) {
           interactor.loadPlayersList(<span class="hljs-keyword">this</span>);
       }
   }

   <span class="hljs-meta">@Override</span>
   <span class="hljs-keyword">public</span> void onFinished(ArrayList&#x3C;Player> players) {
       <span class="hljs-keyword">if</span> (dashboardView != <span class="hljs-literal">null</span>) {
           dashboardView.setItems(players);
       }
   }

   <span class="hljs-meta">@Override</span>
   <span class="hljs-keyword">public</span> void onPlayerUpdated(Player player, int position) {
       <span class="hljs-keyword">if</span> (dashboardView != <span class="hljs-literal">null</span>) {
           dashboardView.updatePlayerData(player, position);
       }
   }

   <span class="hljs-meta">@Override</span>
   <span class="hljs-keyword">public</span> void onDestroy() {
       <span class="hljs-keyword">if</span> (dashboardView != <span class="hljs-literal">null</span>) {
           dashboardView = <span class="hljs-literal">null</span>;
       }
   }

   <span class="hljs-meta">@Override</span>
   <span class="hljs-keyword">public</span> void setGameFinished() {
       <span class="hljs-keyword">if</span> (dashboardView != <span class="hljs-literal">null</span>) {
           interactor.setGameFinished();
       }
   }

   <span class="hljs-meta">@Override</span>
   <span class="hljs-keyword">public</span> void insertStep(Player player) {
       <span class="hljs-keyword">if</span> (dashboardView != <span class="hljs-literal">null</span>) {
           interactor.insertStep(player);
       }
   }
}</code></pre>
<p>You can see that whenever we send the data through the presenter in the interactor, it works with business logic. If the user closes the application, and Activity is destroyed, we can be sure that the callback interactor will not appeal to DashboardView interface which will appeal to the reel to send data to the user's screen (View).</p>
<p>We have re-written this class in Kotlin. It can be achieved with plug-in for Android Studio, made by JetBrains, and will automatically convert the code from Java to Kotlin.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DashboardPresenterImpl</span> : <span class="hljs-type">DashboardPresenter</span>, <span class="hljs-type">DashboardInteractor.OnLoadPlayerListener {</span></span>

   <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> interactor: DashboardInteractor
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> dashboardView: DashboardView?

   <span class="hljs-keyword">constructor</span>(dashboardView: DashboardView, interactor: DashboardInteractor) {
       <span class="hljs-keyword">this</span>.dashboardView = dashboardView
       <span class="hljs-keyword">this</span>.interactor = interactor
   }

   <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">updatePlayerListItem</span><span class="hljs-params">(player: <span class="hljs-type">Player</span>, position: <span class="hljs-type">Int</span>)</span></span> {
       interactor.updatePlayer(player, position, <span class="hljs-keyword">this</span>)
   }

   <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onResume</span><span class="hljs-params">()</span></span> {
       interactor.loadPlayersList(<span class="hljs-keyword">this</span>)
   }

   <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onFinished</span><span class="hljs-params">(players: <span class="hljs-type">ArrayList</span>&#x3C;<span class="hljs-type">Player</span>>)</span></span> {
       dashboardView?.setItems(players)
   }

   <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onPlayerUpdated</span><span class="hljs-params">(player: <span class="hljs-type">Player</span>, position: <span class="hljs-type">Int</span>)</span></span> {
       dashboardView?.updatePlayerData(player, position)
   }

   <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span></span> {
       dashboardView = <span class="hljs-literal">null</span>
   }

   <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setGameFinished</span><span class="hljs-params">()</span></span> {
       interactor.setGameFinished()
   }

   <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">insertStep</span><span class="hljs-params">(player: <span class="hljs-type">Player</span>)</span></span> {
       interactor.insertStep(player)
   }
}</code></pre>
<p>We were able to reduce the code by approximately 20 lines. We excluded checks at Null in three lines, which occupied an important place. When we turn to the interactor, we do not need to know about the status of the twist, so from this part of the code, it can be eliminated. It is much more important to know the state of the twist when we send a callback from interactor back to the presenter. We need to know the state of the twist and interface call methods that are implemented in the Activity code. As a result, the code looks cleaner, clearer and still performs its tasks.</p>
<p>Let's look at how we can improve the code in the Activiti.</p>
<p>We have an activity where we load game results in three fragments that display charts and a list of players with sorting by maximum points.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GameResultActivity</span> <span class="hljs-title">extends</span> <span class="hljs-title">AppCompatActivity</span> <span class="hljs-title">implements</span> <span class="hljs-title">GameResultView</span> </span>{

   <span class="hljs-keyword">public</span> static <span class="hljs-keyword">final</span> String TAG = LogUtil.makeLogTag(GameResultActivity.<span class="hljs-keyword">class</span>);

   <span class="hljs-keyword">private</span> GameResultPresenter presenter;
   <span class="hljs-keyword">private</span> Toolbar toolbar;
   <span class="hljs-keyword">private</span> ViewPager vpCharts;
   <span class="hljs-keyword">private</span> TabLayout tlChartsTitle;
   <span class="hljs-keyword">private</span> ChartsPagerAdapter vpChartsAdapter;

   <span class="hljs-meta">@Override</span>
   <span class="hljs-keyword">protected</span> void onCreate(Bundle savedInstanceState) {
       <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);
       presenter = new GameResultPresenterImpl(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>);
       setContentView(R.layout.activity_game_result);
       toolbar = (Toolbar) findViewById(R.id.toolbar);
       setSupportActionBar(toolbar);
       getSupportActionBar().setHomeButtonEnabled(<span class="hljs-literal">true</span>);
       getSupportActionBar().setDisplayHomeAsUpEnabled(<span class="hljs-literal">true</span>);
       presenter.onCreate();
   }

   <span class="hljs-meta">@Override</span>
   <span class="hljs-keyword">public</span> void loadChartFragments() {
       vpCharts = (ViewPager) findViewById(R.id.vp_charts);
       vpChartsAdapter = new ChartsPagerAdapter(getSupportFragmentManager(), <span class="hljs-keyword">this</span>);
       vpCharts.setAdapter(vpChartsAdapter);
       vpCharts.setOffscreenPageLimit(<span class="hljs-number">3</span>);
       tlChartsTitle = (TabLayout) findViewById(R.id.tl_charts_title);
       tlChartsTitle.setupWithViewPager(vpCharts);
   }

   <span class="hljs-meta">@Override</span>
   <span class="hljs-keyword">protected</span> void onResume() {
       <span class="hljs-keyword">super</span>.onResume();
   }

   <span class="hljs-meta">@Override</span>
   <span class="hljs-keyword">public</span> void onBackPressed() {
       <span class="hljs-keyword">super</span>.onBackPressed();
       presenter.onBackPressed();
       Intent intent = new Intent(<span class="hljs-keyword">this</span>, PlayersListActivity.<span class="hljs-keyword">class</span>);
       startActivity(intent);
       finish();
   }

   <span class="hljs-meta">@Override</span>
   <span class="hljs-keyword">public</span> boolean onOptionsItemSelected(MenuItem item) {
       switch (item.getItemId()) {
           case android.R.id.home:
               onBackPressed();
               <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
           <span class="hljs-keyword">default</span>:
               <span class="hljs-keyword">break</span>;
       }
       <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
   }

   <span class="hljs-meta">@Override</span>
   <span class="hljs-keyword">protected</span> void onStop() {
       <span class="hljs-keyword">super</span>.onStop();
       presenter.onStop();
   }
}</code></pre>
<p>You can see how an activity can look in Kotlin:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GameResultActivity</span> : <span class="hljs-type">AppCompatActivity</span></span>(), GameResultView {

   <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> {
       <span class="hljs-keyword">val</span> TAG = LogUtil.makeLogTag(GameResultActivity::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>)</span>
   }

   <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> toolbar <span class="hljs-keyword">by</span> lazy { findViewById(R.id.toolbar) <span class="hljs-keyword">as</span> Toolbar? }
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> vpCharts <span class="hljs-keyword">by</span> lazy { findViewById(R.id.vp_charts) <span class="hljs-keyword">as</span> ViewPager? }
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> tlChartsTitle <span class="hljs-keyword">by</span> lazy { findViewById(R.id.tl_charts_title) <span class="hljs-keyword">as</span> TabLayout? }
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> vpChartsAdapter: ChartsPagerAdapter = ChartsPagerAdapter(supportFragmentManager, <span class="hljs-keyword">this</span>)

   <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> presenter: GameResultPresenter = GameResultPresenterImpl(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>)

   <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> {
       <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)
       setContentView(R.layout.activity_game_result)
       setSupportActionBar(toolbar)
       supportActionBar?.setHomeButtonEnabled(<span class="hljs-literal">true</span>)
       supportActionBar?.setDisplayHomeAsUpEnabled(<span class="hljs-literal">true</span>)
       presenter.onCreate()
   }

   <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadChartFragments</span><span class="hljs-params">()</span></span> {
       vpCharts?.adapter = vpChartsAdapter
       vpCharts?.offscreenPageLimit = <span class="hljs-number">3</span>
       tlChartsTitle?.setupWithViewPager(vpCharts)
   }

   <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onBackPressed</span><span class="hljs-params">()</span></span> {
       <span class="hljs-keyword">super</span>.onBackPressed()
       presenter.onBackPressed()
       <span class="hljs-keyword">val</span> intent = Intent(<span class="hljs-keyword">this</span>, PlayersListActivity::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>)</span>
       startActivity(intent)
       finish()
   }

   <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onOptionsItemSelected</span><span class="hljs-params">(item: <span class="hljs-type">MenuItem</span>)</span></span>: <span class="hljs-built_in">Boolean</span> {
       <span class="hljs-keyword">when</span> (item.itemId) {
           android.R.id.home -> {
               onBackPressed()
               <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
           }
       }
       <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
   }

   <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onStop</span><span class="hljs-params">()</span></span> {
       <span class="hljs-keyword">super</span>.onStop()
       presenter.onStop()
   }
}</code></pre>
<p>Let's look what we have changed.</p>
<p>First, we have transferred the entire boilerplate-code findViewById View element code of the overridden method onCreate in properties, where we presented our view-components as "lazy" field. What does this mean? It means initialization happens as soon as we turn to this field in the onCreate. Second, we have transferred initialization of presenter and adapter for ViewPager.</p>
<h2>But how we can make it much better?</h2>
<p>We can simply use Butterknife. There are no big changes in comparison with standard Android development with Java.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> toolbar <span class="hljs-keyword">by</span> bindView(R.id.toolbar)
<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> vpCharts <span class="hljs-keyword">by</span> bindView(R.id.vp_charts)
<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> tlChartsTitle <span class="hljs-keyword">by</span> bindView(R.id.tl_charts_title)</code></pre>
<p>Looks better! Let’s see what Kotlin offers us to work with creating layouts.</p>
<h2>Anko</h2>
<p>Typically, Android developers have to write their views in the form of the XML markup. The parsing of XML-markup spent processor resources which caused the applications to load each activity a little longer. Usage of Anko DSL with Kotlin gives an enormous advantage. We can simply turn XML markup in domain-specific language provided by Anko.</p>
<h2>Kotlin in action</h2>
<p>Kotlin already being used in production. In May, I was able to listen to the presentation of two developers from the Belarusian startup, Juno. They built its application in new language. What interesting things did uncover? What is their stack? First, their application is made in the MVVM-architecture. Second, they use Dagger2, RxKotlin, Retrofit and Gson. The developers claim that they don’t completely use for-loops because of RxKotlin. Spek helps them to unit test their code.</p>
<h2>What’s next?</h2>
<p>The developers of Kotlin are constantly improving their language to provide the best experience to developers. For now, we can say that the goals which have been set in the beginning of the development of Kotlin have been achieved. Kotlin makes you write a better, cleaner and safer code, provides long-awaited Java features, and lets you use Java-code along with Kotlin. These are the pros, but we have cons too: compile time is a little bit longer than in Java and some of library is not compatible with Kotlin. But it’s not a serious issue, because the most popular libraries are used by developers from all over the world. So, Kotlin is a great choice to start development for Android now.</p>
]]></description><link>https://datarockets.com/blog/kotlin-in-android-development</link><guid isPermaLink="true">https://datarockets.com/blog/kotlin-in-android-development</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Android]]></category><dc:creator><![CDATA[Dmitry Chyrta]]></dc:creator><pubDate>Tue, 30 Aug 2016 11:54:00 GMT</pubDate></item><item><title><![CDATA[Kotlin: val does not mean immutable, it just means readonly, yeah]]></title><description><![CDATA[<p>Hey hey, dear reader!</p>
<p>I'm <a href="https://www.toptal.com/android/kotlin-boost-android-development">seeing how people</a> (including myself some time ago) tend to think that <code>val</code> in Kotlin means <strong>immutable</strong>. Unfortunately, this is not true 😞</p>
<p>Obviously, <code>val</code> can not guarantee that underlying object is <strong>immutable</strong>, that's clear.</p>
<blockquote>
<p>But can we say that <code>val</code> guarantees that underlying <strong>reference</strong> to the object is <strong>immutable</strong>?</p>
</blockquote>
<p>No...</p>
<p>Kotlin allows you declare <code>get()</code> of the <code>val</code> which breaks immutability of the property and leaves only <code>read</code> permission for external "users".</p>
<p>Example:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OhNo</span> </span>{

  <span class="hljs-keyword">val</span> yeah: <span class="hljs-built_in">Int</span>
    <span class="hljs-keyword">get</span>() = Random().nextInt()

}</code></pre>
<p>Things are especially sad when you declare <code>val</code> in an <code>interface</code>:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SomeService</span> </span>{  
  <span class="hljs-keyword">val</span> user: User
}</code></pre>
<p><strong>Until you check implementation</strong> (which is not always possible) you can't be sure that value will be same each time you read it from the property.</p>
<p>Real world example is <code>List.size</code> from Kotlin stdlib.</p>
<h4>How to live with that?</h4>
<p>We have a <strong>convention</strong> (hopefully haha, at least I point to that in code reviews) internally in our team (100% Kotlin) to not declare properties like <code>val currentSomething: Something</code>, if value can be different each time you read it — please declare a function: <code>fun currentSomething()</code> or just <code>fun something()</code> because when it's a function then it's clear that resulting value can be different on each call. But for types that clearly represent "volatility" themselves, like <code>rx.Observable</code> it's ok to have them as <code>val</code>.</p>
<p>Good thing is that in <code>data class</code> you can't define <code>get()</code> for properties declared in the constructor, but you can do it for non-constructor properties.</p>
<blockquote>
<p>We've discussed that with <a href="https://twitter.com/abreslav">@abreslav</a> and <a href="https://twitter.com/volebamor">@volebamor</a> from Kotlin team, but looks like there is nothing Kotlin team can do about this at the moment. Would be great to have clear separation of immutable <code>val</code> and <code>readonly val</code>, but that's just dreams. Though I've opened an <a href="https://youtrack.jetbrains.com/issue/KT-13578">issue</a> for highlighting that <code>val</code> has overriden <code>get()</code> in IDE.</p>
</blockquote>
<p>Stay immutable!</p>
]]></description><link>https://artemzin.com/blog/kotlin-val-does-not-mean-immutable-it-just-means-readonly-yeah/</link><guid isPermaLink="true">https://artemzin.com/blog/kotlin-val-does-not-mean-immutable-it-just-means-readonly-yeah/</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Artem Zinnatullin]]></dc:creator><pubDate>Tue, 30 Aug 2016 11:41:00 GMT</pubDate></item><item><title><![CDATA[Improved Pattern Matching in Kotlin]]></title><description><![CDATA[<p>Kotlin doesn’t have true pattern matching, and that’s fine. In order to make matchable classes in Scala, there is an awful lot of overhead required to make it work, and I highly respect Kotlin’s goal of <em>not</em> adding much overhead anywhere. But that doesn’t mean we can’t try to make our own way to get something closer to pattern matching.</p>
<h2><strong>Using <code>when</code></strong></h2>
<p>Kotlin’s <code>when</code> block is incredibly handy; It has several ways that it can work. The first way is simple equality check:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">when</span> (x) {
    <span class="hljs-number">1</span> -> print(<span class="hljs-string">"x == 1"</span>)
    <span class="hljs-number">2</span> -> print(<span class="hljs-string">"x == 2"</span>)
    <span class="hljs-keyword">else</span> -> print(<span class="hljs-string">"x is neither 1 nor 2"</span>)
}</code></pre>
<p>And cases can be combined using a comma:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">when</span> (x) {
    <span class="hljs-number">0</span>, <span class="hljs-number">1</span> -> print(<span class="hljs-string">"x == 0 or x == 1"</span>)
    <span class="hljs-keyword">else</span> -> print(<span class="hljs-string">"otherwise"</span>)
}</code></pre>
<p>It can also do <code>is</code> and <code>in</code> checks:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">when</span>(x) {
    <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.10</span> -> print(<span class="hljs-string">"in range"</span>)
    <span class="hljs-keyword">is</span> String -> print(<span class="hljs-string">"I guess it's not even a number"</span>)
}</code></pre>
<p>And with the last one, you can see that you can combine any of the previous into one <code>when</code> block. You also don’t need <code>else</code> if you’re using <code>when</code> as a statement instead of an expression. You also don’t need <code>else</code> if the expression version has all possibilities listed (as far as the compiler can tell).</p>
<p>You can also use <code>when</code> without a value on top, so that it simply works like a set of <code>if-else if</code> blocks:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">when</span> {
    a == b -> doSomething()
    b == c -> doSomethingElse()
    <span class="hljs-keyword">else</span> -> doThatOtherThing()
}</code></pre>
<p>With all these possibilities, do you know which version we’re going to use to build our pattern matching system? Surprisingly, it’s the simplest one with equality checks.</p>
<p>Now, I realize that you can do <code>sealed</code> classes as a sort of union type and <code>is</code> with when to match on those, but that’s has a limited set of use-cases. With the following system, I believe you can cover <em>all</em> use cases.</p>
<h2><strong>So How Do We Do It?</strong></h2>
<p>First, we realize that equality checks use <code>equals()</code> and that <code>equals()</code> is something we can override. So, we make some sort of <code>Pattern</code> type to use in the <code>when</code> block, and <code>equals()</code> checks if the object <code>is Pattern</code> and proceeds to use the <code>Pattern</code> to calculate “equality”.</p>
<p>Here’s a glimpse at how it loosely looks:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Pattern</span>&#x3C;<span class="hljs-type">in Subject</span>> </span>{
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">match</span><span class="hljs-params">(subject: <span class="hljs-type">Subject</span>)</span></span>: <span class="hljs-built_in">Boolean</span>
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySubject</span> </span>{
    ...
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">equals</span><span class="hljs-params">(other: <span class="hljs-type">Any</span>)</span></span>: <span class="hljs-built_in">Boolean</span> {
        <span class="hljs-keyword">if</span>(other <span class="hljs-keyword">is</span> Pattern&#x3C;*>)
            <span class="hljs-keyword">return</span> other.match(<span class="hljs-keyword">this</span>)
        <span class="hljs-keyword">else</span> ...
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomePattern</span> </span>{
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">match</span><span class="hljs-params">(subject: <span class="hljs-type">Any</span>)</span></span>: <span class="hljs-built_in">Boolean</span> {
        ...
    }
}</code></pre>
<p>And it would be used as follows:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> x = MySubject()
...
<span class="hljs-keyword">when</span>(x) {
    SomePattern() -> doSomething()
    SomeOtherPattern() -> doSomethingElse()
}</code></pre>
<h2><strong>Tweaks</strong></h2>
<p>There’s quite a few things that can be done to alter this idea to make it more palatable in different situations.</p>
<h3><strong>Shortcutting</strong></h3>
<p>First, you can try to make the patterns a little more accessible by shortcutting them on the subject class. If a pattern is parameterized – for example, a <code>List</code> could have a parameterized pattern that checks for a certain length, <code>IsLength</code> which would need to take in a parameter for the length – you can put a shortcut function on the <code>companion object</code> instead of directly calling the class’ constructor. If it’s not parameterized, you can cache an instance of the pattern as a value on the <code>companion object</code> of the subject class.</p>
<h3><strong>Lambda Pattern</strong></h3>
<p>The <code>Pattern</code> interface only has one method. You know what that means? It’s a functional interface (in Java 8 terms). That means, in Kotlin, <code>Pattern</code> doesn’t even need to exist. Instead of <code>equals()</code> checking if the object is a <code>Pattern</code>, have it check if it’s a <code>Function1&#x3C;SubjectType, Boolean></code>. You can obviously still shortcut some built-in patterns, but now you can even put in some on-the-fly lambdas into your <code>when</code> block:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">when</span>(x) {
    {it: Subject -> it.isTheCoolest} -> doSomething()
}</code></pre>
<p>This is sadly not all that useful, since type inference won’t be able to determine the type for the input parameter. You need to. At that point, you might as well use the unparameterized <code>when</code> block:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">when</span> {
    x.isTheCoolest -> doSomething()
}</code></pre>
<p>That doesn’t mean using lambdas for the pattern is a bad thing. You can still use method references, which makes quick and simple on-the-fly patterns possible (even for properties):</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">when</span>(x) {
    Subject::isTheCoolest -> doSomething()
}</code></pre>
<p>That’s certainly better than the fully qualified lambda. More complex lambdas can be defined as functions or in values instead:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">moreComplexCheck</span><span class="hljs-params">(subject: <span class="hljs-type">Subject</span>)</span></span>: <span class="hljs-built_in">Boolean</span> {
    ...
}

<span class="hljs-keyword">val</span> moreComplexCheck2 = {subject: Subject -> ...}

<span class="hljs-keyword">when</span>(x) {
    ::moreComplexCheck -> doSomething()
    moreComplexCheck2 -> doSomethingElse()
}</code></pre>
<h2><strong>Outro</strong></h2>
<p>So, there you have it! Better pattern matching in Kotlin! What do you think? I realize it’s a misuse of <code>equals()</code>, but I think it’s worth it in some cases.</p>
]]></description><link>https://programmingideaswithjake.wordpress.com/2016/08/27/improved-pattern-matching-in-kotlin/</link><guid isPermaLink="true">https://programmingideaswithjake.wordpress.com/2016/08/27/improved-pattern-matching-in-kotlin/</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Jacob Zimmerman]]></dc:creator><pubDate>Sat, 27 Aug 2016 08:58:00 GMT</pubDate></item><item><title><![CDATA[Scala vs Kotlin: inline and infix]]></title><description><![CDATA[<p>This is the third post in the Scala vs Kotlin comparison serie:</p>
<ol>
<li><a href="/scala-vs-kotlin/1/">Pimp my library</a></li>
<li><a href="/scala-vs-kotlin/2/">Operator overloading</a></li>
</ol>
<p>This week, I’d like to address two features: inline and infix - not because they’re related but because neither of them would be enough to fill a post.</p>
<p>Inlining comes from C (and then C++). In those languages, a hint could be provided to the compiler through the <code>inline</code> keyword. By doing so, it may replace an inlined function call by the function body itself in order to skip the overhead of a function call.</p>
<p>Infix notation is to be in line with prefix and postfix, it’s relative to the place of the operator compared its 2 operands. Hopefully, the following example is clear enough:</p>
<ul>
<li><em>Prefix</em>: <strong>+</strong> 2 2</li>
<li><em>Postfix</em>: 2 2 <strong>+</strong></li>
<li><em>Infix</em>: 2 <strong>+</strong> 2</li>
</ul>
<h2>Scala</h2>
<p>Scala offers inlining through the <code>@inline</code> annotation on a function. As for C/C++, this is a an hint to the compiler. As per the <a href="http://www.scala-lang.org/api/current/#scala.inline">ScalaDocs</a>:</p>
<blockquote>
<p>An annotation on methods that requests that the compiler should try especially hard to inline the annotated method.</p>
</blockquote>
<p>The compiler has the final say in whether the function will be inlined, or not. On the opposite site, a function can be annotated with <code>@noinline</code> to prevent inlining altogether:</p>
<blockquote>
<p>An annotation on methods that forbids the compiler to inline the method, no matter how safe the inlining appears to be.</p>
</blockquote>
<p>As for infix annotation, it’s interestingly quite different from the definition above. In this context, it means that dot and parentheses can be omitted while calling functions that have a single parameter. There are some additional constraints:</p>
<ul>
<li>Either the function must have <strong>no</strong> side-effects - be <em>pure</em></li>
<li><strong>Or</strong> the parameter must be a function</li>
</ul>
<pre><code class="hljs language-scala"><span class="hljs-keyword">val</span> isLess1 = <span class="hljs-number">1.</span>&#x3C;(<span class="hljs-number">2</span>)
<span class="hljs-keyword">val</span> isLess2 = <span class="hljs-number">1</span> &#x3C; <span class="hljs-number">2</span></code></pre>
<p>Lines 1 and 2 are equivalent. Obviously, line 2 is much more readable. Thanks to infix annotation, Scala doesn’t need operators, as every function can not only <a href="/scala-vs-kotlin/2/#scala">look</a> but be called like an operator.</p>
<h2>Kotlin</h2>
<p>In Kotlin, inlining is set with the <code>inline</code> <em>keyword</em>. However, it’s much more than just a compiler hint: it’s a requirement. Whenever <code>inline</code> is used, the compiler <strong>will</strong> inline the function, no matter what.</p>
<p>As such, it’s very important to use inlining only on small functions. Other limitations might include keeping its use to code under our control, <em>e.g.</em> to use it only for application code or code that is not part of a library’s public API.</p>
<p>Note that inlining affects both the function itself as well as arguments that are lambdas. To make lambda arguments not inlined, use the <code>noinline</code> keyword.</p>
<p>Infix notation is not automatic in Kotlin as it requires the function to be marked with the <code>infix</code> keyword. Additionally, the function needs to be attached to a class, either because it’s a member or an extension. Of course, the single parameter still applies.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">// Defined in Kotlin's runtime</span>
<span class="hljs-keyword">infix</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">and</span><span class="hljs-params">(other: <span class="hljs-type">kotlin</span>.<span class="hljs-type">Int</span>)</span></span>: kotlin.<span class="hljs-built_in">Int</span> { <span class="hljs-comment">/* compiled code */</span> }

<span class="hljs-keyword">val</span> bool1 = <span class="hljs-number">1.</span>and(<span class="hljs-number">2</span>)
<span class="hljs-keyword">val</span> bool2 = <span class="hljs-number">1</span> and <span class="hljs-number">2</span></code></pre>
<p>Be aware that infix notation only looks similar to an operator, it’s still a regular method call underneath.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">// This is valid</span>
<span class="hljs-keyword">val</span> bool3 = <span class="hljs-number">1</span> &#x3C; <span class="hljs-number">2</span>

<span class="hljs-comment">// This is not valid, because &#x3C; is an operator</span>
<span class="hljs-keyword">val</span> bool4 = <span class="hljs-number">1.</span>&#x3C;(<span class="hljs-number">2</span>)</code></pre>
]]></description><link>https://blog.frankel.ch/scala-vs-kotlin/3/</link><guid isPermaLink="true">https://blog.frankel.ch/scala-vs-kotlin/3/</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Scala]]></category><dc:creator><![CDATA[Nicolas Fränkel]]></dc:creator><pubDate>Sun, 21 Aug 2016 09:02:00 GMT</pubDate></item><item><title><![CDATA[Decision Trees with Kotlin]]></title><description><![CDATA[<p>It has been quite a while since my last post; things have been pretty busy in preparation for the launch of our new product <a href="https://www.voodoodreams.com">VoodooDreams</a>. Now that we have shipped our baby, I am super eager to try out <a href="https://www.kotlin.com">Kotlin</a> - a new programming language from JetBrains targeting the JVM.  One interesting aspect about Kotlin (similar to Scala and other JVM-based languages) is that it treats functions as first class citizens (<em>IMO Functional Interfaces just patch the gap</em>).  In order to try out this language we will create a Decision Tree Learning algorithm which is one of the most used and practical methods for learning inductive inference.  </p>
<h1>Learning as a Task</h1>
<p>In order to ground our discussion, we will consider the example of learning the concept "Play Tennis". <em>Note that this example has been adapted from the book - <a href="https://www.amazon.de/Machine-Learning-McGraw-Hill-Computer-Science/dp/0070428077/ref=sr_1_1?ie=UTF8&#x26;qid=1471686003&#x26;sr=8-1&#x26;keywords=machine+Learning+Tom+Mitchell">Machine Learning by Tom Mitchell</a></em>.  The table below represents a list of positive and negative examples which we will use to induce a general function. This will be our training DataSet \(D\).  </p>
<table>
<thead>
<tr>
<th>Outlook</th>
<th>Temperature</th>
<th>Humidity</th>
<th>Wind</th>
<th>Play Tennis</th>
</tr>
</thead>
<tbody>
<tr>
<td>Sunny</td>
<td>Hot</td>
<td>High</td>
<td>Weak</td>
<td>False</td>
</tr>
<tr>
<td>Sunny</td>
<td>Hot</td>
<td>High</td>
<td>Strong</td>
<td>False</td>
</tr>
<tr>
<td>Overcast</td>
<td>Hot</td>
<td>High</td>
<td>Weak</td>
<td>True</td>
</tr>
<tr>
<td>Rain</td>
<td>Mild</td>
<td>High</td>
<td>Weak</td>
<td>True</td>
</tr>
<tr>
<td>Rain</td>
<td>Cool</td>
<td>Normal</td>
<td>Weak</td>
<td>True</td>
</tr>
<tr>
<td>Rain</td>
<td>Cool</td>
<td>Normal</td>
<td>Strong</td>
<td>False</td>
</tr>
<tr>
<td>Overcast</td>
<td>Cool</td>
<td>Normal</td>
<td>Strong</td>
<td>True</td>
</tr>
<tr>
<td>Sunny</td>
<td>Mild</td>
<td>High</td>
<td>Weak</td>
<td>False</td>
</tr>
<tr>
<td>Sunny</td>
<td>Cool</td>
<td>Normal</td>
<td>Weak</td>
<td>True</td>
</tr>
<tr>
<td>Rain</td>
<td>Mild</td>
<td>Normal</td>
<td>Weak</td>
<td>True</td>
</tr>
<tr>
<td>Sunny</td>
<td>Mild</td>
<td>Normal</td>
<td>Strong</td>
<td>True</td>
</tr>
<tr>
<td>Overcast</td>
<td>Mild</td>
<td>High</td>
<td>Strong</td>
<td>True</td>
</tr>
<tr>
<td>Overcast</td>
<td>Hot</td>
<td>Normal</td>
<td>Weak</td>
<td>True</td>
</tr>
<tr>
<td>Rain</td>
<td>Mild</td>
<td>High</td>
<td>Strong</td>
<td>False</td>
</tr>
</tbody>
</table>
<p>The task here is to learn the <em>Play Tennis</em> concept from the attributes: Outlook, Temperature, Humidity and Wind.  Each row in the table represents a hypothesis. We will represent this in Kotlin using the <code>DataPoint</code> class and use the <a href="http://kotlinlang.org/docs/reference/delegated-properties.html">Delegated Properties</a> <strong>map</strong> feature.  </p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataPoint</span></span>(<span class="hljs-keyword">val</span> map: Map&#x3C;String, Any?>, <span class="hljs-keyword">val</span> result: <span class="hljs-built_in">Boolean</span>? = <span class="hljs-literal">null</span>){
    <span class="hljs-keyword">val</span> outlook:String <span class="hljs-keyword">by</span> map
    <span class="hljs-keyword">val</span> temperature: String <span class="hljs-keyword">by</span> map
    <span class="hljs-keyword">val</span> humidity: String <span class="hljs-keyword">by</span> map
    <span class="hljs-keyword">val</span> wind: String <span class="hljs-keyword">by</span> map
}</code></pre>
<p>The <strong>Delegated Property map</strong> feature (<code>by map</code>) allows us to store properties in a map whilst still allowing accessing them as properties.  In the ID3 algorithm we will be using the map to train the algorithm whilst an end user can use the properties directly. Our training DataSet \(D\) can be represented as follows: </p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> D = listOf(
   DataPoint(mapOf(<span class="hljs-string">"outlook"</span> to <span class="hljs-string">"Sunny"</span>, <span class="hljs-string">"temperature"</span> to <span class="hljs-string">"Hot"</span>, <span class="hljs-string">"humidity"</span> to <span class="hljs-string">"High"</span>, <span class="hljs-string">"wind"</span> to  <span class="hljs-string">"Weak"</span>), <span class="hljs-literal">false</span>),
   DataPoint(mapOf(<span class="hljs-string">"outlook"</span> to <span class="hljs-string">"Sunny"</span>, <span class="hljs-string">"temperature"</span> to <span class="hljs-string">"Hot"</span>, <span class="hljs-string">"humidity"</span> to <span class="hljs-string">"High"</span>, <span class="hljs-string">"wind"</span> to <span class="hljs-string">"Strong"</span>), <span class="hljs-literal">false</span>),
   DataPoint(mapOf(<span class="hljs-string">"outlook"</span> to <span class="hljs-string">"Overcast"</span>, <span class="hljs-string">"temperature"</span> to <span class="hljs-string">"Hot"</span>, <span class="hljs-string">"humidity"</span> to <span class="hljs-string">"High"</span>, <span class="hljs-string">"wind"</span> to <span class="hljs-string">"Weak"</span>), <span class="hljs-literal">true</span>),
   DataPoint(mapOf(<span class="hljs-string">"outlook"</span> to <span class="hljs-string">"Rain"</span>, <span class="hljs-string">"temperature"</span> to <span class="hljs-string">"Mild"</span>, <span class="hljs-string">"humidity"</span> to <span class="hljs-string">"High"</span>, <span class="hljs-string">"wind"</span> to <span class="hljs-string">"Weak"</span>), <span class="hljs-literal">true</span>),
   DataPoint(mapOf(<span class="hljs-string">"outlook"</span> to <span class="hljs-string">"Rain"</span>, <span class="hljs-string">"temperature"</span> to <span class="hljs-string">"Cool"</span>, <span class="hljs-string">"humidity"</span> to <span class="hljs-string">"Normal"</span>, <span class="hljs-string">"wind"</span> to <span class="hljs-string">"Weak"</span>), <span class="hljs-literal">true</span>),
   DataPoint(mapOf(<span class="hljs-string">"outlook"</span> to <span class="hljs-string">"Rain"</span>, <span class="hljs-string">"temperature"</span> to <span class="hljs-string">"Cool"</span>, <span class="hljs-string">"humidity"</span> to <span class="hljs-string">"Normal"</span>, <span class="hljs-string">"wind"</span> to <span class="hljs-string">"Strong"</span>), <span class="hljs-literal">false</span>),
   DataPoint(mapOf(<span class="hljs-string">"outlook"</span> to <span class="hljs-string">"Overcast"</span>, <span class="hljs-string">"temperature"</span> to <span class="hljs-string">"Cool"</span>, <span class="hljs-string">"humidity"</span> to <span class="hljs-string">"Normal"</span>, <span class="hljs-string">"wind"</span> to <span class="hljs-string">"Strong"</span>), <span class="hljs-literal">true</span>),
   DataPoint(mapOf(<span class="hljs-string">"outlook"</span> to <span class="hljs-string">"Sunny"</span>, <span class="hljs-string">"temperature"</span> to <span class="hljs-string">"Mild"</span>, <span class="hljs-string">"humidity"</span> to <span class="hljs-string">"High"</span>, <span class="hljs-string">"wind"</span> to <span class="hljs-string">"Weak"</span>), <span class="hljs-literal">false</span>),
   DataPoint(mapOf(<span class="hljs-string">"outlook"</span> to <span class="hljs-string">"Sunny"</span>, <span class="hljs-string">"temperature"</span> to <span class="hljs-string">"Cool"</span>, <span class="hljs-string">"humidity"</span> to <span class="hljs-string">"Normal"</span>, <span class="hljs-string">"wind"</span> to <span class="hljs-string">"Weak"</span>), <span class="hljs-literal">true</span>),
   DataPoint(mapOf(<span class="hljs-string">"outlook"</span> to <span class="hljs-string">"Rain"</span>, <span class="hljs-string">"temperature"</span> to <span class="hljs-string">"Mild"</span>, <span class="hljs-string">"humidity"</span> to <span class="hljs-string">"Normal"</span>, <span class="hljs-string">"wind"</span> to <span class="hljs-string">"Weak"</span>), <span class="hljs-literal">true</span>),
   DataPoint(mapOf(<span class="hljs-string">"outlook"</span> to <span class="hljs-string">"Sunny"</span>, <span class="hljs-string">"temperature"</span> to <span class="hljs-string">"Mild"</span>, <span class="hljs-string">"humidity"</span> to <span class="hljs-string">"Normal"</span>, <span class="hljs-string">"wind"</span> to <span class="hljs-string">"Strong"</span>), <span class="hljs-literal">true</span>),
   DataPoint(mapOf(<span class="hljs-string">"outlook"</span> to <span class="hljs-string">"Overcast"</span>, <span class="hljs-string">"temperature"</span> to <span class="hljs-string">"Mild"</span>, <span class="hljs-string">"humidity"</span> to <span class="hljs-string">"High"</span>, <span class="hljs-string">"wind"</span> to <span class="hljs-string">"Strong"</span>), <span class="hljs-literal">true</span>),
   DataPoint(mapOf(<span class="hljs-string">"outlook"</span> to <span class="hljs-string">"Overcast"</span>, <span class="hljs-string">"temperature"</span> to <span class="hljs-string">"Hot"</span>, <span class="hljs-string">"humidity"</span> to <span class="hljs-string">"Normal"</span>, <span class="hljs-string">"wind"</span> to <span class="hljs-string">"Weak"</span>), <span class="hljs-literal">true</span>),
   DataPoint(mapOf(<span class="hljs-string">"outlook"</span> to <span class="hljs-string">"Rain"</span>, <span class="hljs-string">"temperature"</span> to <span class="hljs-string">"Mild"</span>, <span class="hljs-string">"humidity"</span> to <span class="hljs-string">"High"</span>, <span class="hljs-string">"wind"</span> to <span class="hljs-string">"Strong"</span>), <span class="hljs-literal">false</span>)
)</code></pre>
<h1>Decision Trees Representation</h1>
<p>Having represented our DataSet we will now focus on how to represent the Decision Tree built by using the ID3 algorithm.  This algorithm is but one in the family of Decision Tree Learning Algorithms; a family of algorithms which are great at approximating discrete-valued target functions.  The output of the ID3 algorithm is a decision tree which can be represented visually as follows: </p>
<p><img src="https://cloudmark.github.io/images/kotlin/ID3.png"></p>
<p>In order to classify (predict) a new instance, we will start off at the root of the tree, test the attribute specified and then move down the tree branch corresponding to the value of the attribute.  This process is repeated until a leaf node is reached. </p>
<p>Let us follow with the example:</p>
<blockquote>
<p><strong>Outlook</strong> = Sunny, <strong>Temperature</strong> = Hot, <strong>Humidity</strong> = High, <strong>Wind</strong> = Strong </p>
</blockquote>
<p>We will start off at the root of the tree which contains the attribute <strong>Outlook</strong> and move to the left subtree (since the value is <em>Sunny</em>).  The remaining attributes which could be tested are: </p>
<blockquote>
<p><strong>Temperature</strong> = Hot, <strong>Humidity</strong> = High, <strong>Wind</strong> = Strong </p>
</blockquote>
<p>The root of the left subtree requires us to check the <strong>Humidity</strong> attribute.  Since the value of the attribute is <em>High</em> we will move to the left subtree to find the leaf node containing the result <strong>No</strong>. Hence we can infer that this is not a good day to play tennis (but a great time to read this article! :bowtie:). </p>
<p>In order to represent the following Tree in Kotlin we will make use of the <a href="https://kotlinlang.org/docs/reference/classes.html">Sealed Classes</a>.  From their documentation: </p>
<blockquote>
<p>Sealed classes are used for representing restricted class hierarchies, when a value can have one of the types from a limited set, but cannot have any other type. They are, in a sense, an extension of enum classes: the set of values for an enum type is also restricted, but each enum constant exists only as a single instance, whereas a subclass of a sealed class can have multiple instances which can contain state.</p>
</blockquote>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tree</span> </span>{
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span></span>(<span class="hljs-keyword">val</span> key: String, <span class="hljs-keyword">val</span> children: Map&#x3C;String, Tree>?) : Tree()
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Leaf</span></span>(<span class="hljs-keyword">val</span> result: <span class="hljs-built_in">Boolean</span>) : Tree()
}</code></pre>
<p>The tree above would be represented as follows: </p>
<pre><code class="hljs language-kotlin"> Tree.Node(<span class="hljs-string">"Outlook"</span>, mapOf(
         Pair(<span class="hljs-string">"Sunny"</span>, Tree.Node(<span class="hljs-string">"Humidity"</span>, mapOf(
                 Pair(<span class="hljs-string">"High"</span>, Tree.Leaf(<span class="hljs-literal">false</span>)),
                 Pair(<span class="hljs-string">"Normal"</span>, Tree.Leaf(<span class="hljs-literal">true</span>))
         ))),
         Pair(<span class="hljs-string">"Overcast"</span>, Tree.Leaf(<span class="hljs-literal">true</span>)),
         Pair(<span class="hljs-string">"Rain"</span>, Tree.Node(<span class="hljs-string">"Wind"</span>, mapOf(
                 Pair(<span class="hljs-string">"Strong"</span>, Tree.Leaf(<span class="hljs-literal">false</span>)),
                 Pair(<span class="hljs-string">"Weak"</span>, Tree.Leaf(<span class="hljs-literal">true</span>))

         )))
 ))</code></pre>
<p>Note that we could have also represented this as a disjunction of conjunctions.  If you are interested you can try it out - depth traversal algorithm comes to mind).  </p>
<p>$$
\begin{eqnarray}
(Outlook = Sunny \wedge Humidity = Normal) \vee \nonumber \newline
(Outlook = Overcast) \vee \nonumber \newline
(Outlook = Rain \wedge Wind = Weak)
\end{eqnarray}
$$</p>
<h1>Classifying New Exemplars.</h1>
<p>The advantage of using a sealed class is that it will make the implementation of the <code>classify</code> function more succinct.  When paired with the <a href="https://kotlinlang.org/docs/reference/control-flow.html#when-expression">When Expression</a> feature, sealed classes give us rudimentary pattern matching capabilities .  <em>It would be great to see proper pattern matching support in the coming Kotlin releases.</em>  The implementation of the <code>classify</code> function is as follows: </p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ID3</span></span>() {
    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> {
        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">classify</span><span class="hljs-params">(dataPoint: <span class="hljs-type">DataPoint</span>, tree: <span class="hljs-type">Tree</span>)</span></span>: <span class="hljs-built_in">Boolean</span> = <span class="hljs-keyword">when</span> (tree) {
            <span class="hljs-keyword">is</span> Tree.Leaf -> tree.result
            <span class="hljs-keyword">is</span> Tree.Node -> {
                <span class="hljs-keyword">val</span> value = dataPoint.map[tree.key]
                <span class="hljs-keyword">val</span> subtree = tree.children?.<span class="hljs-keyword">get</span>(value)!!
                classify(dataPoint, subtree)
            }
        }
    }
}</code></pre>
<p>Note that we are using the <a href="https://kotlinlang.org/docs/reference/object-declarations.html">Companion Object</a> feature of Kotlin.  If you have never seen Companion objects before you can think of them as <code>public static</code> methods on the ID3 class. Another feature which we are using is the <a href="https://kotlinlang.org/docs/reference/typecasts.html">Smart Cast</a> feature.  This feature will automatically type cast a variable after using the <code>is</code> checks.  In this case after the <code>is Tree.Leaf</code> expression evaluates to true, tree will automatically be cast to <code>Tree.Leaf</code>.  </p>
<h1>Building the Tree</h1>
<p>Now that we have represented our decision tree and learnt how to classify new exemplars, let us take on the task of building a tree from the example data.  The most important question to ask when building a decision tree is "Which Attribute Is the Best Classifier?". What we would like to determine is which attribute is the best attribute to classify items at a certain level in the tree, or better, which item gives us the best <em>information gain</em>.  </p>
<h2>Entropy</h2>
<p>In order to determine information gain we start off by looking at entropy which measures the (im)purity of an arbitrary collection of examples.  Given a collection of elements \(S\) containing only positive and negative items, entropy is measured by: </p>
<p>\[
Entropy(S) = -p_{\oplus} log_{2} p_{\oplus} - p_{\ominus} log_{2}p_{\ominus}
\]</p>
<p>An intuitive way in which we can think about entropy is a number (\([0,1]\)) which represents the minimum number of bits of information needed to encode the classification of an arbitrary member of \(S\).  If the collection \(S\) does not have any positive or negative examples the entropy will be 0.  If I pick an item at random from the collection \(S\) and all items are from the same class then the item I picked must be from that class hence we need 0 bits to encode this information. If the distribution of samples is equal, then the entropy is 1.  This means that we need at minimum 1 bit to represent a randomly picked item from \(S\).  We could encode a positive sample as 1 and a negative sample as 0.  As an example, if we have 9 positive examples and 5 negative examples the entropy would be: </p>
<p>$$
Entropy([9+, 5-]) = -\frac{9}{14}log_{2}\Big(\frac{9}{14}\Big) -\frac{5}{14}log_{2}\Big(\frac{5}{14}\Big) = 0.940
$$</p>
<p>We can extend this formula of Entropy to multiple attributes (rather than just <em>true</em> and <em>false</em>) as follows: </p>
<p>$$
Entropy(S) = \sum_{i=1}^{c} -p_{i}log_{2}p_{i}
$$</p>
<p>where \(p_{i}\) is the proportion of \(S\) belonging to class \(i\).  </p>
<p>In Kotlin we can express <code>entropy</code> as follows: </p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">entropy</span><span class="hljs-params">(positive: <span class="hljs-type">Double</span>, negative: <span class="hljs-type">Double</span>, total: <span class="hljs-type">Double</span> = positive + negative)</span></span>:<span class="hljs-built_in">Double</span> {
  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">log2</span><span class="hljs-params">(valueA: <span class="hljs-type">Double</span>, valueB: <span class="hljs-type">Double</span>)</span></span> = <span class="hljs-keyword">if</span> (valueA == <span class="hljs-number">0.0</span>) <span class="hljs-number">1.0</span> <span class="hljs-keyword">else</span> Math.log(valueA / (valueA + valueB)) / Math.log(<span class="hljs-number">2.0</span>)
  <span class="hljs-keyword">return</span> -(positive / total * log2(positive, negative) + negative / total * log2(negative, positive))
}</code></pre>
<h1>Information Gain</h1>
<p>Now that we have defined Entropy as an (im)purity measure, we can answer the question "Which Attribute Is The Best Classifier?".  This measure is called <em>Information Gain</em> - you can think of this value as the expected reduction in entropy or the expected number of bits saved if we had to encode the classification using the particular attribute.  The Information Gain of an attribute \(A\) is defined as: </p>
<p>$$
Gain(S, A) = Entropy(S) - \sum_{v \in Values(A)} \frac{|S_{v}|}{|S|}Entropy(S_{v})
$$</p>
<p>To understand what we need to do, lets work out the <em>Information Gain</em> of attribute \(Wind\) for the dataset \(S\) i.e. \(Gain(S, Wind)\).  <em>Note that there are 14 examples in our dataset;  9 positive, 5 negative \([9+ 5-]\).  There are 2 values for the attribute Wind: Weak and Strong.  Weak has 6 positive examples and 2 negative examples \([6+, 2-]\).  Strong has 3 positive examples and 3 negative examples \([3+, 3-]\)</em>.  </p>
<p>$$\begin{eqnarray}
Gain(S, A) &#x26;=&#x26;  Entropy(S) - \sum_{v \in \{Weak, Strong\} } \frac{|S_{v}|}{|S|}Entropy(S_{v}) \nonumber \newline
&#x26;=&#x26; Entropy(S) - \frac{8}{14}Entropy(S_{Weak}) - \frac{6}{14}Entropy(S_{Strong}) \nonumber \newline
&#x26;=&#x26; 0.940 - \frac{8}{14}0.811 - \frac{6}{14}1.0 \nonumber \newline
&#x26;=&#x26; 0.048
\end{eqnarray}$$</p>
<p>In Kotlin the Gain can be implemented as follows: </p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">gain</span><span class="hljs-params">(dataPoints: <span class="hljs-type">List</span>&#x3C;<span class="hljs-type">DataPoint</span>>, extractor: (<span class="hljs-type">DataPoint</span>)</span></span> -> Pair&#x3C;String, <span class="hljs-built_in">Boolean</span>>): <span class="hljs-built_in">Double</span> {
    <span class="hljs-keyword">val</span> (positive, negative) = dataPoints.map { extractor(it) }.partition { it.second }
    <span class="hljs-keyword">val</span> attributes = dataPoints.map { extractor(it) }
        .groupBy { it.first }
        .map {
            <span class="hljs-keyword">val</span> (positiveSv, negativeSv) = it.value.partition { it.second }
            Triple(it.key, positiveSv.size.toDouble(), negativeSv.size.toDouble())
        }
    <span class="hljs-keyword">return</span> (entropy(positive.size.toDouble(), negative.size.toDouble())
            + attributes.map({ -entropy(it.second, it.third, dataPoints.size.toDouble()) }).sum())

}</code></pre>
<p>We can compute the Gain of the attribute Wind as follows: </p>
<pre><code class="hljs language-kotlin">gain(dataPoints, { Pair(it.wind, it.result!!) })</code></pre>
<p>The <code>extractor</code> function defined as </p>
<pre><code class="hljs language-kotlin">extractor: (DataPoint) -> Pair&#x3C;String, <span class="hljs-built_in">Boolean</span>></code></pre>
<p>is a function which will be called on the dataset \(S\) to extract the information required - the value of the wind property and the classification result.  The <code>!!</code> is an indication to Kotlin that we are 100% sure that this property will not be null.  </p>
<h1>ID3 Tree</h1>
<p>Now that we have all the pieces of our puzzle ready, we will write the <code>build</code> function which will create the ID3 Tree. To understand what is going on, I will use a literate programming approach.  Below you will find the listing of the build <code>function</code>. </p>
<pre><code class="hljs language-kotlin"> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">build</span><span class="hljs-params">(dataPoints: <span class="hljs-type">List</span>&#x3C;<span class="hljs-type">DataPoint</span>>)</span></span>: Tree {
    <span class="hljs-keyword">val</span> (positive, negative) = dataPoints.partition { it.result!! }
    <span class="hljs-keyword">if</span> (positive.size == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> Tree.Leaf(<span class="hljs-literal">false</span>)
    <span class="hljs-keyword">if</span> (negative.size == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> Tree.Leaf(<span class="hljs-literal">true</span>)
    <span class="hljs-keyword">val</span> attributes = dataPoints.map { it.map.keys }.flatMap { it }.distinct()
    <span class="hljs-keyword">if</span> (attributes.size == <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (dataPoints.count { it.result!! } > dataPoints.count { !it.result!! }) Tree.Leaf(<span class="hljs-literal">true</span>) <span class="hljs-keyword">else</span> Tree.Leaf(<span class="hljs-literal">false</span>)
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">val</span> (attribute) = attributes.map { attr ->
            Pair(attr,
                gain(dataPoints, { Pair(it.map[attr].toString(), it.result!!) })
            )
        }.sortedByDescending { it.second }.first()
    
        <span class="hljs-keyword">val</span> remaining = dataPoints.groupBy { it.map[attribute] }
        <span class="hljs-keyword">val</span> filteredRemaining = remaining.entries.map {
            entry ->
            Pair(entry.key, entry.value.map { dataPoint ->
                DataPoint(dataPoint.map.filterKeys { it != attribute }, dataPoint.result)
            })
        }
    
        <span class="hljs-keyword">val</span> children = filteredRemaining.map { Pair(it.first.toString(), build(it.second)) }.toMap();
        <span class="hljs-keyword">return</span> Tree.Node(attribute, children)
    }
}</code></pre>
<p>Some explanations are due.  </p>
<p>Starting off, we determine whether the DataSet is made up of all positive or all negative sample points (Entropy 0): </p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> (positive, negative) = dataPoints.partition { it.result!! }
<span class="hljs-keyword">if</span> (positive.size == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> Tree.Leaf(<span class="hljs-literal">false</span>)
<span class="hljs-keyword">if</span> (negative.size == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> Tree.Leaf(<span class="hljs-literal">true</span>)</code></pre>
<p>It such a case we return a <code>Tree.Leaf</code> with the corresponding result.  </p>
<p>Next we will check how many attributes there are in the DataSet: </p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> attributes = dataPoints.map { it.map.keys }.flatMap { it }.distinct()</code></pre>
<p>If there is only one attribute, then the most common value of the target attribute is returned.  </p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">if</span> (attributes.size == <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (dataPoints.count { it.result!! } > dataPoints.count { !it.result!! }) 
        Tree.Leaf(<span class="hljs-literal">true</span>) <span class="hljs-keyword">else</span> Tree.Leaf(<span class="hljs-literal">false</span>)
}</code></pre>
<p>Otherwise, we will first determine "Which attribute is the best?" by working the Information Gain of each attribute and retrieve the one with the highest Information Gain: </p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> (attribute) = attributes.map { attr ->
    Pair(attr,
        gain(dataPoints, { Pair(it.map[attr].toString(), it.result!!) })
    )
}.sortedByDescending { it.second }.first()</code></pre>
<p>For all the values of the chosen attribute: </p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> remaining = dataPoints.groupBy { it.map[attribute] }</code></pre>
<p>we will add a new subtree below the parent node and select the DataSet subset such that the attribute \(A\) in the parent subset matches the value \(v_{i}\).  </p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> filteredRemaining = remaining.entries.map {
    entry ->
    Pair(entry.key, entry.value.map { dataPoint ->
        DataPoint(dataPoint.map.filterKeys { it != attribute }, dataPoint.result)
    })
}</code></pre>
<p>In this case the attribute which has the highest Information Gain is the Outlook attribute.  Since Outlook has three values we will create three subtrees: one for Sunny, one for Overcast and one for Rain.  The Sunny Subtree should filter out all data points whose Overcast attribute value is not Sunny.  In this case this subtree will have 5 data points; 2 positive examples and 3 negative examples \([2+,3-]\): </p>
<table>
<thead>
<tr>
<th>Outlook</th>
<th>Temperature</th>
<th>Humidity</th>
<th>Wind</th>
<th>Play Tennis</th>
</tr>
</thead>
<tbody>
<tr>
<td>Sunny</td>
<td>Hot</td>
<td>High</td>
<td>Weak</td>
<td>False</td>
</tr>
<tr>
<td>Sunny</td>
<td>Hot</td>
<td>High</td>
<td>Strong</td>
<td>False</td>
</tr>
<tr>
<td>Sunny</td>
<td>Mild</td>
<td>High</td>
<td>Weak</td>
<td>False</td>
</tr>
<tr>
<td>Sunny</td>
<td>Cool</td>
<td>Normal</td>
<td>Weak</td>
<td>True</td>
</tr>
<tr>
<td>Sunny</td>
<td>Mild</td>
<td>Normal</td>
<td>Strong</td>
<td>True</td>
</tr>
</tbody>
</table>
<p>Finally we will call the build function recursively on this DataSet subset.  </p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> children = filteredRemaining.map { Pair(it.first.toString(), build(it.second)) }.toMap();
<span class="hljs-keyword">return</span> Tree.Node(attribute, children)</code></pre>
<p>Note that <code>it.first</code> will contain the attribute value (e.g. Sunny) whilst the it.second contains the DataSet subset.  </p>
<h1>Conclusion</h1>
<p>In this post we have looked at some of Kotlin's key features and we have used these to build an ID3 decision tree.  If you are further interested in learning about Kotlin I'd suggest you have a look at the <a href="https://kotlinlang.org/docs/reference/">reference guide</a>.  If you are interested in learn more about Decision Tree Learning consider buying the book linked above.  It is an absolute classic! Stay safe and keep hacking!</p>
]]></description><link>http://cloudmark.github.io/Decision-Trees/</link><guid isPermaLink="true">http://cloudmark.github.io/Decision-Trees/</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Mark Galea]]></dc:creator><pubDate>Sat, 20 Aug 2016 03:28:00 GMT</pubDate></item><item><title><![CDATA[Kotlin: The Good, The Bad, and The Ugly]]></title><description><![CDATA[<p><img src="https://d262ilb51hltx0.cloudfront.net/max/2000/1*qPZUptAisHb0s0TSLrBvHA.jpeg">
<em>Photo By <a href="https://www.flickr.com/photos/johnnysilvercloud/">Johhy Silvercloud</a> / <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a></em></p>
<h3>Kotlin: The Good, The Bad, and The Ugly</h3>
<p>In my <a href="https://medium.com/keepsafe-engineering/lessons-from-converting-an-app-to-100-kotlin-68984a05dcb6">last article</a>, I talked about converting Java codebases to Kotlin, and about some of the libraries I like. Here, I’m going to talk about my thoughts on the Kotlin language itself and the way it interacts with Java.</p>
<h3>The Good</h3>
<p>There’s a lot to like about Kotlin. Some of the obvious features like null safety, property access, and unchecked exceptions are covered at length in other <a href="https://blog.jetbrains.com/kotlin/2016/01/kotlin-digest-2015/">publications</a>, so I won’t repeat them here. Instead, here are some of the less commonly discussed features of Kotlin that I really like.</p>
<h4>Automatic conversion of Java to Kotlin</h4>
<p>JetBrains’ Java to Kotlin converter integrated into IntelliJ saves a huge amount of time. It’s far from perfect, but it saves you from having to retype mundane code. Without it, migrating code from Java to Kotlin would take significantly longer.</p>
<h4>lateinit, Delegates.notNull and lazy</h4>
<p>Kotlin’s null safety is great, but due to the way the Android Activity lifecycle is designed, you’ll often find that you have to initialize a property in a callback like <em>onCreate</em> instead of your class’s constructor. Let’s say you have a property that you would like to define like:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> name: String</code></pre>
<p>If you have to initialize that property in onCreate, it cannot be a <em>val</em>: it has to be mutable var. But it still needs to be given a value at initialization time, so the obvious way to define it would be as a nullable property:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">var</span> name: String? = <span class="hljs-literal">null</span></code></pre>
<p>That works, but then you have to do null checks everywhere you access that property. Even though Kotlin has relatively painless null assertions, you’d rather not have to type <em>!!</em> everywhere if you know that the property isn’t going to be null in practice. Fortunately, Kotlin has better ways: <a href="https://kotlinlang.org/docs/reference/properties.html#late-initialized-properties"><em>lateinit</em></a> and <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.properties/-delegates/not-null.html"><em>Delegates.notNull</em></a>. With either of those, you can define your property as a non-null type without an initializer:</p>
<pre><code class="hljs language-kotlin">lateinit <span class="hljs-keyword">var</span> name: String  
<span class="hljs-keyword">var</span> age: <span class="hljs-built_in">Int</span> <span class="hljs-keyword">by</span> Delegates.notNull&#x3C;String>()</code></pre>
<p>In either case, if you attempt to access the property before it’s initialized, an exception will be thrown <em>[1]</em>. <em>lateinit</em> can’t be used on properties of primitive types, but otherwise the two methods are mostly the same <em>[2]</em>.</p>
<p>A third option that can be useful is the <em>lazy</em> delegate. If your property can be initialized with data from only other properties or methods, then this might be a good fit. You can use it like so:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> imm: InputMethodManager <span class="hljs-keyword">by</span> lazy {   
    getSystemService(INPUT_METHOD_SERVICE) <span class="hljs-keyword">as</span> InputMethodManager   
}</code></pre>
<p>The block passed to <em>lazy</em> isn’t called until the first time the property is read, and the return value of the block is saved for future accesses, so the block will only be called once.</p>
<h4>Functional collection extensions</h4>
<p>Kotlin has some great functional <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/index.html#functions">extensions methods on collections and iterables</a>. Functions like <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/any.html"><em>any</em></a>, <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/join-to-string.html"><em>joinToString</em></a>, and <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/associate.html"><em>associate</em></a> can save you from a lot of hand-coded <em>for</em> loops that are necessary in Java.</p>
<p>There is also a lazy version of many of the functional collections operations that won’t make a copy of your collection after each operation, but my benchmarks find that the lazy and eager versions of operators have a similar enough performance that it usually won’t matter which one you use <em>[3]</em>.</p>
<h4>Named and default function arguments</h4>
<p><a href="https://kotlinlang.org/docs/reference/functions.html#named-arguments">Named parameters</a> and <a href="https://kotlinlang.org/docs/reference/functions.html#named-arguments">Default parameters</a> are pretty basic, but they let you cut down on a lot of boilerplate of defining overloads, and replace one of the main use cases of the Builder pattern.</p>
<p>Depending on your use case, you could potentially even use default arguments for basic dependency injection by making a production dependency the default, and passing a mock during tests.</p>
<p>For example, if you have a presenter that needs some global state, you could define its constructor like this:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Presenter</span></span>(  
        <span class="hljs-keyword">val</span> okhttp: OkHttp = productionOkHttp(),  
        <span class="hljs-keyword">val</span> picasso: Picasso = productionPicassoInstance()  
) {...}</code></pre>
<p>That allows you to create the presenter without arguments from your UI code, while allowing you to pass mock instances of the dependencies during tests. Full DI frameworks are more powerful, but this is a nice example of the usefulness of some simple language constructs.</p>
<h3>The Bad</h3>
<p>Although Kotlin is great, it’s not perfect. Here are a few aspects of the language that I’m not in love with.</p>
<h4>No namespaces</h4>
<p>Kotlin allows you to define functions and properties at the top level of your files. That’s a great feature, but it can cause some confusion when combined with the fact that all top level declarations are referenced unqualified from Kotlin. This can sometimes make it difficult to tell what a function is when reading one of its usages.</p>
<p>For example, if you define a top level function:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> {...}</code></pre>
<p>You will call that function as foo(). If you have a function with the same name in a different package, it’s not obvious from looking at the call site which function is being called. You can fully qualify the name of the function with the entire name of the package that it’s defined in, but given Java’s convention of very deep package names, that’s not ideal.</p>
<p>One workaround is to approximate a namespace by using with a singleton object class.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">object</span> FooActions {  
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> {...}  
}</code></pre>
<p>That allows you to refer to the function as FooActions.foo() if you’re only calling the functions from Kotlin, but it’s not as pretty if you have Java code that needs to call that function. From Java, you have to refer to the function as FooActions.INSTANCE.foo(), which is certainly not ideal. You can avoid the INSTANCE step by annotating your function with @JvmStatic, which is about the best you can do currently. That’s not a big deal, but it’s some boilerplate that wouldn’t be necessary if Kotlin had namespaces.</p>
<h4>No static modifier</h4>
<p>Following on the previous point, Kotlin has unusual handling of static function and property declarations that are called from Java. It’s not bad, but it feels dirtier than necessary. For example, the Android <em>View</em> class defines some static constants like <em>View.VISIBLE</em> and static methods like View.inflate:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">View</span> </span>{  
    <span class="hljs-keyword">public</span> static <span class="hljs-keyword">final</span> int VISIBLE = <span class="hljs-number">0x00000000</span>;  
    <span class="hljs-keyword">public</span> static <span class="hljs-keyword">final</span> int INVISIBLE = <span class="hljs-number">0x00000004</span>;  
    <span class="hljs-keyword">public</span> static View inflate(Context context, int resource) {...}  
}</code></pre>
<p>The declaration is simple. In contrast, here’s the equivalent Kotlin:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">View</span> </span>{  
    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> {  
        <span class="hljs-meta">@JvmField</span>   
        <span class="hljs-keyword">val</span> VISIBLE: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0x00000000</span>  
        <span class="hljs-meta">@JvmField</span>   
        <span class="hljs-keyword">val</span> INVISIBLE: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0x00000004</span>  
        <span class="hljs-meta">@JvmStatic</span>  
        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">inflate</span><span class="hljs-params">(context: <span class="hljs-type">Context</span>, resource: <span class="hljs-type">Int</span>)</span></span> {...}  
    }  
}</code></pre>
<p>Although the Kotlin version isn’t terrible, it’s more verbose than I would normally expect from the language. If you skip the annotations, then Java code will have to use awful syntax to refer to your fields:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">// With annotations:  </span>
View.VISIBLE;</code></pre>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">//Without annotations:  </span>
View.Companion.getVISIBLE();</code></pre>
<p>It feels odd that there are no better ways to create static functions and properties. I know that companion objects are real objects and can do stuff like implement interfaces, but that doesn’t feel like a compelling enough use case to completely replace normal static declarations.</p>
<h4>Automatic conversion of Kotlin to Java</h4>
<p>This was the first topic in the list of things I like about Kotlin, and it works well. But because it work so well 80% of the time, many of the cases where it fails can be frustrating.</p>
<p>Javadocs are often mangled, especially any paragraphs the wrap lines. Static fields and methods are converted to plain declarations on the companion object, which breaks any Java code that previously called them unless you manually add <em>@JvmField</em> or <em>@JvmStatic</em>, respectively.</p>
<p>All of these problems will certainly get fixed as the Kotlin team has more time to work on the converter, so I’m optimistic in this case.</p>
<h4>Required property accessor syntax</h4>
<p>Kotlin has the great syntactic sugar called “property accessor syntax” that allows you to call JavaBeans-style getters and setters as if they were a Kotlin property. So for example, you can call the <em>Activity.getContext()</em> method by writing <em>activity.context</em> instead of writing the whole method name. If you use the actual method call in Kotlin, you will get a lint warning telling you to use the property syntax instead.</p>
<p>That’s definitely a nice feature, but there are a few cases where method names start with the word “get”, but you don’t want to use the property syntax. One common case is with Java’s atomic classes. If you have a <em>val i = AtomicInteger()</em>, you might want to call <em>i.getAndIncrement()</em>. But Kotlin wants you to call <em>i.andIncrement</em>. That’s clearly not an improvement.</p>
<p>You can annotate every call site with <em>@Suppress(“UsePropertyAccessSyntax”)</em>, but that’s ugly. It would be much better if there was a way to annotate functions you write with a similar annotation that would tell the linter that the function shouldn’t be treated like a property.</p>
<h4>Method count</h4>
<p>Writing code in Kotlin will certainly reduce the number of lines of code in your project. But it will also probably increase the method count of the compiled code, which is of course a drawback if you’re using Android. There are a number of reasons for that, but one of the larger contributors is the way Kotlin implements properties.</p>
<p>Unlike Java, the Kotlin language doesn’t provide any way to define a bare field. All val and var declarations instead create a property. This has the advantage of allowing you to add a get or set definition to a property whenever you want without breaking code that references the property. That’s a great feature that removes the need to write defensive getters and setters in the way that you often do in Java.</p>
<p>That feature comes at a cost, though. Every public <em>val</em> causes Kotlin to generate both a backing field and a getter function that can be called from Java <em>[4]</em>. Every public <em>var</em> will cause both a getter and setter to be generated. Fortunately, private properties with default getters and setters are generated as fields and don’t cause getters or setters to be generated. If you were previously exposing a lot of public fields in Java (which is a common practice for constants), you can end up with a surprising increase in method count.</p>
<p>If you are close to the method limit in your android app, I recommend using the workaround of applying the <em>@JvmField</em> annotation on public constants for which you don’t expect to need a custom getter for in the future. This will prevent the getters from being generated, and can cut down on your method count.</p>
<p>It’s not all bad, though. As I discussed in my article on <a href="https://medium.com/keepsafe-engineering/lessons-from-converting-an-app-to-100-kotlin-68984a05dcb6">converting an app to 100% Kotlin</a>, the Kotlin standard library is small and can replace a number of common Java libraries that are much larger once you don’t need them in Java any more. Thanks to the standard library, the method count in that app decreased after converting it to Kotlin. So as long as you avoid the big areas that can increase your method count, you may end up ahead in the end.</p>
<h3>The Ugly</h3>
<p>And finally, here are two design decisions that the Kotlin team made that I strongly disagree with, and that I don’t expect to change in the future.</p>
<h4>SAM conversion and Unit returning lambdas</h4>
<p>This one is a really baffling design decision.</p>
<p>One of the best features of Kotlin is the way it embraces lambda functions. If you have a Java function that takes a SAM interface as a parameter (an interface with a Single Abstract Method):</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">public</span> void registerCallback(View.OnClickListener r)</code></pre>
<p>You can call it by passing a plain lambda from either Kotlin or Java:</p>
<pre><code class="hljs language-java"><span class="hljs-comment">// Java  </span>
registerCallback(() -> { <span class="hljs-comment">/** do stuff */</span> })</code></pre>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">//Kotlin  </span>
registerCallback { <span class="hljs-comment">/** do stuff */</span> }</code></pre>
<p>This is great. But trying to define a similar method in Kotlin is inexplicably harder. The direct translation is called the same from Java, but requires an explicit type when called from Kotlin:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">registerCallback</span><span class="hljs-params">(r: <span class="hljs-type">View</span>.<span class="hljs-type">OnClickListener</span>)</span></span></code></pre>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">// Kotlin. Note that parenthesis are required now._  </span>
registerCallback(View.OnClickListener { <span class="hljs-comment">/** do stuff */</span> })</code></pre>
<p>That’s annoying to have to type out, especially if you convert some Java code to Kotlin and find out that it breaks existing Kotlin code.</p>
<p>The idiomatic way to define that function in Kotlin would be with a function type:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">registerCallback</span><span class="hljs-params">(r: ()</span></span> -> <span class="hljs-built_in">Unit</span>)</code></pre>
<p>Which allows the nice function call syntax in Kotlin, but since all Kotlin functions are required to return a value, this makes calling the function from Java much worse. You have to explicitly return Unit from Java lambdas, so expression lambdas are no longer possible:</p>
<pre><code class="hljs language-kotlin">registerCallback(() -> {
    <span class="hljs-comment">/** do stuff */</span>  
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Unit</span>.INSTANCE;  
})</code></pre>
<p>If you’re writing a library in Kotlin, there isn’t any good way to write a method with a function parameter that is ideal to call from both Java and Kotlin. I try to work around this in my <a href="https://github.com/ajalt/flexadapter">FlexAdapter</a> library by providing overloads for each method with a function parameter that take either a SAM interface or a Kotlin function type. That lets you have a nice call syntax from both languages, but makes the library API less concise.</p>
<p>Hopefully the Kotlin designers change their mind and allow SAM conversions for functions defined in Kotlin in the future, but I’m not optimistic.</p>
<h3>Closed by default</h3>
<p>Every downside to Kotlin I’ve talked about so far are mostly small syntax details that are not quite as clean I’d like, but aren’t a big deal overall. But there’s one design decision that is going to cause a huge amount of pain in the future: All classes and functions in Kotlin are closed by default. It’s a design decision pushed by Effective Java, and it might sound nice in theory, but it’s an obviously bad choice to anyone who’s had to use a buggy or incomplete third-party library.</p>
<blockquote>
<p><em>Make all of your leaf classes final. After all, you’re done with the project — certainly no one else could possibly improve on your work by extending your classes. And it might even be a security flaw — after all, isn’t java.lang.String final for just this reason? If other coders in your project complain, tell them about the execution speed improvement you’re getting. — </em><a href="http://www.mindprod.com/jgloss/unmaindesign.html"><em>Roedy Green, How to Write Unmaintainable Code</em></a></p>
</blockquote>
<p>The Kotlin documentation <a href="#">actually has a paragraph trying to defend the choice</a>, so I’ll address the three reasons they give.</p>
<h4>“Best practices say that you should not allow these hacks anyway”</h4>
<p>The arguments for closed inheritance are mostly centered around the “Fragile Base Class Problem”, which is the idea that, if you allow someone to subclass your library code, they could change the way it works, potentially causing bugs. While that’s a possibility, there are lots of way to use a library incorrectly that will cause bugs. If you override some functionality in a class, it obviously your responsibility if you break something.</p>
<p>I use the word “obviously”, because overriding functionality is the way to use a library that most explicitly places responsibility on the user. I tutored Computer Science students for years, and while they managed to make nearly every mistake you can imagine, they were never surprised when they broke something by overriding a method. There are much more subtle ways to break a library you use, like passing a value with the correct type but wrong units, or forgetting to call a required method.</p>
<p>I appreciate the approach of writing code that has fewer places that can break, and making classes final might seem to do that. But it’s a certainty that libraries will be incomplete or incorrect, and you will eventually need to use one of those libraries. Modifying the behavior of a closed class is going to require much worse hacks that are more likely to result in bugs than if you could just override one or two of that class’s methods.</p>
<p>But you don’t even have to take my word for it. Here’s a real world example that might have impacted you personally if you’re an Android dev:</p>
<p>AppCompat 23.2.0 finally saw the addition of <a href="https://plus.google.com/+AndroidDevelopers/posts/iTDmFiGrVne">VectorDrawables</a> to the support library. This was a very welcome addition that promised to reduce APK size and memory usage. <a href="https://code.google.com/p/android/issues/detail?id=205236">Except that it caused a huge memory leak in any activities that tried to inflate them</a>. The support was <a href="https://plus.google.com/+AndroidDevelopers/posts/iTDmFiGrVne">removed a couple weeks later</a>.</p>
<p>Where did the memory leaks come from? In order to <a href="https://medium.com/@chrisbanes/appcompat-v23-2-age-of-the-vectors-91cbafa87c88">implement VectorDrawable inflation</a>, the support library authors needed to update the way <em>Context.getDrawable</em> is implemented. But that function is final, so they had to make every View create a new copy of a Resources wrapper that could handle <em>VectorDrawables</em>. Besides being a large amount of work, this caused the various wrapped Resources to become out of sync, and to use a large amount of memory due to the duplication. If that function wasn’t final, that mess wouldn’t have happened.</p>
<h4>“People successfully use other languages (C++, C#) that have similar approach”</h4>
<p>People also successfully use languages like Python that allow anything at all to be changed at any time. Python has “non-public” methods like <strong>asdict<em> that are documented to by implementation details. It also has name mangled functions like </em></strong>intern_ that are harder to accidentally call. You can freely monkey-patch or override any of those functions whenever you want, and Python won’t complain.</p>
<p>In five years of full time Python development, I can’t think of a single time when someone broke my code by overriding a function. I can think of many instances where I’ve altered a non-public function in a safe, correct way in much less time than it would have taken to implement the same functionality if Python prevent me from doing so.</p>
<p>I’m not advocating blindly altering implementation detail of every class you come in contact with, but there’s no reason to make that impossible if it becomes necessary. A common saying in the Python community is that “We’re all consenting adults here.” If you need to make a change to one of my classes, you should be able to.</p>
<h4>“If people really want to hack, there still are ways: you can always write your hack in Java and call it from Kotlin (see Java Interop), and Aspect frameworks always work for these purposes”</h4>
<p>This is of course a ridiculous argument. You still can’t override closed Kotlin methods in Java without unacceptable use of reflection, so this doesn’t hold any weight.</p>
<p>Not being able to extend from a library means that it becomes very difficult to add features or fix bugs. And in the real world, more libraries than not will need hacking. That’s simply reality, and is never going to change. A library author is never going to be able to predict every possible use case that users will have. Making all of your classes final only prevents users from easily implementing the features you can’t. This was a surprisingly dogmatic choice given how practical the Kotlin designers were in the rest of the language.</p>
<p>If you write a Kotlin library, please make all of your public functions open. You’ll make life easier on your users in the future.</p>
<h3>Conclusion</h3>
<p>Kotlin is overall a great language. It is much less verbose than Java, and has an excellent standard library that removes the need to use a lot of the libraries that make Java life bearable. Converting an app from Java to Kotlin is made much easier thanks to automated syntax conversion, and the result is almost always an improvement. If you’re an Android developer, you owe it to yourself to give it a try.</p>
<p>At <a href="https://www.getkeepsafe.com/">Keepsafe</a>, all new Android development is in Kotlin, and legacy Java code is steadily being converted to Kotlin as we make changes to it.</p>
<p>Interested in working with us? Have a look at our <a href="https://jobs.lever.co/keepsafe">job openings</a>.</p>
<p><strong>[1]</strong> In the case of a <em>lateinit</em> property, <em>kotlin.UninitializedPropertyAccessException</em> will be thrown, where the <em>Delegates.notNull</em> will throw an <em>IllegalStateException</em>.</p>
<p><strong>[2]</strong> There are some details about <em>lateinit</em> that are worth noting, especially if you plan on accessing a <em>lateinit</em> property from Java code. First is that <em>lateinit</em> cannot be applied to primitive types such as <em>Int</em> or <em>Double</em>. The second is that a <em>lateinit</em> property is backed by a field with the same visibility as the property, and this field is visible from Java. Additionally, that backing field can be freely set to null from Java. If any of those are issues for your use case, <em>Delegates.notNull</em> may be a better choice.</p>
<p><strong>[3]</strong> The lazy <em>Sequence</em> operators can outperform the eager versions by up to 20%, but only once list sizes start growing very large. For lists under a megabyte or so in size, the lazy versions often perform the same or worse than the eager versions.</p>
<p><strong>[4]</strong> This is a bit of a simplification. Kotlin will only generate a backing field if you don’t define a get function, or if the defined get function doesn’t reference the implicit <em>field</em> identifier.</p>
]]></description><link>https://medium.com/keepsafe-engineering/kotlin-the-good-the-bad-and-the-ugly-bf5f09b87e6f#.prwij1b6d</link><guid isPermaLink="true">https://medium.com/keepsafe-engineering/kotlin-the-good-the-bad-and-the-ugly-bf5f09b87e6f#.prwij1b6d</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[AJ Alt]]></dc:creator><pubDate>Sat, 20 Aug 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[The Next Language You Thought You Didn’t Need]]></title><description><![CDATA[<p>At a recent conference, I happened upon some information about the programming language, Kotlin. I had heard of it, but never looked into anything about it. After taking a casual look at it, I’m strongly considering giving it a shot on a “real” project. Read on to find out why. My background is primarly Java programming, followed closely by Ruby. I’ve had experience with numerous other languages over the years, but usually only on a small number of projects, or on projects old enough that I don’t consider myself current. Java is my favorite overall. Ruby has lots of great benefits in certain types of projects, so it’s a handy tool to have around as well. So what about Kotlin?</p>
<p>Kotlin was developed by JetBrains, the makers of IntelliJ IDEA and other IDE variants as well as other developer tools. Kotlin is a statically typed language that runs on the Java Virtual Machine. It is not syntax compatible with Java, but both Java and Kotlin source files can seamlessly interoperate within the same code base. That is a pretty huge benefit if you’d like to try it out in an existing Java project and can not afford to spin up an entirely new rewrite. The language was first announced in 2011 and was open sourced in 2012. The version 1.0 release became available earlier this year. The language supports object oriented and procedural programming. And, like Scala, it tackles many of the shortcomings and inconveniences from Java. For example, Kotlin makes a distinction between nullable and non-nullable types, so you must explicitly indicate that variables can be null.  It allows you to write concise, clear code and reduce lots of boilerplate which is often a big complaint with Java.</p>
<p>So why not just use Scala? In my case, a language needs to really sell me on the benefits and low cost of adoption for it to be worth my time to consider incorporating it into my toolset. Scala just never seemed convenient enough in my cursory glances at it. But Kotlin seems to have knocked down those barriers to entry. It has fantastic tool support in IntelliJ. You can even have the IDE automatically convert Java code to Kotlin if you want. Since Kotlin source code is perfectly happy to live alongside Java code, it is trivial to transition at your own pace or give it a trial run without too much overhead. You can call any existing Java code directly and easily from Kotlin code and vice versa. Kotlin is even quickly gaining ground as a go to platform for Android development.</p>
<p>At this point, I’ve only looked at a few tutorial examples to start getting my feet wet, so I can’t speak to the long term transition and adoption. However, it was ridiculously easy to get started and that is a serious win in my book. I enjoyed it enough to actually take a look at using it on some upcoming personal projects. I’m interested to see how it plays alongside some of my goto Java frameworks like Spring Boot, etc., although it will almost certainly be pretty seamless. JetBrains has committed to long term support of the language so it’s not going away anytime soon.</p>
<p>I’m not one to jump over to the latest and greatest languages that show up on the radar. They usually turn out to be more effort than they are worth for me. However, Kotlin has definitely piqued my interest and I will be taking a closer look at how I can incorporate it my projects. Great benefits to efficiency, low barriers to entry, and low risk. With features like that, if you are a Java developer, it might be a language you are interested in as well. If you’ve tried it already, let me know about your experiences with it.</p>
]]></description><link>http://www.dellingertechnologies.com/2016/08/17/kotlin-the-next-language-you-thought-you-didnt-need/</link><guid isPermaLink="true">http://www.dellingertechnologies.com/2016/08/17/kotlin-the-next-language-you-thought-you-didnt-need/</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Jay Dellinger]]></dc:creator><pubDate>Wed, 17 Aug 2016 10:54:00 GMT</pubDate></item><item><title><![CDATA[Logging in Kotlin & Android: AnkoLogger vs kotlin-logging]]></title><description><![CDATA[<h1>Logging in Kotlin &#x26; Android: AnkoLogger vs kotlin-logging</h1>
<p>In the <a href="https://medium.com/@OhadShai/logging-in-kotlin-95a4e76388f2">previous post</a> <em>kotlin-logging</em> framework was introduced. In this post I am going to compare it with <em>anko</em> in the aspect of logging in Android.</p>
<p><a href="https://github.com/Kotlin/anko">Anko</a> is probably one of the most popular libraries in Kotlin today. It was written by JetBrains as a DSL (Domain Specific Language) for view editing instead of the plain old xml used in Android-Java.</p>
<p>Along with that <em>anko</em> provide other helpers for android development, among them is the <a href="https://github.com/Kotlin/anko/blob/d40dfa016a9cf74286127de16273a131e48348bd/doc/ADVANCED.md#logging"><em>AnkoLogger</em></a> for logging. I am going to observe this specific aspect and compare it to using <a href="https://github.com/MicroUtils/kotlin-logging"><em>kotlin-logging</em></a> for logging in android.</p>
<h3>Installation simplicity</h3>
<p>If you are a user of anko, then using <em>AnkoLogger</em> has no additional installation. Super easy. If you are not using anko, then it is an overkill to install it just for logging. kotlin-logging is pretty simple to install with gradle, and there is an example <a href="https://github.com/MicroUtils/kotlin-logging-example-android">in here</a>.</p>
<h3>Package size</h3>
<p>For anko this is not relevant since the AnkoLogger is just one class among many. kotlin-logging jar is about 10kb but requires additional dependencies of ~50kb (slf4j+android bridge). Pretty light-weight.</p>
<h3>Interface</h3>
<p>In kotlin-logging the recommended interface is like that:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FooWithLogging</span> </span>{  
    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span>: KLogging()  
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span></span> {  
        logger.info { <span class="hljs-string">"twinkle twinkle <span class="hljs-subst">$little</span> star"</span> }  
    }  
}</code></pre>
<p>The logger is defined as a parent for the companion object. The companion object then has a property called <em>logger.</em> In the bytecode, that translates into a static member.</p>
<p>The logger in turn is an extension of slf4j Logger called KLogger. Hence original methods are available as well as lazy evaluation extensions (with curly braces).</p>
<p>In AnkoLogger the recommended interface is like that:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeActivity</span> : <span class="hljs-type">Activity</span></span>(), AnkoLogger {  
    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">someMethod</span><span class="hljs-params">()</span></span> {  
        info(<span class="hljs-string">"London is the capital of Great Britain"</span>)  
        debug(<span class="hljs-number">5</span>) <span class="hljs-comment">// .toString() method will be executed  </span>
        warn(<span class="hljs-literal">null</span>) <span class="hljs-comment">// "null" will be printed  </span>
    }  
}</code></pre>
<p>The logger is defined in an interface called <em>AnkoLogger</em> that your class is extending. You don’t access it directly, instead just call the log methods by the level. Again, a lazy flavors exists for different log levels. AnkoLogger also “pollutes” your class with a public property called <em>loggerTag</em>, and all logging methods are public. Of course this can be fixed with a companion object.</p>
<h3>Logger name</h3>
<p>Looks like a small detail but still...</p>
<p>In kotlin-logging the name of the logger is inferred from the class and package name. In cases the name is too long it is truncated and replaced with stars. more details in <a href="http://www.slf4j.org/android">Logger name mapping</a>. In AnkoLogger, the name of the logger is the class name only without package name. Again, if it is long it is getting truncated.</p>
<p>One notable different is that AnkoLogger doesn’t handle inheritance, so in case of inheritance the logger name is of the child class even when the log message was issued in the parent class. A little bit confusing :-(</p>
<h3>Performance and resource consumption</h3>
<p>First I will start with a note about premature optimization: performance measurements can be very misleading and differ from one use case to another.</p>
<p>Under the hood both frameworks use the native logging of android so only minor differences should be expected.</p>
<p>The main difference in the design is that kotlin-logging has a companion (static) member of the logger as opposed to AnkoLogger that has a property for each object instance.</p>
<p>From my small tests kotlin-logging has slightly better speed, but I did not see any absolute advantage hence you should check that for your use case if it is required.</p>
<h3>Conclusion</h3>
<p>I compared AnkoLogger with kotlin-logging for Android developers, that writes applications in Kotlin.</p>
<p>In case you would like to play with it a bit, I created a project with both frameworks in github: <a href="https://github.com/MicroUtils/anko-vs-kotlin-logging">https://github.com/MicroUtils/anko-vs-kotlin-logging</a></p>
<p>For me the bottom line is that if you use anko in your application then probably AnkoLogger is the solution for you, otherwise I think <a href="https://github.com/MicroUtils/kotlin-logging">kotlin-logging</a> is easier. The rest is a matter of style.</p>
<p>As always, comments are welcome.</p>
]]></description><link>https://medium.com/@OhadShai/logging-in-android-ankologger-vs-kotlin-logging-bb693671442a#.pi8n1ojoh</link><guid isPermaLink="true">https://medium.com/@OhadShai/logging-in-android-ankologger-vs-kotlin-logging-bb693671442a#.pi8n1ojoh</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Android]]></category><dc:creator><![CDATA[osha1]]></dc:creator><pubDate>Sun, 14 Aug 2016 12:33:00 GMT</pubDate></item><item><title><![CDATA[PaperParcel with Kotlin]]></title><description><![CDATA[<p>When I started to code in kotlin, one of the libraries that I found that was really useful is <a href="https://github.com/grandstaish/paperparcel">PaperParcel</a>. PaperParcel is a library that would generate Parcelable using annotation. The good thing about it, is that it will reduce the amount of code and mistake you could make if you manually create those classes. Having said that, the library is not purely for Kotlin and it could be used in Java Android project.  </p>
<p>To use it in kotlin<br>
You will need to add these to your app build gradle dependencies  </p>
<pre><code class="hljs language-gradle"><span class="hljs-keyword">compile</span> <span class="hljs-string">'com.github.grandstaish.paperparcel:paperparcel:1.0.0-rc4'</span>
<span class="hljs-keyword">compile</span> <span class="hljs-string">'com.github.grandstaish.paperparcel:paperparcel-kotlin:1.0.0-rc4'</span>
kapt <span class="hljs-string">'com.github.grandstaish.paperparcel:compiler:1.0.0-rc4'</span></code></pre>
<p>while still in that gradle file, add these before dependencies  </p>
<pre><code class="hljs language-gradle">kapt {
    generateStubs = <span class="hljs-keyword">true</span>
}
<span class="hljs-keyword">repositories</span> {
    maven { url <span class="hljs-string">'https://jitpack.io'</span> }
}</code></pre>
<p>Now the fun part, this is taken from my app <a href="https://play.google.com/store/apps/details?id=com.monmonja.dailyPictureQuotes">Daily Picture Quotes</a>  </p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@PaperParcel</span>
<span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuoteImage</span></span>(<span class="hljs-keyword">val</span> id: String = <span class="hljs-string">""</span>,
                 <span class="hljs-keyword">val</span> name: String = <span class="hljs-string">""</span>,
                 <span class="hljs-keyword">val</span> text_quote: String = <span class="hljs-string">""</span>,
                 <span class="hljs-keyword">val</span> url: String = <span class="hljs-string">""</span>,
                 <span class="hljs-keyword">val</span> created: String = <span class="hljs-string">""</span>,
                 <span class="hljs-keyword">val</span> cursor:String? = <span class="hljs-string">""</span>) : PaperParcelable {
    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> {
        <span class="hljs-meta">@JvmField</span> <span class="hljs-keyword">val</span> CREATOR = PaperParcelable.Creator(QuoteImage::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>)</span>
    }
}</code></pre>
<p>Thats about it, you can use QuoteImage to pass around Activities or Fragment or use it with your custom class.  </p>
<p>Two things you have to remember is that your data class name must be supplied in PaperParcelable.Creator and every time you make changes to this data class (atleast for me) you have to do rebuild project.  </p>
<p>If this interest you then have a check on the <a href="https://github.com/grandstaish/paperparcel/wiki/Kotlin-Usage">kotlin usage</a> section of their github page.  </p>
<p>Hope this helps :)  </p>
]]></description><link>http://www.tutorialforandroid.com/2016/08/paperparcel-with-kotlin.html</link><guid isPermaLink="true">http://www.tutorialforandroid.com/2016/08/paperparcel-with-kotlin.html</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Android]]></category><dc:creator><![CDATA[Almond Joseph Mendoza]]></dc:creator><pubDate>Wed, 10 Aug 2016 22:06:00 GMT</pubDate></item><item><title><![CDATA[Issues Faced With Kotlin During Android Development]]></title><description><![CDATA[<p><a href="https://kotlinlang.org/">Kotlin</a> seems like the future of Android development. It is a new statically-typed programming language that runs on JVM, with a very refined syntax and enhanced features. There is a lot to love about it. Kotlin is interoperable with Java, which should reduce the risk of future incompatibility. The additional language features such as Function Extensions and High Order Function make it much more extensible and scalable. The code is concise with data classes, single expression function, infix and many more... enough said. Kotlin is just great!</p>
<p><img src="http://offers.bilue.com.au/hs-fs/hubfs/Screen_Shot_2016-08-10_at_2.10.19_pm.png?t=1470802416157&#x26;width=733&#x26;height=294" alt="Screen_Shot_2016-08-10_at_2.10.19_pm.png">  </p>
<p>I started working on some real apps using Kotlin that have since been published on the playstore. I have to say it was relatively smooth sailing. Nonetheless, there were some hiccups along the way that are worth sharing.</p>
<h3><strong>1. Method Count Increase.</strong></h3>
<p>Method count increase was one of the issues I was fully aware before starting with Kotlin. At the time of writing, there are an additional <a href="https://blog.jetbrains.com/kotlin/2016/03/kotlins-android-roadmap/">7’191 methods</a> adding to the total method count. This would add more than 10% to the 65k methods limit. Nonetheless, I didn’t worry that much as the MultiDex support is there to help to overcome this issue.</p>
<h3><strong>2. Using Libraries that require Annotation.</strong></h3>
<p>There are many cool libraries that can assist with making Android Development much more efficient. However, when switching over to Kotlin, using some of them becomes a challenge. There are two libraries which I can’t manage to use directly after switching to Kotlin, i.) <a href="https://github.com/frankiesardo/icepick">Icepick</a> and ii.) <a href="https://github.com/greenrobot/EventBus">EventBus</a>. The main reason is that the Annotation (i.e. <em>@State _and</em> @Subscribe_) is not picked up by the code. Fortunately, with EventBus, I managed to work around this by creating a composite class object using Java Code. Note that this doesn’t mean all libraries using Annotation would not work for Kotlin. I managed to use <a href="http://square.github.io/retrofit/">Retrofit 2.0</a> and <a href="http://google.github.io/dagger/">Dagger 2.0</a> (where both use Annotation extensively) in Kotlin directly.</p>
<h3><strong>3. Mocking Need Open Class/Function.</strong></h3>
<p>By default a class and function is considered final for Kotlin. Mocking (using <a href="http://mockito.org/">Mockito</a>) requires a non-final class. So in order to have that, we have to explicitly <em>open</em> a class if we would like to mock it for testing. If this is not done, it would error out easily. The more tricky issue is the function. If the function is not <em>open</em>, there would be no error issue when running the test. Instead of intercepting the function, it would call the actual internal function, where the test would fail with NPE. Without knowing the function needs to be <em>open</em>, the root issue might not be easily discoverable.</p>
<h3><strong>4. Java to Kotlin Converter Limitation.</strong></h3>
<p>The Kotlin Plugin for Android Studio is just great, especially allowing to auto convert from Java to Kotlin. However, the conversion might not be ideal. e.g.</p>
<p>is converted to</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleClass</span></span>(memberVariable: <span class="hljs-built_in">Int</span>) {
  <span class="hljs-keyword">internal</span> <span class="hljs-keyword">var</span> memberVariable = <span class="hljs-number">0</span>

  init {
      <span class="hljs-keyword">this</span>.memberVariable = memberVariable
  }
}</code></pre>
<p>Whereby it could be as simple as</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleClass</span></span>(<span class="hljs-keyword">val</span> memberVariable: <span class="hljs-built_in">Int</span>) {}</code></pre>
<p>Anyway, it’s always good to review the converted code and explore so that we don’t just have Kotlin code in Java style, without the real advantage of Kotlin.</p>
<h3><strong>5. Other Converter Issue.</strong></h3>
<p>I love writing a new function from an object, and pressing <em>Alt-Enter</em> to trigger the auto-function creation. If you are writing on the Java side of code, and call a Kotlin function (that you just intended to create), sorry you are out of luck. Android Studio will only auto create that function for you in the Kotlin code.</p>
<p>At times for experimental purposes we would also like to convert from Kotlin to Java, given that it was inter-operable with Java. This is not possible however the tools only allow you to convert from Java to Kotlin and not vice versa. Perhaps this is by design, and I could imagine it would be difficult for Java to handle conversion of more advanced Kotlin language features.</p>
<p>None of these issues are show stoppers. The advantage and fun of learning new things outweighs them in any case. The language features are richer and there is so much to explore. I haven’t really faced many issues from Kotlin’s language as yet. I’m sure I’ll uncover more issues, but I don’t expect them to “kill me”. Java is always there to the rescue :)</p>
<p>As with any new thing, one other challenge is finding community support. Suppose you are experimenting with new Android Features and face a road-block. If you post your question to Stackoverflow using your Kotlin code, you are unlikely to generate support.</p>
<p>So... you might as well be the one who supports others... which is in itself a good thing! :)</p>
]]></description><link>http://blog.bilue.com.au/issues-faced-with-kotlin-during-android-development-1</link><guid isPermaLink="true">http://blog.bilue.com.au/issues-faced-with-kotlin-during-android-development-1</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Android]]></category><dc:creator><![CDATA[Elisha Lye]]></dc:creator><pubDate>Wed, 10 Aug 2016 11:20:00 GMT</pubDate></item><item><title><![CDATA[Lessons from converting an app to 100% Kotlin]]></title><description><![CDATA[<h3>Lessons from converting an app to 100% Kotlin</h3>
<p>I’ve been following the development of <a href="https://kotlinlang.org">Kotlin</a> for a while. Kotlin is a relatively new language that primarily targets the JVM, and is interoperable with Java. With the release of Kotlin version <a href="https://blog.jetbrains.com/kotlin/2016/05/kotlin-1-0-2-is-here">1.0.2</a>, which brought incremental compilation and a large reduction in the number of methods in its standard library, I was eager to start using it in production.</p>
<p>I’m the lead engineer on <a href="https://play.google.com/store/apps/details?id=com.getkeepsafe.applock">App Lock</a> at <a href="https://www.getkeepsafe.com">Keepsafe</a>, which, like most Android apps, was written in Java. There are quite a few places where Java falls short of modern languages, especially the version of Java 7 that Android supports. To reduce the pain, it is common to use libraries such as <a href="https://github.com/evant/gradle-retrolambda">Retrolambda</a> for a backport of lambdas and try-with-resources, <a href="https://github.com/google/guava">Guava</a> for immutable collections and utility functions, <a href="https://github.com/JakeWharton/butterknife/">ButterKnife</a> for view binding, or <a href="https://github.com/ReactiveX/RxJava">ReactiveX</a> for functional programming. All of those libraries come with drawbacks, though. Retrolambda frequently causes incremental builds to fail, and every library you depend on adds methods to your APK.</p>
<p>Even with those libraries, Java code is verbose. Your code has to go through a lot of ceremony that the designers of Java thought was a good idea in the 90s, but is clearly unnecessary today. Kotlin provides a well thought-out syntax and extensive standard library that removes many of the pain points that exist in Java. So over the course of a few days, I converted the entire App Lock codebase into Kotlin. Here are my thoughts on the process.</p>
<h3>Kotlin vs Java in App Lock</h3>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/800/1*0JjkzvEAP17sK28Ud12QqQ.png">
<em>Method count in App Lock after converting to Kotlin. From the dexcount gradle plugin.</em></p>
<p>One concern that people will raise about converting to Kotlin is the number of methods added by its standard library. Thanks to massive libraries like the support library and GMS, many apps are in danger of bumping up against the <a href="https://developer.android.com/studio/build/multidex.html">Dex method limit</a>. I used the <a href="https://github.com/KeepSafe/dexcount-gradle-plugin">dexcount gradle plugin</a> to break down the method count before and after the rewrite. The end result is that the total method count after proguard <em>decreased</em> by 10% from 5491 to 4987 (not counting GMS or appcompat). The code count decreased by 30% from 12,371 lines of Java, to 8,564 lines of Kotlin.</p>
<blockquote>
<p>Converting the app from Java to Kotlin reduced the total method count by 10%, and the total lines of code by 30%</p>
</blockquote>
<p>The method count decrease is a result of both Kotlin being a more concise language, as well as the fact that many of the quality of life libraries that were previously used in Java are no longer necessary.</p>
<h4>Retrolambda</h4>
<p>Retrolambda generates an anonymous class for every lambda which add several methods each. Kotlin has inline methods to which a lambda can be passed without adding any extra methods.</p>
<p>For example, the extremely useful standard library function <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/apply.html"><em>apply</em></a>:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> nT> T.<span class="hljs-title">apply</span><span class="hljs-params">(block: <span class="hljs-type">T</span>.()</span></span> -> <span class="hljs-built_in">Unit</span>): T {   
    block(); <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>   
}</code></pre>
<p>Which is called like this:</p>
<pre><code class="hljs language-kotlin">myObject.apply **{** <span class="hljs-comment">/* modify myObject */</span> **}**</code></pre>
<p>Even though you’re defining a lambda function at the call site, no anonymous class is generated, so no extra methods are added, and no allocation happens due to that call. In fact, the <em>apply</em> function itself, like most inline functions in the Kotlin standard library, doesn’t cause a method to be added in the compiled code.</p>
<h4>Guava</h4>
<p>The entirety of Guava is covered by the Kotlin standard library, which has the additional advantage of being easier to use. Big Guava ComparisonChains can be replaced with a few characters with the <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.comparisons/index.html">kotlin.comparisons functions</a>.</p>
<pre><code class="hljs language-java"><span class="hljs-comment">// Guava  </span>
ComparisonChain._start_()  
        .compareTrueFirst(lhs.isActive(), rhs.isActive())  
        .compare(lhs.lastName(), rhs.lastName())  
        .compare(lhs.firstName(), rhs.lastName())  
        .result();</code></pre>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">//Kotlin  </span>
_compareValuesBy_(lhs, rhs,   
    **{it**.active**}**, **{it**._lastName_**}**, **{it**._firstName_**}**)</code></pre>
<p>The null safety of Guava’s Optional class is <a href="https://kotlinlang.org/docs/reference/null-safety.html">built in to Kotlin</a>.</p>
<pre><code class="hljs language-java"><span class="hljs-comment">// Guava  </span>
<span class="hljs-keyword">return</span> Optional._of_(value).or(defaultValue);</code></pre>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">// Kotlin  </span>
<span class="hljs-keyword">return</span> value ?: defaultValue</code></pre>
<p>Guava’s lazy fields and Preconditions classes are covered by the <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/index.html">Kotlin standard library</a>.</p>
<pre><code class="hljs language-java"><span class="hljs-comment">// Guava  </span>
<span class="hljs-keyword">private</span> Supplier&#x3C;String> lazyField = Suppliers._memoize_(  
    () -> <span class="hljs-string">"value"</span>);  
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getField</span><span class="hljs-params">()</span> </span>{  
    <span class="hljs-keyword">return</span> lazyField.get();  
}</code></pre>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">// Kotlin  </span>
<span class="hljs-keyword">val</span> field <span class="hljs-keyword">by</span> _lazy_ **{** <span class="hljs-string">"value"</span> **}**</code></pre>
<pre><code class="hljs language-java"><span class="hljs-comment">// Guava  </span>
Preconditions.checkNotNull(value, <span class="hljs-string">"error %s"</span>, arg);</code></pre>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">// Kotlin  </span>
_checkNotNull_(value) **{**<span class="hljs-string">"<span class="hljs-subst">$arg</span>"</span>**}**</code></pre>
<p>Nearly all of Guava’s collections classes <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/index.html">exist in Kotlin</a>. Even with all of that functionality, the entire Kotlin standard library is still smaller than Guava alone.</p>
<h4>ButterKnife</h4>
<p>ButterKnife can still be used in Kotlin, but the <a href="https://kotlinlang.org/docs/tutorials/android-plugin.html">Kotlin Android Extensions</a> provide a more natural way to access bound views. Other solution also exist such as <a href="https://github.com/JakeWharton/kotterknife">Kotterknife</a> and <a href="https://github.com/Kotlin/anko">Anko</a>, but I find that regular XML layouts with the Kotlin Android Extensions are currently the best way to work with Views. Kotterknife requires more boilerplate than the extensions. Anko adds thousands of methods, and its DSL is often more complicated and less capable than XML.</p>
<h4>RxJava</h4>
<p>RxJava is still awesome, and I still use it in many places in App Lock. But since Java on Android doesn’t have functional methods on collections, I will sometimes use RxJava as a substitute. Something like this in Java:</p>
<pre><code class="hljs language-kotlin">Observable.from(collection)  
    .filter(it -> it.isActive())  
    .map(it -> it.size())  
    .reduce((it, sum) -> it + sum)  
    .toBlocking().single();</code></pre>
<p>Can be replaced with this in Kotlin:</p>
<pre><code class="hljs language-kotlin">collection.filter { it.isActive() }  
          .map { it.size() }  
          .reduce { it, sum -> it + sum }</code></pre>
<h3>Getting started with Kotlin</h3>
<p>If you already know Java, learning Kotlin is easy. You can work through the <a href="http://kotlinlang.org/docs/reference/">Kotlin Koans online</a>, and the <a href="http://kotlinlang.org/docs/reference/">reference documentation</a> is very well written. Jake Wharton also gave a <a href="https://vimeo.com/144877458">great talk about some of the useful syntax features in Kotlin</a>.</p>
<p>The best part about Kotlin is that it can be called from Java, and Java can be called from Kotlin. So you don’t need to convert your entire codebase at once. I would suggest you start with a single file that you rewrite from scratch. IntelliJ has an automated Java-to-Kotlin converter, but it frequently produces incorrect code, so it’s better to start from scratch until you have a better handle on the language.</p>
<p>Once you have the basics down, I recommend picking some existing Java code that has few dependencies, and converting it to Kotlin. UI code like an Activity of Fragment on Android is a good place. Picking a class with no dependencies allows you to focus on just the code you’re working on without worrying about how any interfaces are changing. Keep the <a href="https://kotlinlang.org/docs/reference/">Kotlin reference</a> open so that you can quickly answer questions about syntax or the standard library that come up while you’re working. You could also choose to start new Kotlin code from scratch instead of converting from Java, but I find that it’s easier to pick up some of the less obvious syntax from converted code than trying to figure it out from a blank slate. The automated conversion does a really good job in most cases, and the places where it fail are usually easy to fix.</p>
<p>Something to keep in mind while you’re learning Kotlin is to avoid getting overwhelmed. If you don’t already use a design pattern like MVP or MVVM, don’t worry about try to learn it at the same time. Don’t worry about finding every Kotlin library available. Just focus on taking what you know about Java and translating that knowledge to Kotlin. If you still have pain points, then you can add more libraries or design patterns.</p>
<h3>Should you convert your entire codebase at once?</h3>
<p>After you’ve got some Kotlin working in your codebase, you’ll have to decide whether or not to convert everything at once, or take it more slowly. Fortunately, Kotlin has excellent two-way interoperability with Java, so you can convert single classes at a time, and ship with both languages running together.</p>
<p>For large codebases, it can be too much work to convert everything in one release. In <a href="https://play.google.com/store/apps/details?id=com.kii.safe">Keepsafe’s main app</a>, about 15% of the code is Kotlin as of this writing. In that app, if we have to make significant changes to a Java class, we’ll usually convert the class to Kotlin while we’re working on it. This allows us to steadily improve the codebase without slowing down our work on new features.</p>
<p>However, if your project is small enough that you can convert to 100% Kotlin, it’s something worth considering. When you don’t have to maintain Java compatibility, you can simplify your internal APIs and remove a lot of the libraries I talked about earlier. You can convert static utility classes into extension functions, and take advantage of the stronger type inference in Kotlin.</p>
<h3>Final thoughts</h3>
<p>Kotlin is a great language, and is a huge improvement over Java. Converting App Lock to Kotlin resulted in an app that was faster, smaller, and which had fewer bugs than before. The language is mature enough now that there were no important features missing, in either the tooling, the language, or the standard library. If you’re wondering whether to give Kotlin a try now or if you should wait a while longer, I can tell you that Kotlin is ready for full time production use now. If you work with Android or another Java environment where Kotlin is a possibility, you owe it to yourself to give Kotlin a try.</p>
<p><em>This is the first post of a series of two. Follow</em> <a href="http://www.keepsafe.tech"><em>Keepsafe Engineering</em></a> <em>to get notified about future posts. Interested in writing Kotlin code your self? Have a look at our</em> <a href="https://jobs.lever.co/keepsafe/6414e440-ed8e-4c1e-a156-6e4e1b716577"><em>Kotlin job opening</em></a><em>.</em></p>
]]></description><link>https://medium.com/keepsafe-engineering/lessons-from-converting-an-app-to-100-kotlin-68984a05dcb6#.ymxam7e1t</link><guid isPermaLink="true">https://medium.com/keepsafe-engineering/lessons-from-converting-an-app-to-100-kotlin-68984a05dcb6#.ymxam7e1t</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Android]]></category><dc:creator><![CDATA[AJ Alt]]></dc:creator><pubDate>Wed, 10 Aug 2016 11:10:00 GMT</pubDate></item><item><title><![CDATA[The Kobalt diaries: Parallel builds]]></title><description><![CDATA[<p><img src="http://beust.com/pics/parallel-build-result.png"></p>
<p>I’ve always wondered why the traditional build systems we use on the JVM (Maven, Gradle) don’t support parallel builds (edit: this is not quite true, see the comments), so now that I developed my <a href="http://beust.com/kobalt">own build system</a>, I decided to find out if there was any particular difficulty to this problem that I had overlooked. This turned out to be easier than I anticipated and with interesting benefits. Here is a preliminary result of my findings.</p>
<h2>Defining parallel builds</h2>
<p>While most builds are sequential by nature (task B can’t usually run until task A has completed), projects that contain multiple sub projects can greatly benefit from the performance boost of parallel builds. This speed up will obviously not apply to single projects or subprojects that have direct dependencies on each other (although this is not quite true as we will see below). If you’re curious, the engine that powers Kobalt’s parallel builds is an improved version of TestNG’s own <code>DynamicGraphExecutor</code>, which I described in details <a href="http://beust.com/weblog/2009/11/28/hard-core-multicore-with-testng/">in this post</a>.</p>
<p>In order to measure the efficacy of parallel builds, I needed a more substantial project, so I picked <a href="https://github.com/Kotlin/ktor">ktor</a>, Kotlin’s web framework developed by JetBrains. ktor is interesting because it contains more than twenty sub projects with various dependencies with each other. Here is a dependency graph:</p>
<p><img src="http://beust.com/pics/ktor-dependencies.png"></p>
<p>You can see that <code>core</code> is the main project that everybody else depends on. After that, the dependencies open up and we have the potential to build some of these projects in parallel: <code>locations</code>, <code>samples</code>, etc...</p>
<p>I started by converting the <code>ktor</code> build from Maven to Kobalt. Right now, <code>ktor</code> is made of about twenty-five <code>pom.xml</code> files that add up to a thousand lines of build files. Kobalt’s build file (<code>Build.kt</code>) is one file of about two hundred lines, and you can <a href="https://github.com/cbeust/ktor/blob/kobalt/kobalt/src/Build.kt">find it here</a>. The fact that this build file is a pure Kotlin file allows to completely eliminate the redundancies and maximize the reuse of boiler plate code that most sub projects define.</p>
<p>Extracting the dependencies from <code>Build.kt</code> is trivial thanks to Kobalt’s convenient syntax to define dependencies:</p>
<pre><code class="hljs language-kotlin">$ grep project kobalt/src/Build.kt
<span class="hljs-keyword">val</span> core = project {
<span class="hljs-keyword">val</span> features = project(core) {
<span class="hljs-keyword">val</span> tomcat = project(core, servlet) {</code></pre>
<p>We see the <code>core</code> project at the top of the dependency graph. Then <code>features</code> depends on <code>core</code>, <code>tomcat</code> depends on both <code>core</code> and <code>servlet</code> and so on...</p>
<p>So without further ado, let’s launch the build in parallel mode and let’s see what happens:</p>
<pre><code>$ ./kobaltw --parallel assemble
</code></pre>
<p>At the end of a parallel build, Kobalt optionally displays a summary of the way it scheduled the various tasks. Here is what we get after building the project from scratch:</p>
<pre><code>╔══════════════════════════════════════════════════════════════════════════════════════════════════════
║  Time (sec) ║ Thread 39           ║ Thread 40           ║ Thread 41           ║ Thread 42           ║
╠══════════════════════════════════════════════════════════════════════════════════════════════════════
║  0          ║ core                ║                     ║                     ║                     ║
║  45         ║ core (45)           ║                     ║                     ║                     ║
║  45         ║                     ║ ktor-locations      ║                     ║                     ║
║  45         ║                     ║                     ║ ktor-netty          ║                     ║
║  45         ║                     ║                     ║                     ║ ktor-samples        ║
║  45         ║ ktor-hosts          ║                     ║                     ║                     ║
║  45         ║                     ║                     ║                     ║                     ║
║  45         ║ ktor-hosts (0)      ║                     ║                     ║                     ║
║  45         ║ ktor-servlet        ║                     ║                     ║                     ║
║  45         ║                     ║                     ║                     ║                     ║
║  45         ║                     ║                     ║                     ║                     ║
║  45         ║                     ║                     ║                     ║ ktor-samples (0)    ║
║  45         ║                     ║                     ║                     ║ ktor-freemarker     ║
║  49         ║                     ║                     ║                     ║ ktor-freemarker (3) ║
...
╚═════════════════════════════════════════════════════════════════════════════════════════════════════╝

PARALLEL BUILD SUCCESSFUL (68 seconds, sequential build would have taken 97 seconds)
</code></pre>
<p>The “Time” column on the left describes at what time (in seconds) each task was scheduled. Each project appears twice: when they start and when they finish (and when they do, the time they took is appended in parentheses).</p>
<h2>Analyzing the thread scheduling</h2>
<p>As you can see, <code>core</code> is scheduled first and since all the other projects depend on it, Kobalt can’t build anything else until that project completes, so the other four threads remain idle during that time. When that build completes forty-five seconds later, Kobalt now determines that quite a few projects are now eligible to build, so they get scheduled on all the idle threads: <code>ktor-locations</code>, <code>ktor-netty</code>, etc... The first to complete is <code>ktor-hosts</code> and Kobalt immediately schedules the next one on that thread.</p>
<p>Finally, Kobalt gives you the complete time of the build and also how long a sequential build would have taken, calculated by simply adding all the individual project times. It’s an approximation (maybe these projects would have been built faster if they weren’t competing with other build threads) but in my experience, it’s very close to what you actually get if you perform the same build sequentially.</p>
<p>Obviously, the gain with parallel build is highly dependent on the size of your projects. For example, if project C depends on projects A and B and these two projects are very small, the gain in parallelizing that build will be marginal. However, if A and B are both large projects, you could see your total build time divided by two. Another big factor in the gain you can expect is whether you use an SSD. Since all these parallel builds are generating a lot of files in various directories concurrently, I suspect that a physical hard drive will be much slower than an SSD (I haven’t tested, I only have SSD’s around).</p>
<h2>Taking things further</h2>
<p>When project B depends on project A, it certainly looks like you can’t start building B until A has completed, right? Actually, that’s not quite true. It’s possible to parallelize (or more accurately, vectorize) such builds too. For example, suppose you launch <code>./kobaltw test</code> on these two projects:</p>
<pre><code class="hljs language-kotlin">$ ./kobalw test
----- A:compile
----- A:assemble
----- A:test
----- B:compile
----- B:assemble
----- B:test</code></pre>
<p>But the dependency of B on A is not on the full build: B certainly doesn’t need to wait for A to have run its tests before it can start building. In this case, B is ready to build as soon as A is done assembling (i.e. created A.jar). So here, we could envision having threads scheduled at the task level, and not at the project level. So what we could really do is:</p>
<pre><code>╔═════════════════════════════════════════════════════════╗
║  Time (sec) ║ Thread 39           ║ Thread 40           ║
╠═════════════════════════════════════════════════════════╣
║             ║ A:compile           ║                     ║
║             ║ A:assemble          ║                     ║
║             ║ A:test              ║ B:compile           ║
║             ║                     ║ B:assemble          ║
║             ║                     ║ B:test              ║
╔═════════════════════════════════════════════════════════╗
║  Time (sec) ║ Thread 39           ║ Thread 40           ║
╠═════════════════════════════════════════════════════════╣
║             ║ A:compile           ║                     ║
║             ║ A:assemble          ║                     ║
║             ║ A:test              ║ B:compile           ║
║             ║                     ║ B:assemble          ║
║             ║                     ║ B:test              ║
</code></pre>
<p>As you can see above, Kobalt schedules <code>B:compile</code> as soon as <code>A:assemble</code> has completed while starting <code>A:test</code> on a separate thread, resulting in a clear reduction in build time.</p>
<p>This task-based approach can improve build times significantly since tests (especially functional tests) can take minutes to run.</p>
<h2>Wrapping up</h2>
<p>I started implementing parallel builds mostly as a curiosity and with very low expectations but I ended up being very surprised to see how well they work and how they improve my build times, even when just considering project-based concurrency and not task-based concurrency. I’d be curious to hear back from Kobalt users on how well this new feature performs on their own projects.</p>
<p>And if you haven’t tried Kobalt yet, it’s extremely easy <a href="http://beust.com/kobalt">to get started</a>.</p>
]]></description><link>http://beust.com/weblog/2016/08/06/the-kobalt-diaries-parallel-builds/</link><guid isPermaLink="true">http://beust.com/weblog/2016/08/06/the-kobalt-diaries-parallel-builds/</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Kobalt]]></category><dc:creator><![CDATA[Cédric Beust]]></dc:creator><pubDate>Sat, 06 Aug 2016 09:12:00 GMT</pubDate></item><item><title><![CDATA[Writing Gradle Build Scripts in Kotlin]]></title><description><![CDATA[<p>As you may have heard Kotlin-based build scripting is coming in Gradle 3.0. In this talk Chris Beams and Rodrigo B. de Oliveira will cover the motivation behind providing first-class support for Kotlin-based build scripts as well as the principles and design tradeoffs that drive the effort. We’ll demonstrate a Kotlin-based Gradle build in action show you how to try it for yourself and share details about the project roadmap.</p>
<iframe width="960" height="480" src="https://www.youtube.com/embed/vv4zh_oPBTw" frameborder="0" allowfullscreen></iframe>
]]></description><link>https://www.youtube.com/watch?v=vv4zh_oPBTw</link><guid isPermaLink="true">https://www.youtube.com/watch?v=vv4zh_oPBTw</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Gradle]]></category><dc:creator><![CDATA[Chris Beams & Rodrigo B. de Oliveiranp]]></dc:creator><pubDate>Fri, 05 Aug 2016 11:49:00 GMT</pubDate></item><item><title><![CDATA[More readable tests with Kotlin]]></title><description><![CDATA[<h1>More readable tests with Kotlin</h1>
<p><em>The following is a highly opinionated rant. These are just my personal views on a subject I care about.</em></p>
<p>Tests should be easy to read. You should be able to go to a test class you are not familiar with, collapse all the methods, and have a very quick read of all the test names. You do that, and in a matter of seconds you should have a very good idea of what the system under test is expected to do and in what circumstances. If you can do this then what they say about tests, that they serve as living documentation, becomes more true than ever.</p>
<p>Now here’s what a BDD-style <code>given-when-then</code> format I’ve seen used and have used myself in the past looks like:</p>
<p><img src="http://tengio.com/img/blog/0002/given-when-then-sample.jpg" alt="article-img"> <em>Given when then tests</em></p>
<p>It’s not exactly a pleasure to read a screen full of this stuff is it? The <code>given-when-then</code> keywords take up precious space on the screen. I really don’t want to read a screen full of this stuff, because after a while it sort of starts looking a bit like:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">blahblahIHopeTheyPayMeThisMonthBlahblahBlahblahBlahblah</span><span class="hljs-params">()</span></span> { ... }

<span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">blahblahBlahblahIHateMyLifeBlahblahBlahblahBlahblahBlahBlahBlah</span><span class="hljs-params">()</span></span> { ... }

<span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">blahblahBlahblahBlahblahBlahIWantToGoHomeAndCryBlahblahBlahBlahBlah</span><span class="hljs-params">()</span></span> { ... }</code></pre>
<p>at which point I might well be tempted to uncollapse the methods and just read the test code, and bam! my reading speed and information retention just plummeted. Not what I wanted.</p>
<p>Well, that’s one way of doing it, but there are others. Roy Osherove suggests something like the following format instead:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createUser_WithAllFieldsValid_DisplaysSuccessScreen</span><span class="hljs-params">()</span></span> { ... }

<span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createUser_WithAnyInvalidField_DoesNotSendRequest</span><span class="hljs-params">()</span></span> { ... }</code></pre>
<p>I’ve used that for a while, it was neat and I liked it. It still has a clear structure, and it gets rid of the formulaic keywords <code>given-when-then</code> while achieving a very similar result. Nice, but in my humble opinion it still has a little bit of a flaw. It reads like it was meant to be read by a robot, not a human. Also it’s pretty much inevitable that eventually you run on problems expressing your intention behind what you are trying to test when using this format. Or maybe it’s just me.</p>
<p>So here’s an alternative approach I prefer using at the moment, which I think I learnt from <a href="https://medium.com/@mvarnagiris">@mvarnagiris</a> :</p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">displaysSuccessScreenWhenCreatingAUserWithAllFieldsValid</span><span class="hljs-params">()</span></span> { ... }

<span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doesNotSendRequestWhenCreatingAUserWithAnyFieldInvalid</span><span class="hljs-params">()</span></span> { ... }</code></pre>
<p>I think it reads more like what you would actually say when asked “what does this system do?” by a colleague or manager. You lose the nice structure of the other formats, but hey, I don’t see many people explaining their product owner or colleague what they just did by speaking like a robot.</p>
<p>But wait what’s that? Oh look! It’s the good old <code>blahblahBlahblahBlahblahIsIt530YetBlahblahBlahblah()</code> effect again!</p>
<p>Now, it’s Kotlin we’re using, so let’s use the <code></code> thingy Kotlin offers, I say. Feel free to use them in your test methods, or even class names, and feel free to write your test names in a as readable and as descriptive a way as you can. This is what I’d rather see:</p>
<p><img src="http://tengio.com/img/blog/0002/human-readable-tests.jpg" alt="article-img"> <em>Human readable tests</em></p>
<p>Now I can read a whole page of this stuff, quickly and without getting tired. What’s more, I can actually read the summaries of the tests that have run at the bottom of the screen and actually get some more info out of it more than that all my <code>givenBlahblahCoolStoryBroBlahblah</code>s are green, whatever they mean. What summary would you rather read?</p>
<p><em>Wall of text meant for robots:</em></p>
<p><img src="http://tengio.com/img/blog/0002/robot-readable-results.jpg" alt="article-img-not-scaled"></p>
<p><em>Information meant for humans:</em></p>
<p><img src="http://tengio.com/img/blog/0002/human-readable-results.jpg" alt="article-img-not-scaled"></p>
<p>I for one would definitely go for the second one. But that’s only my fallible opinion anyway, what do <em>YOU</em> think?
n</p>
]]></description><link>http://tengio.com/blog/more-readable-tests-with-kotlin/</link><guid isPermaLink="true">http://tengio.com/blog/more-readable-tests-with-kotlin/</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Tests]]></category><dc:creator><![CDATA[Flavio]]></dc:creator><pubDate>Fri, 05 Aug 2016 09:27:00 GMT</pubDate></item><item><title><![CDATA[Calling on EAPers]]></title><description><![CDATA[<p>At JetBrains we’ve always believed in our Early Access Program for our tools, giving developers a chance to use the latest features or fixes as soon as they’re ready. We’ve followed the same philosophy with Kotlin, knowing of course that with a language, some decisions can haunt you for life.</p>
<p>That is why during the pre-release days of Kotlin, we’d have milestone releases with features and important changes for our early adopters (including ourselves at JetBrains), collect feedback on whether things were working as designed. This release-feedback-adjust cycle has proven invaluable in so many occasions and has definitely helped shape Kotlin 1.0.</p>
<p>But it’s not over with the release. We’re still continuing to develop Kotlin with new language features and we need your continued support. As you know, we have two ‘branches’ of EAP’s, the 1.0.X ones which are more about bug fixes and tooling, and the 1.1 EAP which is about language changes. And it’s with these EAP’s, the ones with language changes, where we could really use your help. While we don’t recommend you using these 1.1 EAP’s in production code, we definitely do need you to give us feedback. In return, we promise to listen to everything you have to say!</p>
<h2>Using EAP’s</h2>
<p>The easiest way to access EAP’s is via the Tools menu. Open <em>Tools | Kotlin | Configure Kotlin Plugin Updates</em> in the main menu, select Early Access Preview channel 1.0.x or 1.1 and press the <em>Check for updates now</em> button.
<img src="https://i0.wp.com/blog.jetbrains.com/kotlin/files/2016/08/Screen-Shot-2016-08-01-at-17.55.03.png?w=640&#x26;ssl=1" alt="Screen Shot 2016-08-01 at 17.55.03">
To use the new builds from Maven or Gradle: add <em><a href="https://dl.bintray.com/kotlin/kotlin-eap">https://dl.bintray.com/kotlin/kotlin-eap</a></em> or <em><a href="https://dl.bintray.com/kotlin/kotlin-eap-1.1">https://dl.bintray.com/kotlin/kotlin-eap-1.1</a></em> as a repository to your project</p>
<p><em>At the moment the first EAP of Kotlin 1.1 is available (with <a href="https://youtu.be/4W3ruTWUhpw">coroutines</a>, type aliases, bound callable reference, local delegated properties, Java 7/8 support and <a href="https://blog.jetbrains.com/kotlin/2016/07/first-glimpse-of-kotlin-1-1-coroutines-type-aliases-and-more/">many more</a>). Also today we just published first EAP build of Kotlin 1.0.4 with lots of bugs fixes in the compiler and IDE, whole bunch of new intentions, inspections and quickfixes, and it’s now fully compatible with Gradle 2.14.1. For more information check out <a href="https://github.com/JetBrains/kotlin/blob/767329fcab8249214c9c77db8ff1b8c1b3bd44b9/ChangeLog.md">the full Kotlin 1.0.4 changelog</a></em></p>
<h2>Giving Feedback</h2>
<p>Most of the Kotlin team are available on our public (<a href="http://kotlinslackin.herokuapp.com">Slack community</a>), and specifically on the #eap channel, where we’re very eager to listen to your feedback and help with any questions or issues you may have. Of course, our <a href="http://kotl.in/issue">issue tracker</a> is always open too</p>
<p>One of our main goals with Kotlin has always been to make it an industrial language that is pragmatic. And it’s by using Kotlin in many types of applications and scenarios that will help us achieve this goal. For this, we continue to need your help!</p>
<p>Thank you and let’s Kotlin!</p>
]]></description><link>https://blog.jetbrains.com/kotlin/2016/08/calling-on-eapers/</link><guid isPermaLink="true">https://blog.jetbrains.com/kotlin/2016/08/calling-on-eapers/</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[EAP]]></category><dc:creator><![CDATA[Roman Belov]]></dc:creator><pubDate>Thu, 04 Aug 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[Better Android Development with Kotlin and Gradle]]></title><description><![CDATA[<p>In this talk, Ty will walk you through setting up and using Kotlin with Gradle to streamline your workflow for Android development, both within the build tool phase and within the application itself. After a brief overview of Kotlin, we’ll dive into how it can be used with Gradle to accelerate Android Development with a consistent language.</p>
<iframe width="960" height="480" src="https://www.youtube.com/embed/bVSeKexyzhs" frameborder="0" allowfullscreen></iframe>
]]></description><link>https://www.youtube.com/watch?v=bVSeKexyzhs</link><guid isPermaLink="true">https://www.youtube.com/watch?v=bVSeKexyzhs</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Android]]></category><category><![CDATA[Gradle]]></category><dc:creator><![CDATA[Ty Smith]]></dc:creator><pubDate>Wed, 03 Aug 2016 11:53:00 GMT</pubDate></item><item><title><![CDATA[Andrey Breslav: Kotlin Coroutines, JVMLS 2016]]></title><description><![CDATA[<iframe width="960" height="480" src="https://www.youtube.com/embed/4W3ruTWUhpw" frameborder="0" allowfullscreen></iframe>
]]></description><link>https://www.youtube.com/watch?v=4W3ruTWUhpw</link><guid isPermaLink="true">https://www.youtube.com/watch?v=4W3ruTWUhpw</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Coroutines]]></category><dc:creator><![CDATA[Andrey Breslav]]></dc:creator><pubDate>Wed, 03 Aug 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[KotlinLifeguard #1]]></title><description><![CDATA[<p>Using <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-jvm-overloads/">@JvmOverloads</a> tag helps to avoid multiple constructors with Kotlin</p>
<h2>The headache</h2>
<p>It’s really possible that you had some code like:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCustomView</span> : <span class="hljs-type">FrameLayout {</span></span>
  
  <span class="hljs-keyword">constructor</span>(context: Context) : <span class="hljs-keyword">super</span>(context) {
    init()
  }

  <span class="hljs-keyword">constructor</span>(context: Context, attrs: AttributeSet) : <span class="hljs-keyword">super</span>(context, attrs) {
    init()
  }

  <span class="hljs-keyword">constructor</span>(context: Context, attrs: AttributeSet, defStyleAttr: <span class="hljs-built_in">Int</span>)
  : <span class="hljs-keyword">super</span>(context, attrs, defStyleAttr) {
    init()
  }

  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> { 
    <span class="hljs-comment">// ...</span>
  }
}</code></pre>
<p>As you can see there are all the constructors needed for a <em>custom</em> <code>FrameLayout</code> but all with same “body”.</p>
<p><img src="http://blog.makingiants.com/assets/article_images/hmm.jpg"></p>
<h1>The remedy</h1>
<p>Refactored with <code>@JvmOverloads</code>:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCustomView</span> <span class="hljs-meta">@JvmOverloads</span> <span class="hljs-keyword">constructor</span></span>(
    context: Context,
    attrs: AttributeSet? = <span class="hljs-literal">null</span>,
    defStyleAttr: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span>)
: FrameLayout(context, attrs, defStyleAttr){

  init {
    <span class="hljs-comment">// ...</span>
  }
}</code></pre>
<h2>Thanks to</h2>
<ul>
<li><a href="https://discuss.kotlinlang.org/t/simple-constructors-for-inheritance/1874/2">Kotlin discuss</a></li>
</ul>
]]></description><link>http://blog.makingiants.com/kotlin-lifeguard-1/</link><guid isPermaLink="true">http://blog.makingiants.com/kotlin-lifeguard-1/</guid><category><![CDATA[Android]]></category><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Daniel Gomez Rico]]></dc:creator><pubDate>Thu, 28 Jul 2016 15:44:00 GMT</pubDate></item><item><title><![CDATA[UI Testing: separating Assertions from Actions with Kotlin DSL]]></title><description><![CDATA[<p>Hello, dear reader!</p>
<p>Recently Jake Wharton did a talk <a href="https://realm.io/news/kau-jake-wharton-testing-robots/">"Instrumentation Testing Robots"</a> 📺.</p>
<p>The pattern itself is not a new concept, <strong>but</strong> combining it with <a href="https://kotlinlang.org/docs/reference/type-safe-builders.html">Kotlin DSL</a> is pretty nice! So we decided to try it for our <a href="https://play.google.com/store/apps/details?id=com.gojuno.rider">Juno app</a> which is fully written in Kotlin, including Unit, Integration and Functional tests.</p>
<p>What we found is that mixing Actions and Assertions inside "Robots" (we call them Screens) doesn't look great, both for tests readability and "Robot" maintenance 🤖 (same is true for regular Screen abstractions).</p>
<blockquote>
<p>Though I used mixed variant for years... (sigh). For some reason, only seeing screen abstraction as a Kotlin DSL finally clicked that we need to divide assertions from actions.</p>
</blockquote>
<h4>Before: mixed Actions and Assertions 😿</h4>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">// We actually use Spek but unfortunately I can't say</span>
<span class="hljs-comment">// that it works great for instrumentation tests yet...</span>
<span class="hljs-meta">@Test</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loginAndPasswordAreEntered</span><span class="hljs-params">()</span></span> {
  loginScreen {

    login(<span class="hljs-string">"artem_zin"</span>)
    password(<span class="hljs-string">"*****"</span>)

    loginButtonActivated()
    noLoginWarnings()
    noPasswordWarnings()
  }
}</code></pre>
<h4>After: Assertions are separated from Actions 😸</h4>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@Test</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loginAndPasswordAreEntered</span><span class="hljs-params">()</span></span> {
  loginScreen {

    login(<span class="hljs-string">"artem_zin"</span>)
    password(<span class="hljs-string">"*****"</span>)

    assert {
      loginButtonActivated()
      noLoginWarnings()
      noPasswordWarnings()
    }
  }
}</code></pre>
<p>Now that's a clear separation of actions and assertions, right? Same is true for internal structure of <code>LoginScreen</code> class:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loginScreen</span><span class="hljs-params">(func: <span class="hljs-type">LoginScreen</span>.()</span></span> -> <span class="hljs-built_in">Unit</span>) = LoginScreen().apply { func() }

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginScreen</span> </span>{

  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">login</span><span class="hljs-params">(login: <span class="hljs-type">String</span>)</span></span> = enterText(R.id.login, email)
  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">password</span><span class="hljs-params">(password: <span class="hljs-type">String</span>)</span></span> = enterText(R.id.password, password)
  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">assert</span><span class="hljs-params">(func: <span class="hljs-type">Assert</span>.()</span></span> -> <span class="hljs-built_in">Unit</span>) = Assert().apply { func() }

  <span class="hljs-comment">// Previously all these assertions </span>
  <span class="hljs-comment">// were on the same level in the LoginScreen class as actions.</span>
  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Assert</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loginButtonActivated</span><span class="hljs-params">()</span></span> = ...
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">noLoginWarnings</span><span class="hljs-params">()</span></span> = ...
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">noPasswordWarnings</span><span class="hljs-params">()</span></span> = ...
  }
}</code></pre>
<blockquote>
<p>Write tests and take care!</p>
</blockquote>
]]></description><link>https://artemzin.com/blog/ui-testing-separating-assertions-from-actions-with-kotlin-dsl/</link><guid isPermaLink="true">https://artemzin.com/blog/ui-testing-separating-assertions-from-actions-with-kotlin-dsl/</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Testing]]></category><dc:creator><![CDATA[Artem Zinnatullin]]></dc:creator><pubDate>Wed, 27 Jul 2016 08:52:00 GMT</pubDate></item><item><title><![CDATA[JUnit 5 with Spring Boot (plus Kotlin)]]></title><description><![CDATA[<p>This summer the JUnit team released a beta version of the next iteration, <a href="http://junit.org/junit5/">version five</a>. This newest version adds a ton of new features that will be a welcome relief for JVM developers who have been dealing with the limitations and idiosyncrasies of version four over the past decade. I’ve put together an <a href="https://github.com/mike-plummer/junit5-springboot-kotlin">example project</a> to learn about the new feature set and tried to summarize some of my favorites in this post.</p>
<h1>Features of JUnit 5</h1>
<p><strong>Backwards Compatibility:</strong> One of the biggest concerns with any update is how it affects an existing baseline. One of the great features of version 5 is that it nicely coexists with any JUnit tests you already have. In fact, the platform supplies a special test runner that allows any version 5 test to be run as a version 4 test, albeit without some of the more advanced features. This allows a project to adopt the update and gradually migrate its test suite rather than forcing a ‘big bang’-style conversion.</p>
<p><strong>Nesting:</strong> A common complaint of JUnit 4 tests is the relative difficulty of writing behavior-driven tests in the style of Cucumber or Jasmine (in the JavaScript arena). Behavior Driven Testing (BDT) aims to test software by focusing on desired activities and features rather than the more technical focus of traditional Test Driven Development (TDD). BDT writes tests in a more verbose style, typically structuring tests in logical groups using a natural language format. In JUnit 4 this often results in dauntingly-long unit test names and large amounts of repetition. JUnit 5 resolves many of these problems by supporting Nested tests.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@Autowired</span> lateinit <span class="hljs-keyword">var</span> dataBean: DataBean

<span class="hljs-meta">@Nested</span>
inner <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">dataBean</span></span>() {
    <span class="hljs-meta">@Nested</span>
    inner <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">whenRetrievingData</span></span>() {
        <span class="hljs-meta">@Test</span>
        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">returnsCorrectData</span><span class="hljs-params">()</span></span> {
            assertEquals(dataBean.getData(), expectedData)
        }
    }
}</code></pre>
<p>Nested tests allow for easier decomposition of tests into individual units that can easily share setup logic and also display in the test report in a more logical, grouped structure. For example, the code segment above will result in a test that naturally describes the expected behavior ‘dataBean, when retrieving data, returns correct data’ while allowing each segment of that behavior to be expanded with additional tests.</p>
<p><strong>Dynamic Tests:</strong> In many situations testsneed to react to generated data or are unwieldy to write manually. For this use case JUnit 4 supplied the concept of Parameterized tests and JUnit 5 replaces it with simpler Dynamic Tests.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@TestFactory</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">valuesShouldIncludeAllStates</span><span class="hljs-params">()</span></span>: Collection {
    <span class="hljs-keyword">return</span> STATES.map { state -&#x26;gt;
        dynamicTest(state) {
            assertTrue(values.contains(state))
        }
    }.toList()
}</code></pre>
<p>This short block generates 50 individual tests to validate that my dataset includes the names of all 50 US states. This mechanism works particularly well for data-driven testing but has one significant drawback: dynamic tests do not support Before/After lifecycle hooks the way that legacy Parameterized tests do. This is an unfortunate limitation and can be partially worked around using Nested tests, but if multiple dynamic tests share data it cannot be reset between tests.</p>
<p><strong>Extension:</strong> Extensions replace much of the legacy ‘Runner’ construct by enabling easy enhancement and expansion of test capabilities. For example, extensions exist to automatically handle Spring and Mockito integration to help keep your tests clean and simple. By using extensions you can also neatly sidestep some of the limitations of test subclassing – multiple extensions can be applied to a single test.</p>
<p><strong>Tags, Filtering, and Naming:</strong> Sometimes you only need to run a subset of tests, for example only those dealing with a particular service or functional path. Each test or block of tests can be tagged, and at runtime a subset of tags can be included or excluded from execution. In addition, sometimes a test needs a name that doesn’t conform with method naming conventions. An optional DisplayName can be supplied for each test to print out in the test reports which can help readability.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@Test</span>
<span class="hljs-meta">@Tag(<span class="hljs-meta-string">"LoadTests"</span>)</span>
<span class="hljs-meta">@DisplayName(<span class="hljs-meta-string">"Very long test that is disabled by default"</span>)</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">largeLoadTest</span><span class="hljs-params">()</span></span> {
    <span class="hljs-comment">// TEST CONTENT</span>
}</code></pre>
<p><strong>Dependency Injection:</strong> Custom ParameterResolvers can be written that will be used to inject parameters into any constructors or test methods. This can help reduce boilerplate in your before/after lifecycle hooks and provides an easy way to swap out implementations when running tests against different back-ends. This is particularly useful if you’re using a Dependency Injection (DI) mechanism in your code like Guice or Java CDI as the ParameterResolver can hook into or replace many DI functions.</p>
<pre><code class="hljs language-kotlin">    <span class="hljs-meta">@ExtendWith(TestTrackerResolver::class)</span>
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DependencyInjectionTest</span> </span>{
        <span class="hljs-meta">@BeforeEach</span>
        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setup</span><span class="hljs-params">(tracker: <span class="hljs-type">TestTracker</span>)</span></span> {
            tracker.testCount++
        }
 
        <span class="hljs-meta">@Test</span>
        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">testTracker</span><span class="hljs-params">(tracker: <span class="hljs-type">TestTracker</span>)</span></span> {
            assertEquals(tracker.testCount, <span class="hljs-number">1</span>L)
        }
    }
 
    <span class="hljs-comment">/** ParameterResolver that automatically supplies a TestTracker object where requested in the tests above **/</span>
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestTrackerResolver</span>: <span class="hljs-type">ParameterResolver {</span></span>
        <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> {
            <span class="hljs-keyword">val</span> tracker: TestTracker = TestTracker(<span class="hljs-number">0</span>)
        }
 
        <span class="hljs-comment">/** Whether this ParameterResolver supports the requested Parameter **/</span>
        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">supports</span><span class="hljs-params">(parameterContext: <span class="hljs-type">ParameterContext</span>?, extensionContext: <span class="hljs-type">ExtensionContext</span>?)</span></span>: <span class="hljs-built_in">Boolean</span> {
            <span class="hljs-keyword">return</span> parameterContext?.parameter?.type == TestTracker::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span></span>
        }
 
        <span class="hljs-comment">/** Supply a value for the requested Parameter. **/</span>
        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resolve</span><span class="hljs-params">(parameterContext: <span class="hljs-type">ParameterContext</span>?, extensionContext: <span class="hljs-type">ExtensionContext</span>?)</span></span>: Any? {
            <span class="hljs-keyword">return</span> tracker
        }
    }</code></pre>
<p><strong>Java 8:</strong> Many test constructs have been updated to be lambda-friendly, and others like dynamic tests are a natural fit to be driven from a Stream. One of my personal favorite features is the idea of Supplier-based messages – in legacy tests a failure message was compiled and generated before the test even ran, but in the new format the Supplier will only be called in the event of a failure. This helps speed up tests ever so slightly but more importantly allows easy re-use of method references to generate detailed and standardized messages.</p>
<h1>Use with Spring Boot</h1>
<p>Even though JUnit 5 is in beta it’s already easy to use in Spring Boot. An excellent <a href="https://github.com/sbrannen/spring-test-junit5">JUnit Extension</a> supplies easy Spring integration including Autowiring. By using this extension and annotating with @SpringBootTest a test has a complete Spring context to work with. As of the time of this post that extension is not published out to a public repository, but the code can be pulled from GitHub and built manually in just a few minutes.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@SpringBootTest</span>
<span class="hljs-meta">@ExtendWith(SpringExtension::class)</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataBeanTest</span> : <span class="hljs-type">ApplicationTest</span></span>() {

    <span class="hljs-meta">@Autowired</span> lateinit <span class="hljs-keyword">var</span> dataBean: DataBean

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">testAutowiring</span><span class="hljs-params">()</span></span> {
        assertNotNull(dataBean)
    }
}</code></pre>
<h1>Spring Boot with Kotlin</h1>
<p>Moving off the topic of JUnit, one of my favorite new languages in the JVM space is Kotlin. I’ve <a href="https://objectpartners.com/2016/02/23/an-introduction-to-kotlin/">written a bit about it here before</a>, and given its great feature set I wanted to see how well it worked for writing a Spring Boot application and JUnit 5 tests. Short answer: it works great once you know all the tricks.</p>
<h2>Defining the Application</h2>
<p>As it is in Java, creating your SpringBoot application in Kotlin is easy and concise.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-meta">@ComponentScan(<span class="hljs-meta-string">"com.objectpartners.plummer.junit5"</span>)</span>
<span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span></span>

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>)</span></span> {
    SpringApplication.run(Application::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>, <span class="hljs-type">*args)</span></span>
}</code></pre>
<h2>Defining a Bean</h2>
<p>With a quick annotation a Kotlin class becomes a Spring-managed bean.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">FibonacciService</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fibonacci</span><span class="hljs-params">(max: <span class="hljs-type">Long</span>)</span></span>: List;
}

<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FibonacciServiceImpl</span>: <span class="hljs-type">FibonacciService {</span></span>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fibonacci</span><span class="hljs-params">(max: <span class="hljs-type">Long</span>)</span></span>: List {
        Assert.isTrue(max &#x26;gt; <span class="hljs-number">0</span>)
        <span class="hljs-keyword">return</span> generateSequence (<span class="hljs-number">0</span>L to <span class="hljs-number">1</span>L, { previous -&#x26;gt; previous.second to previous.first + previous.second})
            .takeWhile { result -&#x26;gt; result.second  result.second}
            .toList()
    }
}</code></pre>
<h2>Using a Bean</h2>
<p>This is the only really tricky area. Kotlin’s null-safety rules can cause problems with Dependency Injection since those fields are by definition not initialized at the time of declaration. Early versions of the language forced you to work around this by either performing a faux-initialization at declaration or by using parameter-based injection rather than field-based, but now Kotlin has the ‘lateinit’ keyword. This indicates to the compiler that the field will be initialized at some point between declaration and usage and to make assumptions based on that guarantee. If a ‘lateinit’ field is not initialized prior to use a special exception will be thrown to identify the unsatisfied assumption.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@Autowired</span> lateinit <span class="hljs-keyword">var</span> fibonacciSvc: FibonacciService</code></pre>
<h1>Wrap Up</h1>
<p>Hopefully this article has gotten you interested in checking out JUnit5 and maybe even giving Kotlin a try. JUnit may not be the most flexible or powerful testing framework out there but this newest version improves what continues to be the simplest, most-used testing platform for the JVM and is ideal for anyone who is looking to incrementally update an existing test suite or wants to write tests that are easy, familiar, and maintainable. Be sure to check out the <a href="https://github.com/mike-plummer/junit5-springboot-kotlin">example project</a> to see these features in action as part of a SpringBoot Kotlin application. Happy coding!</p>
]]></description><link>https://objectpartners.com/2016/07/26/junit-5-with-spring-boot-plus-kotlin/</link><guid isPermaLink="true">https://objectpartners.com/2016/07/26/junit-5-with-spring-boot-plus-kotlin/</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Spring Boot]]></category><dc:creator><![CDATA[Mike Plummer]]></dc:creator><pubDate>Tue, 26 Jul 2016 09:22:00 GMT</pubDate></item><item><title><![CDATA[Things We've Learned During Coolcal Development in Kotlin]]></title><description><![CDATA[<p>Learning Kotlin is a pleasant process and only takes a few hours if you’re familiar with the Java programming language :)  The syntax is very intuitive, e.g. a when block is more readable than an if block or switch. At Netguru we had quite an adventure with Kotlin over the last few weeks while creating <a href="https://play.google.com/store/apps/details?id=co.netguru.android.coolcal">the Coolcal app</a>. <a href="https://www.netguru.co/blog/coolcal-android-development-made-easy-and-fun">Here you can read about how we did it.</a> In this article I want to tell you more about what it’s like to learn Kotlin.</p>
<h2>Our Kotlin Adventure</h2>
<p>The development process is much faster and hassle free with Kotlin. Look at the snippets below.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">when</span> (type) {
            WeatherCodes.CLEAR_SKY_DAY -> descArray[<span class="hljs-number">0</span>]
            WeatherCodes.CLEAR_SKY_NIGHT -> descArray[<span class="hljs-number">1</span>]
            <span class="hljs-keyword">else</span> -> defaultMessage()
}</code></pre>
<p><strong>When matches the argument against all branches until some branch condition is satisfied.</strong> It can be an expression or a statement, as the expression value of the satisfied branch becomes the value of the whole expression; the statement values of individual branches are ignored.</p>
<p>Declaring a singleton object is done by simply adding the object keyword before the name of our object.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">object</span> InstancesLoader { <span class="hljs-comment">//Implementaion}</span></code></pre>
<p>Objects inside a class can be marked with companion object and can be called by using simply the class name as the qualifier.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> {
        <span class="hljs-keyword">val</span> EVENT_DETAILS_BUNDLE = <span class="hljs-string">"event_details_bundle"</span>
        }
<span class="hljs-comment">//usage</span>
ClassName.EVENT_DETAILS_BUNDLE</code></pre>
<p><strong>In apps, we frequently need classes just to hold data; a lot of boilerplate code needs to be written.</strong> But in Kotlin, everything is achieved by using data classes. The compiler automatically derives the necessary code.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Event</span></span>(<span class="hljs-keyword">val</span> id: <span class="hljs-built_in">Long</span>,
                 <span class="hljs-keyword">val</span> calendarId: <span class="hljs-built_in">Long</span>,
                 <span class="hljs-keyword">val</span> begin: <span class="hljs-built_in">Long</span>,
                 <span class="hljs-keyword">val</span> end: <span class="hljs-built_in">Long</span>,
                 <span class="hljs-keyword">val</span> isAllDay: <span class="hljs-built_in">Boolean</span> = <span class="hljs-literal">false</span>,
                 <span class="hljs-keyword">val</span> title: String? = <span class="hljs-literal">null</span>,
                 <span class="hljs-keyword">val</span> displayColor: <span class="hljs-built_in">Int</span>? = <span class="hljs-literal">null</span>,
                 <span class="hljs-keyword">val</span> owner: String,
                 <span class="hljs-keyword">val</span> location: String,
<span class="hljs-keyword">val</span> description: String): Parcelable { <span class="hljs-comment">//Parcelable implementation}</span></code></pre>
<p>The code above implements members from primary constructor and necessary methods:</p>
<ul>
<li><code>equals()</code>/<code>hashcode()</code> pair,</li>
<li><code>toString()</code>,</li>
<li><code>copy()</code></li>
</ul>
<p>Small things like no new keyword also improve the development process.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">var</span> adapter = EventAdapter(context, <span class="hljs-literal">null</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>)</code></pre>
<p><strong>The above snippet creates an instance of the EventAdapter class.</strong> These features and many others make Kotlin a really enjoyable language.</p>
<p>Compared to Java, Kotlin is a really modern solution for implementation problems. <strong>Null object handling is a big issue in Java, but Kotlin is a null type safety language</strong> so we don’t have to worry about this, e.g</p>
<pre><code class="hljs language-kotlin">subscription?.unsubscribe()</code></pre>
<p>The syntax above means that the variable subscription will execute the method unsubscribe if subscription isn’t null. This construction is very helpful and solves null handling problems.</p>
<p>What’s more - <strong>when we need to check if a variable is null to operate on it after a null check, we don’t need to cast it to non-null type</strong>; Kotlin supports smart cast operation.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">if</span> (dtStart == <span class="hljs-literal">null</span> || dtEnd == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> (isAllDay) {
                <span class="hljs-literal">true</span> -> formatLongDateAllDay(dtStart)
                <span class="hljs-literal">false</span> -> formatLongDateNotAllDay(dtStart, dtEnd)
            }
}</code></pre>
<p>In the example above dtStart and dtEnd were automatically cast to proper type.</p>
<p>According to <a href="http://www.oracle.com/technetwork/java/effectivejava-136174.html">Effective Java</a>, Item 17 (“Design and document for inheritance or else prohibit it”) <strong>all classes should be final and Kotlin classes correspond to this statement.</strong> This helps developers build a better code base.  </p>
<h2>Awesome libraries to browse</h2>
<p>Awesome libraries exist in the Android developer community, and to give up on them would be painful. Fortunately Kotlin is 100% interoperable with Java so it’s possible to use popular Java libraries like Retrofit in Kotlin :)</p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@GET(<span class="hljs-meta-string">"forecast"</span>)</span>
   <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getForecast</span><span class="hljs-params">(<span class="hljs-meta">@Query(<span class="hljs-meta-string">"lat"</span>)</span> latitude: <span class="hljs-type">Double</span>,
                   <span class="hljs-meta">@Query(<span class="hljs-meta-string">"lon"</span>)</span> longitude: <span class="hljs-type">Double</span>,
<span class="hljs-meta">@Query(<span class="hljs-meta-string">"cnt"</span>)</span> count: <span class="hljs-type">Long</span> = <span class="hljs-number">0</span>)</span></span>: Observable&#x3C;ForecastResponse></code></pre>
<p>If you are planning to code in Kotlin please take a look at these short tips. <strong>Using higher-order functions in Kotlin creates additional memory allocations and runtime overhead, but we can remedy this problem using an inline modifier.</strong> Remember, though, that inlining is not always possible or wanted - it causes generated code to grow. Listeners and callbacks are awful to write, but they can be clean and more readable thanks to lambda expressions .</p>
<pre><code class="hljs language-kotlin">eventIconClose.setOnClickListener { activity.finish() }</code></pre>
<p>A nasty thing in Android is the findViewById function, but thanks to <a href="https://kotlinlang.org/docs/tutorials/android-plugin.html">Kotlin Android Extensions</a> we can obtain the same functionality without this extra, awful code.</p>
<pre><code class="hljs language-kotlin">dayOfWeekTextView.text = timeFormatter.formatDayOfWeekShort(todayDt) </code></pre>
<p>Default values are very helpful - no more method overloading or creating several constructors to cut input parameters.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">formatTimeOfDay</span><span class="hljs-params">(dt: <span class="hljs-type">Long</span>?, isAllDay: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">false</span>)</span></span></code></pre>
<p>We can use this method with only one parameter like formatTimeOfDay(dt)</p>
<p><strong>Sometimes a method or constructor has many parameters of the same type, which can be very error prone</strong> - it’s easy to put the wrong value in the wrong place. To help developers beat this problem, language creators added named parameters. It’s worth using :)   </p>
<pre><code class="hljs language-kotlin">formatTime(timeMillis = i)</code></pre>
<p>I is value of timeMillis parameter.</p>
<p>During the development process, three Netguru Android team members made commits to the code base. As it was an internal project we had very limited resources, commercial projects were always a priority. <strong>This didn’t matter in terms of the quality or continuity of the project, as <a href="https://www.netguru.co/blog/development-process">our process</a> makes it easier for a team member to join or leave.</strong></p>
<p>During development we found places to make code easier and more readable. We achieved this thanks to powerful language features. <strong>Kotlin extension functions help us make our code easy to understand.</strong> A good example of using this feature is getting a cursor value for a specific column. Writing this in Java for a generic field wouldn’t be as simple as in Kotlin.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&#x3C;T></span> Cursor.<span class="hljs-title">from</span><span class="hljs-params">(columnName: <span class="hljs-type">String</span>, getter: <span class="hljs-type">Cursor</span>.(<span class="hljs-type">Int</span>)</span></span> -> T): T {
    <span class="hljs-keyword">val</span> columnIndex = getColumnIndex(columnName)
<span class="hljs-keyword">return</span> getter(columnIndex)</code></pre>
<p>This method gets a value from cursor for a specific column name; usage of this method is even simpler.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">var</span> lastForecastSync: <span class="hljs-built_in">Long</span>
        <span class="hljs-keyword">get</span>() = preferences.getLong(PREF_FORECAST_SYNC, <span class="hljs-number">0</span>)
        <span class="hljs-keyword">set</span>(value) {
            into(preferences){
                putLong(PREF_FORECAST_SYNC, value)
            }
        }
<span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">into</span><span class="hljs-params">(preferences: <span class="hljs-type">SharedPreferences</span>,
                <span class="hljs-keyword">crossinline</span> block: <span class="hljs-type">SharedPreferences</span>.<span class="hljs-type">Editor</span>.()</span></span> -> SharedPreferences.Editor) {
    preferences.edit().block().apply()
}</code></pre>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> Cursor.<span class="hljs-title">eventId</span><span class="hljs-params">()</span></span> = from(_ID) { getLong(it) }</code></pre>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> Cursor.<span class="hljs-title">eventDescription</span><span class="hljs-params">()</span></span> = from(DESCRIPTION) { getString(it) }</code></pre>
<p>Everything looks very intuitive and awesome. The next cool thing is using properties for handling shared preferences.</p>
<p>Using preferences implemented this way is very readable and clean.</p>
<pre>appPreferences.lastForecast = response </pre>
<p>The above code saves the response into lastForecast.</p>
<h2>Wrapping up</h2>
<p>Kotlin is one of those languages whose processes are faster and less problematic than those of many other languages. I hope you will find my tips useful and that you will like <a href="https://play.google.com/store/apps/details?id=co.netguru.android.coolcal">our showcase app - Coolcal</a>. Please let me know what you think in the comments below. All feedback will be greatly appreciated.</p>
]]></description><link>https://www.netguru.co/blog/coolcal-development-in-kotlin</link><guid isPermaLink="true">https://www.netguru.co/blog/coolcal-development-in-kotlin</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Przemek Dąbrowski]]></dc:creator><pubDate>Mon, 25 Jul 2016 09:13:00 GMT</pubDate></item><item><title><![CDATA[Scala vs Kotlin: Operator overloading]]></title><description><![CDATA[<p>Last week, I started my comparison of Scala and Kotlin with the <a href="/scala-vs-kotlin/1/">Pimp my library</a> pattern. In the second part of this serie, I’d like to address operator overloading.</p>
<h2>Overview</h2>
<p>Before to dive into the nitty-gritty details, let’s try first to tell what it’s all about.</p>
<p>In every language where there are functions (or methods), a limited set of characters is allowed to define the name of said functions. Some languages are more lenient toward allowed characters: naming a function <code>\O/</code> might be perfectly valid.</p>
<p>Some others are much more strict about it. It’s interesting to note that Java eschewed the ability to use symbols in function names besides <code>$</code> - probably in response to previous abuses in older languages. It definitely stands on the less lenient part of the spectrum and the Java compiler won’t compile the previous <code>\O/</code> function.</p>
<p>The name operator overloading is thus slightly misleading, even if widespread. IMHO, it’s semantically more correct to talk about operator characters in function names.</p>
<h2>Scala</h2>
<p>Scala stands on the far side of leniency spectrum, and allows characters such as <code>+</code> and <code>£</code> to be used to name functions, alone or in combinations. Note I couldn’t find any official documentation regarding accepted characters (but some helpful discussion is available <a href="https://stackoverflow.com/questions/7656937/valid-identifier-characters-in-scala">here</a>).</p>
<p>This enables libraries to offer operator-like functions to be part of their API. One example is the <code>foldLeft</code> function belonging to the <code>TraversableOnce</code> type, which is also made available as the <code>/:</code> function.</p>
<p>This allows great flexibility, especially in defining <abbr title="Domain Specific Language">DSL</abbr>s. For example, mathematics: functions can be named <code>π</code>, <code>∑</code> or <code>√</code>. On the flip side, this flexibility might be subject to abuse, as <code>\O/</code>, <code>^_^</code> or even <code>|-O</code> are perfectly valid function names. Anyone for an emoticon-based API?</p>
<pre><code class="hljs language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">∑</span></span>(i: <span class="hljs-type">Int</span>*) = i.sum

<span class="hljs-keyword">val</span> s = ∑(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>) <span class="hljs-comment">// = 11</span></code></pre>
<h2>Kotlin</h2>
<p>Kotlin stands on the middle of the leniency scale, as it’s possible to define only a <a href="https://kotlinlang.org/docs/reference/operator-overloading.html">limited set of operators</a>.</p>
<p>Each such operator has a corresponding standard function signature. To define a specific operator on a type, the associated function should be implemented and prepended with the <code>operator</code> keyword. For example, the <code>+</code> operator is associated with the <code>plus()</code> method. The following shows how to define this operator for an arbitrary new type and how to use it:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Complex</span></span>(<span class="hljs-keyword">val</span> i: <span class="hljs-built_in">Int</span>, <span class="hljs-keyword">val</span> j: <span class="hljs-built_in">Int</span>) {
    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">plus</span><span class="hljs-params">(c: <span class="hljs-type">Complex</span>)</span></span> = Complex(<span class="hljs-keyword">this</span>.i + c.i, <span class="hljs-keyword">this</span>.j + c.j)
}

<span class="hljs-keyword">val</span> c = Complex(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>) + Complex(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// = Complex(1, 1)</span></code></pre>
<h2>Conclusion</h2>
<p>Scala’s flexibility allows for an almost unlimited set of operator-looking functions. This makes it suited to design DSL with a near one-to-one mapping between domains names and function names. But it also relies on implicitness: every operator has to be known to every member of the team, present <strong>and</strong> future.</p>
<p>Kotlin takes a much more secure path, as it allows to define only a limited set of operators. However, those operators are so ubiquitous that even beginning software developer know them and their meaning (and even more so experienced ones).</p>
]]></description><link>https://blog.frankel.ch/scala-vs-kotlin/2/</link><guid isPermaLink="true">https://blog.frankel.ch/scala-vs-kotlin/2/</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Scala]]></category><dc:creator><![CDATA[Nicolas Fränkel]]></dc:creator><pubDate>Sun, 24 Jul 2016 09:05:00 GMT</pubDate></item><item><title><![CDATA[First glimpse of Kotlin 1.1: Coroutines, Type aliases and more]]></title><description><![CDATA[<p>While Kotlin 1.0.X releases keep delivering incremental updates and tooling features, we are working on the new language features in Kotlin 1.1. Today we are presenting the first preview version of 1.1, it’s far from Beta, but the brave and curious ones can play with new exciting things (and hopefully give us their invaluable feedback).</p>
<h2>Compatibility</h2>
<p>This is not a stable version of Kotlin, and <strong>no compatibility guarantees</strong> are given here: in the future previews of 1.1, syntax, APIs, command-line switches and anything else may be changed. If you need a stable version of Kotlin, please stay on 1.0.X until further notice.</p>
<h2>Feedback</h2>
<p>The upside of this temporary lack of guarantees is that we can make immediate use of all the feedback you provide us! The best way to tell us what you think is through <a href="https://github.com/Kotlin/KEEP">KEEP</a>: please leave your comments on the issues associated with proposals mentioned below. The implementations in Kotlin 1.1 M01 are prototypes of the functionality described in the KEEPs.</p>
<h2>Overview</h2>
<p>The full changelog for 1.1 M01 is available <a href="https://github.com/JetBrains/kotlin/blob/1.1-M1/ChangeLog.md#11-m01-eap-1">here</a>.</p>
<h2>Coroutines</h2>
<p>We all know that blocking is bad under a high load, that polling is a no-go, and the world is becoming more and more push-based and asynchronous. Many languages (starting with C# in 2012) support asynchronous programming through dedicated language constructs such as <code>async</code>/<code>await</code> keywords. In Kotlin, we generalized this concept so that libraries can define their own versions of such constructs, and <code>async</code> is not a keyword, but simply a function.</p>
<p>This design allows for integration of different asynchronous APIs: futures/promises, callback-passing, etc. It is also general enough to express lazy generators (<code>yield</code>) and cover some other use cases.</p>
<p>So, meet one of the bigger features of Kotlin 1.1: <em>coroutines</em>. This is a traditional CS term for “program components that generalize subroutines for nonpreemptive multitasking”, but we’ll not dive into theory here <img src="https://i2.wp.com/blog.jetbrains.com/kotlin/wp-includes/images/smilies/simple-smile.png?zoom=1w=64&#x26;ssl=1" alt=":)"></p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&#x3C;<span class="hljs-type">String</span>>)</span></span> {
    <span class="hljs-keyword">val</span> future = async&#x3C;String> {
        (<span class="hljs-number">1.</span><span class="hljs-number">.5</span>).map {
            await(startLongAsyncOperation(it)) <span class="hljs-comment">// suspend while the long method is running</span>
        }.joinToString(<span class="hljs-string">"\n"</span>)
    }

    println(future.<span class="hljs-keyword">get</span>())
}</code></pre>
<p>The great thing about coroutines is that they can <em>suspend</em> without blocking a thread, and yet they look like normal sequential code. Please see a <a href="https://github.com/Kotlin/kotlin-coroutines/blob/master/kotlin-coroutines-informal.md">detailed description</a> and examples in a dedicated <a href="https://github.com/Kotlin/kotlin-coroutines">KEEP repository</a> and comment on the <a href="https://github.com/Kotlin/kotlin-coroutines/issues">issues there</a>.</p>
<p>We are prototyping coroutine-based libraries <a href="https://github.com/Kotlin/kotlinx.coroutines">here</a>, to be later included with the Standard Library. This includes JDK’s <code>CompletableFuture</code>, asynchronous IO (NIO), RxJava, and off-loading tasks from the UI thread in Swing. The repo contains examples as well as the libraries themselves. To play with it, follow the instructions in the <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/README.md">readme file</a>.</p>
<h2>Type aliases</h2>
<p>In Kotlin 1.1 we can write</p>
<pre><code class="hljs language-kotlin">typealias Action&#x3C;T> = (T) -> <span class="hljs-built_in">Unit</span></code></pre>
<p>This means that we can use <code>Action&#x3C;T></code> interchangeably with <code>(T) -> Unit</code>, i.e. it is a true <strong>alias</strong>. Type aliases are useful for abbreviating longer types that are used in multiple places in the code:</p>
<ul>
<li>function types with complex signatures: <code>UserAction = (User, Context) -> ActionResponse</code>,</li>
<li>complex generic types: <code>Multimap&#x3C;K, V> = Map&#x3C;K, List&#x3C;V>></code></li>
</ul>
<p>In anticipation of your questions: this feature does not cover the use cases where the aliased type is not assignable to the original type (something similar to newtype in Haskell): e.g. if we try to implement units of measurement and say</p>
<pre><code class="hljs language-kotlin">typealias Length = <span class="hljs-built_in">Double</span>
typealias Weight = <span class="hljs-built_in">Double</span></code></pre>
<p>it won’t do us much good, because <code>Length</code> can be freely assigned to <code>Weight</code> and vice versa. In fact, they can both be assigned to and from a regular <code>Double</code>. We understand the importance of such use cases, and are planning to cover them in the future, most likely through <em>value classes</em>, but that’s another story. For now we only have type aliases.</p>
<p>Read more and comment <a href="https://github.com/Kotlin/KEEP/issues/4">here</a>.</p>
<h2>Bound callable references</h2>
<p>In Kotlin 1.0 one can obtain a reference to a function (or property) like this: <code>String::length</code>, i.e. using a name of the containing class. In 1.1 we are adding <em>bound references</em>: i.e. we’ll be able to say <code>mystr::length</code> where <code>mystr</code> is a variable (or any other expression). Such references are bound to their receiver, and thus are a special case of partial function application (that we are not supporting in the general case, at least for now).</p>
<p>Read more and comment <a href="https://github.com/Kotlin/KEEP/issues/5">here</a>.</p>
<h2>Local delegated properties &#x26; Inline properties</h2>
<p>Delegated properties have proven to be a very useful abstraction, now we allow them inside functions/code blocks too. For example, we can say:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">example</span><span class="hljs-params">(foo: (<span class="hljs-type">Bar</span>)</span></span> -> Foo, bar: Bar) {
    <span class="hljs-keyword">val</span> memoizedFoo <span class="hljs-keyword">by</span> lazy { foo(bar) }

    <span class="hljs-comment">// use memoizedFoo instead of foo to get it computed at most once</span>
    <span class="hljs-keyword">if</span> (someCondition &#x26;&#x26; memoizedFoo.isValid()) {
        memoizedFoo.doSomething()
    }
}</code></pre>
<p>DSLs and scripts will also benefit from this feature.</p>
<p>Read more and comment <a href="https://github.com/Kotlin/KEEP/issues/25">here</a>.</p>
<p>We also allow <a href="https://github.com/Kotlin/KEEP/issues/34">inlining property accessors</a> now.</p>
<h2>Relaxed rules for sealed classes and data classes</h2>
<p>We now lift some restrictions on data classes and sealed classes.</p>
<p>Data classes can now be inherited from other classes. Note that automatically generated methods may override those defined in superclasses!</p>
<p>For sealed classes we broaden the scope where their inheritors may be defined: before it was only inside the sealed class itself, now it’s anywhere in the same file.</p>
<p>Read more and comment <a href="https://github.com/Kotlin/KEEP/issues/29">here</a> and <a href="https://github.com/Kotlin/KEEP/issues/31">here</a>.</p>
<h2>Scripting</h2>
<p>As you’ve probably heard, we all will soon be able to write Gradle build scripts in Kotlin which will considerably improve the IDE experience for editing such scripts and make them more reliable through static type checking. This project motivated us to work more on Kotlin scripting in general: we are developing the infrastructure to enable using Kotln scripts in the context of different tools, as well as the plain command-line support.</p>
<p>More details in the <a href="https://github.com/Kotlin/KEEP/issues/28">proposal</a>.</p>
<h2>Java 7/8 support</h2>
<p>We are working on the improved support for Java 8: 1.1 fixes the issues with Stream APIs that we used to have (and mitigated with a support library), and adds support for generating default methods in Kotlin interfaces, so that Java clients can implement them seamlessly. Read and comment <a href="https://github.com/Kotlin/KEEP/issues/30">here</a>.</p>
<p>To enable generation of version 8 class files, supply the <code>-jvm-target 1.8</code> command line switch.</p>
<p>We are also adding new functions to the Standard Library, and as they rely on Java API version newer than 1.6, we introduce new artifacts: <code>kotlin-stdlib-jre7</code> and <code>kotlin-stdlib-jre8</code> that carry extra functionality such as <code>AutoCloseable.use()</code>, Regex named groups support and stream-related functions. Use these artifacts instead of <code>kotlin-stdlib</code> from your Maven/Gradle builds if you need the APIs they add.</p>
<p>Read and discuss the proposals related to stdlib <a href="https://github.com/Kotlin/KEEP/labels/stdlib">here</a>.</p>
<h2>JavaScript</h2>
<p>We are actively working on the JavaScript back-end: all the language features available in 1.0 are covered now, and we are close to getting JavaScript (runtime) module systems integrated into the picture. Note that all this functionality is also available in Kotlin 1.0.X.</p>
<p>Find the proposals related to JavaScript <a href="https://github.com/Kotlin/KEEP/labels/JS">here</a>.</p>
<h2>Contributors</h2>
<p>We are very grateful to GitHub users <a href="https://github.com/dotlin">dotlin</a>, <a href="https://github.com/Valdemar0204">Valdemar0204</a>, <a href="https://github.com/ensirius">ensirius</a> and <a href="https://github.com/geoand">geoand</a> for their contributions to this version!</p>
<h2>How to try it</h2>
<p><strong>In Maven/Gradle</strong>. Add <a href="https://bintray.com/kotlin/kotlin-eap-1.1">https://bintray.com/kotlin/kotlin-eap-1.1</a> (see instructions under <em>“Set me up!”</em>) as a repository to your project. Use version 1.1-M01 for your Kotlin artifacts.</p>
<p><strong>In the IDE</strong>. If you are running <a href="https://blog.jetbrains.com/kotlin/2016/06/kotlin-1-0-3-is-here/">Kotlin 1.0.3</a>, go to <em>Tools → Kotlin → Configure Kotlin Plugin Updates</em>, then select “Early Access Preview 1.1” in the <em>Update channel</em> drop-down list:</p>
<p><img src="https://i1.wp.com/blog.jetbrains.com/kotlin/files/2016/07/Configure-Plugin-Updates.png?zoom=1.5&#x26;w=400&#x26;ssl=1" alt="Configure-Plugin-Updates"></p>
<p>Press <em>Check for updates</em> in the same dialog, and, when the new version is show, <em>Install</em>.</p>
<p><strong>On <a href="http://try.kotlinlang.org/">try.kotlinlang.org</a></strong>. Use the drop-down list at the bottom-right corner to change the compiler version:<br>
<img src="https://i0.wp.com/blog.jetbrains.com/kotlin/files/2016/07/Screen-Shot-2016-07-14-at-20.23.48.png?zoom=1.5&#x26;resize=640%252C549&#x26;ssl=1" alt="Screen Shot 2016-07-14 at 20.23.48"></p>
<p><strong>With SDKMan</strong>. Run <code>sdk install kotlin 1.1-M01</code>.</p>
<p>Your feedback is very welcome, as always.</p>
<h3>Have a nice Kotlin!</h3>
]]></description><link>https://blog.jetbrains.com/kotlin/2016/07/first-glimpse-of-kotlin-1-1-coroutines-type-aliases-and-more/</link><guid isPermaLink="true">https://blog.jetbrains.com/kotlin/2016/07/first-glimpse-of-kotlin-1-1-coroutines-type-aliases-and-more/</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Andrey Breslav]]></dc:creator><pubDate>Thu, 14 Jul 2016 15:01:00 GMT</pubDate></item><item><title><![CDATA[Scala vs Kotlin: Pimp my library]]></title><description><![CDATA[<p>I’ve been introduced to the world of immutable data structures with the Scala programming language - to write I’ve been introduced to the <abbr title="Functional Programming">FP</abbr> world would sound too presumptuous. Although I wouldn’t recommend its usage in my day-to-day projects, I’m still grateful to it for what I learned: my Java code is now definitely not the same because Scala made me aware of some failings in both the language <strong>and</strong> my coding practices.</p>
<p>On the other hand, I became recently much interested in <a href="https://kotlinlang.org/">Kotlin</a>, another language that tries to bridge between the Object-Oriented and Functional worlds. In this serie of articles, I’d like to compare some features of Scala and Kotlin and how each achieve it.</p>
<p>In this article, I’ll be tackling how both offer a way to improve the usage of <em>existing</em> Java libraries.</p>
<h2>Scala</h2>
<p>Let’s start with Scala, as it coined the term <a href="http://www.artima.com/weblogs/viewpost.jsp?thread=179766">Pimp My Library</a> 10 years ago.</p>
<p>Scala’s approach is based on <em>conversion</em>. Consider a base type lacking the desired behavior. For example, Java’s <code>double</code> primitive type - mapped to Scala’s <code>scala.Double</code> type, is pretty limited.</p>
<p>The first step is to create a new type with said behavior. Therefore, Scala provides a <code>RichDouble</code> type to add some methods <em>e.g.</em> <code>isWhole()</code>.</p>
<p>The second step is to provide an <em>implicit</em> function that converts from the base type to the improved type. The signature of such a function must follow the following rules:</p>
<ul>
<li>Have a single parameter of the base type</li>
<li>Return the improved type</li>
<li>Be tagged <code>implicit</code></li>
</ul>
<p>Here’s how the Scala library declares the <code>Double</code> to <code>RichDouble</code> conversion function:</p>
<pre><code class="hljs language-scala"><span class="hljs-keyword">private</span>[scala] <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LowPriorityImplicits</span> </span>{
    ...
    <span class="hljs-keyword">implicit</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">doubleWrapper</span></span>(x: <span class="hljs-type">Double</span>) = <span class="hljs-keyword">new</span> runtime.<span class="hljs-type">RichDouble</span>(x)
    ...
}</code></pre>
<p>An alternative is to create an <em>implicit class</em>, which among other requirements must have a constructor with a single parameter of base type.</p>
<p>The final step step is to bring the conversion <em>in scope</em>. For conversion functions, it means importing the function in the class file where the conversion will be used. Note that in this particular case, the conversion function is part of the automatic imports (there’s no need to explicitly declare it).</p>
<p>At this point, if a function is not defined for a type, the compiler will look for an imported conversion function that transforms this type to a new type that provides this function. In that case, the type will be replaced with the conversion function.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> x = <span class="hljs-number">45</span>d
<span class="hljs-keyword">val</span> isWhole = x.isWhole <span class="hljs-comment">// Double has no isWhole() function</span>

<span class="hljs-comment">// But there's a conversion function in scope which transforms Double to RichDouble</span>
<span class="hljs-comment">// And RichDouble has a isWhole() function</span>
<span class="hljs-keyword">val</span> isWhole = doubleWrapper(x).isWhole</code></pre>
<h2>Kotlin</h2>
<p>One of the main reasons I’m cautious about using Scala is indeed the implicit part: it makes it much harder to reason about the code - just like <abbr title="Aspect-Oriented Programming">AOP</abbr>. Homeopathic usage of AOP is a life saver, widespread usage is counter-productive.</p>
<p>Kotlin eschews implicitness: instead of conversions, it provides <a href="https://kotlinlang.org/docs/reference/extensions.html#extension-functions">extension methods</a> (and properties).</p>
<p>Let’s analyze how to add additional behavior to the <code>java.lang.Double</code> type.</p>
<p>The first step is to provide an extension function: it’s a normal function, but grafted to an existing type. To add the same <code>isWhole()</code> function as above, the syntax is the following:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Double</span>.<span class="hljs-title">isWhole</span><span class="hljs-params">()</span></span> = <span class="hljs-keyword">this</span> == Math.floor(<span class="hljs-keyword">this</span>) &#x26;&#x26; !java.lang.<span class="hljs-built_in">Double</span>.isInfinite(<span class="hljs-keyword">this</span>)</code></pre>
<p>As for Scala, the second step is to bring this function in scope. As of Scala, it’s achieved through an import. If the previous function has been defined in any file of the <code>ch.frankel.blog</code> package:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">import</span> ch.frankel.blog.isWhole

<span class="hljs-keyword">val</span> x = <span class="hljs-number">45.0</span>
<span class="hljs-keyword">val</span> isWhole = x.isWhole <span class="hljs-comment">// Double has no isWhole() function</span>

<span class="hljs-comment">// But there's an extension function in scope for isWhole()</span>
<span class="hljs-keyword">val</span> isWhole = x == Math.floor(x) &#x26;&#x26; !java.lang.<span class="hljs-built_in">Double</span>.isInfinite(x)</code></pre>
<p>Note that extension methods are resolved <strong>statically</strong>.</p>
<blockquote>
<p>Extensions do not actually modify classes they extend. By defining an extension, you do not insert new members into a class, but merely make new functions callable with the dot-notation on instances of this class.</p>
<p>We would like to emphasize that extension functions are dispatched statically, i.e. they are not virtual by receiver type. This means that the extension function being called is determined by the type of the expression on which the function is invoked, not by the type of the result of evaluating that expression at runtime.</p>
</blockquote>
<h2>Conclusion</h2>
<p>Obviously, Scala has one more indirection level - the conversion. I let anyone decide whether this is a good or a bad thing. For me, it makes it harder to reason about the code.</p>
<p>The other gap is the packaging of the additional functions. While in Scala those are all attached to the enriched type and can be imported as a whole, they have to be imported one by one in Kotlin.</p>
]]></description><link>https://blog.frankel.ch/scala-vs-kotlin/1/</link><guid isPermaLink="true">https://blog.frankel.ch/scala-vs-kotlin/1/</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Scala]]></category><dc:creator><![CDATA[Nicolas Fränkel]]></dc:creator><pubDate>Sun, 10 Jul 2016 08:57:00 GMT</pubDate></item><item><title><![CDATA[Never say final: mocking Kotlin classes in unit tests]]></title><description><![CDATA[<p><a href="http://www.martinfowler.com/bliki/TestDouble.html">Test doubles</a> are one of the most essential part of unit testing. A test double replaces a class that we need in our test but that is not the focus of our test. We remove that dependency by using a “fake” object. This way our test becomes more robust due to a reduced dependency on other classes. Such a double could be a stub, a dummy or a mock. All of these need the ability to replace an object with something artificial that looks and behaves like the object we need. In Java, the common approach for test doubles is using interfaces: one implementation of the class is the “real” one, and the other one is used for testing.</p>
<p>Writing a lot of unit tests means that all your classes need interfaces. This creates a lot of boilerplate. Therefore it became a common rule for many developers that if you have only one implementation for your interface the interface is useless and can be dropped.</p>
<p>This rule can easily be applied for testing also. As long as we only test the “public contract” of a class we can still replace this by a double. This can be done via extension and overriding or via a mocking framework like <a href="https://github.com/mockito/mockito">Mockito</a>. Mocking classes not only interfaces became pretty common and are a powerful feature. In other languages, like ObjectiveC, where developers do not focus on interfaces as much as in Java, this is the default approach.</p>
<h3>The Kotlin problem</h3>
<p>Everything seemed fine, until <a href="https://kotlinlang.org/">Kotlin</a> came around, a great modern language. Given how well Kotlin and Java work together, the Android developer community was hooked almost from the beginning.
But Kotlin brought a new concept: everything is <em>final</em> by default. The rule: “closed for modifications, open for extension” is baked into the language. Every class is <em>final</em> by default, every method is <em>final</em> by default! Inheritance was widely overused in the last decades and Kotlin tries to make this a bit better.</p>
<p>From a testing perspective this is a problem: if you can not extend a class you can not replace it with any kind of double, not even a generated mock:</p>
<pre><code class="hljs language-kotlin">org.mockito.exceptions.base.MockitoException:
Cannot mock/spy <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">com</span>.<span class="hljs-title">mypackage</span>.<span class="hljs-title">MyKotlinClass</span></span>
Mockito cannot mock/spy following:
 — <span class="hljs-keyword">final</span> classes
 — anonymous classes
 — primitive types</code></pre>
<p>And if the class would not be <em>final</em> you still have all the <em>final</em> methods. But as <em>final</em> methods can not be overridden, real code will suddenly run in your mock. This is something you want to avoid.
The problem itself is not new, especially APIs or different third party code were sealed with <em>finals</em>. The developers from <a href="https://www.jayway.com/sharing-knowledge/blog/">Jayway</a> solved this solution a long time ago by creating <a href="https://github.com/jayway/powermock/">PowerMock</a>.
PowerMock allows to mock <em>finals</em> and even <em>statics</em>. The question for us Kotlin developers is: is there a better way, easier way? Using PowerMock is like using a sledge hammer to crack a nut.</p>
<p>What else could we do? Going back to interfaces? This would lead us to the situation described above.
We could open all the classes we need. As we (hopefully) test all the classes, could this lead to opening all our classes!? And would this mean modifying our code just for testing? This sounds wrong! The main feature of the language would be broken.</p>
<h3>An idea to solve it</h3>
<p>In an ideal world we would just have something like:</p>
<pre><code class="hljs language-kotlin">controller = mockFinal()</code></pre>
<p>which would be an extension of normal <em>mock()</em> method. Everything this call would need to do, is removing the <em>final</em> modifier from the class and all its public methods.</p>
<p>With Java reflection is very easy to remove the <em>final</em> modifier of a field.
For example:</p>
<pre><code class="hljs language-kotlin">Field modifiersField = Field.<span class="hljs-keyword">class</span>.getDeclaredField(“modifiers”); modifiersField.setAccessible(<span class="hljs-literal">true</span>);
modifiersField.setInt(field, field.getModifiers() &#x26; ~Modifier.FINAL);</code></pre>
<p>But for classes and methods things tend to be a bit trickier. You can not achieve this with pure Java reflection API.</p>
<p>But thanks to frameworks like <a href="http://jboss-javassist.github.io/javassist/"><em>javassist</em></a> there is a way. Javassist is a large toolkit around byte code. It allows the manipulation and even creation of Java classes at runtime. And it also includes a way to change the class and method modifiers:</p>
<pre><code class="hljs language-kotlin">CtClass clazz = ...
int notFinalModifier = Modifier.clear(clazz.getModifiers(), Modifier.FINAL);
clazz.setModifiers(notFinalModifier);
<span class="hljs-keyword">return</span> clazz.toClass();  <span class="hljs-comment">// returns new non final class</span></code></pre>
<p>With this, a new non-final class can be easily created. But this leads to the next problem: <em>javassist</em> creates a new class but we can not load the new class into the current test. Because the class is already loaded by the class loader. Two version of it are not allowed:</p>
<pre><code class="hljs language-kotlin">javassist.CannotCompileException: <span class="hljs-keyword">by</span> java.lang.LinkageError: loader (instance of  sun/misc/Launcher$AppClassLoader): attempted  duplicate <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">definition</span> <span class="hljs-title">for</span> <span class="hljs-title">name</span>: <span class="hljs-type">"com/myPackage/MyKotlinClass"</span></span></code></pre>
<p>So we just need a different class loader right?
The problem: an assignment like</p>
<pre><code class="hljs language-kotlin">controller = mockFinal()</code></pre>
<p>would not work if two different class loaders would be used. So even if we could get passed that Linker error for duplicate class from above we would get a ClassCastException! This is because for the JVM classes are identified by <em>name, package</em> and _class loade_r. So even without modification, instances of two identical classes cannot be assigned to each other if the class loader differs.</p>
<p>This means we need to aim a bit larger than the initial idea: there must be only one class loader for our full test class.
Good news! With JUnit there is way to achieve this. We can change the TestRunner that is used for our class.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTestRunner</span> <span class="hljs-title">extends</span> <span class="hljs-title">BlockJUnit4ClassRunner</span> </span>{

    <span class="hljs-keyword">public</span> MyTestRunner(Class&#x3C;?> clazz) throws InitializationError {
        <span class="hljs-keyword">super</span>(getFromMyClassloader(clazz));
    }

    <span class="hljs-keyword">private</span> static Class&#x3C;?> getFromMyClassloader(Class&#x3C;?> clazz) ...</code></pre>
<p>then we would write our own <em>ClassLoader</em> and override:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> Class&#x3C;?> loadClass(String name) throws ClassNotFoundException { ...</code></pre>
<p>Here you can remove the <em>final</em> modifier with <em>javassist</em> as shown above and return the new “better” class.</p>
<p>Have a look on how all of these look when put together:
<a href="https://github.com/dpreussler/kotlin-testrunner"><em>https://github.com/dpreussler/kotlin-testrunner</em></a></p>
<p>If you want to use it, all you need to do is to add <strong><em>@RunWith(KotlinTestRunner.class)</em> </strong>for Java tests
or
<strong><em>@RunWith(KotlinTestRunner::class)</em> </strong>for Kotlin tests</p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@RunWith(KotlinTestRunner::class)</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyKotlinTestclass</span> </span>{
   <span class="hljs-meta">@Test</span>
   <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span> {
   ...
   }
}</code></pre>
<p>With this you will never have to care about if your Kotlin class is <em>final</em> or <em>open</em>. Simply mock them, it will work :-)</p>
<h3>Wrap up</h3>
<p>For now it seems there is no way around without changing the Testrunner. PowerMock uses the same approach but requires more configuration. So for what we wanted to achieve this is a reasonable solution. Give it a try and let me know how it works for you.</p>
<p>And of course the Runner is not limited to Kotlin. It can also be used for any Java test where a <em>final</em> method or class needs to be mocked.</p>
]]></description><link>https://medium.com/@dpreussler/never-say-final-mocking-kotlin-classes-in-unit-tests-314d275b82b1#.9oldk16f5</link><guid isPermaLink="true">https://medium.com/@dpreussler/never-say-final-mocking-kotlin-classes-in-unit-tests-314d275b82b1#.9oldk16f5</guid><category><![CDATA[Testing]]></category><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Danny Preussler]]></dc:creator><pubDate>Wed, 06 Jul 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[Data Driven Testing with Spek ]]></title><description><![CDATA[<p>Several days ago, when we were developing a parser in Kotlin, we found ourselves copying and pasting series of tests with slight adjustments. This has become really annoying, especially when we thought of all the tests we would need to change every time the behaviour of our parser is going to change. As we have used Spock on previous projects, we wanted to replicate Spock's <a href="https://spockframework.github.io/spock/docs/1.0/data_driven_testing.html">Data Driven Testing</a> approach in <a href="https://jetbrains.github.io/spek/">Spek</a>.</p>
<h2>Spock Example</h2>
<p>Before diving into the Kotlin exploration, let's quickly review the Spock interface for data driven testing. Spock provides means for defining easily readable tests, and even supports inclusion of test data into the test name using the <code>@Unroll</code> annotation:</p>
<pre><code class="hljs language-groovy">    <span class="hljs-meta">@Unroll</span>
    <span class="hljs-keyword">def</span> <span class="hljs-string">"maximum of #a and #b is #c"</span>(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c) {
<span class="hljs-symbol">        expect:</span>
            Math.max(a, b) == c
<span class="hljs-symbol">
        where:</span>
            a | b | c
            <span class="hljs-number">1</span> | <span class="hljs-number">3</span> | <span class="hljs-number">3</span>
            <span class="hljs-number">7</span> | <span class="hljs-number">4</span> | <span class="hljs-number">4</span>
            <span class="hljs-number">0</span> | <span class="hljs-number">0</span> | <span class="hljs-number">0</span>
    }</code></pre>
<p>The definition above will yield three tests in the report:</p>
<pre><code>maximum of 1 and 3 is 3 [PASS]
maximum of 7 and 4 is 4 [FAIL]
maximum of 0 and 0 is 0 [PASS]
</code></pre>
<p>When the set of data is more complicated, a label can be included as part of the test data parameters:</p>
<pre><code class="hljs language-groovy">    <span class="hljs-meta">@Unroll</span>
    <span class="hljs-keyword">def</span> <span class="hljs-string">"maximum of two numbers when #testLabel"</span>(String testLabel, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c) {
<span class="hljs-symbol">        expect:</span>
            Math.max(a, b) == c
<span class="hljs-symbol">
        where:</span>
            testLabel                 | a | b | c
            <span class="hljs-string">"first number is bigger"</span>  | <span class="hljs-number">4</span> | <span class="hljs-number">1</span> | <span class="hljs-number">4</span>
            <span class="hljs-string">"second number is bigger"</span> | <span class="hljs-number">0</span> | <span class="hljs-number">5</span> | <span class="hljs-number">5</span>
            <span class="hljs-string">"numbers are equal"</span>       | <span class="hljs-number">3</span> | <span class="hljs-number">3</span> | <span class="hljs-number">3</span>
    }</code></pre>
<h2>Spek approach</h2>
<p>Originally we would like to replicate the features of Spock interface as close as possible.</p>
<p>In Spek, as of version 1.0, all tests are defined within a lambda that is supplied as a constructor argument. This provides flexibility needed to replicate the RSpec DSL, but imposes limitations such as preventing the use of annotations.</p>
<h3>Trusting your heroes</h3>
<p>For the sake of this article, let's assume that we are writing a game in Kotlin, and we need to test the query methods in our <code>Hero</code> class that depend on the state our <code>Hero</code> is in. The state change can be triggered by calling an appropriate method, as per the skeleton defined below:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hero</span></span>() {
    <span class="hljs-keyword">val</span> isRunning: <span class="hljs-built_in">Boolean</span> <span class="hljs-keyword">get</span>() = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">val</span> isStanding: <span class="hljs-built_in">Boolean</span> <span class="hljs-keyword">get</span>() = <span class="hljs-literal">true</span>
    <span class="hljs-keyword">val</span> isJumping: <span class="hljs-built_in">Boolean</span> <span class="hljs-keyword">get</span>() = <span class="hljs-literal">false</span>

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span> {}
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">stand</span><span class="hljs-params">()</span></span> {}
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">jump</span><span class="hljs-params">()</span></span> {}
}</code></pre>
<p>In contrast to the Spock example above, we need to run a series of tests for every state of the object. For every one of the four states (initial, running, standing and jumping), we would need to verify all three query methods. With Spock we would have to put the three assertions into a single test method.</p>
<h3>First attempt</h3>
<p>Our first approach was to use lists of arbitrary objects to emulate the Spock <code>when</code> table. Then all our test blocks can be dynamically defined while iterating over those lists:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeroTests</span>: <span class="hljs-type">Spek</span></span>({
    describe(<span class="hljs-string">"query methods"</span>) {
        listOf(
            listOf(<span class="hljs-string">"initial state"</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>, Hero()),
            listOf(<span class="hljs-string">"when running"</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>, Hero().apply { run() }),
            listOf(<span class="hljs-string">"when jumping"</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>, Hero().apply { jump() }),
            listOf(<span class="hljs-string">"when standing"</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>, Hero().apply { stand() })
        ).forEach { test ->
            describe(test.first) {
                <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">testLabel</span><span class="hljs-params">(flag: <span class="hljs-type">Boolean</span>, action: <span class="hljs-type">String</span>)</span></span>: String = <span class="hljs-string">"<span class="hljs-subst">${if (flag) "should" else "shouldn<span class="hljs-string">'t"} be $action"

                it(testLabel(test[1], "running")) {
                    expect(test[1]) { test[4].isRunning }
                }

                it(testLabel(test[2], "walking")) {
                    expect(test[2]) { test[4].isWalking }
                }

                it(testLabel(test[3], "jumping")) {
                    expect(test[3]) { test[4].isJumping }
                }
            }
        }
    }
})</span></span></span></code></pre>
<p>When running these tests, we can get a very nicely organized output:</p>
<p><img src="https://dl.dropboxusercontent.com/u/364765/hero-tests-report.png" alt="HeroTests report"></p>
<blockquote>
<p><strong>Please note</strong></p>
<p>Only the platform test runner should be used in IDEA to get meaningful test reports for Spek tests. At the time of writing, Gradle test runner output was pretty confusing and rather useless. For the test case above it reported 48 tests named "classMethod", and even though the stack trace for failed tests would indicate the point of failure, it is absolutely meaningless without knowledge of the failed iteration.</p>
</blockquote>
<p>We now have a fine-grained output, and adding a new set of tests straight away is fairly simple and straightforward. However, it is difficult to keep track of the value types and meanings. And maintaining these tests could become difficult over time, especially when you need to restructure the test data.</p>
<h3>Moving test data to a DTO</h3>
<p>In order to improve clarity and maintainability, we can replace the list of arbitrary objects with a DTO. Additionally, we can move some test reporting helpers, such as test and test group name generators, into that DTO as well:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeroQueryTest</span></span>(<span class="hljs-keyword">val</span> state: String, <span class="hljs-keyword">val</span> subject: Hero, <span class="hljs-keyword">val</span> isRunning: <span class="hljs-built_in">Boolean</span>, <span class="hljs-keyword">val</span> isJumping: <span class="hljs-built_in">Boolean</span>, <span class="hljs-keyword">val</span> isStanding: <span class="hljs-built_in">Boolean</span>) {
    <span class="hljs-keyword">val</span> runningTestLabel = testLabel(isRunning, <span class="hljs-string">"running"</span>)
    <span class="hljs-keyword">val</span> standingTestLabel = testLabel(isStanding, <span class="hljs-string">"standing"</span>)
    <span class="hljs-keyword">val</span> jumpingTestLabel = testLabel(isJumping, <span class="hljs-string">"jumping"</span>)
    <span class="hljs-keyword">val</span> testGroupLabel = <span class="hljs-string">"when <span class="hljs-subst">$state</span>"</span>

    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">testLabel</span><span class="hljs-params">(condition: <span class="hljs-type">Boolean</span>, action: <span class="hljs-type">String</span>)</span></span> = <span class="hljs-keyword">if</span> (condition) <span class="hljs-string">"should be <span class="hljs-subst">$action</span>"</span> <span class="hljs-keyword">else</span> <span class="hljs-string">"shouldn't be <span class="hljs-subst">$action</span>"</span>
}</code></pre>
<p>In the code above, we could have used <a href="https://kotlinlang.org/docs/reference/reflection.html">introspection</a> to derive the action string from the property name, but that would require to drag in the heavy <code>kotlin-reflect.jar</code>, which might not be needed otherwise. But just in case you were wondering, this is how it might look like:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">import</span> kotlin.reflect.KProperty

<span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeroQueryTest</span></span>(<span class="hljs-keyword">val</span> state: String, <span class="hljs-keyword">val</span> subject: Hero, <span class="hljs-keyword">val</span> isRunning: <span class="hljs-built_in">Boolean</span>, <span class="hljs-keyword">val</span> isJumping: <span class="hljs-built_in">Boolean</span>, <span class="hljs-keyword">val</span> isStanding: <span class="hljs-built_in">Boolean</span>) {
    <span class="hljs-keyword">val</span> runningTestLabel = HeroQueryTest::isRunning.testLabel(<span class="hljs-keyword">this</span>)
    <span class="hljs-keyword">val</span> standingTestLabel = HeroQueryTest::isStanding.testLabel(<span class="hljs-keyword">this</span>)
    <span class="hljs-keyword">val</span> jumpingTestLabel = HeroQueryTest::isJumping.testLabel(<span class="hljs-keyword">this</span>)
    <span class="hljs-keyword">val</span> testGroupLabel = <span class="hljs-string">"when <span class="hljs-subst">$state</span>"</span>

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> KProperty&#x3C;<span class="hljs-built_in">Boolean</span>>.action: String <span class="hljs-keyword">get</span>() = <span class="hljs-keyword">this</span>.name.substring(<span class="hljs-number">2</span>).toLowerCase()
    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> KProperty<span class="hljs-type">&#x3C;Boolean></span>.<span class="hljs-title">testLabel</span><span class="hljs-params">(owner: <span class="hljs-type">Any</span>)</span></span>: String = <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.getter.call(owner)) <span class="hljs-string">"should be <span class="hljs-subst">${this.action}</span>"</span> <span class="hljs-keyword">else</span> <span class="hljs-string">"shouldn't be <span class="hljs-subst">${this.action}</span>"</span>
}</code></pre>
<p>Regardless of the internal implementation, we transform our test case, utilizing the newly defined DTO:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeroTests</span> : <span class="hljs-type">Spek</span></span>({
    describe(<span class="hljs-string">"query methods"</span>) {
        listOf(
                HeroQueryTest(<span class="hljs-string">"created"</span>, isRunning = <span class="hljs-literal">false</span>, isJumping = <span class="hljs-literal">false</span>, isStanding = <span class="hljs-literal">true</span>, subject = Hero()),
                HeroQueryTest(<span class="hljs-string">"running"</span>, isRunning = <span class="hljs-literal">true</span>, isJumping = <span class="hljs-literal">false</span>, isStanding = <span class="hljs-literal">false</span>, subject = Hero().apply { run() }),
                HeroQueryTest(<span class="hljs-string">"jumping"</span>, isRunning = <span class="hljs-literal">false</span>, isJumping = <span class="hljs-literal">true</span>, isStanding = <span class="hljs-literal">false</span>, subject = Hero().apply { jump() }),
                HeroQueryTest(<span class="hljs-string">"standing"</span>, isRunning = <span class="hljs-literal">false</span>, isJumping = <span class="hljs-literal">false</span>, isStanding = <span class="hljs-literal">true</span>, subject = Hero().apply { stand() })
        ).forEach { test ->
            describe(test.testGroupLabel) {
                it(test.runningTestLabel) {
                    expect(test.isRunning) { test.subject.isRunning }
                }

                it(test.jumpingTestLabel) {
                    expect(test.isJumping) { test.subject.isJumping }
                }

                it(test.standingTestLabel) {
                    expect(test.isStanding) { test.subject.isStanding }
                }
            }
        }
    }
})</code></pre>
<p>This looks much nicer - named arguments can be used to rearrange constructor arguments in a way that would make the "table" more readable. At the same time, named arguments are also used to avoid any confusion regarding the meaning of the test data. Not to mention that all of our actual test definitions became clearer and are much easier to follow.</p>
<h3>Using a factory to configure the test subject</h3>
<p>In real projects, configuring the subject may be much more complicated. In those cases, a factory object can be used to isolate that complexity, and to provide a readable name for the configured object:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">object</span> HeroFactory {
    <span class="hljs-keyword">val</span> <span class="hljs-keyword">default</span>: Hero <span class="hljs-keyword">get</span>() = Hero()
    <span class="hljs-keyword">val</span> running: Hero <span class="hljs-keyword">get</span>() = Hero().apply { run() }
    <span class="hljs-keyword">val</span> standing: Hero <span class="hljs-keyword">get</span>() = Hero().apply { stand() }
    <span class="hljs-keyword">val</span> jumping: Hero <span class="hljs-keyword">get</span>() = Hero().apply { jump() }
}</code></pre>
<p>rendering our test "table" even more readable:</p>
<pre><code>    HeroQueryTest("created", isRunning = false, isJumping = false, isStanding = true, subject = HeroFactory.default),
    HeroQueryTest("running", isRunning = true, isJumping = false, isStanding = false, subject = HeroFactory.running),
    HeroQueryTest("jumping", isRunning = false, isJumping = true, isStanding = false, subject = HeroFactory.jumping),
    HeroQueryTest("standing", isRunning = false, isJumping = false, isStanding = true, subject = HeroFactory.standing)
</code></pre>
<h3>Improving the factory</h3>
<p>We can go even a bit further, and combine the state label with the configured subject in the factory, returning an instance of a DTO holding both the state label and the subject. This approach is, of course, specific to the particular use case:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConfiguredHero</span></span>(<span class="hljs-keyword">val</span> subject: Hero, <span class="hljs-keyword">val</span> stateLabel: String)

<span class="hljs-keyword">object</span> HeroFactory {
    <span class="hljs-keyword">val</span> <span class="hljs-keyword">default</span>: ConfiguredHero <span class="hljs-keyword">get</span>() = ConfiguredHero(Hero(), <span class="hljs-string">"created"</span>)
    <span class="hljs-keyword">val</span> running: ConfiguredHero <span class="hljs-keyword">get</span>() = ConfiguredHero(Hero().apply { run() }, <span class="hljs-string">"running"</span>)
    <span class="hljs-keyword">val</span> standing: ConfiguredHero <span class="hljs-keyword">get</span>() = ConfiguredHero(Hero().apply { stand() }, <span class="hljs-string">"standing"</span>)
    <span class="hljs-keyword">val</span> jumping: ConfiguredHero <span class="hljs-keyword">get</span>() = ConfiguredHero(Hero().apply { jump() }, <span class="hljs-string">"jumping"</span>)
}

<span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeroQueryTest</span></span>(<span class="hljs-keyword">val</span> configuration: ConfiguredHero, <span class="hljs-keyword">val</span> isRunning: <span class="hljs-built_in">Boolean</span>, <span class="hljs-keyword">val</span> isJumping: <span class="hljs-built_in">Boolean</span>, <span class="hljs-keyword">val</span> isStanding: <span class="hljs-built_in">Boolean</span>) {
    <span class="hljs-keyword">val</span> state = configuration.stateLabel
    <span class="hljs-keyword">val</span> subject = configuration.subject
    <span class="hljs-comment">// the remaining implementation remains untouched</span>
}</code></pre>
<p>Using this configuration makes our test definitions tidier than ever, while retaining the granularity of feedback we had on our first iteration:</p>
<pre><code>    HeroQueryTest(HeroFactory.default, isRunning = false, isJumping = false, isStanding = true),
    HeroQueryTest(HeroFactory.running, isRunning = true, isJumping = false, isStanding = false),
    HeroQueryTest(HeroFactory.jumping, isRunning = false, isJumping = true, isStanding = false),
    HeroQueryTest(HeroFactory.standing, isRunning = false, isJumping = false, isStanding = true)
</code></pre>
<h2>Spock test revisited</h2>
<p>Let's define the Spock example from the beginning of this article using our approach:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MathTests</span> : <span class="hljs-type">Spek</span></span>({
    <span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MaxTest</span></span>(<span class="hljs-keyword">val</span> a: <span class="hljs-built_in">Int</span>, <span class="hljs-keyword">val</span> b: <span class="hljs-built_in">Int</span>, <span class="hljs-keyword">val</span> c: <span class="hljs-built_in">Int</span>)
    describe(<span class="hljs-string">"max"</span>) {
        listOf(
                MaxTest(a = <span class="hljs-number">1</span>, b = <span class="hljs-number">3</span>, c = <span class="hljs-number">3</span>),
                MaxTest(a = <span class="hljs-number">7</span>, b = <span class="hljs-number">4</span>, c = <span class="hljs-number">4</span>),
                MaxTest(a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>, c = <span class="hljs-number">0</span>)
        ).forEach { test ->
            it(<span class="hljs-string">"calculates maximum of <span class="hljs-subst">${test.a}</span> and <span class="hljs-subst">${test.b}</span> as <span class="hljs-subst">${test.c}</span>"</span>) {
                expect(test.c) { Math.max(test.a, test.b) }
            }
        }
    }
})</code></pre>
<p>This test case is only one line longer than the original, readable and maintainable, but feels more cluttered.</p>
<p>Let's see if we can implement an approximation of the pipe syntax. Since | is unavailable as a function name, we can use the uppercase <code>I</code> instead:</p>
<pre><code class="hljs language-kotlin">    <span class="hljs-keyword">infix</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">I</span><span class="hljs-params">(other: <span class="hljs-type">Int</span>)</span></span>: List&#x3C;<span class="hljs-built_in">Int</span>> = listOf(<span class="hljs-keyword">this</span>, other)
    <span class="hljs-keyword">infix</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> List<span class="hljs-type">&#x3C;Int></span>.<span class="hljs-title">I</span><span class="hljs-params">(other: <span class="hljs-type">Int</span>)</span></span>: List&#x3C;<span class="hljs-built_in">Int</span>> = <span class="hljs-keyword">this</span> + listOf(other)</code></pre>
<p>This way we could define our data table by listing numbers separated by <code>I</code>s. The resulting list should be fed into a factory to produce our DTO:</p>
<pre><code class="hljs language-kotlin">        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">maxTest</span><span class="hljs-params">(values: <span class="hljs-type">List</span>&#x3C;<span class="hljs-type">Int</span>>)</span></span>: MaxTest = MaxTest(values[<span class="hljs-number">0</span>], values[<span class="hljs-number">1</span>], values[<span class="hljs-number">2</span>])</code></pre>
<p>on the result of which we can call <code>apply</code> to get rid of all of the <code>test.</code> prefixes. This is the final form of the test case:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MathTests</span> : <span class="hljs-type">Spek</span></span>({
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MaxTest</span></span>(<span class="hljs-keyword">val</span> a: <span class="hljs-built_in">Int</span>, <span class="hljs-keyword">val</span> b: <span class="hljs-built_in">Int</span>, <span class="hljs-keyword">val</span> c: <span class="hljs-built_in">Int</span>)
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">maxTest</span><span class="hljs-params">(values: <span class="hljs-type">List</span>&#x3C;<span class="hljs-type">Any</span>>)</span></span>: MaxTest = MaxTest(values[<span class="hljs-number">0</span>] <span class="hljs-keyword">as</span> <span class="hljs-built_in">Int</span>, values[<span class="hljs-number">1</span>] <span class="hljs-keyword">as</span> <span class="hljs-built_in">Int</span>, values[<span class="hljs-number">2</span>] <span class="hljs-keyword">as</span> <span class="hljs-built_in">Int</span>)
    <span class="hljs-keyword">infix</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> Any.<span class="hljs-title">I</span><span class="hljs-params">(other: <span class="hljs-type">Any</span>)</span></span>: List&#x3C;Any> = listOf(<span class="hljs-keyword">this</span>, other)
    <span class="hljs-keyword">infix</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> List<span class="hljs-type">&#x3C;Any></span>.<span class="hljs-title">I</span><span class="hljs-params">(other: <span class="hljs-type">Any</span>)</span></span>: List&#x3C;Any> = <span class="hljs-keyword">this</span> + listOf(other)

    describe(<span class="hljs-string">"max"</span>) {
        listOf(
                <span class="hljs-number">1</span> I <span class="hljs-number">3</span> I <span class="hljs-number">3</span>,
                <span class="hljs-number">7</span> I <span class="hljs-number">4</span> I <span class="hljs-number">4</span>,
                <span class="hljs-number">0</span> I <span class="hljs-number">0</span> I <span class="hljs-number">0</span>
        ).forEach { <span class="hljs-keyword">data</span> ->
            maxTest(<span class="hljs-keyword">data</span>).apply {
                it(<span class="hljs-string">"calculates maximum of <span class="hljs-subst">$a</span> and <span class="hljs-subst">$b</span> as <span class="hljs-subst">$c</span>"</span>) {
                    expect(c) { Math.max(a, b) }
                }
            }
        }
    }
})</code></pre>
<p>Although the data table now looks cleaner, and has become generic, it has lost it's labels, and the indentation won't be maintained by the IDE, as is the case with Spock. The latter means that in reality this table will become an unreadable mess, meaning that we'd be better off with the DTO constructor using labelled arguments.</p>
<h1>Conclusion</h1>
<p>Although we were unable to fully replicate the simplicity of Spock's data tables, the end result became more flexible and powerful. We have discovered a way to create clean and maintainable data-driven tests with Spek, and even made one row in our data "table" generate several named assertions.</p>
<p>The shortest implementation can be made by using lists of arbitrary objects to hold the test data, but it would be hard to maintain. By introducing a few DTOs and a factory object, we have been able to increase both usability and maintainability of the test suite. And although the DTOs are tightly coupled to the test, the factory could be easily reused elsewhere in the test suite. Even so, the size of the whole test case is still kept under 50 lines of code, as opposed to a hundred lines of duplicated unmaintainable test code for the regular, non-data-driven approach.</p>
]]></description><link>http://engineering.pivotal.io/post/spek-data-driven-tests/</link><guid isPermaLink="true">http://engineering.pivotal.io/post/spek-data-driven-tests/</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Testing]]></category><dc:creator><![CDATA[Konstantin Semenov]]></dc:creator><pubDate>Sun, 03 Jul 2016 03:25:00 GMT</pubDate></item><item><title><![CDATA[Kotlin 1.0.3 Is Here!]]></title><description><![CDATA[<p>We are delighted to present <strong>Kotlin 1.0.3</strong>. This update is not full of brand new and shiny features, it is more about bug fixes, tooling improvements and performance boosts. That’s why you’ll like it <img src="https://s.w.org/images/core/emoji/72x72/1f609.png" alt="😉"> Take a look at the full <a href="https://github.com/JetBrains/kotlin/blob/1.0.3/ChangeLog.md">change log</a> and issues stats by subsystem:</p>
<p><img src="https://d3nmt5vlzunoa1.cloudfront.net/kotlin/files/2016/06/Pasted-image-at-2016_06_28-07_25-PM.png" alt="Kotlin 1.0.3. Fixed issues">  </p>
<p>Specifically we want to express our gratitude to our contributors whose commits are included in 1.0.3 namely <a href="https://github.com/yarulan">Yaroslav Ulanovych</a>, <a href="https://github.com/JakeWharton">Jake Wharton</a> and <a href="https://github.com/cypressious">Kirill Rakhman</a>. Kirill has done more than a dozen improvements to formatter and submitted 20+ commits — great job, Kirill, we really appreciate it. Here we also want to thank each and every one of our EAP users who tested and provided their priceless feedback on 1.0.3 prerelease builds.</p>
<p>Although this update is not feature-rich, there are several important improvements and features which are worth highlighting here:</p>
<h2>What’s new in the compiler:</h2>
<ul>
<li>New option <code>-jdk-home</code> to specify the JDK against which the code is compiled</li>
<li>Options to specify Kotlin language version (<code>-language-version</code>) and target Java version (<code>-jvm-target</code>) (will have effect in 1.1, added now for forward compatibility)</li>
<li>More efficient bytecode (no more iterator in <code>indices</code> loop, avoid unnecessary operations with <code>Unit</code>)</li>
<li>Various improvements to diagnostic messages</li>
</ul>
<h2>What’s new in the IDE:</h2>
<ul>
<li>
<p>Autosuggestion for Java to Kotlin conversion for Java code copied from browser and other sources outside of the IDE
<img src="https://d3nmt5vlzunoa1.cloudfront.net/kotlin/files/2016/06/copypaste.gif"></p>
</li>
<li>
<p>Language injection for strings passed to parameters annotated with @Language. Also predefined Java injections applied in Kotlin code. Read more about using language injections in the <a href="https://www.jetbrains.com/help/idea/2016.1/using-language-injections.html">documentation</a>
<img src="https://d3nmt5vlzunoa1.cloudfront.net/kotlin/files/2016/06/inject.gif"></p>
</li>
<li>
<p>Completion now always shows non-imported classes and methods and adds imports automatically when they are selected
<img src="https://d3nmt5vlzunoa1.cloudfront.net/kotlin/files/2016/06/import-1.gif"></p>
</li>
<li>
<p>Smart completion works after ‘by’ and ‘in’
<img src="https://d3nmt5vlzunoa1.cloudfront.net/kotlin/files/2016/06/smart.gif"></p>
</li>
<li>
<p>Move Element Left/Right actions work for Kotlin
<img src="https://d3nmt5vlzunoa1.cloudfront.net/kotlin/files/2016/06/move.gif"></p>
</li>
<li>
<p><em>Decompile</em> button is now available in Kotlin bytecode toolwindow and for .class files compiled with Kotlin
<img src="https://d3nmt5vlzunoa1.cloudfront.net/kotlin/files/2016/06/decompile.png" alt="decompile"></p>
</li>
<li>
<p>Now you can navigate from stacktrace to the call site of an inline function</p>
</li>
<li>
<p>Inspections and intentions to check and adjust Kotlin configuration in pom.xml files</p>
</li>
<li>
<p>Various Spring support improvements</p>
</li>
</ul>
<h2>How to update</h2>
<p>To update the plugin, use Tools | Kotlin | Configure Kotlin Plugin Updates and press the “Check for updates now” button. Also, don’t forget to update the compiler and standard library version in your Maven and Gradle build scripts.</p>
<p>As usual, if you run into any problems with the new release, you’re welcome to ask for help on the <a href="https://discuss.kotlinlang.org/">forums</a>, on Slack (get an invite <a href="http://kotlinslackin.herokuapp.com/">here</a>), or to report issues in the <a href="https://youtrack.jetbrains.com/issues/KT">issue tracker</a>.</p>
<p>Let’s Kotlin!</p>
]]></description><link>https://blog.jetbrains.com/kotlin/2016/06/kotlin-1-0-3-is-here/</link><guid isPermaLink="true">https://blog.jetbrains.com/kotlin/2016/06/kotlin-1-0-3-is-here/</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Roman Belov]]></dc:creator><pubDate>Thu, 30 Jun 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[How to get IDEA to detect kotlin generated sources using Gradle]]></title><description><![CDATA[<p>So I recently got my hands on Kotlin and it's been great so far.</p>
<p>However one of the things that the IDEA kotlin plugin doesn't do<sup id="fnref:1"><a href="#fn:1">1</a></sup> is detect the <code>kapt</code> folder which contains any sources generated from annotation processing. This can be fixed using the IDEA gradle plugin<sup id="fnref:2"><a href="#fn:2">2</a></sup>.</p>
<p>The idea plugin isn't able to mark the kapt folder as a source directory unless it's been added to the gradle source set.</p>
<pre><code class="hljs language-gradle"><span class="hljs-keyword">sourceSets</span>.main.java.srcDir <span class="hljs-keyword">file</span>(<span class="hljs-string">"$buildDir/generated/source/kapt/"</span>)  </code></pre>
<p>The next step is to tell the idea plugin to mark the kapt folder as a generated sources root in the module<sup id="fnref:3"><a href="#fn:3">3</a></sup>.</p>
<pre><code class="hljs language-gradle">idea {  
    module {
        <span class="hljs-comment">// Tell idea to mark the folder as generated sources</span>
        generatedSourceDirs += <span class="hljs-keyword">file</span>(<span class="hljs-string">"$buildDir/generated/source/kapt/"</span>)
    }
}</code></pre>
<p>When put together your build script should look a little like this.</p>
<pre><code class="hljs language-gradle">apply plugin: <span class="hljs-string">'idea'</span>

...

kapt {  
    generateStubs = <span class="hljs-keyword">true</span>
}

<span class="hljs-comment">// Add kapt directory to sources</span>
<span class="hljs-keyword">sourceSets</span>.main.java.srcDir <span class="hljs-keyword">file</span>(<span class="hljs-string">"$buildDir/generated/source/kapt/"</span>)

idea {  
    module {
<span class="hljs-comment">// Tell idea to mark the folder as generated sources</span>
        generatedSourceDirs += <span class="hljs-keyword">file</span>(<span class="hljs-string">"$buildDir/generated/source/kapt/"</span>)
    }
}</code></pre>
<h6>Footnotes and references</h6>
<ol>
<li>
<p><a name="fn:1"></a> →, V. (2015). Better Annotation Processing: Supporting Stubs in kapt. [online] Kotlin Blog. Available at: <a href="https://blog.jetbrains.com/kotlin/2015/06/better-annotation-processing-supporting-stubs-in-kapt/#comment-36065">https://blog.jetbrains.com/kotlin/2015/06/better-annotation-processing-supporting-stubs-in-kapt/#comment-36065</a> [Accessed 25 Jun. 2016]. <a href="#fnref:1" title="return to article">↩</a></p>
</li>
<li>
<p><a name="fn:2"></a> Docs.gradle.org. (2016). The IDEA Plugin - Gradle User Guide Version 2.14. [online] Available at: <a href="https://docs.gradle.org/current/userguide/idea_plugin.html">https://docs.gradle.org/current/userguide/idea_plugin.html</a> [Accessed 25 Jun. 2016]. <a href="#fnref:2" title="return to article">↩</a></p>
</li>
<li>
<p><a name="fn:3"></a> Docs.gradle.org. (2016). IdeaModule - Gradle DSL Version 2.14. [online] Available at: <a href="https://docs.gradle.org/current/dsl/org.gradle.plugins.ide.idea.model.IdeaModule.html">https://docs.gradle.org/current/dsl/org.gradle.plugins.ide.idea.model.IdeaModule.html</a> [Accessed 25 Jun. 2016]. <a href="#fnref:3" title="return to article">↩</a></p>
</li>
</ol>
]]></description><link>https://blog.nishtahir.com/2016/06/25/how-to-get-idea-to-detect-kotlin-generated-sources-using-gradle/</link><guid isPermaLink="true">https://blog.nishtahir.com/2016/06/25/how-to-get-idea-to-detect-kotlin-generated-sources-using-gradle/</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Nish Tahir]]></dc:creator><pubDate>Sat, 25 Jun 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[Ad-hoc polymorphism in Kotlin]]></title><description><![CDATA[<p>Even though Kotlin doesn’t natively support ad-hoc polymorphism today, it’s actually pretty straightforward to use it with little effort. Doing so is not as straightforward as it is in Haskell, obviously, but it’s been simple enough that I haven’t really encountered situations in Kotlin where the lack of native support in the language was a showstopper. In this article, I present two techniques you can use to leverage ad-hoc polymorphism in Kotlin.</p>
<h2>Extending for “fun” and some profit</h2>
<p>Here is what the <a href="https://wiki.haskell.org/Polymorphism">Haskell wiki</a> has to say about ad-hoc polymorphism:</p>
<blockquote>
<p>Despite the similarity of the name, Haskell’s type classes are quite different from the classes of most object-oriented languages. They have more in common with interfaces, in that they specify a series of methods or values by their type signature, to be implemented by an instance declaration.</p>
</blockquote>
<p>Before we get into details, let’s define exactly what we are trying to do and why we’re trying to do it. One intuitive way of looking at ad-hoc polymorphism is that it enables us to retroactively make values conform to a certain type. This is a bit abstract but I’m pretty sure you have encountered this problem many times before even if you never realized it. Let’s look at a simple example.</p>
<p>A library typically defines types and then offers functions that take parameters and returns values of that type. The only way to make use of that library is to find a way to bring your objects into that library’s object world, or in other words, be able to convert your objects to objects that this library expects and vice versa. You will find many examples of type classes if you do a simple search: values that behave like a Number, Functor, Applicative, Monad, Monoid, Equality, Comparability, etc... In order not to repeat what’s already out there and in an effort to remain focused on concrete problems, I’m going to pick a different field: JSON.</p>
<p>The need to parse JSON and also convert your objects to JSON is pretty much universal, so in all likeliness, you are already using a JSON library in your code. And at some point, you have had to ask yourself a very simple question: “How do I convert my current objects to JSON so I can use this library”. The library probably defines some kind of <code>JsonObject</code> type and most of its API is defined in terms of this type, either with functions accepting parameters of that type or returning such values:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">JsonObject</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">toJson</span><span class="hljs-params">()</span></span> : String
}</code></pre>
<p>In order to leverage this library, converting your objects so they conform to this interface is very important, and once you have converted your objects, you gain full access to all the functionalities that this library offers, such as pretty printing in JSON, doing search/replaces in JSON, reshaping JSON object from one form to another, etc...</p>
<p>If you own (i.e. you are the author of) these classes, doing so is very easy. For example, you can modify your class to implement that interface:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span> : <span class="hljs-type">JsonObject {</span></span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-keyword">override</span> <span class="hljs-title">toJson</span><span class="hljs-params">()</span></span> : String { ... }
}</code></pre>
<p>The advantage of this approach is that you can now pass all your <code>Account</code> values directly to functions of the JSON libraries that accept a <code>JsonObject</code>. This is very useful, but the downside is that you have now polluted your class with a concern that make your design more bloated. If you are going to extend this approach to other types, very soon, your <code>Account</code> class will extend multiple interfaces filling various functionalities, and you have now tied your business logic to a lot of dependencies (i.e. you now need this JSON library in order to compile your <code>Account</code>...).</p>
<p>Another approach is simply to write a function that converts your business objects to <code>JsonObjects</code>:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> Account.<span class="hljs-title">toJson</span><span class="hljs-params">()</span></span> : JsonObject { ... }</code></pre>
<p>This defines an extension function that adds the method <code>toJson()</code> directly on the <code>Account</code> class, where it belongs. The extension function buys us two very important benefits:</p>
<ul>
<li>Since it’s an extension function, its implementation runs on the <code>Account</code> instance itself (in other word, <code>this</code> is of type <code>Account</code>).</li>
<li>This function is defined without making any modification to the <code>Account</code> class itself. Not only does it leave your class untouched and unpolluted with unrelated concerns, you can also apply this approach to classes that you don’t own. This is extremely important and a critical step toward ad-hoc polymorphism.</li>
</ul>
<p>With this approach, we have won separation of concerns and a great amount of flexibility but we have lost some typing power: we can no longer pass an instance of <code>Account</code> to a function accepting a <code>JsonObject</code> parameter, we need to call <code>toJson()</code> on that instance first.</p>
<p>This is how far we can go with Kotlin today and this fits in Kotlin’s general design principle to stay away from implicit conversions, a decision I’ve come to respect greatly after several years writing Kotlin code.</p>
<h2>Escaping the tyranny of nominal typing</h2>
<p>Let’s look at another approach to implement ad hoc polymorphism. Consider the following simple function that saves an object to a database:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">persist</span><span class="hljs-params">(person: <span class="hljs-type">Person</span>)</span></span> {
    db.save(person.id, person)
}</code></pre>
<p>The object is saved to the database and associated to its <code>id</code>. A little later, I want to persist an <code>Account</code> object, and in the spirit of proper software engineering, I’d rather abstract my existing code rather than writing a second <code>persist()</code> function. So I make my function more generic and in the process, I discover that in order to be persisted, my <code>Account</code> instance needs to be able to give me its <code>id</code>. After refactoring, my code now looks like this:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Id</span> </span>{
    <span class="hljs-keyword">val</span> id : String
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> : <span class="hljs-type">Id {</span></span>
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> id: String <span class="hljs-keyword">get</span>() = <span class="hljs-string">"1"</span>
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">persist</span><span class="hljs-params">(id: <span class="hljs-type">Id</span>)</span></span> { ... }</code></pre>
<p>But now, I find myself having to make <code>Account</code> implement <code>Id</code>, which is exactly what I am trying to avoid with ad hoc polymorphism (either because I think it’s bad design or more simply because the class <code>Account</code> is not mine, so I can’t modify it). The realization here is that these type names get in the way of my goal and I’d rather keep all these concepts separate.</p>
<p>What if, instead, the <code>persist()</code> method accepted an additional parameter (a function) that allows me to obtain an <code>Id</code> from its parameter?</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&#x3C;T></span> <span class="hljs-title">persist</span><span class="hljs-params">(o: <span class="hljs-type">T</span>, toId: (<span class="hljs-type">T</span>)</span></span> -> String)

<span class="hljs-comment">// Persist a Person: easy since Person extends Id</span>
persist(person, { person -> person.id })

<span class="hljs-comment">// Persist an Account: need to get an id some other way</span>
persist(account, { account -> getAnIdForAccountSomehow(account) }</code></pre>
<p>This new approach has a few interesting characteristics:</p>
<ol>
<li>Notice how completely generic the <code>persist()</code> method has become: it doesn’t reference <code>Person</code>, <code>Account</code> and not even <code>Id</code>, even though it needs some sort of id in order to operate. This function is literally applicable “for all” types (I am intentionally using double quotes here, some of you will probably immediately understand what “for all” means in this context).</li>
<li>We have detached the ability to provide an id from our types. You still have the option to implement this functionality into your types (like <code>Person</code> does) but it’s now entirely optional (like <code>Account</code> shows). This gives you a lot of flexibility since you are now longer forced to use the id supplied by the class and you can also be more creative in your testing (e.g. trying to save two different objects but force them to have the same <code>id</code> in order to test for collision error cases).</li>
</ol>
<p>This approach makes a drastic step toward a more functional solution to the problem of ad hoc polymorphism: we depend less on types and more on functions. As you can see, this approach provides some interesting benefits.</p>
<h2>An ad-hoc polymorphism proposal for Kotlin</h2>
<p>When I reflected about this problem a while ago, it occurred to me that ad-hoc polymorphism has a lot in common with Kotlin’s extension functions: an extension function adds a function to a type outside of the definition of that type and ad-hoc polymorphism makes a type extend another type outside of the definition of that type. I came up with the concent of “Extension types” and I gave a quick overview of this idea <a href="https://discuss.kotlinlang.org/t/extension-types-for-kotlin/1390">in this article</a>. Extension types would allow us to make types retroactively implement other types with this made up syntax:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">// Not legal Kotlin</span>
<span class="hljs-keyword">override</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span>: <span class="hljs-type">Monoid</span>&#x3C;<span class="hljs-type">String</span>></span></code></pre>
<p>The rest of the interface would be implemented with extension functions, as demonstrated in the link above. The downside of this proposal is that it adds some form of implicit conversion, something that is at odds with Kotlin’s current design, so it’s probably unlikely this proposal will go past the stage of strawman but I thought it would be interesting to draw a parallel between extension functions and extension types.</p>
<h2>Does Kotlin really need ad-hoc polymorphism?</h2>
<p>The more I think about it, the more convinced I am that the value offered by ad-hoc polymorphism is very closely tied to the language you’re using it in. In other words, it’s not a universal tool but one that’s heavily dependent on how well supported it is in your language. Ad-hoc polymorphism is obviously a critical component of Haskell and it has given rise to high amounts of reuse and elegant abstractions in that language but I’m not sure Kotlin would benefit as much from it.</p>
<p>Another important aspect of deciding how useful ad-hoc polymorphism would be in a language is whether that language supports higher kinds (type families). Without higher kinds, your ability to abstract is limited, which lessens the value of ad-hoc polymorphism significantly. And since Kotlin doesn’t support higher kinds as of this writing, the importance of native support for ad-hoc polymorphism is questionable, or at least, certainly not as high a priority as other features.</p>
<p>At any rate, I have used the two techniques described above in my own code bases with reasonable benefit, so I hope they will be useful to others as well.</p>
]]></description><link>http://beust.com/weblog/2016/06/20/ad-hoc-polymorphism-in-kotlin/</link><guid isPermaLink="true">http://beust.com/weblog/2016/06/20/ad-hoc-polymorphism-in-kotlin/</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Cédric Beust]]></dc:creator><pubDate>Mon, 20 Jun 2016 08:47:00 GMT</pubDate></item><item><title><![CDATA[Kotlin null safety and its performance considerations -- part 1]]></title><description><![CDATA[<p><a href="http://kotlinlang.org">Kotlin</a> may seem like a new kid on the block – itʼs been officially released only in <a href="http://blog.jetbrains.com/kotlin/2016/02/kotlin-1-0-released-pragmatic-language-for-jvm-and-android/">February</a>. Its history however dates <a href="http://www.infoworld.com/article/2622405/java/jetbrains-readies-jvm-based-language.html">a few years back</a> and itʼs mature and stable enough to be used for developing solid reliable applications. Therefore at <a href="http://allegro.pl">Allegro</a> we decided to give it a chance – we built our new shiny server-side system using Kotlin as its primary language and we do not regret it.</p>
<p>One of the first features a Kotlin developer learns is the languageʼs approach to handling <code>null</code> values. It is quite interesting – especially at times like these when the most popular way of handling this problem is to use some kind of <a href="https://en.wikipedia.org/wiki/Option_type">Option monad</a>. As weʼll soon see Kotlin actually does not introduce any new special wrapper type – it uses regular Java types albeit with slight variance.</p>
<h2>Null-safe world</h2>
<p>In Kotlin when you declare a variable, a field or a function parameter, by default they cannot be <code>null</code>. For example letʼs suppose we have a class <code>Greeter</code> which has a function <code>hello</code> that by default prints a greeting message on the standard output:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Greeter</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hello</span><span class="hljs-params">(who: <span class="hljs-type">String</span>)</span></span>: <span class="hljs-built_in">Unit</span> {
    println (<span class="hljs-string">"Hello <span class="hljs-subst">$who</span>"</span>)
  }
}</code></pre>
<p>We declared <code>who</code> to be of type <code>String</code> which is interpreted by the compiler to mean that <code>who</code> cannot be <code>null</code>. If we want to declare a <em>nullable</em> parameter we have to add a question mark at the end of the type name:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Greeter</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hello</span><span class="hljs-params">(who: <span class="hljs-type">String</span>?)</span></span>: <span class="hljs-built_in">Unit</span> {
    println (<span class="hljs-string">"Hello <span class="hljs-subst">$who</span>"</span>)
  }
}</code></pre>
<p>This simple solution turns out to be very convenient and strong at the same time. It divides the world of our code into two areas: one where <code>null</code>s are allowed and one where they arenʼt. As weʼll see in a moment Kotlin provides quite a range of helpful features which makes the transition between those areas entirely safe. Yet we have to be aware of a few surprising issues.</p>
<p>To fully explore how Kotlin handles <code>null</code>s underneath weʼll take a closer look at the code generated by Kotlin compiler. Weʼll do it on two levels: first weʼll inspect the output bytecode – although for brevity weʼll actually see equivalent Java code. Then, in the second part of this article – for some interesting cases weʼll have a glance at the machine code generated by <a href="http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html#JITCompilers">JVM JIT compiler</a>.</p>
<h3>Smart casts</h3>
<p>Since Kotlin compiler knows the type of every variable, field, function parameter, etc. it can check if an incorrect assignment takes place and throw an error in such case. In the code below we try to assign a <em>nullable</em> reference to a <em>non-null</em> property:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> username: String = <span class="hljs-string">""</span>

  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setName</span><span class="hljs-params">(newName: <span class="hljs-type">String</span>?)</span></span> {
    username = newName <span class="hljs-comment">// the compiler will indicate an error here</span>
  }
}</code></pre>
<p>What if we wanted to check if the reference is not <code>null</code> and only then assign it to a property? The following code provides an answer:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> username: String = <span class="hljs-string">""</span>

  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setName</span><span class="hljs-params">(newName: <span class="hljs-type">String</span>?)</span></span> {
    <span class="hljs-keyword">if</span> (newName == <span class="hljs-literal">null</span>)
      <span class="hljs-keyword">throw</span> NullPointerException(<span class="hljs-string">"Name cannot be null!"</span>)

    username = newName <span class="hljs-comment">// here the compiler knows that newName cannot be null and therefore</span>
  }                    <span class="hljs-comment">// its type is String and not String?</span>
}</code></pre>
<p>This construct – where the compiler can infer that the reference cannot be <code>null</code> – is called smart casting as it seems to cast the reference from <code>String?</code> to <code>String</code>.</p>
<p>There is one thing we have to bear in mind when using smart casts. We can only do it with references that cannot be changed between the checkpoint and the actual assignment. In the code above the reference was taken from the function parameter which cannot change in the course of function execution. If we were to take the reference from some read/write property the compiler would not allow it:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserRequest</span> </span>{
  <span class="hljs-keyword">var</span> username: String? = <span class="hljs-literal">null</span>
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> username: String = <span class="hljs-string">""</span>

  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setNameFrom</span><span class="hljs-params">(request: <span class="hljs-type">UserRequest</span>)</span></span> {
    <span class="hljs-keyword">if</span> (request.username == <span class="hljs-literal">null</span>)
      <span class="hljs-keyword">throw</span> NullPointerException(<span class="hljs-string">"Name cannot be null!"</span>)

    username = request.username <span class="hljs-comment">// here the compiler cannot be sure that request.username</span>
  }                             <span class="hljs-comment">// is not null - it could change in some other thread</span>
}                               <span class="hljs-comment">// right after the condition check</span></code></pre>
<h3>The !! operator</h3>
<p>The code shown in the above example looks quite common. When we expect a reference to be not <code>null</code> and this assumption proves wrong we may want to throw <code>NullPointerException</code>. Kotlin has a special syntax for such cases:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> username: String = <span class="hljs-string">""</span>

  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setName</span><span class="hljs-params">(newName: <span class="hljs-type">String</span>?)</span></span> {
    username = newName!! <span class="hljs-comment">// the type of newName!! is String and the compiler generates a runtime check to be sure of that...</span>
  }
}</code></pre>
<p>The equivalent Java code as taken from the bytecode generated by the Kotlin compiler is as follows:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">import</span> org.jetbrains.annotations.Nullable;

<span class="hljs-keyword">import</span> static kotlin.jvm.<span class="hljs-keyword">internal</span>.Intrinsics.throwNpe;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{
  <span class="hljs-keyword">private</span> String username = <span class="hljs-string">""</span>;

  <span class="hljs-keyword">public</span> void setName(<span class="hljs-meta">@Nullable</span> newName: String) {
    <span class="hljs-keyword">if</span> (newName == <span class="hljs-literal">null</span>) {
      throwNpe();
    }

    username = newName;
  }
}</code></pre>
<p>We can see a couple of interesting things here:</p>
<ol>
<li>The <code>newName</code> parameter of the <code>setName</code> method gets an annotation indicating its <em>nullability</em>. This annotation is used internally by Kotlin compiler and <a href="https://www.jetbrains.com/idea/">IntelliJ IDEA</a>, although one can think of using it also in tools like <a href="http://findbugs.sourceforge.net/">FindBugs</a> or <a href="http://types.cs.washington.edu/checker-framework/current/checker-framework-manual.html#nullness-checker">Checker Framework</a>.</li>
<li>The code in <code>setName</code> has a striking resemblance (surprise!) to the code we wrote in our smart cast example. The only difference is the usage of the <code>throwNpe</code> method. Weʼll delve into the details in part 2 – for now we can make a simplification and state that it throws <code>KotlinNullPointerException</code> (which extends <code>NullPointerException</code>).</li>
</ol>
<h3>Parameter validation</h3>
<p>So far in our examples we didnʼt have methods which were not private and at the same time had non-<code>null</code> parameters. In order to gain some insight into what happens in such situations letʼs modify our code:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{
  <span class="hljs-keyword">var</span> username: String = <span class="hljs-string">""</span>

  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setName</span><span class="hljs-params">(newName: <span class="hljs-type">String</span>)</span></span> {
    username = newName
  }
}</code></pre>
<p>One obvious method that weʼd like to have a look at is the <code>setName</code> method. But the equivalent Java code contains a surprise:</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">import</span> org.jetbrains.annotations.NotNull;
<span class="hljs-keyword">import</span> org.jetbrains.annotations.Nullable;

<span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> kotlin.jvm.internal.Intrinsics.checkParameterIsNotNull;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{
  <span class="hljs-meta">@NotNull</span>
  <span class="hljs-keyword">private</span> String username = <span class="hljs-string">""</span>;

  <span class="hljs-meta">@NotNull</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUsername</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> username;
  }

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUsername</span><span class="hljs-params">(@NotNull String value)</span> </span>{
    checkParameterIsNotNull(value, <span class="hljs-string">"&#x3C;set-?>"</span>);

    username = value;
  }

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(@NotNull String newName)</span> </span>{
    checkParameterIsNotNull(value, <span class="hljs-string">"newName"</span>);

    username = value;
  }
}</code></pre>
<p>We can see that we now have two additional methods (<code>getUsername</code> and <code>setUsername</code>) and the <code>username</code> field earned a <code>@NotNull</code> annotation. Weʼre witnesses to how Kotlin compiler manages properties in classes:</p>
<ol>
<li>If it is <code>private</code> then a property is simply a field of the class with no special annotations – this is because this property is not visible anywhere outside the class and therefore Kotlin compiler can optimize access to it and it can be sure that the field will always be non-<code>null</code>.</li>
<li>If it is not <code>private</code> then a property is actually a field with a pair of setter and getter methods – this is because the property is visible to the outside world and Kotlin compiler must check upon every access that it is non-<code>null</code> and at the same time provide this information to this outside world.</li>
</ol>
<p>We can also observe that to check whether a value of a parameter is not <code>null</code> the <code>checkParameterIsNotNull</code> method is used. Again weʼll investigate this method in part 2. For now it is enough to say that upon receiving a <code>null</code> value an <code>IllegalArgumentException</code> will be thrown.</p>
<h3>Elvis operator</h3>
<p>When we have a <code>null</code> value there are situations when instead of throwing an exception weʼd rather do something else. We can compare this to a <code>default</code> block in Java <code>switch</code> statement. A simple <code>if</code> statement with an <code>else</code> should suffice here, but Kotlin has a special syntax for it – the famous <a href="https://en.wikipedia.org/wiki/Elvis_operator">Elvis operator</a>.</p>
<p>Letʼs suppose that for a <code>null</code> value weʼd like to set <code>username</code> to <code>"N/A"</code>:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> username: String = <span class="hljs-string">""</span>

  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setName</span><span class="hljs-params">(newName: <span class="hljs-type">String</span>?)</span></span> {
    username = newName ?: <span class="hljs-string">"N/A"</span>
  }
}</code></pre>
<p>The equivalent Java code is:</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">import</span> org.jetbrains.annotations.Nullable;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{
  <span class="hljs-keyword">private</span> String username = <span class="hljs-string">""</span>;

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(@Nullable String newName)</span> </span>{
    username = (newName != <span class="hljs-keyword">null</span>) ? newName : <span class="hljs-string">"N/A"</span>;
  }
}</code></pre>
<p>The Kotlin syntax is more concise and itʼs also worth mentioning that the expression after the Elvis operator is lazily evaluated and it can also throw an exception. So itʼs completely legal to have this kind of code:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> username: String = <span class="hljs-string">""</span>

  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setName</span><span class="hljs-params">(newName: <span class="hljs-type">String</span>?)</span></span> {
    username = newName ?: <span class="hljs-keyword">throw</span> RuntimeException(<span class="hljs-string">"Are you nuts?"</span>)
  }
}</code></pre>
<p>The equivalent Java code is:</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">import</span> org.jetbrains.annotations.Nullable;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{
  <span class="hljs-keyword">private</span> String username = <span class="hljs-string">""</span>;

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(@Nullable String newName)</span> </span>{
    <span class="hljs-keyword">if</span> (newName != <span class="hljs-keyword">null</span>)
      username = newName;
    <span class="hljs-keyword">else</span>
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"Are you nuts?"</span>);
  }
}</code></pre>
<h3>Safe calls and let/run/apply functions</h3>
<p>There are circumstances when we have a possibly <code>null</code> object and we want to invoke a method on it but only if it is actually non-<code>null</code> (because otherwise we would get <code>NullPointerException</code>). We can do it with simple <code>if</code>, but Kotlin provides a fancy <code>?.</code> operator to make the code more compact. So this code:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleUser</span></span>(<span class="hljs-keyword">var</span> name: String)

<span class="hljs-keyword">object</span> Users {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> userMap = mapOf(<span class="hljs-number">1</span> to SimpleUser(<span class="hljs-string">"John"</span>))

  <span class="hljs-meta">@JvmStatic</span>
  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getUser</span><span class="hljs-params">(userId: <span class="hljs-type">Int</span>)</span></span>: SimpleUser? = userMap[userId]
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getUserName</span><span class="hljs-params">(userId: <span class="hljs-type">Int</span>)</span></span>: String? =
        getUser (userId)?.name</code></pre>
<p>has the following equivalent Java code for <code>getUserName</code>:</p>
<pre><code class="hljs language-java"><span class="hljs-meta">@Nullable</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUserName</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId)</span> </span>{
  SimpleUser simpleUser = getUser(userId);
  <span class="hljs-keyword">return</span> simpleUser != <span class="hljs-keyword">null</span> ? simpleUser.getName() : <span class="hljs-keyword">null</span>;
}</code></pre>
<p>Kotlin code is indeed a lot shorter and more expressive. To further aid developers Kotlin provides three convenient <a href="https://kotlinlang.org/docs/reference/lambdas.html#higher-order-functions">higher-order functions</a>: <code>let</code>, <code>run</code> and <code>apply</code>. Although they are not directly related to <code>null</code>-safety issues we often use them with potentially <code>null</code> objects. Below you can find some code examples – they should give you an intuition about when and how to use them.</p>
<h4>let</h4>
<p>Letʼs look at the following code with <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/let.html"><code>let</code></a> (pardon the pun):</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">findUserNameWithLet</span><span class="hljs-params">(userId: <span class="hljs-type">Int</span>)</span></span>: String? =
    getUser (userId)?.let { it.name }</code></pre>
<p><code>let</code> is essentially an <a href="https://kotlinlang.org/docs/reference/extensions.html#extension-functions">extension function</a> (i.e. a method of a class which you can define outside of the class definition) that can be invoked on any type. It takes a <a href="https://kotlinlang.org/docs/reference/lambdas.html#lambda-expressions-and-anonymous-functions">lambda expression</a> as its parameter and calls the expression with <code>this</code> as an argument. If a <em>lambda expression</em> has only one parameter then we may skip declaring it and simply access the parameter via the name... <code>it</code>. Therefore in the example above <code>this</code> inside the lambda (<code>this</code> is of type <code>SimpleUser</code> – the type returned by the <code>getUser</code> method) is accessible as <code>it</code>. The value of the <em>lambda expression</em> is returned as the result of the <code>let</code> function.</p>
<p>The equivalent Java code for <code>findUserNameWithLet</code> is as follows:</p>
<pre><code class="hljs language-java"><span class="hljs-meta">@Nullable</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">findUserNameWithLet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId)</span> </span>{
  String result;

  SimpleUser simpleUser = getUser(userId);
  <span class="hljs-keyword">if</span> (simpleUser != <span class="hljs-keyword">null</span>) {
    SimpleUser it = simpleUser;

    result = it.getName(); <span class="hljs-comment">// { it.name }</span>
  } <span class="hljs-keyword">else</span> {
    result = <span class="hljs-keyword">null</span>;
  }

  <span class="hljs-keyword">return</span> result;
}</code></pre>
<p><code>let</code> is usually used if we want to perform some operations on a non-<code>null</code> object and return the result of these operations while simply returning <code>null</code> for <code>null</code> objects.</p>
<h4>run</h4>
<p>The <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/run.html"><code>run</code></a> function is a slight variation of <code>let</code>. It takes a parameterless <em>lambda expression</em> as its parameter and the object on which you invoke <code>run</code> can be accessed via <code>this</code> inside the <em>lambda expression</em>. Just like in <code>let</code> the result of the <em>lambda expression</em> is returned as the result of the <code>run</code> function.</p>
<p>Letʼs see an example:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">findUserNameWithRun</span><span class="hljs-params">(userId: <span class="hljs-type">Int</span>)</span></span>: String? =
    getUser (userId)?.run { name }</code></pre>
<p>and the equivalent Java code:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@Nullable</span>
<span class="hljs-keyword">public</span> String findUserNameWithRun(int userId) {
  String result;

  SimpleUser simpleUser = getUser(userId);
  <span class="hljs-keyword">if</span> (simpleUser != <span class="hljs-literal">null</span>) {
    SimpleUser $receiver = simpleUser;

    result = $receiver.getName(); <span class="hljs-comment">// { name }</span>
  } <span class="hljs-keyword">else</span> {
    result = <span class="hljs-literal">null</span>;
  }

  <span class="hljs-keyword">return</span> result;
}</code></pre>
<p>As we can see there is little difference with <code>let</code> – Kotlin code is similar although with <code>run</code> it is even more concise.</p>
<h4>apply</h4>
<p>The last of the three convenient functions weʼre going to talk about is <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/apply.html"><code>apply</code></a>. The following code illustrates its usage:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">findUserNameWithApply</span><span class="hljs-params">(userId: <span class="hljs-type">Int</span>)</span></span>: SimpleUser? =
      getUser (userId)?.apply { name = <span class="hljs-string">"Jane"</span> }
}</code></pre>
<p><code>apply</code> is similar to <code>run</code> – it is an <em>extension function</em> which takes a parameterless <em>lambda expression</em> as its parameter and the object on which you invoke <code>apply</code> can be accessed via <code>this</code> inside the <em>lambda expression</em>. However, the return value of <code>apply</code> is the object on which you invoke it (and not the <em>lambda expression</em> result).</p>
<p>The equivalent Java code for <code>findUserNameWithApply</code> is as follows:</p>
<pre><code class="hljs language-java"><span class="hljs-meta">@Nullable</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> SimpleUser <span class="hljs-title">findUserNameWithApply</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId)</span> </span>{
  SimpleUser result;

  SimpleUser simpleUser = getUser(userId);
  <span class="hljs-keyword">if</span> (simpleUser != <span class="hljs-keyword">null</span>) {
    SimpleUser $receiver = simpleUser;

    $receiver.setName(<span class="hljs-string">"Jane"</span>); <span class="hljs-comment">// { name = "Jane" }</span>

    result = simpleUser;
  } <span class="hljs-keyword">else</span> {
    result = <span class="hljs-keyword">null</span>;
  }

  <span class="hljs-keyword">return</span> result;
}</code></pre>
<p>The most common reason to use <code>apply</code> is the initialisation of an object. If there is something we have to do before returning an object (and simply return <code>null</code> if it is <code>null</code>) then <code>apply</code> is the way to go.</p>
<h3>Platform types</h3>
<p>So far we have not talked about the interoperability with Java. While from Java code point of view with regard to <code>null</code>-safety nothing unusual happens if we call Kotlin code, there is a difference when we want to call Java code from Kotlin. This is especially important for the case of the result returned from Java method where Kotlin compiler has to take some precautions. After all it does not know if the value returned can be <code>null</code> or not.</p>
<p>To resolve this problem Kotlin introduces the concept of <a href="https://kotlinlang.org/docs/reference/java-interop.html#null-safety-and-platform-types">platform types</a>. In essence <em>platform type</em> is used every time Kotlin compiler encounters an invocation of Java method which was not generated by Kotlin compiler. At the same time a developer cannot explicitly declare anything to be of <em>platform type</em> – it exists solely when Kotlin compiler infers it from the code.</p>
<p>Letʼs look at some code samples which present most of things you have to know about <em>platform types</em>:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">writeOutNullable</span><span class="hljs-params">(s: <span class="hljs-type">String</span>?)</span></span> = println(s)

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">nullableCase</span><span class="hljs-params">()</span></span> {
  <span class="hljs-keyword">val</span> value = System.getProperty(<span class="hljs-string">"key"</span>) <span class="hljs-comment">// value has a platform type String!</span>
  writeOutNullable(value)               <span class="hljs-comment">// The ! after a type indicates it's a platform type</span>
}</code></pre>
<p>The equivalent Java code is:</p>
<pre><code class="hljs language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nullableCase</span><span class="hljs-params">()</span> </span>{
  String value = System.getProperty(<span class="hljs-string">"key"</span>);
  writeOutNullable(value);
}</code></pre>
<p>We can see nothing special here – the <em>platform type</em> is taken as is when it is converted to a <em>nullable</em> type.</p>
<p>Letʼs see what happens when the target type is non-<code>null</code>:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">writeOut</span><span class="hljs-params">(s: <span class="hljs-type">String</span>)</span></span> {
  println(s)
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">nonNullCase</span><span class="hljs-params">()</span></span> {
  <span class="hljs-keyword">val</span> value = System.getProperty(<span class="hljs-string">"key"</span>) <span class="hljs-comment">// value has a platform type String!</span>

  writeOut(value)
}</code></pre>
<p>The equivalent Java code is:</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> kotlin.jvm.internal.Intrinsics.checkExpressionValueIsNotNull;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nonNullCase</span><span class="hljs-params">()</span> </span>{
  String value = System.getProperty(<span class="hljs-string">"key"</span>);

  checkExpressionValueIsNotNull(value, <span class="hljs-string">"value"</span>);
  writeOut(value);
}</code></pre>
<p>Now we have a validation in the generated code. <code>writeOut</code> expects a non-<code>null</code> type, but the <code>value</code> type is <em>platform type</em> and in theory it could be <code>null</code>. Therefore the compiler produces a runtime check with the help of <code>checkExpressionValueIsNotNull</code> method which weʼll explore in part 2.</p>
<p>Next example shows the code where only Java methods are used.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">pureJavaCase</span><span class="hljs-params">()</span></span> {
  <span class="hljs-keyword">val</span> value = System.getProperty(<span class="hljs-string">"key"</span>) <span class="hljs-comment">// value has a platform type String!</span>

  System.setProperty(<span class="hljs-string">"other_key"</span>, value)
}</code></pre>
<p>The equivalent Java code is:</p>
<pre><code class="hljs language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pureJavaCase</span><span class="hljs-params">()</span> </span>{
  String value = System.getProperty(<span class="hljs-string">"key"</span>);

  System.setProperty(<span class="hljs-string">"other_key"</span>, value);
}</code></pre>
<p>Just like when we had the <em>nullable</em> types no runtime check is generated. After all at no place in the code do we pass the value to the code which explicitly expects non-<code>null</code> values.</p>
<p>One might ask what happens after the value is checked not to be <code>null</code> – does the compiler treat it as a non-<code>null</code> value?</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doubleCheckCase</span><span class="hljs-params">()</span></span> {
  <span class="hljs-keyword">val</span> value = System.getProperty(<span class="hljs-string">"key"</span>) <span class="hljs-comment">// value has a platform type String!</span>

  writeOut(value)
  writeOut(value)
}</code></pre>
<p>The equivalent Java code is:</p>
<pre><code class="hljs language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doubleCheckCase</span><span class="hljs-params">()</span> </span>{
  String value = System.getProperty(<span class="hljs-string">"key"</span>);

  checkExpressionValueIsNotNull(value, <span class="hljs-string">"value"</span>);
  writeOut(value);
  checkExpressionValueIsNotNull(value, <span class="hljs-string">"value"</span>);
  writeOut(value);
}</code></pre>
<p>It appears it doesnʼt – the runtime checks are generated each time the conversion to non-<code>null</code> type takes place.</p>
<p>The following example shows assigning the value with <em>platform type</em> to some variable without explicitly stating this variable type:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">assignCase</span><span class="hljs-params">()</span></span> {
  <span class="hljs-keyword">val</span> value = System.getProperty(<span class="hljs-string">"key"</span>) <span class="hljs-comment">// value has a platform type String!</span>
  <span class="hljs-keyword">val</span> newValue = value <span class="hljs-comment">// newValue has a platform type String!</span>

  writeOut(newValue)
}</code></pre>
<p>The equivalent Java code is:</p>
<pre><code class="hljs language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">assignCase</span><span class="hljs-params">()</span> </span>{
  String value = System.getProperty(<span class="hljs-string">"key"</span>);
  String newValue = value;

  checkExpressionValueIsNotNull(newValue, <span class="hljs-string">"newValue"</span>);
  writeOut(newValue);
}</code></pre>
<p>No surprise here – the type of the variable <code>newValue</code> is also a <em>platform type</em> and runtime checks are generated.</p>
<p>What if we explicitly state the variableʼs type?</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">explicitCase</span><span class="hljs-params">()</span></span> {
  <span class="hljs-keyword">val</span> value = System.getProperty(<span class="hljs-string">"key"</span>) <span class="hljs-comment">// value has a platform type String!</span>

  <span class="hljs-keyword">val</span> nullableValue: String? = value
  writeOutNullable(nullableValue)

  <span class="hljs-keyword">val</span> nonNullValue: String = value
  writeOut(nonNullValue)
  writeOut(nonNullValue)
}</code></pre>
<p>The equivalent Java code is:</p>
<pre><code class="hljs language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">explicitCase</span><span class="hljs-params">()</span> </span>{
  String value = System.getProperty(<span class="hljs-string">"key"</span>);

  String nullableValue = value;
  writeOutNullable(nullableValue);

  checkExpressionValueIsNotNull(value)
  String nonNullValue = value;
  writeOut(nonNullValue);
  writeOut(nonNullValue);
}</code></pre>
<p>As we can see the rule is simple – every time we go from the <em>plaform type</em> to non-<code>null</code> type a runtime check is generated. Once weʼre in the <code>null</code>-safe world no additional validation is needed.</p>
<p>In the examples above weʼve seen that the <code>checkExpressionValueIsNotNull</code> method takes a variable name as the second parameter. This is done so that when a <code>null</code> value is passed youʼll see an error message with the name of the variable in it. But as the name of the method implies the second parameter does not have to be a variable name. In fact itʼs always an expression name, but in the cases presented above we had simple one-variable expressions. If we had a more complicated expression...:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">funnyCase</span><span class="hljs-params">()</span></span> {
  writeOut(System.getProperty(<span class="hljs-string">"key"</span>))
}</code></pre>
<p>The equivalent Java code is:</p>
<pre><code class="hljs language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">funnyCase</span><span class="hljs-params">()</span> </span>{
  String tmp = System.getProperty(<span class="hljs-string">"key"</span>);
  checkExpressionValueIsNotNull(tmp, <span class="hljs-string">"System.getProperty(\"key\")"</span>);
  writeOut(tmp);
}</code></pre>
<p>If we now call <code>funnyCase</code> (and there is no <code>"key"</code> system property set) then weʼll see the following stack trace:</p>
<pre><code>Exception in thread "main" java.lang.IllegalStateException: System.getProperty("key") must not be null
    at pl.kk.test.kotlin.PlatformTypesKt.funnyCase(PlatformTypes.kt:54)
    at pl.kk.test.kotlin.FunnyCaseCall.main(PlatformTypes.kt:60)
</code></pre>
<h3>Summary</h3>
<p>Weʼve taken a tour of different Kotlin language constructs where you could observe the code generated by the compiler. During regular development you rarely have to think about how things work under the hood. Nonetheless it is useful to know a thing or two about it. And if youʼre interested in the performance issues surrounding some of those constructs check out the second part of this article which will be soon published.</p>
]]></description><link>http://allegro.tech/2016/06/kotlin-null-safety-part1.html</link><guid isPermaLink="true">http://allegro.tech/2016/06/kotlin-null-safety-part1.html</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Konrad Kamiński]]></dc:creator><pubDate>Mon, 20 Jun 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[Kotlin Native]]></title><description><![CDATA[<h3>Kotlin Native</h3>
<p>A frequent question about Kotlin is if/when it will support compilation to native binaries that run without a JVM. Usually this takes the form of a more technical question like, “will the Kotlin compiler get an LLVM backend?”</p>
<p>I am not on the JetBrains team and I believe they’ve already made up their minds to do this, but I don’t personally think this feature would be the best way to solve the problems that are driving these questions.</p>
<p>Luckily, there are better ways that can. Kotlin doesn’t need an LLVM backend: the wider JVM community is producing all the needed puzzle pieces already. Someone just has to put them together.</p>
<h3>Why do people want native binaries?</h3>
<p>Here’s an entirely unscientific summary of the top reasons why people so often request a native backend for managed languages, based on conversations I’ve had over the years:</p>
<ol>
<li>They think the code would run faster or use less memory</li>
<li>They want better startup time</li>
<li>They think deploying programs that have only one file is simpler</li>
<li>They want to avoid garbage collection</li>
<li>They want to run on iOS, which forbids JIT compilers by policy</li>
<li>They want better native-code interop</li>
</ol>
<p>This list covers two of the three reasons cited by <a href="http://www.scala-native.org/">the Scala Native website</a> for why it exists. The other reason is that Scala Native is extending the language to support C++ like constructs that are normally forbidden by the JVM, like forced stack allocation, but building a better C++ is already being handled by Rust. I suspect that trying to convert Scala or Kotlin into C++/Rust competitors wouldn’t go well.</p>
<p>Sometimes people think a ‘native’ version of a managed language would fix problems that have nothing to do with compiler technology, like <a href="https://news.ycombinator.com/item?id=11226023">this guy</a> who believes it would change font rendering. I’ve seen ‘native’ become a mythical cure-all for any frustration or problem the user might have ... which isn’t surprising, given that most people have no experience with managed-to-native technologies.</p>
<h3>A ‘Kotlin Native’ would make slower code</h3>
<p>It is a common belief that code compiled by an ahead-of-time compiler must be faster or less memory hungry than just-in-time compiled code. I used to believe this too. It makes sense: C++ apps run fast, and C++ compilers are very slow. It stands to reason that the compilers are slow because they’re spending a lot of time optimising the code they’re producing. Surely, a compiler that can only grab a handful of spare cycles here and there whilst the app is running can never do such a good job?</p>
<p>Unfortunately, performance is subtle and often unintuitive. C++ compilers are slow mostly due to the #include and generics model the language uses, not due to optimisations. And a team at Oracle is adding ahead of time compilation to HotSpot. They gave a tech talk about it last year called “<a href="https://www.youtube.com/watch?v=Xybzyv8qbOc">Java goes AOT</a>”. Plain old AOT seems to give around 10%–20% slower code, depending on the kind of app (in the talk this is the difference between tiered and non-tiered). The reason is that virtual machines that support deoptimization, as the JVM does, can make speculative optimisations that aren’t always correct. Programs written in higher level languages benefit from this technique more, for instance Scala code benefits more than Java code does. The AOT compiler they’re using (Graal) isn’t weak or amateur: it’s competitive with GCC when compiling C code. It’s just that these advanced optimisations are really powerful.</p>
<p>It’s for this reason that the HotSpot AOT mode actually supports using a mix of AOT and JIT compiled code. The app can be compiled ahead of time so the interpreter isn’t used, but in a way that self-profiles. Then the JIT compiler is still invoked at runtime to recompile the hot spots, winning back most of the performance loss. You get a much less severe warmup period, whilst still obtaining the best peak performance.</p>
<p>Android has learned the same lesson. The replacement for Dalvik that was introduced in Marshmallow (ART) started out as a pure AOT compiler. In Android N, it will start using a mix of AOT and JIT compilation.</p>
<p>Additionally, the shortest path to a Kotlin-specific native compiler backend would be LLVM. LLVM is primarily used to compile C and C++. Many optimisations that can really help high level managed languages like Kotlin simply don’t apply to C++, so LLVM doesn’t implement them at all. That’d result in an even bigger speed hit.</p>
<blockquote>
<p><strong>Sidenote</strong>: the .NET virtual machine does not have an interpreter nor does it support speculative optimisations. It’s really just a regular compiler that happens to run the first time a method is called. This is why Microsoft has tended to be more interested in AOT compilation than the Java space has been: they never exploited the potential of JIT compilation, so they have less to lose from abandoning it.</p>
</blockquote>
<p>What about other forms of bloat, like memory usage, binary size and startup time?</p>
<p>Even those are complicated. Most of the memory usage of apps written in managed languages like Kotlin, Scala, Java, C# etc comes from their reliance on object identity, garbage collection, unicode strings and other things that native compilation doesn’t affect.</p>
<p>Worse, native CPU code is a lot larger than JVM bytecode. Larger code bloats downloads and uses more RAM, lowering cache utilisation. An AOT compiled “Hello World” Java app doesn’t start any faster than the regular interpreted version because even though the interpreter runs far fewer instructions per second than the CPU can, each instruction does a lot more and takes much less space in memory. Runtime of a hello world app is only about 80 milliseconds anyway, which is a relevant cost only if you’re making tiny tools for a UNIX shell.</p>
<p>And whilst hauling around a couple of JIT compilers and three garbage collectors adds bloat, that’s not inherent to using a virtual machine rather than compiling to native. It’s just that HotSpot is a one-size-fits-all program that is designed to run on everything from laptops to giant servers. You can make much smaller virtual machines if you’re willing to specialise.</p>
<h3>Enter Avian</h3>
<blockquote>
<p>“Avian is a lightweight virtual machine and class library designed to provide a useful subset of Java’s features, suitable for building self-contained applications.”</p>
</blockquote>
<p>So says <a href="https://readytalk.github.io/avian/">the website</a>. They aren’t joking. The example app demos use of the native UI toolkit on Windows, MacOS X or Linux. It’s not a trivial Hello World app at all, yet it’s a standalone self-contained binary that clocks in at only one megabyte. In contrast, “Hello World” in Go generates a binary that is 1.1mb in size, despite doing much less.</p>
<p>Avian can get these tiny sizes because it’s fully focused on doing so: it implements optimisations and features the standard HotSpot JVM lacks, like the use of LZMA compression and ProGuard to strip the standard libraries. Yet it still provides a garbage collector and a JIT compiler.</p>
<p>For people who want to use Kotlin to write small, self contained command line apps of the kind Go is sometimes used for, a much simpler and better solution than an LLVM backend would be to make a fully integrated Avian/Kotlin combination. Avian is hard to use right now — you’re expected to be familiar with native-world tools like GCC and make. Making a one-click JetBrains style GUI would yield programs that <em>look</em> to the user like they were AOT compiled: they’re single executables that only require the base OS. And using SWT you can build GUIs that look native on every platform because under the hood they <em>are</em> native. But you wouldn’t need to abandon the benefits of JIT compilation or garbage collection.</p>
<h3>Losing garbage collection</h3>
<p>Sometimes the people requesting a native backend want it because they want to avoid GC, and associate “native” with “not garbage collected”. There is no connection between these things: you can have garbage collected C++ and you can do manual memory management in Java (and some high performance libraries do).</p>
<p>The problem with extensively mixing techniques is that it forks the language. A library that assumes garbage collection cannot be used without a collector and likewise, a library that expects manual management becomes a lot harder to use from code that expects a GC. You’d have to introduce smart pointers and other C++ like constructs to the language to make it really convenient.</p>
<p>I wouldn’t like to see Kotlin splinter into two different languages, Kotlin-GC and Kotlin-Manual. That would hurt the community and ecosystem for questionable benefits.</p>
<p>And the benefits <em>are</em> questionable. Many devs who think they can’t tolerate GC are basing their opinions on old/crappy GCs in mobile phones or (worse) web browsers. This impression is heightened by the fact that some well known garbage collected apps are written by people who just don’t seem to care about performance at all, like Minecraft or Eclipse, leading people to blame GC for what is in reality just badly written code. But there are counterexamples that show it doesn’t have to be this way: Unreal Engine is written in C++ and has used a core garbage collected game heap since version 3. It powers many of the worlds AAA titles. They can hit 60 frames per second and they are using a very basic GC. Tim Sweeney’s secret is that he cares about performance and productivity simultaneously. If they can do it, so can you.</p>
<h3>iOS and native code interop</h3>
<p>The final reasons people want a native compiler backend are iOS support and to make native code interop easier.</p>
<p>iOS is a good reason. That platform bans JIT compilers because it helps Apple enforce their incredibly rigid policies. But doing a native backend at the language level is the wrong approach. RoboVM is a project that built a JVM bytecode to ARM AOT compiler, and although RoboVM is now a dead project due to being acquired by Microsoft, old versions of its code are still available under an open source license. It works for any JVM language and doesn’t really suffer from this generality: a Scala or Kotlin specific ARM compiler wouldn’t do much different.</p>
<p>But that’s probably not the long term direction the JVM platform will go in for iOS. As HotSpot itself is getting support for AOT compilation, and HotSpot has an ARM backend too, and there’s an official OpenJDK mobile project that’s already made an iOS (interpreter only) mobile version, it would make sense for them to plug these things together and end up with a mode in which HotSpot can generate AOT iOS binaries too. I wouldn’t be surprised to see something like this announced between Java 9 and 10.</p>
<p>The final reason is native code interop. If you compile to native, so the reasoning goes, it’ll be easier to use C/C++ libraries like the ones your operating system provides.</p>
<p>But the existence of projects like JNA seem to disprove this — you can have convenient interop without generating native code yourself. And there are some exciting techniques for working with native libraries coming up:</p>
<ul>
<li>The OpenJDK Panama project is adding support for things like inline assembly, pointers and struct layouts directly to Java and HotSpot. Yes, if you check out the Panama branch of the hotspot repository you can actually define assembly snippets in Java and they’ll be inlined directly into usage sites, just like an <strong>asm</strong> block in C would. Panama also provides a clang-based tool that parses C/C++ headers and auto generates the equivalent Java declarations. All this should be automatically available to Kotlin and Scala users too.</li>
<li>The Graal/Truffle research projects are creating <a href="http://github.com/graalvm/sulong/">Sulong</a>, which is a way to JIT compile LLVM bitcode on top of the JVM. There is a simple C API that exists when code is run on top of Sulong that allows for near zero-overhead interop with managed code.</li>
</ul>
<h3>Conclusion</h3>
<p>Kotlin doesn’t need an LLVM backend, and by extension I believe neither does Scala. Creating such a thing would be a huge and ongoing drain of manpower, take a long time, and end up duplicating work already being done elsewhere in the JVM ecosystem ... very likely with worse results.</p>
<p>Instead, I think the right direction for the community to go is:</p>
<ol>
<li>Building a simple IntelliJ plugin that uses Avian to spit out tiny, self contained binaries, for when weight is more important than features. This would present some strong competition to Go in the command line tools space.</li>
<li>Using the AOT mode being added to HotSpot to eliminate warmup times and (hopefully) support iOS, for times when AOT compilation really is the only solution.</li>
<li>Waiting for JVM upgrades to reduce memory usage, support better native interop and so on. Don’t try to duplicate these efforts at the language level.</li>
<li>Educating the developer community about how to write high performance garbage collected apps <em>outside</em> of the server context.</li>
</ol>
<p>This approach isn’t flawless: the AOT mode being added to HotSpot is planned to be a commercial feature, and big upgrades like Panama are long term projects. But adding an LLVM backend to the Kotlin or Scala compilers would be a long term project too, it’d mean sacrificing other features that might be more useful, and it would likely never close the performance gap.</p>
<p>As always in engineering, there are no solutions — only trade offs. I’d rather have more features in the core Kotlin language/tooling than a native backend, and let other teams tackle the varying challenges involved.</p>
]]></description><link>https://medium.com/@octskyward/kotlin-native-310ffac94af2#.3oep6gxpa</link><guid isPermaLink="true">https://medium.com/@octskyward/kotlin-native-310ffac94af2#.3oep6gxpa</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Mike Hearn]]></dc:creator><pubDate>Fri, 17 Jun 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[Kotlin Night in San Francisco Recordings]]></title><description><![CDATA[<p>On May 17th we held an evening event at San Francisco in cooperation with Realm and Netflix. Thanks to everyone who joined us this evening! There were great talks and important announcements, and the good news is that all of them were recorded:</p>
<h2>Talk #1: Andrey Breslav. <strong>Where We Stand and What’s Next</strong></h2>
<p>Kotlin project lead Andrey Breslav gave an overview of what Kotlin is today and took a peek into the near future: what the Kotlin team is planning for the next release.</p>
<iframe src="https://www.youtube.com/embed/POZmfjRHdfE" allowfullscreen="" frameborder="0" height="480" width="960"></iframe>
<iframe webkitallowfullscreen="true" mozallowfullscreen="true" allowfullscreen="true" src="//speakerdeck.com/player/f1dea41f659a4c70a6e8fb20291b871b?" style="border: 0px none; background: transparent none repeat scroll 0% 0%; margin: 0px; padding: 0px; border-radius: 5px; width: 960px; height: 480px;" class="speakerdeck-iframe" frameborder="0"></iframe>
<h2>Bonus Talk by Hans Dockter. <strong>Gradle goes Kotlin</strong></h2>
<p>Hans Dockter, CEO of Gradle demoed the first milestone of writing a Gradle build script using Kotlin.</p>
<iframe src="https://www.youtube.com/embed/4gmanjWNZ8E" allowfullscreen="" frameborder="0" height="480" width="960"></iframe>
<h2>Talk #2: Jake Wharton. <strong>Instrumentation Testing Robots</strong></h2>
<p>Libraries like Espresso allow UI tests to have stable interactions with your app, but without discipline these tests can become hard to manage and require frequent updating. In this talk Jake covered how the so-called robot pattern allows you to create stable, readable, and maintainable tests with the aid of Kotlin’s language features.</p>
<p>See the full recording along with transcribing on <a href="https://realm.io/news/kau-jake-wharton-testing-robots/">realm.io</a></p>
<h2>Talk #3: Laura Kogler &#x26; Rob Fletcher. <strong>Kotlin Testing</strong></h2>
<p>Spek framework contributor Laura and Spock maintainer Rob demonstrated the current state of Kotlin testing frameworks and discussed expected further advancements in testing support.</p>
<p>Part1:</p>
<iframe src="https://www.youtube.com/embed/pCg3P7AOtHo" allowfullscreen="" frameborder="0" height="480" width="960"></iframe>
<iframe webkitallowfullscreen="true" mozallowfullscreen="true" allowfullscreen="true" src="//speakerdeck.com/player/4bfe84ca3f6f45979f2bd1d67fb2d12b?" style="border: 0px none; background: transparent none repeat scroll 0% 0%; margin: 0px; padding: 0px; border-radius: 5px; width: 960px; height: 480px;" class="speakerdeck-iframe" frameborder="0"></iframe>
<p>Part2:</p>
<iframe src="https://www.youtube.com/embed/y5U8uiI2S0I" allowfullscreen="" frameborder="0" height="480" width="960"></iframe>
<iframe src="//www.slideshare.net/slideshow/embed_code/key/9ZqOCfx8zmnOXZ" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen="" frameborder="0" height="480" width="960"></iframe>
<p>Thanks all participants and speakers for great atmosphere and engaging discussions. Here are several photos from the event:
<img src="https://i2.wp.com/blog.jetbrains.com/kotlin/files/2016/06/IMG_0109-1.jpg?zoom=1.5&#x26;resize=370%252C278&#x26;ssl=1" alt="Swag">
<img src="https://i2.wp.com/blog.jetbrains.com/kotlin/files/2016/06/IMG_0114-1.jpg?zoom=1.5&#x26;resize=370%252C278&#x26;ssl=1" alt="Community">
<img src="https://i1.wp.com/blog.jetbrains.com/kotlin/files/2016/06/IMG_0129-1.jpg?zoom=1.5&#x26;resize=370%252C278&#x26;ssl=1" alt="Hans">
<img src="https://i1.wp.com/blog.jetbrains.com/kotlin/files/2016/06/IMG_0150-1.jpg?zoom=1.5&#x26;resize=370%252C278&#x26;ssl=1" alt="Kotlin&#x26;Gradle"></p>
<p><strong>See you on next K•NIGHT!</strong>  </p>
]]></description><link>https://blog.jetbrains.com/kotlin/2016/06/kotlin-night-recordings/</link><guid isPermaLink="true">https://blog.jetbrains.com/kotlin/2016/06/kotlin-night-recordings/</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[K.Night]]></category><dc:creator><![CDATA[Roman Belov]]></dc:creator><pubDate>Tue, 14 Jun 2016 15:32:00 GMT</pubDate></item><item><title><![CDATA[News from KotlinTest]]></title><description><![CDATA[<p>In the last weeks <a href="https://github.com/kotlintest/kotlintest">KotlinTest</a> got some new and useful features:</p>
<h2>Testing for Exceptions</h2>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> exception = shouldThrow&#x3C;IllegalAccessException> {
  <span class="hljs-comment">// code in here that you expect to throw an IllegalAccessException</span>
}
exception.message should start with <span class="hljs-string">"Something went wrong"</span></code></pre>
<h2>Before and after each</h2>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">beforeEach</span><span class="hljs-params">()</span></span> {
  println(<span class="hljs-string">"Test starting"</span>)
}

<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">afterEach</span><span class="hljs-params">()</span></span> {
  println(<span class="hljs-string">"Test completed"</span>)
}</code></pre>
<h2>Test configuration</h2>
<p>Each test case can followed by a call to the <code>config</code> function.</p>
<p>To execute a test two times with two threads you would write:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTests</span> : <span class="hljs-type">ShouldSpec</span></span>() {
  init {

    should(<span class="hljs-string">"return the length of the string"</span>) {
      <span class="hljs-string">"sammy"</span>.length shouldBe <span class="hljs-number">5</span>
      <span class="hljs-string">""</span>.length shouldBe <span class="hljs-number">0</span>
    }.config(invocations = <span class="hljs-number">10</span>, threads = <span class="hljs-number">2</span>)

  }
}</code></pre>
<p>You can tag tests to be able run them selectively:</p>
<pre><code class="hljs language-kotlin">...
}.config(tags = listOf(<span class="hljs-string">"database"</span>, <span class="hljs-string">"linux"</span>))</code></pre>
<p>Timeouts are configured like this:</p>
<pre><code class="hljs language-kotlin">...
}.config(timeout = <span class="hljs-number">2</span>, timeoutUnit = TimeUnit.SECONDS)</code></pre>
<p>To ignore a test, you set <code>ignored</code> to true:</p>
<pre><code class="hljs language-kotlin">...
}.config(ignored = <span class="hljs-literal">true</span>)</code></pre>
<h2>Future</h2>
<p>Some more features like property based (and table driven) testing are on the roadmap.</p>
]]></description><link>https://discuss.kotlinlang.org/t/news-from-kotlintest/1797</link><guid isPermaLink="true">https://discuss.kotlinlang.org/t/news-from-kotlintest/1797</guid><category><![CDATA[Testing]]></category><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[medium]]></dc:creator><pubDate>Tue, 14 Jun 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[Meet the Kotlin Team at Gradle Summit]]></title><description><![CDATA[<p>You’ve probably heard the news announcing that you’ll soon be able to <a href="https://blog.jetbrains.com/kotlin/2016/05/gradle-meets-kotlin/">write your Gradle build scripts and plugins in Kotlin</a>. At the Kotlin Night in San Francisco, Hans Dockter from Gradle demoed the first prototype of the support. After the initial announcement, we’ve continued our work together with the Gradle team to flesh out the prototype and bring it closer to the release. And next week, at the <a href="https://gradlesummit.com/">Gradle Summit in Palo Alto</a>, we’ll be sharing the details on our progress.</p>
<p>In addition to presentations by Gradle developers and users, you’ll see <a href="https://gradlesummit.com/schedule/kotlin">the keynote by Dmitry Jemerov from the Kotlin team</a>, talking about the DSL support features of Kotlin and their use in the Gradle build script DSL. And in the expo area, you’ll be able to chat with developers working on Kotlin, IntelliJ IDEA and TeamCity, who will help you with any questions related to the use of Gradle together with JetBrains products.</p>
<p>The summit will be on June 23-24th in Palo Alto, California, and <a href="https://info.gradlesummit.com/conference/palo_alto/2016/06/register">the registration is open</a>. Looking forward to seeing you there!</p>
]]></description><link>https://blog.jetbrains.com/kotlin/2016/06/meet-the-kotlin-team-at-gradle-summit/</link><guid isPermaLink="true">https://blog.jetbrains.com/kotlin/2016/06/meet-the-kotlin-team-at-gradle-summit/</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Gradle]]></category><dc:creator><![CDATA[Dmitry Jemerov]]></dc:creator><pubDate>Mon, 13 Jun 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[Архитектор Kotlin: «Язык программирования — рабочий инструмент. Если никогда их не менять, можно отстать от жизни» ]]></title><description><![CDATA[<p>В феврале 2016-го, после шести лет разработки, компания JetBrains выпустила в релиз версию 1.0 статически типизированного языка программирования <a href="https://kotlinlang.org/">Kotlin</a>. Его авторы ставили целью создать язык «более лаконичный и типобезопасный, чем Java, и более простой, чем Scala». О том, что из этого вышло, а также о моде на языки программирования, конкуренции между ними, перспективах и «серебряной пуле» в интервью dev.by рассказал руководитель разработки проекта Kotlin в JetBrains​ <strong>Андрей Бреслав</strong>.   </p>
<p><img src="https://dev.by/ckeditor_assets/pictures/20014/content_breslav.jpg"></p>
<h1>О Kotlin и о конкуренции</h1>
<p><strong>— Первому релизу Kotlin предшествовали шесть лет разработки. Получилось ли у вас то, к чему стремились?</strong></p>
<p><strong>—</strong> В разные моменты мы стремились к разным вещам, но большая часть из того, что сейчас мы считаем правильными целями, состоялась. Мы хотели сделать удобный язык для разработчиков с широким кругом задач — получилось. Мы хотели сделать язык, который будет нравиться людям и сделает их жизнь заметно лучше — результатом мы довольны. Цели в процессе менялись: менялись приоритеты, появлялись новые внешние обстоятельства — конкуренты, новые платформы. Например, Android, о котором мы изначально не думали, стал для нас очень интересной и важной платформой, и сейчас мы получаем аудиторию в среде Android-разработчиков. Мы придумали компилироваться в JavaScript — сразу такой мысли не было, а сейчас понятно, что это тоже очень полезное направление.</p>
<p><strong>— Кстати, о конкурентах. За последние 10-15 лет языков под JVM развелось много, и многие на слуху: Groovy, Gosu, Ceylon. Почему этих разработок так много? Почему не удаётся сконцентрироваться на какой-то одной, особенно в случаях, когда цели схожи?</strong></p>
<p>— Языков программирования вообще появляется много, и поиск в этом поле бесконечен.</p>
<blockquote>
<p>Создать новый язык — одна из немногих задач системного программирования, относительно несложная, с интересной «математикой». Написать базу данных или операционную систему куда сложнее, поэтому это делают не так часто.</p>
</blockquote>
<p>Многие языки возникают, чтобы заполнить новые или пустующие ниши. Например, Gosu изначально создавался для внуренних конфигурационных скриптов, то есть как язык внутри конкретного продукта компании Guidewire, и только потом отделился и стал более самостоятельным. Groovy — одна из первых успешных попыток сделать динамически типизированный язык специально для JVM, и в какой-то момент он стал новым словом в этом направлении.</p>
<p><strong>— Многие ли идеи конкурентов перекочевали в Kotlin?</strong></p>
<p>— Мы использовали всё полезное, что нашли у других: цели придумывать всё с нуля не было. Из названных языков по задачам мы пересекаемся с Ceylon, но общий набор требований у нас другой. Большой упор в Kotlin — на взаимодействие с существующим кодом, так называемый interop с Java, а создатели Ceylon от этой идеи отказались. Они запускаются на JVM, но при этом полностью переписывают стандартную библиотеку: вместо классов из JDK используется их собственная SDK. Это сильно меняет дело: подмешать немножечко Ceylon в существующий проект на Java — большая проблема просто потому, что язык создан не для этого, а для того, чтобы на нём с нуля разрабатывать красивые проекты. А Kotlin хорошо подходит для уже существующих проектов.</p>
<p><strong>— Создание обратной совместимости с Java и стало самой сложной частью проекта?</strong></p>
<p>— Да, это, пожалуй, принесло больше всего головной боли. По пути мы перебрали четыре основных схемы взаимодействия с библиотеками Java. Первая была очень консервативной: мы считали, что код на Java очень небезопасен, и в Kotlin нужно проверять всё, что можно. Оказалось, что это очень неудобно. Потом мы пытались аннотировать Java-библиотеки, чтобы внести в код на Java дополнительную типовую информацию и её использовать — это решение оказалось слишком хрупким. Закончили мы тем, что создали концепцию платформенных типов, у меня есть <a href="http://medianetwork.oracle.com/video/player/1785452087001">целый доклад о ней</a> на JVM Language Summit. Модель достаточно сложна и оригинальна, но на практике она работает хорошо.</p>
<p><strong>— Вернёмся к релизу. Первый фидбек уже собран? Что понравилось пользователям?</strong></p>
<p>— Разным людям — разные вещи. Очень многим нравится, что программы становятся короткими и понятными, что компилятор ловит ошибки, которые другие компиляторы не поймали бы.</p>
<blockquote>
<p>На Kotlin удаётся и прозрачно использовать существующие библиотеки, и писать хорошие новые — а это значит, что можно добавлять немножко кода на Kotlin в существующий проект и ничего не бояться. Есть и узкоспециализированные вещи: пользователям на Android, например, нравится, что у нас маленькая стандартная библиотека.</p>
</blockquote>
<h1>Как и почему возникает мода на языки</h1>
<p><strong>— Появились ли в последние лет 10-15 языки, которые уже стали поворотными для сферы или могут ими стать?</strong></p>
<p>— Есть такое образное выражение: «Язык превратился в COBOL». Казалось бы, COBOL — старый язык, который должны давно забыть, но в реальности на нём работает ещё очень много систем, особенно в финансовой сфере. Мы наверняка пишем на Java больше новых проектов, чем на COBOL, но при этом я не брался бы утверждать, что мы пишем больше кода на Java в целом :).</p>
<blockquote>
<p>Я к тому, что судьбоносными становятся те языки, которые в какой-то момент были популярны — на них пишут много больших систем, которые потом нужно поддерживать, и от них никуда не денешься.</p>
</blockquote>
<p>В своё время C в этом смысле совершил революцию, Java тоже стала судьбоносным языком. Из более новых языков не смогу назвать ни одного —  наверное, прошло недостаточно много времени, чтобы они могли набрать такую популярность. Но в любом случае, очень успешные языки были. На JVM это Scala и Groovy, на которых крупные компании написали уже немало кода. Вне JVM в своё время имел огромный успех Ruby, на нём писали крупные web-проекты; потом случился кризис роста, люди стали отказываться от Ruby, но этот язык так или иначе серьёзно повлиял на восприятие динамических языков программирования.</p>
<p>Очень большое влияние на направление мысли оказывают функциональные языки. С одной стороны, это языки семейства Lisp-Scheme и всё, что рядом с ним. На JVM есть Clojure, который воплощает те же идеи. С другой стороны — Haskell и другие языки семейства ML. Думаю, что хорошо закрепится Swift, поскольку Apple переводит на него разработчиков для своих платформ, а платформа — вещь такая, что с ней не поспоришь. Раз велено писать на Swift под устройства Apple, значит, все будут писать на Swift — а язык очень хороший, поэтому никакого сопротивления я не ожидаю.</p>
<p><strong>— Как вы считаете, стоит ли гнаться за модой на языки?</strong></p>
<p>— Есть люди, которые получают удовольствие от того, что пробуют новые языки и технологии — им, безусловно, стоит пробовать. А есть те, у которых нет на это времени — им есть смысл подождать, пока более резвые коллеги разберутся, какой из конкурирующих языков лучше, и уже постфактум выбирать язык для себя.</p>
<blockquote>
<p>В принципе, язык программирования — это только рабочий инструмент. Менять его слишком часто не нужно — не будет полноты овладения инструментом. Но если не менять инструменты совсем, можно отстать от жизни.</p>
</blockquote>
<p>Здесь нужен баланс. Важно правильно выбирать инструмент по задаче. Когда мы меняем сферу деятельности или переходим к работе в другой области, или просто устали от проблем с тем, что используем сейчас, то есть смысл рассмотреть новые инструменты, понять, не сделают ли они нашу работу принципиально лучше.</p>
<p><strong>— Тот же Ruby, да и Swift тоже, частенько называют «хипстерскими языками». Почему они стали такими модными?</strong></p>
<p>— Элемент моды возникает там, где пишутся короткие маленькие проекты. Люди начинают новый проект каждые три месяца и могут себе позволить очередной из них написать на Ruby или на новомодной технологии на базе JavaScript. Естественно, этот эффект хайпа недолговечен, как и любая мода. В мире клиентской разработки это видно особенно ярко: фреймворки и системы программирования на JavaScript сменяют одна другую со страшной скоростью. Мы даже испытываем некоторые сложности из-за этого при разработке Kotlin, потому что при компиляции в JavaScript нам нужно поддерживать какие-то популярные технологии, а их каждый день появляется очень много, и за всем очень сложно уследить. Для Swift всё сказанное тоже частично релевантно, но у этого языка принципиально другая судьба: это стандартное решение, которое поставляется вместе с платформой, и его выбирают не из-за моды.</p>
<p><strong>— Есть ли, по-вашему, критерии, по которым язык может «выстрелить»?</strong></p>
<p>— Возвращаясь к сказанному, самый надёжный способ «выстрелить» — быть языком, привязанным к платформе. В своё время C широко распространился, потому что он был языком для платформы Unix, которая была популярной и очень удобной. Java тоже в распространялась как платформа, и язык был её частью. То же касается C#: пускай это и не единственный, но основной язык для платформы .NET. Опять же, есть JavaScript, который популярен не потому, что он хороший или плохой, а потому, что это язык для браузера, браузер нужен всем.</p>
<p>Дать надежный рецепт «Как сделать язык, который станет популярным», я не могу, но есть и другие понятные причины, по которым языки становятся популярными.</p>
<p>Есть языки, которые распространяются по идеологическим моделям — например, Haskell или в какой-то степени Python. Но идеология — это скорее способ сформировать комьюнити, а не удержать его. Тот же Python — это просто хороший язык для многих задач. А вот кто победит из нескольких конкурирующих языков, которые не являются частью платформы и не являются идеологической революцией — как Kotlin, например, — решает рынок.</p>
<blockquote>
<p>Попадание во время и потребности пользователей, правильная маркетинговая работа, своевременный отзыв от ярких представителей сообщества — это все очень важно, но на популярность влияет ещё целая куча разных вещей, которые трудно предсказывать.</p>
</blockquote>
<p><img src="https://dev.by/ckeditor_assets/pictures/20015/content_breslav2.jpg"></p>
<h1>Прилетит ли «серебряная пуля»?</h1>
<p><strong>— В каком направлении сейчас меняются языки программирования?</strong></p>
<p>— Есть выраженная тенденция включения в мейнстримовые языки возможностей, изначально придуманных в мире функционального программирования. Наибольшую популярность получили функции высших порядков и лямбда-выражения.</p>
<p>Ещё одна популярная вещь, которая пришла из функционального мира — неизменяемые данные. Здесь есть вполне понятная причина: многоядерные процессоры, которые не так давно произвели революцию на рынке аппаратных средств, а вместе с собой принесли много так называемого «конкурентного программирования», когда программа выполняется в нескольких параллельных нитях. Разделяемые между разными потоками изменяемые данные ведут себя плохо, ошибки отслеживать очень сложно, а чтобы этих ошибок не делать, нужно очень многое держать в голове. В функциональных языках программирования мутирующие операции изначально не в чести, и сейчас эта идея неизменяемых данных становится всё популярнее, поскольку пользоваться ими гораздо проще и надёжнее.</p>
<p><strong>— Чего, на ваш взгляд, современным языкам не хватает? Что в них «ещё не пришло» из того, что уже, казалось бы, должно?</strong></p>
<p>— Про языки мне сложно ответить: если бы знал, чего не хватает, уже добавил бы! Мне кажется, что основные болезненные места на сегодня связаны, как я отмечал выше, с многопоточностью. А там главная сложность в том, что никто не знает хорошей модели для многопоточного программирования. Сама эта идея — независимые нитки исполнения, имеющие общую память — несколько противоестественная, и порождает тяжкие ухищрения на аппаратном уровне. Процессор, синхронизируя кеши между ядрами, фактически реализует message passing, но мы притворяемся, что этого нет, и на самом деле у нас разделяемая память. Но чтобы как-то совладать с многопоточным программированием, мы стараемся поменьше пользоваться разделяемой памятью, и программно реализуем поверх неё — снова message passing!</p>
<p>Так получилось исторически: новые процессоры эмулируют поведение старых для совместимости, поэтому сменить парадигму радикально очень сложно. И это отражается на программировании, конечно. Если бы железо могло быть гибче, программирование тоже было бы другим, я думаю. Но мы все в этом смысле связаны во многом всё той же совместимостью. Можно сделать всё очень здорово — и процессор и языки, но только программ и библиотек под это все никаких не будет, и пользователи останутся на традиционных платформах...</p>
<p><strong>— У программистов есть давняя мечта о «серебряной пуле» — одном языке, который удовлетворил бы большинство или даже всех. Возможно ли его появление?</strong></p>
<p>— Думаю, в обозримое время ни один язык не победит. Есть искусственные ситуации, в которых можно писать только на одном языке: например, в случае с клиентским вебом. Основным языком браузера был и остаётся JavaScript, и не очень понятно, может ли это измениться. А в остальных случаях, когда есть свобода выбора, я не вижу никаких предпосылок к появлению универсальной идеи, которая бы всех примирила. Слишком уж много противоречивых требований.</p>
<h1>Надо ли уметь программировать каждому школьнику</h1>
<p><strong>— Программирование становится всё более популярным. Сложится ли так, что через какое-то время программировать должен будет уметь каждый?</strong></p>
<p>— Не думаю, что такое должно произойти. У людей есть автоматически не приобретаемые навыки, которые нужны всем. Например, писать на родном языке или считать. А вот зачем всем на свете нужно будет программировать, я себе представить не могу. Непрограммисты иногда пишут программы, но, как правило, этим всё же занимаются профессионалы. Например, инженеры, которые работают с численными моделями и используют специализированные языки программирования для математического моделирования. Или люди, которые пользуются сложными офисными программами — внутри того же Microsoft Office есть язык программирования Visual Basic for Applications, на котором часто пишут достаточно сложные вещи.</p>
<p>Если человек по роду деятельности никак не связан с таким набором задач, то зачем ему программировать? Многие считают, что раз компьютеры — передний край прогресса, значит, все должны разбираться в компьютерах. Когда квантовая физика казалась передним краем прогресса, многие думали, что все будут очень «квантово» жить, но на самом деле никто не будет жить более «квантово», чем живёт сейчас, по-моему.</p>
<p><strong>— Тем не менее, пока число программистов растёт, и количество запросов на программы тоже растёт.</strong></p>
<p>— И в ближайшее время этот рост никуда не денется хотя бы из-за того, что правительство Китая изменяет экономический курс. Насколько я понимаю, количество программистов в Китае должно резко увеличиться в ближайшие годы, и для мирового рынка программистов это будет весьма заметный рост. Означает ли это, что в других странах количество рабочих мест для программистов замедлит рост или начнёт падать — хороший вопрос.</p>
<p><strong>— Стоит ли тогда, на ваш взгляд, преподавать программирование в школе?</strong></p>
<p>— Я сам восемь лет преподавал программирование в физико-математической школе, и мне кажется, что это столь же разумно, как и преподавание математики или физики. Другой вопрос — содержание курса. Как правильно преподавать программирование в школе без специализации или с гуманитарным уклоном, я не знаю, но всё равно считаю, что это может быть полезным. Программирование развивает алгоритмические и аналитические навыки мышления, очень полезные по жизни, даже если человек никогда больше не будет писать программы.</p>
]]></description><link>https://dev.by/lenta/main/arhitektor-kotlin-yazyk-programmirovaniya-rabochiy-instrument</link><guid isPermaLink="true">https://dev.by/lenta/main/arhitektor-kotlin-yazyk-programmirovaniya-rabochiy-instrument</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[yankoits]]></dc:creator><pubDate>Thu, 09 Jun 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[Kotlin 1.0.3 EAP]]></title><description><![CDATA[<p>We're starting Kotlin <code>1.0.3</code> EAP.</p>
<h3>What's new</h3>
<p>1.0.3 brings some minor changes to compiler and lots of improvements to IntelliJ plugin:</p>
<ul>
<li>Improved completion, refactorings, Maven support, formatter and Spring support</li>
<li>Language injection support</li>
<li>New intentions, inspections and quickfixes</li>
<li>Lots of bugfixes</li>
</ul>
<p>See full <a href="https://github.com/JetBrains/kotlin/blob/3731e170e459bf02b562464ca02ccb6812760ee2/ChangeLog.md">changelog</a></p>
<h3>How to get EAP build</h3>
<p>To use this build from Gradle or Maven, add <a href="https://dl.bintray.com/kotlin/kotlin-eap">https://dl.bintray.com/kotlin/kotlin-eap</a> to your repositories.
To use the new version of the Kotlin plugin for IntelliJ IDEA, configure Early Access Preview channel in <strong>Tools | Kotlin | Configure Kotlin Plugin Updates</strong> and press "Check for updates now".</p>
<p>Build number is <code>1.0.3-eap-30</code></p>
<p>Please do provide feedback and report any issues to our <a href="https://youtrack.jetbrains.com/issues/KT#newissue">issue tracker</a> (please specify your plugin version and IDE version)</p>
]]></description><link>https://discuss.kotlinlang.org/t/kotlin-1-0-3-eap/1729</link><guid isPermaLink="true">https://discuss.kotlinlang.org/t/kotlin-1-0-3-eap/1729</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Pavel Talanov]]></dc:creator><pubDate>Wed, 08 Jun 2016 21:57:00 GMT</pubDate></item><item><title><![CDATA[When Kotlin met Gradle]]></title><description><![CDATA[<p><em>Love story alert</em></p>
<p><img src="https://jaxenter.com/wp-content/uploads/2016/06/Screen-Shot-2016-06-06-at-2.56.13-PM.png" alt="Kotlin"></p>
<p>Source: <a href="http://gradle.org/">http://gradle.org/</a></p>
<p>The idea of having a Kotlin-based approach to writing Gradle build scripts and plugins was enticing enough to convince the JetBrains team and the Gradle team to concoct a way to get the best of both worlds. And this is how Gradle Script Kotlin was born.</p>
<p>Kotlin seems tireless these days! First, Gradle announced what they call <em><a href="http://gradle.org/blog/kotlin-meets-gradle/">Gradle Script Kotlin</a></em>; then JetBrains announced <a href="https://blog.jetbrains.com/kotlin/2016/06/kotlin-eclipse-plugin-0-7-is-here/">a new release of their plugin</a> for Eclipse IDE. But first things first!</p>
<h2>Gradle + Kotlin = New project</h2>
<p>Gradle’s Chris Beams <a href="http://gradle.org/blog/kotlin-meets-gradle/">announced</a> in mid-May that after years of closely watching Kotlin, the team sat down with some people from the JetBrains team in late 2015 and tried to answer the following questions: what might it look like to have a Kotlin-based approach to writing Gradle build scripts and plugins? How might it help teams—especially big ones—work faster and write better structured, more maintainable builds?</p>
<p>Kotlin could give Gradle users proper IDE support from auto-completion to refactoring and everything in-between since this statically-typed language offers deep support in both IDEA and Eclipse. Plus, the fact that it is rich with features such as first-class functions and extension methods means that it could retain and improve on the best parts of writing Gradle build scripts. The result is called Gradle Script Kotlin, a Kotlin-based build language for Gradle.</p>
<p><a href="https://github.com/gradle/gradle-script-kotlin/releases/tag/v1.0.0-M1">The first milestone</a> towards version 1.0 was launched less than a month ago and its repository was open-sourced at <a href="https://github.com/gradle/gradle-script-kotlin">https://github.com/gradle/gradle-script-kotlin</a>. Take a look at the outcome:</p>
<p><a href="http://gradle.org/blog/kotlin-meets-gradle/"><img src="https://jaxenter.com/wp-content/uploads/2016/06/Screen-Shot-2016-06-06-at-3.28.27-PM.png" alt="Screen Shot 2016-06-06 at 3.28.27 PM"></a></p>
<p>Source: <a href="http://gradle.org/blog/kotlin-meets-gradle/">http://gradle.org/blog/kotlin-meets-gradle/</a></p>
<p>As you begin to explore what’s possible in the IDE, you will will be able to ‘play with’ things such as refactoring, quick documentation, auto-completion and content assist, navigation to source and more.</p>
<h2>Kotlin Eclipse plugin 0.7</h2>
<p>Roughly two weeks after <em>Gradle Script Kotlin</em> was announced, Kotlin returned to the spotlight thanks to a new release. In addition to the support for Kotlin 1.0.2 compiler, Eclipse plugin 0.7 brings highly important features and improvements such as a rebuilt code formatting feature and the <em>Organize Imports</em> feature which cleans unused imports, adds missing imports for classes used in the file and resorts them.</p>
<p>The team also added some quick-fixes about missing or illegal modifiers. As a result, it is now possible to add an open modifier to a declaration which is overridden or subclassed and it is easy to deal with the “class must be declared abstract” compiler error. Plus, invalid modifier removing is now available for the quick-fix popup.</p>
]]></description><link>https://jaxenter.com/when-kotlin-met-gradle-126726.html</link><guid isPermaLink="true">https://jaxenter.com/when-kotlin-met-gradle-126726.html</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Gradle]]></category><dc:creator><![CDATA[Gabriela Motroc]]></dc:creator><pubDate>Mon, 06 Jun 2016 15:44:00 GMT</pubDate></item><item><title><![CDATA[Kotlin Eclipse Plugin 0.7 Is Here!]]></title><description><![CDATA[<p>We are happy to present a new release of our plugin for Eclipse IDE. Along with the support for Kotlin <strong>1.0.2</strong> compiler, this update brings very important features and improvements.</p>
<p>The code formatting feature was rebuilt in this release. Instead of our first naive implementation we have mostly managed to port the advanced formatter from the Kotlin IntelliJ Idea plugin into Eclipse. This means that <a href="https://youtrack.jetbrains.com/issues/KT?q=Formatter%20State:%20Fixed%20Subsystems:%20IDE">a lot of fixes</a> are already there and upcoming improvements will be picked up automatically!</p>
<p><img src="http://d3nmt5vlzunoa1.cloudfront.net/kotlin/files/2016/06/fromater.gif"></p>
<p>New line auto-indent also benefitted from this code reuse and now shows far more predictable and smart behaviour.</p>
<p>It was possible to add missing classes imports one-by-one with a quick-fix since 0.1.0 version, and now we’ve improved on that by introducing the <em>Organize Imports</em> feature. It will clean unused imports, add missing imports for classes used in the file and resort them.</p>
<p><img src="http://d3nmt5vlzunoa1.cloudfront.net/kotlin/files/2016/06/organize.gif"></p>
<p>Our completion got several fixes in prioritizing variants and is now far more usable. Also not-imported classes are now suggested in completion popup at once and will be inserted together with the corresponding import.</p>
<p><img src="http://d3nmt5vlzunoa1.cloudfront.net/kotlin/files/2016/06/import.gif"></p>
<p>Several quick-fixes about missing or illegal modifiers were added:</p>
<ul>
<li>
<p>It’s now possible to add an open modifier to a declaration which is overridden or subclassed.
<img src="http://d3nmt5vlzunoa1.cloudfront.net/kotlin/files/2016/06/open.gif"></p>
</li>
<li>
<p>It’s now easy to deal with the <em>“class must be declared abstract”</em> compiler error.
<img src="http://d3nmt5vlzunoa1.cloudfront.net/kotlin/files/2016/06/abstract.png"></p>
</li>
<li>
<p>Invalid modifier removing is now also available from the quick-fix popup.
<img src="http://d3nmt5vlzunoa1.cloudfront.net/kotlin/files/2016/06/modifiers.png"></p>
</li>
</ul>
<p>Please give it a try.</p>
<p><a href="http://marketplace.eclipse.org/marketplace-client-intro?mpc_install=2257536" title="Drag to your running Eclipse workspace to install Kotlin Plugin for Eclipse"><img src="http://i2.wp.com/marketplace.eclipse.org/sites/all/themes/solstice/_themes/solstice_marketplace/public/images/btn-install.png?zoom=1.5&#x26;w=640" alt="Drag to your running Eclipse workspace to install Kotlin Plugin for Eclipse"></a></p>
<p>If you run into any problems or encounter missing features, please don’t hesitate to leave your feedback here or file issues in YouTrack.</p>
]]></description><link>http://blog.jetbrains.com/kotlin/2016/06/kotlin-eclipse-plugin-0-7-is-here/</link><guid isPermaLink="true">http://blog.jetbrains.com/kotlin/2016/06/kotlin-eclipse-plugin-0-7-is-here/</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Eclipse]]></category><dc:creator><![CDATA[Nikolay Krasko]]></dc:creator><pubDate>Fri, 03 Jun 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[What’s in store for Kotlin this year]]></title><description><![CDATA[<p><em>Taking a peek into the near future</em></p>
<p>Andrey Breslav, the lead language designer of Kotlin at JetBrains, is spilling the beans about the next Kotlin release in a new <a href="https://realm.io/news/andrey-breslav-whats-next-for-kotlin-roadmap/">video</a>. Breslav talks about where Kotlin stands right now and what’s next for it.</p>
<p>Three months after releasing Kotlin 1.0.1, Andrey Breslav,  the lead language designer of Kotlin, shared a <a href="https://realm.io/news/andrey-breslav-whats-next-for-kotlin-roadmap/">video</a> in which he explained where this programming language stands and what’s next for it.</p>
<iframe webkitallowfullscreen="true" mozallowfullscreen="true" allowfullscreen="true" src="//speakerdeck.com/player/f1dea41f659a4c70a6e8fb20291b871b?" style="border: 0px none; background: transparent none repeat scroll 0% 0%; margin: 0px; padding: 0px; border-radius: 5px; width: 960px; height: 480px;" frameborder="0"></iframe>
<p>Breslav announced that the development is in two lines: the incremental updates, 1.0.2, 1.0.3, which are source compatible, and 1.1 —another parallel line where they do language features, and their source compatibility is backward compatibility. 1.0 may not be able to compile 1.1.</p>
<h2>Goals: Java 8/9</h2>
<p>Breslav revealed that their current target is Java 6, which means that whatever users compile in Kotlin can run on anything which runs Java 6, including Java 8/9. JetBrains is now working on generating default methods for Java 8 because even though one can always implement methods and interfaces in Kotlin, extending such an interface in Java is not possible with Java 6 since it wouldn’t know that those methods are implemented.</p>
<p>Furthermore, the support library for Java 8 streams will be removed in Kotlin 1.1.</p>
<p>The lead language designer of Kotlin answered a question that has been on everybody’s lips in the past few months, namely “Can I run Kotlin in a native environment without a virtual machine?” Although the answer is “No,” Breslav sweetened it by suggesting that this is not a permanent answer.</p>
<p>Click <a href="https://realm.io/news/andrey-breslav-whats-next-for-kotlin-roadmap/">here</a> if you want to see the video or read the entire summary.</p>
<p><strong>SEE ALSO: <a href="https://jaxenter.com/10-features-i-wish-java-would-steal-from-the-kotlin-language-2-125308.html">10 features I wish Java would steal from the Kotlin language</a></strong></p>
<h2>An unexpected ode to Kotlin</h2>
<p>Kotlin is loved —we can conclude this after seeing Java champion <a href="https://jaxenter.com/10-features-i-wish-java-would-steal-from-the-kotlin-language-2-125308.html">Lukas Eder</a> and former Bitcoin core developer <a href="https://medium.com/@octskyward/why-kotlin-is-my-next-programming-language-c25c001e26e3#.b3lyfhjmr">Mike Hearn</a> praise this language. In his ode to Kotlin, Hearn opined that this programming language will be a very successful project because it comes from industry, not academia, it costs nothing to adopt, it can be learned in a few hours and it enforces no particular philosophy of programming. Kotlin imposes no runtime overhead, is highly suitable for enterprise Java shops and adopting it is low risk.</p>
<p>Because nothing is perfect in this world, Hearn also encountered some issues while using Kotlin: there are no type aliases yet, the IDE plugin still throws exceptions more often than it should and it targets Java 6 bytecode. Plus, the community is still experiencing its growth pains and is pickier about some things than Java, but the good news is that Kotlin is outgrowing its minuses.</p>
]]></description><link>https://jaxenter.com/whats-in-store-for-kotlin-this-year-126672.html</link><guid isPermaLink="true">https://jaxenter.com/whats-in-store-for-kotlin-this-year-126672.html</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Gabriela Motroc]]></dc:creator><pubDate>Thu, 02 Jun 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[Where We Stand & What's Next for Kotlin]]></title><description><![CDATA[<p>Andrey Breslav, the Kotlin project lead, gives an overview of what Kotlin is today, as a tool for developers and as an ecosystem. He then takes a peek into the near future, to their next release.</p>
<p>See the discussion on <a href="http://news.ycombinator.com/item?id=11814488">Hacker News</a>.</p>
<p>Transcription below provided by Realm: a replacement for SQLite that you can use in Java or Kotlin. <a href="https://realm.io/docs/java/latest/">Check out the docs!</a></p>
<iframe width="960" height="480" src="https://www.youtube.com/embed/LtfxNPOImyg" style="border-radius: 5px;" frameborder="0" allowfullscreen></iframe>
<iframe width="960" height="480" src="//speakerdeck.com/player/f1dea41f659a4c70a6e8fb20291b871b?" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true" style="border-radius: 5px;" frameborder="0"></iframe>
<p>Andrey Breslav, the lead language designer for Kotlin, began his career at Borland, where he worked on language implementations for MDA support. After spending a few years as a college teacher, he joined JetBrains in 2010 to lead Project Kotlin and currently serves as a member of the Java Community Process Expert Group for JSR 335, “Project Lambda.” He is a frequent conference speaker at venues such as OSCON, JavaOne, Strange Loop, and Devoxx.</p>
<p><a href="https://twitter.com/abreslav">@abreslav</a></p>
<h3>Introduction 00:00</h3>
<p>My name is Andrey, I lead the <a href="http://kotlinlang.org">Kotlin</a> team at <a href="https://www.jetbrains.com">JetBrains</a>. I am here to tell you about where we stand and about what is next.</p>
<h3>Learning Materials 00:30</h3>
<p>This talk is not an introduction to Kotlin. If you want to learn Kotlin, there are many sources to learn from. There is <a href="http://kotlinlang.org">language reference, tutorials, talk videos</a>. Check out our <a href="http://try.kotlinlang.org">mini-IDE</a>, Kotlin Koans is a set of problems that walks you through the language, similar to an IDE with a educational plug-in. <em>I am here to motivate you to learn!</em></p>
<h3>Where We Stand 01:03</h3>
<p>Kotlin 1.0 released in February 2016. Since then we were doing incremental updates: 1.0.2 is our current version, and we are working on 1.1 (a feature driven release, although I am not giving you a date yet). The Early Access Program (EAP) will start this summer.</p>
<p>In this slide (<em>see video</em>) we have the people that have used Kotlin (<em>maybe not admitting it publicly!</em>). JetBrains is a big user, we were probably the first to start trying it in production. We have over half a million lines of code and production in different projects, from IntelliJ production of our main IDE to server side products (...to everything). A few projects are written in Kotlin from scratch. Others are catching up. We are grateful to everyone trying Kotlin in production. It is such an early stage of the release time! Join in, you will be in a good company.</p>
<p>And being in a good company, you will not be alone. We have a lively community, Slack, forums, StackOverflow, full of people who are happy to tell you what you are doing wrong, and how to fix whatever issues you have. Come over to our GitHub Project, it is open source, you can join (we already have over 100 OSS contributors!). If you are stuck, we will work as hard as we can to be responsive. If you have a critical issue, we will role it out as an EAP build, which you can use to work on the problem.</p>
<h3>KEEP 03:14</h3>
<p>Kotlin Evolution and Enhancement Process (KEEP): we try to accumulate all the design process we are having, and be as open as possible. If you go to this <a href="https://github.com/Kotlin/KEEP">GitHub repo</a> you will see all the proposals that are considered for Kotlin 1.1 at the moment. You can provide your ideas, feedback, do corrections. We are very grateful: use cases are what drive our design. KEEP is the venue for our plans.</p>
<h3>Our Plans - Lines of Development 03:56</h3>
<p>Now we have 1.0, 1.0.2, as the main release, and our development is in two lines. We have those incremental updates, 1.0.2, 1.0.3, which are source compatible (meaning that language does not change more than the bugs). We fix bugs in the compiler; this sometimes slightly changes the language (but that is always for the better). There you find bugfixes, performance updates, and tooling features. This is where IDEs are improved: build systems.</p>
<p>1.1 is another parallel line, where we do language features, and their source compatibility is backward compatibility. 1.0 may not be able to compile 1.1 (because there are new features 1.0 does not know about). Backwards is always compatible. If you have your old code, it will work with 1.1.</p>
<p><em>This slide does not mention anything about binary compatibility, because that goes without saying.</em></p>
<h3>Tooling Plans: 1.0.X 05:18</h3>
<ul>
<li>
<p>We released 1.0.2, which has incremental compilation for Gradle (<em>and speeds things up quite a bit</em>). Now, when you change something you are calling code, and recompile it with Gradle, with the incremental flag enabled (it is an experimental flag, you do not have it on by default), you only have those files recompiled that actually need recompilation. The whole project is not rebuilt, only those individual files touched or that were affected by your changes. And we will be working on this feature; after some time it will be not experimental anymore (<em>hopefully!</em>). That is one big infrastructural change.</p>
</li>
<li>
<p>Spring Support in the IDE. You have some of the features that the big IntelliJ idea has for Java, but in caudlen.</p>
</li>
<li>
<p>Reduce our standard library size. That is not because our standard library is big (it is probably the smallest among the alternative jvm languages). Last time we shaved off some 1500 methods off the library binary, without changing the API. It is a compatible change, but there are fewer functions now. If you are an Android developer, it matters to you.</p>
</li>
<li>
<p>Android Lint Checks (<em>people were asking for those</em>). The IDE warns you if you do something wrong in Android specific terms (not language specific terms). We will have more and more Lint Checks added over time.</p>
</li>
<li>
<p>Jack&#x26;Jill, the new Android tool chain we are integrating with. We are fixing bugs to be able to Jill compile the Kotlin center library (because, without the bug fixes, it would not).</p>
</li>
</ul>
<h3>New Targets 07:49</h3>
<p>And for 1.1... we are planning many things!</p>
<ol>
<li>
<p><strong>Java 8/9</strong>. Our current target is Java 6: whatever you compile in Kotlin can run on anything that runs Java 6, including Java 8/9 (but it does not use the features of 8/9). We are working on generating default methods for Java 8. In Kotlin, you can always implement methods and interfaces, but if you want to extend such an interface in Java, Java 6 would not know that those methods are implemented (Java 8 would). We also have some issues with Stream API collection in Java 8. We have a support library for Java 8 streams, but that will be removed in Kotlin 1.1 and we will just support natively in the compiler.</p>
</li>
<li>
<p>The JavaScript backend for Kotlin has been around for years, but we de-prioritized it to shape 1.0 for Java as soon as we could. We are working on it again, and all the language features are covered. We are working on runtime module support (amd, umd, common.js). JavaScript has many common toolchains (npm, browserify, gulp, ...), and we will try to support as many of them as we can.</p>
</li>
<li>
<p>Another popular question, can I run Kotlin in a native environment without a virtual machine? The current answer is no; at least, not easily. No code is written in this section yet, and it is probably not going to be available in 1.1, but we are looking into this and we will probably have some news sometime later.</p>
</li>
</ol>
<h3>Scripting: example.kts 10:08</h3>
<p>One thing that is needed from any modern language is to be a scripting language. This is more or less supported, although it has not been officially promoted that much. You can write a script in Kotlin, the file extension would be .kts. For now, you can import anything and write the expressions and statements on the top level of the file. It will be compiled to a Java class and run as normal.</p>
<p>However, you cannot define dependencies inside a script, which means you have to either configure your class path, or be stuck with the jtk and the Kotlin standard library. This is something we are working on now, and it will probably help many other usages of Kotlin. This is an infrastructural change.</p>
<h4>Type Aliases 11:04</h4>
<p>When you want to pass a function (say, a foo and bar to buzz), you end up repeating this function signature many times. That is why people want some abbreviation mechanism, to give a name to this complex type.</p>
<pre><code class="hljs language-kotlin">typealias Int32 = <span class="hljs-built_in">Int</span>
typealias Predicate&#x3C;T> = (T) -> <span class="hljs-built_in">Boolean</span></code></pre>
<p>Here my complex type is T to Boolean, a function, and I want a name for it. I say <code>typealias Predicate&#x3C;T> = (T) -> Boolean</code>. This is not a new type, this is just an abbreviation; an alias. <code>Int32</code> here is just an <code>Int</code>. These are interchangeable, but they will help you abbreviate your long types and make your APIs more speaking. The new type is something many people want. It is not something a type alias is. It will be covered later, probably in 1.1, with value types (or something related to those). You have probably heard about Project Valhalla (those of you interested in Java), it is easier.</p>
<h3>Bound Method References 12:35</h3>
<p>You probably know that Kotlin has reflection (on top of whatever platform reflection there is). There is language support for reflection.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> p: Predicate&#x3C;String> = “foo”::equals
    <span class="hljs-comment">// behaves as { x -> “foo”.equals(x) }</span>

<span class="hljs-keyword">val</span> c: KClass&#x3C;Foo> = x.foo()::<span class="hljs-class"><span class="hljs-keyword">class</span></span></code></pre>
<p>Those two colons (type ::foo) is something that is supported now. You can take a type, and take a reference to it is member, a function or a property. Or, you can take a type and make it a class literal by saying Type::class. This is something you can do now, but in 1.1 you will be able to do that with an object. It can take a foo (“foo” is a string, obviously), and it can take an <code>equals</code> of that string, which is a function of one argument, and put to a variable as a predicate. It will be comparing any string you pass to it to foo. This is a partial application, but a limited one. Convenient, according to our use-case surveys.</p>
<p>More or less works, like lamda over there. Same thing you will be able to do with a class; you can take a class of x to foo by saying ::class.</p>
<h3>Enhancements for Properties 13:54</h3>
<p>If you do not know what delegated properties are... Google it, because they are cool. <em>(Ed. note: <a href="https://kotlinlang.org/docs/reference/delegated-properties.html">Here you go!</a>)</em> This is something that allows good re-using code, Kotlin. Good news: in 1.1 we will allow that as a local variable. Now you can use <strong>delegated properties</strong> on a top level or in a class; you will be able to do it in a function. This enables DSLs, and this will help us with new cases.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> lazyBar <span class="hljs-keyword">by</span> lazy { ... }
    <span class="hljs-keyword">while</span> (...) {
        <span class="hljs-keyword">if</span> (...) {
            lazyBar.doBaz()
    ...
}</code></pre>
<p>Inline properties: technical thing for some libraries; for binary compatibility, it is better to have properties inlineable.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> foo: Foo
    <span class="hljs-keyword">inline</span> <span class="hljs-keyword">get</span>() = ...
    <span class="hljs-keyword">inline</span> <span class="hljs-keyword">set</span>(v) { ... }</code></pre>
<h3>Hierarchies for Data Classes 14:53</h3>
<p>(<em>If you have not heard of data classes, learn about them</em>). <em>(Ed. note: <a href="https://kotlinlang.org/docs/reference/data-classes.html">Here you go!</a>)</em></p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span></span>(<span class="hljs-keyword">val</span> name: String, <span class="hljs-keyword">val</span> age: <span class="hljs-built_in">Int</span>)

<span class="hljs-comment">// automatically gets</span>
equals() / hashCode() / toString()
copy() <span class="hljs-comment">// val newUser = someUser.copy(name = “Jane Doe”)</span>
componentN() <span class="hljs-comment">// val (name, age) = someUser</span></code></pre>
<p>Kotlin has this simple but useful feature, where it can define a class with two members. It is a <code>class User</code>, which has a name and an age (these are fields). It can mark it data, and the compiler can generate all this for you. It will give you equals() and hashCode() based on those values, toString(), rendering those. A copy() method to change a name of an object in a shallow copy of it. And componentN() functions for destructuring. It can say: I have a user (a user is a pair of name and age), I declare a local variable, name and age at the same time and assign the user to two of them. I have two values at the same time assigned to those names.</p>
<p>Data classes are good, but we did not support any inheritance for those. 1.1 will fix that; you will be able to say, have a sealed class, and be able to extend a data class from it.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span></span>() {
    <span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span></span>(...) : C()
}</code></pre>
<p>This covers everything people need about algebraic data types in Kotlin. It is not Haskell yet (it will never be), but it is as close to Haskell as use cases we see require.</p>
<h3>Destructuring in Lambdas 16:22</h3>
<pre><code class="hljs language-kotlin">myMap.forEach {
    (k, v) ->
    println(“$k => $v”)
}</code></pre>
<p>A map from N to string is a sequence of pairs, map entries of keys and values. In the library, Map has a .forEach method. That simply iterates through the pairs, and you can do whatever with them. In Kotlin 1.0, you only have one variable for the whole pair. You can say, forEach has an entry, and it can say <code>(k, v) -> println(“$k => $v”)</code>. And this new syndex in 1.1 will help you destructure right away. If you say K and V is a pair (which means that the entry is structured in the two), and then you can print the two. <em>Have I lost all of my audience by now?</em></p>
<p>I have a black screen for you (<em>see video</em>). You are not supposed to read the code. All you care about is this staircase of brackets. This is the picture I Googled by the query ‘callback hell’. This picture is a typical piece of JavaScript (not only JavaScript, other languages suffer from this as well). This illustrates the world of asyncronist computation as it is, more or less, today in many languages.</p>
<p>We want to be asynchronist as much as we can, because we like to offload things on different threads or other different ways of execution. The way I want to read from a file is: “Here is my file, I want to read from it. When the read is done, here is my callback, call it when it is finished”. That is great; I can call something, I am not blocking. I can continue working; the read will do its work. But, if after that read I want to write, and then another read, each next asynchronist call has to be nested inside that callback. It is a callback in a callback in a callback in a callback... and at the end I have this staircase. It is okay if it fits in 115 lines, but sometimes it does not. And this is why some languages have async/await.</p>
<h3>Asynchronous Computation 19:10</h3>
<p>Some languages want to write the same asyncronist code that does not block on many calls, but in a sequential way.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadImage</span><span class="hljs-params">(url: <span class="hljs-type">URL</span>)</span></span> = async {
    <span class="hljs-keyword">val</span> bytes = await(loadBytes(url))
    bytesToImage(bytes)
}</code></pre>
<p>I just say loadBytes and then bytesToImage, meaning that loadBytes should work asynchronistically and execute bytes image only when it is done. There is this <code>await</code> keyword, that means call load bytes, put the rest of the computation away somewhere, do not block the thread, give the thread up to somebody else who can use it. And, when the loadBytes is done, resurrect the whole computation and run the next line.</p>
<p>This is what C# introduced in version five. Many other languages adopted this idea because it is fruitful, and this is something we want to cover. But we do not want to copy it from others because it is not general enough, in our opinion. They have a asynchronist computation, a sync block, and a suspension point. Await means we can suspend here and then resurrect afterwards.</p>
<h4>Coroutines 20:24</h4>
<p>Alternatively, we want to do coroutines. It is a generalization. We want to cover async/await/yield on generator blocks from other languages, but with maximum flexibility. We want to support virtually all existing asynchronous APIs, futures, callbacks, promises. And this means that the language is not bound to a given task framework.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadImage</span><span class="hljs-params">(url: <span class="hljs-type">URL</span>)</span></span> = async {
    <span class="hljs-keyword">val</span> bytes = await(loadBytes(url))
    bytesToImage(bytes)
}</code></pre>
<p>We have these <code>async</code> and <code>await</code>: these are library functions, not keywords. It is the same machinery with a different API, and much flexibility. The prototype for this is under way (maybe available in June), and we will be able to play with library making and library using, using this abstraction.</p>
<h3>Conclusion 21:25</h3>
<p>I invite you to come to KEEP, and review the proposals. Give us your feedback, ideas, use cases.</p>
<p>Kotlin has been known for making nice APIs, and some people like making APIs so much that I have the honor to invite Hans Docter on stage, because he has <a href="https://realm.io/news/gradle-kotlin/">something to show you</a>.</p>
<p>See the discussion on <a href="http://news.ycombinator.com/item?id=11814488">Hacker News</a>.</p>
]]></description><link>https://realm.io/news/andrey-breslav-whats-next-for-kotlin-roadmap/</link><guid isPermaLink="true">https://realm.io/news/andrey-breslav-whats-next-for-kotlin-roadmap/</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Andrey Breslav]]></dc:creator><pubDate>Wed, 01 Jun 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[Neural Networks in Kotlin (part 2)]]></title><description><![CDATA[<p>In the <a href="http://beust.com/weblog/2016/05/27/neural-network-in-kotlin/">previous installment</a>, I introduced a mystery class <code>NeuralNetwork</code> which is capable of calculating different results depending on the data that you train it with. In this article, we’ll take a closer look at this neural network and crunch a few numbers.</p>
<h2>Neural networks overview</h2>
<p>A neural network is a graph of neurons made of successive layers. The graph is typically split in three parts: the leftmost column of neurons is called the “input layer”, the rightmost columns of neurons is the “output layer” and all the neurons in-between are the “hidden” layer. This hidden layer is the most important part of your graph since it’s responsible for making the calculations. There can be any numbers of hidden layers and any number of neurons in each of them (note that the Kotlin class I wrote for this series of articles only uses one hidden layer).</p>
<p>Each edge that connects two neurons has a weight which is used to calculate the output of this neuron. The calculation is a simple addition of each input value multiplied by its weight. Let’s take a look at a quick example:</p>
<p><img src="https://docs.google.com/drawings/d/1lnkGCoJ5DsJcXlqXnjmE0oGM6l1wHrf9pRuN-8ZU7Xc/pub?w=480&#x26;h=360">  </p>
<p>This network has two input values, one hidden layer of size two and one output. Our first calculation is therefore:</p>
<pre><code class="hljs language-kotlin">w11-output = <span class="hljs-number">2</span> * <span class="hljs-number">0.1</span> + (<span class="hljs-number">-3</span>) * (<span class="hljs-number">-0.2</span>) = <span class="hljs-number">0.8</span>
w12-output = <span class="hljs-number">2</span> * (<span class="hljs-number">-0.4</span>) + (<span class="hljs-number">-3</span>) * <span class="hljs-number">0.3</span> = <span class="hljs-number">-1.7</span></code></pre>
<p>We’re not quite done: the actual outputs of neurons (also called “activations”) are typically passed to a normalization function first. To get a general intuition for this function, you can think of it as a way to constrain the outputs within the [-1, 1] range, which prevents the values flowing through the network from overflowing or underflowing. Also, it’s useful in practice for this function to have additional properties connected to its derivative but I’ll skip over this part for now. This function is called the “activation function” and the implementation I used in the <code>NeuralNetwork</code> class is the <a href="http://mathworld.wolfram.com/HyperbolicTangent.html">hyperbolic tangent, <code>tanh</code></a>.</p>
<p>In order to remain general, I’ll just refer to the activation function as <code>f()</code>. We therefore refine our first calculations as follows:</p>
<pre><code class="hljs language-kotlin">w11-output = f(<span class="hljs-number">2</span> * <span class="hljs-number">0.1</span> + (<span class="hljs-number">-3</span>) * (<span class="hljs-number">-0.2</span>))
w12-output = f(<span class="hljs-number">2</span> * (<span class="hljs-number">-0.4</span>) + (<span class="hljs-number">-3</span>) * <span class="hljs-number">0.3</span>)</code></pre>
<p>There are a few additional details to this calculation in actual neural networks but I’ll skip those for now.</p>
<p>Now that we have all our activations for the hidden layer, we are ready to move to the next layer, which happens to be the ouput layer, so we’re almost done:</p>
<pre><code class="hljs language-kotlin">output = f(<span class="hljs-number">0.1</span> * w11-output - <span class="hljs-number">0.2</span> * w12-output
       = <span class="hljs-number">0.42</span></code></pre>
<p>As you can see, calculating the output of a neural network is fairly straightforward and fast, much faster than actually training that network. Once you have created your networks and you are satisfied with its results, you can just pass around the characteristics of that network (weights, sizes, ...) and any device (even phones) can then use that network.</p>
<h2>Revisiting the xor network</h2>
<p>Let’s go back to the <code>xor</code> network we created in the first episode. I created this network as follows:</p>
<pre><code class="hljs language-kotlin">NeuralNetwork(inputSize = <span class="hljs-number">2</span>, hiddenSize = <span class="hljs-number">2</span>, outputSize = <span class="hljs-number">1</span>)</code></pre>
<p>We only need two inputs (the two bits) and one output (the result of <code>a xor b</code>). These two values are fixed. What is not fixed is the size of the hidden layer, and I decided to pick 2 here, for no particular reason. It’s interesting to tweak these values and see whether your neural network performs better of worse based on these values and there is actually a great deal of both intuition and arbitrary choices that go into these decisions. These values that you use to configure your network before you run it are called “hyper parameters”, in contrast to the other values which get updated while your network runs (e.g. the weights).</p>
<p>Let’s now take a look at the weights that our <code>xor</code> network came up with, which you can display by running the Kotlin application with <tt>--log 2</tt>:</p>
<pre><code class="hljs language-plain"><span class="hljs-selector-tag">Input</span> <span class="hljs-selector-tag">weights</span>:
<span class="hljs-selector-tag">-1</span><span class="hljs-selector-class">.21</span> <span class="hljs-selector-tag">-3</span><span class="hljs-selector-class">.36</span>
<span class="hljs-selector-tag">-1</span><span class="hljs-selector-class">.20</span> <span class="hljs-selector-tag">-3</span><span class="hljs-selector-class">.34</span>
1<span class="hljs-selector-class">.12</span> 1<span class="hljs-selector-class">.67</span>
 
<span class="hljs-selector-tag">Output</span> <span class="hljs-selector-tag">weights</span>:
3<span class="hljs-selector-class">.31</span>
<span class="hljs-selector-tag">-2</span><span class="hljs-selector-class">.85</span> </code></pre>
<p>Let’s put these values on the visual representation of our graph to get a better idea:</p>
<p><img src="https://docs.google.com/drawings/d/1vzNDxpKkIP0h6pp8KglUn55a-pLE5PIAaO204ZNqYR0/pub?w=960&#x26;h=720">  </p>
<p>You will notice that the network above contains a neuron called “bias” that I haven’t introduced yet. And I’m not going to just yet besides saying that this bias helps the network avoid edge cases and learn more rapidly. For now, just accept it as an additional neuron whose output is not influenced by the previous layers.</p>
<p>Let’s run the graph manually on the input (1,0), which should produce 1:</p>
<pre><code class="hljs language-kotlin">hidden1<span class="hljs-number">-1</span> = <span class="hljs-number">1</span> * <span class="hljs-number">-1.21</span>
hidden1<span class="hljs-number">-2</span> = <span class="hljs-number">0</span> * <span class="hljs-number">-1.20</span>
bias1     = <span class="hljs-number">1</span> * <span class="hljs-number">1.12</span>
 
output1 = tanh(<span class="hljs-number">-1.21</span> + <span class="hljs-number">1.12</span>) = <span class="hljs-number">-0.09</span>
 
hidden2<span class="hljs-number">-1</span> = <span class="hljs-number">1</span> * <span class="hljs-number">-3.36</span>
hidden2<span class="hljs-number">-2</span> = <span class="hljs-number">0</span> * <span class="hljs-number">-3.34</span>
bias2     = <span class="hljs-number">1</span> * <span class="hljs-number">1.67</span>
 
output2 = tanh(<span class="hljs-number">-3.36</span> + <span class="hljs-number">1.6</span>) = <span class="hljs-number">-0.94</span>
 
<span class="hljs-comment">// Now that we have the outputs of the hidden layer, we can caculate</span>
<span class="hljs-comment">// our final result by combining them with the output weights:</span>
 
finalOutput = tanh(output1 * <span class="hljs-number">3.31</span> + output2 * (<span class="hljs-number">-2.85</span>))
            = <span class="hljs-number">0.98</span></code></pre>
<p>We have just verified that if we input <code>(0,1)</code> into the network, we’ll receive <code>0.98</code> in output. Feel free to calculate the other three inputs yourself or maybe just run the <code>NeuralNetwork</code> class with a log level of 2, which will show you all these calculations.</p>
<h2>Revisiting the parity network</h2>
<p>So the calculations hold up but it’s still a bit hard to understand where these weights come from and why they interact in the way they do. Elucidating this will be the topic of the next installment but before I wrap up this article, I’d like to take a quick look at the parity network because its content might look a bit more intuitive to the human eye, while the <code>xor</code> network detailed above still seems mysterious.</p>
<p>If you train the parity network and you ask the <code>NeuralNetwotk</code> class to dump its output, here are the weights that you’ll get:</p>
<pre><code class="hljs language-plain"><span class="hljs-selector-tag">Input</span> <span class="hljs-selector-tag">weights</span>:
0<span class="hljs-selector-class">.36</span> <span class="hljs-selector-tag">-0</span><span class="hljs-selector-class">.36</span>
0<span class="hljs-selector-class">.10</span> <span class="hljs-selector-tag">-0</span><span class="hljs-selector-class">.09</span>
0<span class="hljs-selector-class">.30</span> <span class="hljs-selector-tag">-0</span><span class="hljs-selector-class">.30</span>
<span class="hljs-selector-tag">-2</span><span class="hljs-selector-class">.23</span> <span class="hljs-selector-tag">-1</span><span class="hljs-selector-class">.04</span>
0<span class="hljs-selector-class">.57</span> <span class="hljs-selector-tag">-0</span><span class="hljs-selector-class">.58</span>
 
<span class="hljs-selector-tag">Output</span> <span class="hljs-selector-tag">weights</span>:
<span class="hljs-selector-tag">-1</span><span class="hljs-selector-class">.65</span>
<span class="hljs-selector-tag">-1</span><span class="hljs-selector-class">.64</span> </code></pre>
<p>If you pay attention, you will notice an interesting detail about these numbers: the weights of the first three neurons of our hidden layer cancel each other out while the two inputs of the fourth neuron reinforce each other. It’s pretty clear that the network has learned that when you are testing the parity of a number in binary format, the only bit that really matters is the least significant one (the last one). All the others can simply be ignored, so the network has learned from the training data that the best way to get close to the desired output is to only pay attention to that last bit and cancel all the other ones out so they don’t take part in the final result.</p>
<h2>Wrapping up</h2>
<p>This last result is quite remarkable if you think about it, because it really looks like the network learned how to test parity at the formal level (“The output of the network should be the value of the least significant bit, ignore all the others”), inferring that result just from the numeric data we trained it with. Understanding how the network learned how to modify itself to reach this level will be the topic of the next installment of the series.</p>
]]></description><link>http://beust.com/weblog/2016/05/30/neural-networks-in-kotlin-part-2/</link><guid isPermaLink="true">http://beust.com/weblog/2016/05/30/neural-networks-in-kotlin-part-2/</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Cédric Beust]]></dc:creator><pubDate>Mon, 30 May 2016 14:26:00 GMT</pubDate></item><item><title><![CDATA[Neural Network in Kotlin]]></title><description><![CDATA[<p><img src="http://beust.com/pics/neural-network.png"></p>
<p>It’s hard not to hear about machine learning and neural networks these days since the practice is being applied to an ever increasingly wide variety of problems. Neural networks can be intimidating and look downright magical to the untrained (ah!) eye, so I’m going to attempt to dispel these fears by demonstrating how these mysterious networks operate. And since there are already so many tutorials on the subject, I’m going to take a different approach and go from top to bottom.</p>
<h2>Goal</h2>
<p>In this first series of articles, I will start by running a very simple network on two simple problems, show you that they work and then walk through the network to explain what happened. Then I’ll backtrack to deconstruct the logic behind the network and why it works.</p>
<p>The neural network I’ll be using in this article is a simple one I wrote. No TensorFlow, no Torch, no Theano. Just some basic Kotlin code. The original version was about 230 lines but it’s a bit bigger now that I broke it up in separate classes and added comments. The <a href="http://github.com/cbeust/nnk">whole project can be found on github under the temporary “nnk” name</a>. In particular, <a href="https://github.com/cbeust/nnk/blob/master/src/main/kotlin/com/beust/nnk/NeuralNetwork.kt">here is the source of the neural network we’ll be using</a>.</p>
<p>I will be glossing over a lot of technical terms in this introduction in order to focus on the numeric aspect but I’m hoping to be able to get into more details as we slowly peel the layers. For now, we’ll just look at the network as a black box that get fed input values and which outputs values.</p>
<p>The main characteristic of a neural network is that it starts completely empty but it can be taught to solve problems. We do this by feeding it values and telling it what the expected output is. We iterate over this approach many times, changing these inputs/expected parameters and as we do that, the network updates its knowledge to come up with answers that are as close to the expected answers as possible. This phase is called “training” the network. Once we think the network is trained enough, we can then feed it new values that it hasn’t seen yet and compare its answer to the one we’re expecting.</p>
<h2>The problems</h2>
<p>Let’s start with a very simple example: <code>xor</code>.</p>
<p>This is a trivial and fundamental binary arithmetic operation which returns 1 if the two inputs are different and 0 if they are equal. We will train the network by feeding it all four possible combinations and telling it what the expected outcome is. With the Kotlin implementation of the Neural Network, the code looks like this:</p>
<pre><code class="hljs language-kotlin">with(NeuralNetwork(inputSize = <span class="hljs-number">2</span>, hiddenSize = <span class="hljs-number">2</span>, outputSize = <span class="hljs-number">1</span>)) {
    <span class="hljs-keyword">val</span> trainingValues = listOf(
        NetworkData.create(listOf(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), listOf(<span class="hljs-number">0</span>)),
        NetworkData.create(listOf(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>), listOf(<span class="hljs-number">1</span>)),
        NetworkData.create(listOf(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), listOf(<span class="hljs-number">1</span>)),
        NetworkData.create(listOf(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>), listOf(<span class="hljs-number">0</span>)))
 
    train(trainingValues)
    test(trainingValues)
}</code></pre>
<p>Let’s ignore the parameters given to <code>NeuralNetwork</code> for now and focus on the rest. Each line of <code>NetworkData</code> contains the inputs (each combination of 0 and 1: (0,0), (0,1), (1,0), (1,1)) and the expected output. In this example, the output is just a single value (the result of the operation) so it’s a list of one value, but networks can return an arbitrary number of outputs.</p>
<p>The next step is to test the network. Since there are only four different inputs here and we used them all for training, let’s just use that same list of inputs but this time, we’ll display the ouput produced by the network instead of the expected one. The result of this run is as follows:</p>
<p>Running neural network xor()</p>
<pre><code class="hljs language-plain"><span class="hljs-string">[0.0, 0.0]</span> -> <span class="hljs-string">[0.013128957]</span>
<span class="hljs-string">[0.0, 1.0]</span> -> <span class="hljs-string">[0.9824073]</span>
<span class="hljs-string">[1.0, 0.0]</span> -> <span class="hljs-string">[0.9822749]</span>
<span class="hljs-string">[1.0, 1.0]</span> -> <span class="hljs-string">[-2.1314621E-4]</span></code></pre>
<p>As you can see, these values are pretty decent for such a simple network and such a small training data set and you might rightfully wonder: is this just luck? Or did the network cheat and memorize the values we fed it while we were training it?</p>
<p>One way to find out is to see if we can train our network to learn something else, so let’s do that.</p>
<h2>A harder problem</h2>
<p>This time, we are going to teach our network to determine whether a number is odd or even. Because the implementation of the graph is pretty naïve and this is just an example, we are going to train our network with binary numbers. Also, we are going to learn a first important lesson in neural networks which is to choose your training and testing data wisely.</p>
<p>You probably noticed in the example above that I used the same data to train and test the network. This is not a good practice but it was necessary for <code>xor</code> since there are so few cases. For better results, you usually want to train your network on a certain population of the data and then test it on data that your network hasn’t seen yet. This will guarantee that you are not “overfitting” your network and also that it is able to generalize what you taught it to input values that it hasn’t seen yet. Overfitting means that your network does great on the data you trained it with but poorly on new data. When this happens, you usually want to tweak your network so that it will possibly perform less well on the training data but it will return better results for new data.</p>
<p>For our parity test network, let’s settle on four bits (integers 0 – 15) and we’ll train our network on about ten numbers and test it on the remaining six:</p>
<pre><code class="hljs language-kotlin">with(NeuralNetwork(inputSize = <span class="hljs-number">4</span>, hiddenSize = <span class="hljs-number">2</span>, outputSize = <span class="hljs-number">1</span>)) {
    <span class="hljs-keyword">val</span> trainingValues = listOf(
        NetworkData.create(listOf(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), listOf(<span class="hljs-number">0</span>)),
        NetworkData.create(listOf(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>), listOf(<span class="hljs-number">1</span>)),
        NetworkData.create(listOf(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>), listOf(<span class="hljs-number">0</span>)),
        NetworkData.create(listOf(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>), listOf(<span class="hljs-number">0</span>)),
        NetworkData.create(listOf(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>), listOf(<span class="hljs-number">1</span>)),
        NetworkData.create(listOf(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>), listOf(<span class="hljs-number">0</span>)),
        NetworkData.create(listOf(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>), listOf(<span class="hljs-number">1</span>)),
        NetworkData.create(listOf(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), listOf(<span class="hljs-number">0</span>)),
        NetworkData.create(listOf(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>), listOf(<span class="hljs-number">1</span>)),
        NetworkData.create(listOf(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>), listOf(<span class="hljs-number">0</span>)),
        NetworkData.create(listOf(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>), listOf(<span class="hljs-number">1</span>))
    )
    train(trainingValues)
 
    <span class="hljs-keyword">val</span> testValues = listOf(
        NetworkData.create(listOf(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>), listOf(<span class="hljs-number">1</span>)),
        NetworkData.create(listOf(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), listOf(<span class="hljs-number">0</span>)),
        NetworkData.create(listOf(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>), listOf(<span class="hljs-number">1</span>)),
        NetworkData.create(listOf(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), listOf(<span class="hljs-number">0</span>)),
        NetworkData.create(listOf(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>), listOf(<span class="hljs-number">1</span>))
    )
    test(testValues)
}</code></pre>
<p>And here is the output of the test:</p>
<pre><code class="hljs language-plain">Running neural network isOdd()
 
<span class="hljs-string">[0.0, 0.0, 1.0, 1.0]</span> -> <span class="hljs-string">[0.9948013]</span>
<span class="hljs-string">[0.0, 1.0, 0.0, 0.0]</span> -> <span class="hljs-string">[0.0019584869]</span>
<span class="hljs-string">[0.0, 1.0, 0.0, 1.0]</span> -> <span class="hljs-string">[0.9950419]</span>
<span class="hljs-string">[1.0, 0.0, 0.0, 0.0]</span> -> <span class="hljs-string">[0.0053276513]</span>
<span class="hljs-string">[1.0, 0.0, 0.0, 1.0]</span> -> <span class="hljs-string">[0.9947305]</span></code></pre>
<p>Notice that the network is now outputting correct results for numbers that it hadn’t seen before, just because of the way it adapted itself to the training data it was initially fed. This gives us good confidence that the network has configured itself to classify numbers from any input values and not just the one it was trained for.</p>
<h2>Wrapping up</h2>
<p>I hope that this brief overview will have whetted your appetite or at least piqued your curiosity. In the <a href="http://beust.com/weblog/2016/05/30/neural-networks-in-kotlin-part-2/">next installment</a>, I’ll dive a bit deeper into the <code>NeuralNetwork</code> class, explain the constructor parameters and we’ll walk through the inner working of the neural network that we created to demonstrate how it works.</p>
]]></description><link>http://beust.com/weblog/2016/05/27/neural-network-in-kotlin/</link><guid isPermaLink="true">http://beust.com/weblog/2016/05/27/neural-network-in-kotlin/</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Cédric Beust]]></dc:creator><pubDate>Fri, 27 May 2016 07:57:00 GMT</pubDate></item><item><title><![CDATA[You can do Better with Kotlin]]></title><description><![CDATA[<p>The Kotlin programming language is gaining popularity amongst the Android developer community. It’s a modern language that gives more power in everyday routines. Kotlin code generally looks cleaner and nicer, and it’s much easier to work with when you have less verbosity or code duplication. And this is especially noticeable comparing with the soon-to-be-archaic versions of Java used on Android.</p>
<p>But what’s even more important, is that Kotlin is 100% compatible with all existing Java frameworks, and has good tooling in Android Studio and IntelliJ IDEA. It’s a pragmatic language with a very low learning curve, and can be quickly grasped by Java developers.</p>
<p>In this talk we’ll discuss the concepts of the language that provide the desired expressiveness, as well as additional goodies designed specifically for Android.</p>
<iframe width="960" height="480" src="https://www.youtube.com/embed/Es32UqHNza0" frameborder="0" allowfullscreen></iframe>
]]></description><link>https://www.youtube.com/watch?v=Es32UqHNza0</link><guid isPermaLink="true">https://www.youtube.com/watch?v=Es32UqHNza0</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Android]]></category><dc:creator><![CDATA[Svetlana Isakova]]></dc:creator><pubDate>Tue, 24 May 2016 11:47:00 GMT</pubDate></item><item><title><![CDATA[Kotlin, dragging java into the modern world]]></title><description><![CDATA[<p><img src="http://35gd0g2fpmpc2rmy8u1ld360.wpengine.netdna-cdn.com/wp-content/uploads/2016/05/kotlin_800x320.png" alt="kotlin_800x320"></p>
<p>Even though we love our coffee here at OptimalBI, we have never had a place in our hearts for Java. Even so Java has a lot to offer for the modern cloud-driven world, but writing good, maintainable and human readable code has never been part of a Java developers life.
This is where <a href="https://kotlinlang.org/">Kotlin </a> comes into things. Kotlin is a statically typed language that runs on the JVM (Java Virtual Machine) which is designed to write better and safer Java-like applications that also have a certain level of human readability.</p>
<h2>Why do we need Java anyway?</h2>
<p>At OptimalBI we do stuff in the cloud. This means that we have a large toolbox we can reach into to help us with a bunch of different tasks. As you might have seen from <a href="https://github.com/OptimalBI/optimal-spyglass-open-source">Optimal Spyglass</a> Java was one of the tools we have used to create a reliable cross-platform GUI, using the always helpful AWS SDK. Java was chosen here so that support for all platforms could be offered easily without maintaining multiple versions<a href="http://35gd0g2fpmpc2rmy8u1ld360.wpengine.netdna-cdn.com/wp-content/uploads/2016/05/Campagnolo_Tool_Kit_Super_Record_Wooden_Box_Nr._16.jpg"><img src="http://35gd0g2fpmpc2rmy8u1ld360.wpengine.netdna-cdn.com/wp-content/uploads/2016/05/Campagnolo_Tool_Kit_Super_Record_Wooden_Box_Nr._16-300x225.jpg" alt="Campagnolo_Tool_Kit_Super_Record_Wooden_Box_Nr._16"></a> of the same application. The issue here is that most of the code in Optimal Spyglass tend towards making Java’s life easier to run rather than developer’s lives easier to add features.
Being in the cloud sometimes means that we have a need for long-running jobs; Monitoring system health, SQL execution systems, etc. There is a strange Java shaped hole in our toolbox for these types of jobs, but despite fitting in the toolbox, Java never fitted in our hearts. We just never felt like battling the language to do what we wanted it to do. So up until recently we have jammed Python or NodeJS into the Java shaped hole and hoped that they would be quiet and help us out until we have a better fitting solution.</p>
<h2>What about the other traditional big chunky languages?</h2>
<p><img src="http://35gd0g2fpmpc2rmy8u1ld360.wpengine.netdna-cdn.com/wp-content/uploads/2016/05/Prog-languages-300x125.png" alt="Prog-languages"></p>
<p>Java is not the only language that can run long jobs without creaking, but all of these languages have some drawbacks, big or small.</p>
<p><strong>C#</strong> is one of our favorite languages; it talks well to SQL Server, is has one of the easiest to read syntax for your traditional developer types, it compiles to a proper executable, it has a proper GC, it is easy to make services that run on windows, it has the best desktop/mobile GUI system ... and much more. All of that aside, C# has one big problem, Windows. When you run in the cloud you want your OS to quietly get on with managing the system and stay out of the way of your nicely performance tweaked code. Windows likes to poke his head in the door a little too much and then charges you license fees for the privilege. We like our code to run on Linux and C# doesn’t <a href="https://dotnet.github.io/">(yet... reliably...)</a>.</p>
<p><strong>C++</strong> makes it too hard to produce a good system in the time-frames we have available to us. When you always have in the back of your mind that if you have a bad day in the office you could accidentally fill 64 GB of RAM with an array of Integers that you forgot to clear, it’s really hard to make good code quickly. Or at least for your average non-superhero based programmer. (Where is C++ man when I need him?)</p>
<p><a href="https://nodejs.org"><strong>Node.js</strong></a> was the industry favorite child recently, but the JavaScript world is full of terrible code that no one <em>wants</em> to pay to maintain. That being said with a proper development team Node.js is a very powerful tool. (<a href="https://www.typescriptlang.org">TypeScript</a> anyone?)</p>
<p>There are many, more than this, but this blog is long as it is</p>
<p>There are many choices but from a functional point of view, Java still manages to keep its head above the ocean of programming languages.</p>
<h2>So what does this Kotlin thing do for us anyway?</h2>
<blockquote>
<p><em>“Kotlin is designed to be an industrial-strength object-oriented language, and to be a better language than Java but still be fully interoperable with Java code, allowing companies to make a gradual migration from Java to Kotlin.”</em> – Andrey Breslav, Development Lead for Kotlin.</p>
</blockquote>
<p>Kotlin is a statically typed language just like Java, that ends up as Java byte code that then can be run on the JVM. This means the outputs are .jar files as we would expect for a Java application.</p>
<p>One of Kotlin’s main selling points is that they are 100% interoperable with Java. This means that if you want a JSON serializer for your Kotlin application that you can just grab and run the rather useful Google GSON library and Kotlin will have no issues using it.</p>
<p>Another thing that Kotlin likes to brag about is its safety or mainly it’s system of avoiding NullPointerExceptions. Types in Kotlin have no ability to hold nulls (unless you ask really really nicely) which mean that there is no chance of accidentally asking for a null to split itself on “,”.</p>
<p>For us though the main thing Kotlin does is clean up the mess that is working with Java. Take the simple job of writing a line to the terminal for example. System.out.println(“Man this is annoying to do all the time”); becomes println(“Java don’t hurt me, no more!”);. This is easier to type, but also easier to read, makes developers happier. And a happy developer is a good developer.</p>
<p>There are many examples of why Kotlin helps us with writing modern cloud-based applications with Java level reliability (another blog post someday perhaps), all we know for now is we have found a better fit for that hole in our toolkit. Will it stick around? We will have to wait and see.</p>
<h5><em>Coffee to Code – Tim Gray</em></h5>
<h5><em>Tim blogs about the sharp end of code and the languages we write in.</em></h5>
]]></description><link>http://optimalbi.com/blog/2016/05/20/kotlin-dragging-java-into-the-modern-world/</link><guid isPermaLink="true">http://optimalbi.com/blog/2016/05/20/kotlin-dragging-java-into-the-modern-world/</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Tim Gray]]></dc:creator><pubDate>Fri, 20 May 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[Gradle Meets Kotlin]]></title><description><![CDATA[<p>Back at <strong>JavaOne 2015</strong>, during a lunch break we started chatting with <strong>Hans Dockter, CEO of Gradle</strong>. A couple of days after the conference, a few of us were at the Gradle offices talking about what would be the beginning of the collaboration between JetBrains and Gradle; to bring first-class tooling and support for a static language to Gradle.</p>
<p>Today, at the <a href="http://info.jetbrains.com/Kotlin-Night-2016.html">Kotlin Night in San Francisco</a>, Hans Dockter demoed the first milestone of writing a Gradle build script using Kotlin.</p>
<iframe src="https://www.youtube.com/embed/4gmanjWNZ8E" allowfullscreen="" frameborder="0" height="480" width="960"></iframe>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">import</span> org.gradle.api.plugins.*
<span class="hljs-keyword">import</span> org.gradle.api.tasks.wrapper.*
<span class="hljs-keyword">import</span> org.gradle.script.lang.kotlin.*

apply&#x3C;ApplicationPlugin>()

configure&#x3C;ApplicationPluginConvention> {
    mainClassName = <span class="hljs-string">"samples.HelloWorld"</span>
}

repositories {
    jcenter()
}

dependencies {
    <span class="hljs-string">"testCompile"</span>(<span class="hljs-string">"junit:junit:4.12"</span>)
}</code></pre>
<p>Gradle allows developers and build engineers to deal with complex build automation scripts. As complexity grows, having a language that is statically-typed can help detect potential misconfigurations at compile time, contributing in reducing runtime issues. Static typing also opens up the door to more sophisticated tooling. All this, combined with key characteristics of Kotlin that enable easy creation of DSL’s, can provide Gradle users benefits while maintaining the level of fluency they are accustomed to.</p>
<p>For the past 6 months, we’ve been working closely with the Gradle team, in particular with Chris Beams and Rodrigo de Oliveira in bringing Kotlin to Gradle. It has been a tremendously rewarding experience because it has also helped us see use-case scenarios for making scripting in Kotlin a first-class citizen.</p>
<p>We are very excited for what Gradle has in store and are happy to continue collaborating with them closely in bringing a great experience to Gradle users.</p>
<p>For more information and how to get the bits to start playing with this, make sure you read the <a href="http://gradle.org/blog/kotlin-meets-gradle">blog post by the Gradle team</a> for more details. In addition, if you are on the public <a href="https://kotlinlang.slack.com"><strong>Kotlin Slack</strong></a>, there’s a newly created <strong>#gradle</strong> channel for discussions.</p>
]]></description><link>http://blog.jetbrains.com/kotlin/2016/05/gradle-meets-kotlin/</link><guid isPermaLink="true">http://blog.jetbrains.com/kotlin/2016/05/gradle-meets-kotlin/</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Gradle]]></category><dc:creator><![CDATA[Hadi Hariri]]></dc:creator><pubDate>Wed, 18 May 2016 02:18:00 GMT</pubDate></item><item><title><![CDATA[Kotlin Meets Gradle]]></title><description><![CDATA[<p>Many readers will be familiar with JetBrains’ excellent <a href="http://kotlinlang.com">Kotlin</a> programming language. It’s been under development since 2010, had its first public release in 2012, and went 1.0 GA earlier this year.</p>
<p>We’ve been watching Kotlin over the years, and have been increasingly impressed with what the language has to offer, as well as with its considerable uptake—particularly in the Android community.</p>
<p>Late last year, Hans sat down with a few folks from the JetBrains team, and they wondered together: what might it look like to have a Kotlin-based approach to writing Gradle build scripts and plugins? How might it help teams—especially big ones—work faster and write better structured, more maintainable builds?</p>
<p>The possibilities were enticing.</p>
<p>Because Kotlin is a statically-typed language with deep support in both IDEA and Eclipse, it could give Gradle users proper IDE support from auto-completion to refactoring and everything in-between. And because Kotlin is rich with features like first-class functions and extension methods, it could retain and improve on the best parts of writing Gradle build scripts—including a clean, declarative syntax and the ability to craft DSLs with ease.</p>
<p>So we got serious about exploring these possibilities, and over the last several months we’ve had the pleasure of working closely with the Kotlin team to develop a new, Kotlin-based build language for Gradle.</p>
<p>We call it Gradle Script Kotlin, and Hans just delivered the first demo of it onstage at JetBrains’ Kotlin Night event in San Francisco. We’ve <a href="https://github.com/gradle/gradle-script-kotlin/releases/tag/v1.0.0-M1">released the first milestone</a> towards version 1.0 of this work today, along with open-sourcing its repository at <a href="https://github.com/gradle/gradle-script-kotlin">https://github.com/gradle/gradle-script-kotlin</a>.</p>
<p><a href="http://gradle.wpengine.netdna-cdn.com/wp-content/uploads/2016/05/KotlinGradleBanner.gif"><img src="http://gradle.wpengine.netdna-cdn.com/wp-content/uploads/2016/05/KotlinGradleBanner.gif" alt="KotlinGradleBanner"></a></p>
<p>So what does it look like, and what can you do with it? At a glance, it doesn’t look <em>too</em> different from the Gradle build scripts you know today:</p>
<p><a href="http://gradle.wpengine.netdna-cdn.com/wp-content/uploads/2016/05/pasted-image-0.png"><img src="http://gradle.wpengine.netdna-cdn.com/wp-content/uploads/2016/05/pasted-image-0.png" alt="pasted image 0"></a></p>
<p>But things get very interesting when you begin to explore what’s possible in the IDE. You’ll find that, suddenly, the things you usually expect from your IDE <em>just work</em>, including:</p>
<ul>
<li>auto-completion and content assist</li>
<li>quick documentation</li>
<li>navigation to source</li>
<li>refactoring and more</li>
</ul>
<p>The effect is dramatic, and we think it’ll make a big difference for Gradle users. Now, you might be wondering about a few things at this point—like whether existing Gradle plugins will work with Gradle Script Kotlin (yes, they will), and whether writing build scripts in Groovy is deprecated (no, it’s not). You can find complete answers to these and other questions in the <a href="https://github.com/gradle/gradle-script-kotlin/wiki/Frequently-Asked-Questions">project FAQ</a>. Do let us know if you have a question that’s not answered there.</p>
<p>Of course, all this is just the beginning. We’re happy to announce that Kotlin scripting support will be available in Gradle 3.0, and we’ll be publishing more information about our roadmap soon. In the meantime, there’s no need to wait—you can try out Gradle Script Kotlin for yourself right now by <a href="https://github.com/gradle/gradle-script-kotlin/tree/master/samples#readme">getting started with our samples</a>.</p>
<p>And we hope you do, because we’d love your feedback. We’d love to hear what you think, and how you’d like to see this new work evolve. You can file issues via the project’s <a href="https://github.com/gradle/gradle-script-kotlin/issues">GitHub Issues</a> and please come chat with us in the #gradle channel of the public <a href="http://kotlinslackin.herokuapp.com/">Kotlin Slack</a>.</p>
<p>I’d like to say a big thanks to my colleague Rodrigo B. de Oliveira for the last few months of working together on this project—it’s been a lot of fun! And a big thanks to the Kotlin team, in particular Ilya Chernikov and Ilya Ryzhenkov for being so responsive in providing us with everything we needed in the Kotlin compiler and Kotlin IDEA plugin. Onward!</p>
]]></description><link>http://gradle.org/blog/kotlin-meets-gradle/</link><guid isPermaLink="true">http://gradle.org/blog/kotlin-meets-gradle/</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Gradle]]></category><dc:creator><![CDATA[Chris Beams]]></dc:creator><pubDate>Wed, 18 May 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[Gradle Elevates the Build to First-Class Programming With Kotlin Language]]></title><description><![CDATA[<h2>Alliance between Gradle Inc. and JetBrains makes the Build a first-class citizen in Software Development</h2>
<p>SAN FRANCISCO--(<a href="http://www.businesswire.com/">BUSINESS WIRE</a>)--Gradle Inc. today announced an alliance with JetBrains to provide a Kotlin-based Build Programming Language for Gradle, the popular open source build automation software.</p>
<blockquote>
<p>Build programming is advanced engineering— @Gradle @JetBrains alliance promotes @Kotlin-based builds #ElevateBuilds</p>
</blockquote>
<p>Why is this important? Historically, build automation has relied on simplistic shell scripts or inflexible XML files. This no longer works. In the age of Continuous Delivery and DevOps, builds have become a full-fledged engineering discipline. Today, a product’s build is mission-critical; it automates and assembles, connects, tests, packages and—in many cases—deploys or ships that product. As such, the design, implementation and maintainability of build code demands first-class treatment. Today, Gradle is taking the next step in elevating the discipline of build automation by supporting writing Gradle builds in Kotlin—a modern, pragmatic, and statically-typed language developed by JetBrains. The result for Gradle users will be best-in-class usability and performance, and deep IDE support in IntelliJ IDEA and Eclipse—including refactoring, symbol navigation, code completion and content assist.
Why is this important? Historically, build automation has relied on simplistic shell scripts or inflexible XML files. This no longer works. In the age of Continuous Delivery and DevOps, builds have become a full-fledged engineering discipline. Today, a product’s build is mission-critical; it automates and assembles, connects, tests, packages and—in many cases—deploys or ships that product. As such, the design, implementation and maintainability of build code demands first-class treatment. Today, Gradle is taking the next step in elevating the discipline of build automation by supporting writing Gradle builds in Kotlin—a modern, pragmatic, and statically-typed language developed by JetBrains. The result for Gradle users will be best-in-class usability and performance, and deep IDE support in IntelliJ IDEA and Eclipse—including refactoring, symbol navigation, code completion and content assist.</p>
<p>“JetBrains is widely respected for their excellent products.” said Hans Dockter, CEO and founder of Gradle Inc. “This alliance is based on mutual technical admiration and a common goal to place the most effective tools in the hands of developers.”</p>
<p>Build programming is an advanced engineering discipline— @Gradle @JetBrains alliance promotes @Kotlin-based builds #ElevateBuilds</p>
<p><strong>Modern Build Infrastructure, Largest Community</strong></p>
<p>A majority of enterprises are already using Gradle to build and deliver mission-critical software written in dozens of programming languages and platforms including Java, Android, C, C++, Python, Kotlin, Groovy, Scala, Hadoop and many more. Gradle is the new market leader for build automation, with 10.4 million direct downloads in 2015, and is growing fast with nearly 2 million new direct downloads per month in 2016. Because Gradle is a core part of Google’s Android Studio IDE (based on JetBrains’ IntelliJ IDEA), virtually every Android developer also uses Gradle. The fact that Google chose both JetBrains and Gradle Inc. for Android tooling further validates IntelliJ IDEA and Gradle as world-class technologies.</p>
<p>“The ultimate goal of Kotlin is to make developers' lives easier, and we’re excited to partner with a great product like Gradle on this mission.” said Andrey Breslav, Kotlin team lead at JetBrains. “Together we’ll create a unique experience to the benefit of Gradle’s many users.”</p>
<p><strong>Advanced Customers Lead the Way</strong></p>
<p>Mobile, SaaS, IoT and Container technologies along with modern DevOps practices have transformed the requirements for modern build systems. With the DevOps and Continuous Delivery age producing more and more complex automation requirements on the build, there is an increased need to see build code as first-class, performance optimized software—an enterprise asset as opposed to a collection of scattered, convenience scripts.</p>
<p>“We are building the future of software delivery for all enterprises by working closely and at a large scale with some of the best software teams in the world.” said Adam Murdoch, CTO and co-founder of Gradle Inc. “We see these teams increasing their investment in scaling up their automation pipeline to improve their ability to deliver software.”</p>
<p>With organizations running tens of thousands of builds a day, having a fast, maintainable, extensible build is required to be successful. Since build code has become a first-class citizen in software, the need for a statically-typed, elegant, high-performing build language with deep IDE integration led Gradle to embrace Kotlin.</p>
<p><strong>Learn More at Gradle Summit 2016</strong></p>
<p>Learn more about this development and much more at the Continuous Delivery conference of the year, Gradle Summit 2016 in Palo Alto CA June 23-24th. You can win a free ticket at <a href="http://cts.businesswire.com/ct/CT?id=smartlink&#x26;url=http%253A%252F%252Fgradle.org&#x26;esheet=51343942&#x26;newsitemid=20160517006230&#x26;lan=en-US&#x26;anchor=http%253A%252F%252Fgradle.org&#x26;index=1&#x26;md5=0a36f28ca4ba005bd64f525e4c278adf">http://gradle.org</a>.</p>
<p><strong>About Gradle</strong></p>
<p>Gradle Inc. is a Silicon Valley startup whose mission is to transform how software is built and shipped. Gradle Inc. develops, distributes and supports the Gradle Platform—consisting of the popular Gradle open source build tool and Gradle.com commercial SaaS service. With approximately 2 million downloads per month, Gradle is the most popular build automation system world-wide. Powered by a unique Build Programming Language, Gradle also boasts an ecosystem with over eight hundred plugins supporting all facets of software development and deployment. Gradle is at the heart of the Continuous Delivery pipelines of some of the most advanced software companies in the world including LinkedIn, Netflix, Unity Technologies and many more. Gradle helps enterprises ship software faster, with fewer defects, and more continuously by unifying and automating build processes. Gradle Inc. also provides training, consulting and support for its customers. Our motto is “Build Happiness”. Learn more at <a href="http://cts.businesswire.com/ct/CT?id=smartlink&#x26;url=http%253A%252F%252Fgradle.org&#x26;esheet=51343942&#x26;newsitemid=20160517006230&#x26;lan=en-US&#x26;anchor=gradle.org&#x26;index=2&#x26;md5=3e96189fc8c662c318c35dfc5645b553">gradle.org</a> and follow us on Twitter at <a href="http://cts.businesswire.com/ct/CT?id=smartlink&#x26;url=http%253A%252F%252Ftwitter.com%252Fgradle&#x26;esheet=51343942&#x26;newsitemid=20160517006230&#x26;lan=en-US&#x26;anchor=%2540Gradle&#x26;index=3&#x26;md5=83692a7d6b9a8e7968410ff7e19a8df2">@Gradle</a>.</p>
<p><strong>About JetBrains</strong></p>
<p>JetBrains s.r.o. is a technology-leading software development firm specializing in the creation of intelligent, productivity-enhancing software. It maintains its headquarters in Prague, Czech Republic, with its R&#x26;D labs located in St. Petersburg, Moscow, Munich and Boston. JetBrains employs over 600 people and is organically grown. Its product catalogue includes award-winning tools such as IntelliJ IDEA and ReSharper, and its IntelliJ Platform has been chosen by variety of companies to build their own tooling on, including Google's Android Studio. For more information, see <a href="http://cts.businesswire.com/ct/CT?id=smartlink&#x26;url=https%253A%252F%252Fwww.jetbrains.com%252F&#x26;esheet=51343942&#x26;newsitemid=20160517006230&#x26;lan=en-US&#x26;anchor=www.jetbrains.com&#x26;index=4&#x26;md5=b00800605a6efcea3b36eed88b76c699">www.jetbrains.com</a>.</p>
]]></description><link>http://www.businesswire.com/news/home/20160517006230/en/Gradle-Elevates-Build-First-Class-Programming-Kotlin-Language</link><guid isPermaLink="true">http://www.businesswire.com/news/home/20160517006230/en/Gradle-Elevates-Build-First-Class-Programming-Kotlin-Language</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Gradle]]></category><dc:creator><![CDATA[BusinessWire]]></dc:creator><pubDate>Tue, 17 May 2016 11:16:00 GMT</pubDate></item><item><title><![CDATA[Kotlin 1.0.2 is Here]]></title><description><![CDATA[<p>We’re happy to announce the release of Kotlin 1.0.2, the second bugfix and tooling update for Kotlin. In addition to compiler and language bugfixes, Kotlin 1.0.2 adds a number of major features to the IDE and the build tools.</p>
<h3>Incremental Compilation in Gradle and the IDE</h3>
<p>The new release continues our work on Kotlin incremental compilation support, speeding up the turnaround time during development. Incremental compilation in the IDE (which was previously marked as experimental) is now enabled by default. Also, the long-awaited support for <strong>incremental compilation in Gradle builds</strong> is now there.</p>
<p>To enable incremental compilation for Gradle, you need to set the <strong>kotlin.incremental</strong> property to true (for example, by adding the line <code>kotlin.incremental=true</code> to the <code>gradle.properties</code> file in the root directory of your project).</p>
<h3>Android Lint Checks</h3>
<p>Kotlin 1.0.2 introduces support for <strong>Android Lint checks</strong> for Kotlin code, ensuring that issues like using the API not available in the Android version you’re targeting are correctly detected.</p>
<p>The set of checks supported in Kotlin 1.0.2 corresponds to the checks supported in Android Studio 1.5; checks added or improved in Android Studio 2.0 will be supported in the next release of Kotlin. Also, the current version runs Lint checks for Kotlin code only inside the IDE (as part of on-the-fly code inspections, or in batch mode through Analyze | Inspect Code). Running checks from the command line will be supported in the next release.</p>
<h3>Compact Standard Library</h3>
<p>One other improvement relevant for Android developers is that the size of the standard library has been reduced by ~1500 methods (from approximately 6600 to 5100). Even before this change, the library was <a href="https://github.com/SidneyXu/AndroidDemoIn4Languages">smaller than those of Kotlin’s main competitors</a>, and now the situation is even better. Of course, the library is still fully binary compatible.</p>
<h3>Java 7/8 Support Libraries</h3>
<p>As a temporary workaround for better Java 7/8 support before full support is introduced in Kotlin 1.1, we’re now providing support libraries that expose the APIs added in Java 7 and 8 (such as the Stream API) as extension functions on Kotlin standard library classes. See the <a href="https://discuss.kotlinlang.org/t/jdk7-8-features-in-kotlin-1-0/1625">forum post</a> for instructions on using the libraries.</p>
<h3>IntelliJ IDEA Plugin features</h3>
<p>The IntelliJ IDEA plugin has gained a number of major new features:</p>
<ul>
<li>For users of Android Studio, there’s now a possibility to create a <strong>new activity</strong> in Kotlin;</li>
<li>For users of IntelliJ IDEA Ultimate, there is now initial support for the <strong>Spring Framework</strong>, including inspections, line markers, SpEL language injection support, actions to generate dependencies, and more;</li>
<li>A bunch of <strong>inspections and quickfixes</strong> have been added, such as an inspection for highlighting <code>var</code>s that can be <code>val</code>;</li>
<li>Improvements to Gradle integration, debugger, formatter, refactorings and other areas of the plugin.</li>
</ul>
<h3>JavaScript support</h3>
<p>We’ve resumed work on our JavaScript backend, and the version 1.0.2 fills in most of the remaining gaps in the language feature support when targeting JavaScript. Newly supported features include nested classes, local classes, non-local returns in local lambdas, unsafe casts and more.</p>
<h3>Maven Archetype</h3>
<p>We’re now providing a Maven archetype to easily create Kotlin projects. Use “New project | Maven | Create from Archetype...” in IntelliJ IDEA, or the following command line:</p>
<pre><code class="hljs language-kotlin">mvn archetype:generate -Dfilter=org.jetbrains.kotlin:</code></pre>
<h3>Dokka 0.9.8</h3>
<p>Together with Kotlin 1.0.2, we’re releasing a new version of <a href="https://github.com/kotlin/dokka">Dokka</a>, the Kotlin documentation generation tool. If you’re using Dokka in your project, you need to upgrade Dokka together with Kotlin, because older Dokka versions are incompatible with Kotlin 1.0.2. New features in Dokka 0.9.8 include:</p>
<ul>
<li>Android Gradle plugin, for generating documentation for Android libraries and applications;</li>
<li>Support for generating a javadoc jar file in the Maven plugin.</li>
</ul>
<h3>Conclusion</h3>
<p>You can see the full list of bugfixes and changes to the compiler, standard library and the tools in the <a href="https://github.com/JetBrains/kotlin/blob/1.0.2/ChangeLog.md">changelog</a>.</p>
<p>While working on the release, we received a lot of valuable feedback from the users of the <a href="https://discuss.kotlinlang.org/t/kotlin-1-0-2-eap/1581">Early Access Preview builds</a>. We’re really grateful to everyone who has provided feedback, and we welcome you to join the EAP program for future updates.</p>
<p>As usual, if you run into any problems with the new release, you’re welcome to ask for help on the <a href="https://discuss.kotlinlang.org/">forums</a>, on Slack (get an invite <a href="http://kotlinslackin.herokuapp.com/">here</a>), or to report issues in the <a href="https://youtrack.jetbrains.com/issues/KT">issue tracker</a>.</p>
]]></description><link>http://blog.jetbrains.com/kotlin/2016/05/kotlin-1-0-2-is-here/</link><guid isPermaLink="true">http://blog.jetbrains.com/kotlin/2016/05/kotlin-1-0-2-is-here/</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Release]]></category><dc:creator><![CDATA[Dmitry Jemerov]]></dc:creator><pubDate>Fri, 13 May 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[Kosent]]></title><description><![CDATA[<p>I've just released <a href="https://github.com/dmcg/konsent">Kosent</a>, an acceptance testing library for Kotlin.</p>
<p>The basic idea is that you can write your tests in a nice IDE-friendly and refactorable Kotlin DSL, but they generate
Gherkin that your customer can read and approve as the spec.</p>
<p>So you write this</p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@RunWith(Konsent::class)</span>
<span class="hljs-meta">@Preamble(
    <span class="hljs-meta-string">"As a developer named Duncan"</span>,
    <span class="hljs-meta-string">"I want to know that example.com is up and running"</span>)</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KonsentExampleTests</span> : <span class="hljs-type">ChromeAcceptanceTest</span></span>() {

    <span class="hljs-keyword">val</span> duncan = actorNamed(<span class="hljs-string">"Duncan"</span>)

    <span class="hljs-meta">@Scenario(1)</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> `Example_dot_com loads`<span class="hljs-params">()</span></span> {
        Given(duncan).loadsThePageAt(<span class="hljs-string">"http://example.com"</span>)
        Then(duncan) {
            shouldSee(::`the page location`, pathContains(<span class="hljs-string">"example.com"</span>))
            shouldSee(::`the page title`, equalTo(<span class="hljs-string">"Example Domain"</span>))
            shouldSee(::`the page content`, containsALink(<span class="hljs-string">"More information..."</span>, <span class="hljs-string">"http://www.iana.org/domains/example"</span>))
        }
    }

    <span class="hljs-meta">@Scenario(2, <span class="hljs-meta-string">"Following a link from example.com"</span>)</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">cant_have_dots_in_quoted_method_names</span><span class="hljs-params">()</span></span> {
        Given(duncan).loadsThePageAt(<span class="hljs-string">"http://example.com"</span>)
        When(duncan).followsTheLink(<span class="hljs-string">"More information..."</span>, <span class="hljs-string">"http://www.iana.org/domains/example"</span>)
        Then(duncan).shouldSee(::`the page location`, equalTo(URI(<span class="hljs-string">"http://www.iana.org/domains/reserved"</span>)))
    }

    <span class="hljs-meta">@Scenario(3)</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> `Dispensing with the given <span class="hljs-keyword">when</span> then`<span class="hljs-params">()</span></span> {
        duncan.he.loadsThePageAt(<span class="hljs-string">"http://example.com"</span>)
        duncan.he.followsTheLink(<span class="hljs-string">"More information..."</span>, <span class="hljs-string">"http://www.iana.org/domains/example"</span>)
        duncan.shouldSee(::`the page location`, equalTo(URI(<span class="hljs-string">"http://www.iana.org/domains/reserved"</span>)))
    }
}</code></pre>
<p>and they read this</p>
<pre><code class="hljs language-gherkin"><span class="hljs-keyword">Feature</span>: Konsent Example Tests
    As a developer named Duncan
    I want to know that example.com is up and running

    <span class="hljs-keyword">Scenario</span>: Example_dot_com loads
        <span class="hljs-keyword">Given</span> Duncan loads the page at <span class="hljs-string">"http://example.com"</span>
        <span class="hljs-keyword">Then</span> Duncan sees the page location <span class="hljs-string">"location contains "</span>example.com<span class="hljs-string">"
        and Duncan sees the page title is equal to "</span>Example Domain<span class="hljs-string">"
        and Duncan sees the page content contains a link [More information...](http://www.iana.org/domains/example)

    Scenario: Following a link from example.com
        Given Duncan loads the page at "</span>http://example.com<span class="hljs-string">"
        When Duncan follows the link [More information...](http://www.iana.org/domains/example)
        Then Duncan sees the page location is equal to http://www.iana.org/domains/reserved

    Scenario: Dispensing with the given when then
        Duncan loads the page at "</span>http://example.com<span class="hljs-string">"
        Duncan follows the link [More information...](http://www.iana.org/domains/example)
        Duncan sees the page location is equal to http://www.iana.org/domains/reserved</span></code></pre>
<p>Thanks to my patrons at <a href="http://springernature.com">Springer Nature</a>, on whose dime this approach has been developed. We're
hiring, so <a href="https://twitter.com/duncanmcg">get in touch</a> if you're in London and this stuff interests you.</p>
<p>Stay tuned - I'm planning a post soon on how to implement a DSL like this in Kotlin.</p>
]]></description><link>http://oneeyedmen.com/konsent.html</link><guid isPermaLink="true">http://oneeyedmen.com/konsent.html</guid><category><![CDATA[Testing]]></category><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Duncan McGregor]]></dc:creator><pubDate>Thu, 12 May 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[Testing in Kotlin]]></title><description><![CDATA[<p>Following on from my recent article on Kotlin for Scala developers, in this blog I’ll introduce how you can use the <a href="https://github.com/kotlintest/kotlintest">KotlinTest</a> framework to write unit tests in Kotlin, which is a great way to begin exploring Kotlin.</p>
<p>KotlinTest is based on <a href="http://www.scalatest.org/">ScalaTest</a> (a superb jUnit like test framework created by Bill Venners) and offers the same choice of testing styles as well as many assertions and helpers for matching through the use of a light DSL.</p>
<p>To use KotlinTest first add the dependencies to your build. We’ll assume you’re using gradle (but obviously Maven is fine too).</p>
<pre><code class="hljs language-kotlin">compile <span class="hljs-string">'io.kotlintest:kotlintest:1.1.1'</span></code></pre>
<p>Then we can create a test. Each test must extend from one of the spec classes. Each spec class offers a different way of laying out your tests. Some are very similar and similar to jTest’s @Test annotation, and some are more complicated offering BDD style descriptions.</p>
<h3>Testing Styles</h3>
<p>Lets give an example of the FlatSpec, which allows you to write tests like this:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeTests</span> : <span class="hljs-type">FlatSpec</span></span>() {
  init {
    <span class="hljs-string">"ListStack.pop"</span> should <span class="hljs-string">"return the last element from stack” {
      // your test here
    }
    "</span>ListStack.pop<span class="hljs-string">" should "</span>remove the element from the stack<span class="hljs-string">" {
      // another test
    }
  }
}</span></code></pre>
<p>As you can see, you start with some text, then the keyword should, then some more text, and finally the test as a block. This gives you a readable description of what your test is doing. The split of the test description into two parts means that the IDE / build tools can nest the test output into something like:</p>
<p>ListStack.pop should</p>
<ul>
<li>return the last element from stack    ok</li>
<li>remove the element from the stack    ok</li>
</ul>
<p>All tests need to be placed inside the init {} block. For those of you coming from a Scala background, this is because Kotlin doesn’t allow the body of the class to be treated as the constructor like you can in Scala.</p>
<p>A quick example of another style is WordSpec, in which the tests are nested. So,</p>
<p>"ListStack.pop" should {
"remove the last element from stack" {
// test 1
}
}</p>
<p>"ListStack.peek" should {
"should leave the stack unmodified" {
// test 2
}
}</p>
<p>I think this is fairly self explanatory. The rest of the testing styles are available on the KotlinTest homepage.</p>
<h3>Matchers</h3>
<p>Let's move onto the matchers. When writing your tests in Java, it is common to use assertions like assertEquals(a, b). This is fine, but we can do something a bit more readable with KotlinTest. As a simple example, to assert two values are equal, we can say</p>
<pre><code class="hljs language-kotlin"><span class="hljs-string">"a"</span> shouldBe <span class="hljs-string">"a"</span> or <span class="hljs-string">"a"</span> shouldEqual <span class="hljs-string">"a"</span></code></pre>
<p>We can do clever things with strings:</p>
<pre><code class="hljs language-kotlin">someStr should start with <span class="hljs-string">"foo"</span>
someStr should end with <span class="hljs-string">"bar"</span>
someStr should have substring <span class="hljs-string">"xxx"</span></code></pre>
<p>Or with collections</p>
<pre><code class="hljs language-kotlin">myList should have size <span class="hljs-number">4</span>
mySet should contain element <span class="hljs-string">"a"</span></code></pre>
<p>There are many matchers available for collections, strings, longs, ints, etc.</p>
<p>Sometimes we need to assert that an exception is thrown under certain conditions. The typical way to do this in other test frameworks is to wrap the code in a try/catch and then assert false at the bottom of the try, eg</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">try</span> {
  <span class="hljs-comment">// this code should throw an exception</span>
  assert(<span class="hljs-literal">false</span>)
} <span class="hljs-keyword">catch</span> (Exception e) {
  <span class="hljs-comment">// good</span>
}</code></pre>
<p>We can remove this boilerplate in KotlinTest using the <code>shouldThrow&#x3C;T></code> function. Just wrap your code with this function, replacing T with the type (or supertype) of Exception you want to catch, eg</p>
<pre><code class="hljs language-kotlin">shouldThrow&#x3C;IllegalArgumentException> {
  <span class="hljs-comment">// code that should throw an exception</span>
}</code></pre>
<p>One of the more tricky things in testing, is when you have code that completes non-deterministically. Perhaps you’re sending off an async call and need to wait until a reply comes back.</p>
<p>The naive way to do this is to sprinkle your test code with Thread.sleeps but how long to wait? You don’t want the time-out to expire prematurely. So if your call takes 2 seconds to complete, you set your sleep to 5 seconds. Until the time your build server is running slow, and 5 seconds wasn't enough, so you set it to 15 seconds. But now you wait 15 seconds every time regardless.</p>
<p>Another tool is to use countdown latches, and these are often my preferred choice. Have some code trigger the latch once it's completed (i.e. in a callback) and have the main test thread block on the latch.</p>
<p>If that doesn't work, KotlinTest introduces the eventually function. This allows you to repeatedly probe for a test condition and once it passes the function will return. This means you can wait up to a set time, but no more. It’s very easy to use, you just supply the max time you’re prepared to wait before considering it a failure. Extend the Eventually interface in your test class, e.g.:</p>
<pre><code class="hljs language-kotlin">Class MyTest : FlatSpec(), Eventually {
  Init {
    <span class="hljs-string">"This test"</span> should <span class="hljs-string">"finish quickly"</span> {
      eventually(<span class="hljs-number">5</span>, TimeUnit.SECONDS) {
        <span class="hljs-comment">// code here</span>
      }
    }
  }
}</code></pre>
<p>Now if the assertions doesn't pass within 5 seconds, the test will fail. If the assertions pass quicker than 5 seconds, your test will return as soon as it can.</p>
<p>KotlinTest borrows another feature from ScalaTest in the form of inspectors. Inspectors are helpers for assertions on elements of collections.</p>
<p>Let's suppose you wanted to test that a collection of strings had one at most one string “root”, and the rest of the elements were not “root”, you could do this:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> count = strings.count { it == <span class="hljs-string">"root"</span> }
(count ==<span class="hljs-number">0</span> || count == <span class="hljs-number">1</span>) shouldBe <span class="hljs-literal">true</span></code></pre>
<p>We can do this very easily using an inspector called forAtMostOne. This function will assert that there either zero or one elements pass the assertions, otherwise the test fails.</p>
<pre><code class="hljs language-kotlin">forAtMostOne(strings) {  it == <span class="hljs-string">"root"</span> }</code></pre>
<p>There are many inspectors: forAll, forNone, forSome, forExactly(k), forAtMostOne, forAtLeastOne. The full list can be found <a href="https://github.com/kotlintest/kotlintest#inspectors">here</a></p>
<p>Another quick example to assert that in a collection of people, some of them are called David some live in London, and some work for 51zero. (By some we mean at least 1, but not all).</p>
<pre><code class="hljs language-kotlin">forSome(people) { it .firstName() shouldBe <span class="hljs-string">"David"</span> }
forSome(people) { it .location() shouldBe <span class="hljs-string">"London"</span> }
forSome(people) { it .employer() shouldBe <span class="hljs-string">"51zero"</span> }</code></pre>
<p>Writing that without an inspector would be at least a few lines longer.</p>
<p>The final thing I want to mention is setting up and tearing down tests. We can do this before and after each test, or before and after each test suite (test suite is the class file). To do this we just override whichever methods we need, e.g.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">beforeEach</span><span class="hljs-params">()</span></span> {
  println(<span class="hljs-string">"Test starting"</span>)
}

<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">afterEach</span><span class="hljs-params">()</span></span> {
  println(<span class="hljs-string">"Test completed"</span>)
}

<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">beforeAll</span><span class="hljs-params">()</span></span> {
  println(<span class="hljs-string">"Setting up my tests"</span>)
}

<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">afterAll</span><span class="hljs-params">()</span></span> {
  println(<span class="hljs-string">"Cleaning up after my tests"</span>)
}</code></pre>
<p>That’s all for now. This should help get you up and running and using Kotlin in your projects. In the next article, we’ll write about how you can create custom matchers to allow your own DSL syntax for complicated matchers.</p>
<p>Please let <a href="http://www.51zero.com/about">us</a> know your experience of testing in Kotlin in the comments below.</p>
]]></description><link>http://www.51zero.com/blog/testing-in-kotlin</link><guid isPermaLink="true">http://www.51zero.com/blog/testing-in-kotlin</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Testing]]></category><dc:creator><![CDATA[Stephen Samuel]]></dc:creator><pubDate>Tue, 10 May 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[JMock and Kotlin]]></title><description><![CDATA[<p><a href="http://www.jmock.org/">JMock</a> may have lost the mocking war, but for the London crowd it's still the go-to mocking tool.
It turns out that a little Kotlin fairy-dust can make it even more expressive.</p>
<p>In <a href="/mocks-v-approvals-tests-part2.html">my last post</a> we saw a pretty vanilla use of JMock. In fact there was <em>one</em> nice
Kotlin'ism, defining an extension method on Mockery. So where in Java we would write</p>
<pre><code class="hljs language-java">mockery.checking(<span class="hljs-keyword">new</span> Expectations() { {
    oneOf(progress).reset(<span class="hljs-number">2</span>);
    oneOf(indexer).createIndex();
} })</code></pre>
<p>in Kotlin, by defining</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> Mockery.<span class="hljs-title">expecting</span><span class="hljs-params">(block: <span class="hljs-type">MyExpectations</span>.()</span></span> -> <span class="hljs-built_in">Unit</span>) {
   <span class="hljs-keyword">this</span>.checking(MyExpectations().apply(block))
}</code></pre>
<p>we can write</p>
<pre><code class="hljs language-kotlin">mockery.expecting {
    oneOf(progress).reset(<span class="hljs-number">2</span>)
    oneOf(indexer).createIndex()
}</code></pre>
<p>In addition, in the name of more readable tests, I had added a subclass of Expectations
to allow me to write, for example</p>
<pre><code class="hljs language-kotlin">mockery.expecting {
   givenActiveJournalIds(
       <span class="hljs-string">"1"</span> to throwException(RuntimeException(<span class="hljs-string">"oops"</span>)),
       <span class="hljs-string">"2"</span> to returnValue(journal2))
   }
   ...</code></pre>
<p>This was achieved with</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyExpectations</span> : <span class="hljs-type">Expectations</span></span>() {
   <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">givenActiveJournalIds</span><span class="hljs-params">(<span class="hljs-keyword">vararg</span> idResultPairs: <span class="hljs-type">Pair</span>&#x3C;<span class="hljs-type">String</span>, Action>)</span></span> {
       allowing(journals).loadActiveIds()
       will(returnValue(idResultPairs.map { it.first }))
       idResultPairs.forEach { pair ->
           allowing(journals).loadJournalWithArticles(pair.first, <span class="hljs-number">99</span>)
           will(pair.second)
       }
   }
}</code></pre>
<p>which is tighter in Kotlin, but nothing that you couldn't do in Java.</p>
<p>Looking at a one of the tests, this plugs together into something like</p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@Test</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">reports_exceptions_and_continues</span><span class="hljs-params">()</span></span> {
   mockery.expecting {
       <span class="hljs-keyword">val</span> x = RuntimeException(<span class="hljs-string">"oops"</span>)

       givenActiveJournalIds(
           <span class="hljs-string">"1"</span> to throwException(x),
           <span class="hljs-string">"2"</span> to returnValue(journal2))

       oneOf(progress).reset(<span class="hljs-number">2</span>)
       oneOf(indexer).createIndex()

       never(indexer).index(JournalJson(journal1))
       oneOf(progress).exception(<span class="hljs-string">"1"</span>, x)

       oneOf(indexer).index(JournalJson(journal2))
       oneOf(progress).indexed(journal2)
   }
   refresher.refresh(journals, indexer, emptySet())
}</code></pre>
<p>This isn't bad, but one of JMock's problems is that it doesn't differentiate between interactions
that are queries, and those that are operations. In this case the refresher queries the <code>journals</code>
to find what needs to be indexed, then operates on the <code>indexer</code> to add them. Introducing
<code>givenActiveJournalIds</code> gives a clue, but it would be nice to see the split more formally.</p>
<p>What I'd like to see is</p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@Test</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">reports_exceptions_and_continues</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> x = RuntimeException(<span class="hljs-string">"oops"</span>)
    mockery.given {
        activeJournalIds(
            <span class="hljs-string">"1"</span> to throwException(x),
            <span class="hljs-string">"2"</span> to returnValue(journal2))
    }.whenRunning {
        refresher.refresh(journals, indexer, emptySet())
    }.thenExpect {
        oneOf(progress).reset(<span class="hljs-number">2</span>)
        oneOf(indexer).createIndex()

        never(indexer).index(JournalJson(journal1))
        oneOf(progress).exception(<span class="hljs-string">"1"</span>, x)

        oneOf(indexer).index(JournalJson(journal2))
        oneOf(progress).indexed(journal2)
    }
}</code></pre>
<p>This can be achieved through 2 extension methods and a little class -</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> Mockery.<span class="hljs-title">expecting</span><span class="hljs-params">(expectations: <span class="hljs-type">Expektations</span>.()</span></span> -> <span class="hljs-built_in">Unit</span>): Mockery {
    <span class="hljs-keyword">this</span>.checking(Expektations().apply(expectations))
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> Mockery.<span class="hljs-title">whenRunning</span><span class="hljs-params">(block: ()</span></span> -> <span class="hljs-built_in">Unit</span>) = ThenClause(<span class="hljs-keyword">this</span>, block)

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThenClause</span></span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> mockery: Mockery, <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> block: () -> <span class="hljs-built_in">Unit</span>) {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">thenExpect</span><span class="hljs-params">(expectations: <span class="hljs-type">Expektations</span>.()</span></span> -> <span class="hljs-built_in">Unit</span>) {
        mockery.expecting(expectations)
        block()
        mockery.assertIsSatisfied()
    }
}</code></pre>
<p>Actually that trick <a href="https://github.com/dmcg/nowthen">can be played in Java 8 too</a>.</p>
<p>If you're really eagle-eyed, you may have noticed <code>Expektations</code> pop up in that example.
That's to support my final trick, an extension method on <code>Nothing</code>. Why?</p>
<p>Well what if we wanted to simulate an exception in the indexing?</p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@Test</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> `reports exceptions <span class="hljs-keyword">in</span> indexing and continues`<span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> x = RuntimeException(<span class="hljs-string">"oops"</span>)
    mockery.given {
        activeJournalIds(
            <span class="hljs-string">"1"</span> to returnValue(journal1),
            <span class="hljs-string">"2"</span> to returnValue(journal2))
    }.whenRunning {
        refresher.refresh(journals, indexer, emptySet())
        executor.runUntilIdle()
    }.thenExpect {
        oneOf(progress).reset(<span class="hljs-number">2</span>)
        oneOf(indexer).createIndex()

        oneOf(indexer).index(JournalJson(journal1))
        will(throwException(x))
        oneOf(progress).exception(<span class="hljs-string">"1"</span>, x)

        oneOf(indexer).index(JournalJson(journal2))
        oneOf(progress).indexed(journal2)
    }
}</code></pre>
<p>That <code>will()</code> as a separate statement has always bothered me about JMock - it should
bind to the previous statement, but can't because <code>indexer.index(...)</code> returns <code>Unit</code>
(<code>void</code> in Java). In Kotlin we can define</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Expektations</span>: <span class="hljs-type">Expectations</span></span>() {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> Any?.<span class="hljs-title">will</span><span class="hljs-params">(action: <span class="hljs-type">Action</span>)</span></span> = <span class="hljs-keyword">super</span>.will(action)
    <span class="hljs-comment">// fun Nothing.will(action: Action) = super.will(action) Update 2016-05-17 - looks like this isn't needed, as Unit extends Any</span>
}</code></pre>
<p>and now within our expectation blocks we can write</p>
<pre><code class="hljs language-koklin">{
    oneOf(<span class="hljs-name">indexer</span>).index(<span class="hljs-name">JournalJson</span>(<span class="hljs-name">journal1</span>)).will(<span class="hljs-name">throwException</span>(<span class="hljs-name">x</span>))
    // or
    allowing(<span class="hljs-name">journals</span>).loadJournalWithArticles(<span class="hljs-string">"1"</span>, <span class="hljs-number">99</span>).will(<span class="hljs-name">returnValue</span>(<span class="hljs-name">journal1</span>))
}</code></pre>
<p>With a bit of work I think that would allow a typed JMock <code>Action</code> so that you could only
<code>returnValue</code> with the correct type, but I haven't pulled on that thread yet.</p>
<p>The final bonus marks in this post go for spotting</p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@Test</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> `reports exceptions <span class="hljs-keyword">in</span> indexing and continues`<span class="hljs-params">()</span></span></code></pre>
<p>Ignoring the fact that it breaks <a href="http://prismjs.com/">Prism</a>'s Kotlin highlighter, this hack was pointed out by
<a href="http://natpryce.com">Nat Pryce</a> - backticks allow spaces in method names, giving beautifully
readable specs in code and test runners.</p>
]]></description><link>http://www.oneeyedmen.com/jmock-and-kotlin.html</link><guid isPermaLink="true">http://www.oneeyedmen.com/jmock-and-kotlin.html</guid><category><![CDATA[Unit Testing]]></category><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Duncan McGregor]]></dc:creator><pubDate>Sun, 01 May 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[Exercises in Kotlin: Part 5 - Classes]]></title><description><![CDATA[<p>After the last post <a href="http://dnblog.ddesk/2016/04/exercises-in-kotlin-part-4-control-flows-and-return/">Exercises in Kotlin: Part 4 - Control flows and return</a>, we shall be exploring classes and objects in the exercises in this post. While retaining many similarities to Java classes, there are actually significant differences in syntax as well and these help classes become a little easier to work with in Kotlin. And save a lot of unnecessary boilerplate code.</p>
<h2>Minimalist Syntax</h2>
<p>Probably the minimalistic (and for all practical purposes useless) declaration of a class in Kotlin will be</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span></span></code></pre>
<h2>A typical class</h2>
<p>Thats it. No constructor, no fields, no body. However as is obvious this is not particularly useful. Let us look at a more useful one.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span> </span>(<span class="hljs-keyword">val</span> number: String, <span class="hljs-keyword">var</span> balance: BigDecimal) {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">deposit</span><span class="hljs-params">(amount: <span class="hljs-type">BigDecimal</span>)</span></span> {
        balance += amount
    }
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(amount: <span class="hljs-type">BigDecimal</span>)</span></span> {
        <span class="hljs-keyword">if</span> (balance &#x3C; amount) {
            <span class="hljs-keyword">throw</span> Exception(<span class="hljs-string">"Insufficient funds in the account"</span>)
        }
        balance -= amount
    }
}</code></pre>
<p>Here <code>Account</code> is the class name. It has two properties <code>number</code> which is a <code>String</code> and <code>balance</code> which is a <code>BigDecimal</code>. Another aspect is <code>number</code> is a read-only property ie. you can't change the value within the body of the class (say in a method) after one is provided at the construction time. As mentioned in an earlier post read-only properties (aka <code>final</code> in Java terms) are identified by the keyword <code>val</code>, while read-write properties are identified by <code>var</code>. Notice the succinct constructor. The properties of the class that are required by the primary constructor are specified immediately after the class name within parenthesis. You can have variables declared in the constructor that are neither <code>val</code>s nor <code>var</code>s. However they can be used only during construction time and do not become properties of the class (more about that later). Thus unlike Java you don't need to write constructors just in order copy values from the constructor parameter to a member field. Also unlike Java you do not need to write getter/ setter methods in most cases (though you could if you had a specific reason to write custom getter/setters).</p>
<p>Client code for the account class could perhaps use it as follows. Do note that the object is instantiated using the <code>ClassName(parameter_list)</code> construct. It is essentially similar to Java except that there is no <code>new</code> keyword preceding it.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">// Instantiate object</span>
<span class="hljs-keyword">val</span> acc1 = Account(<span class="hljs-string">"123"</span>, BigDecimal(<span class="hljs-string">"456.70"</span>))

<span class="hljs-comment">// get value of a property and print it</span>
println(acc1.number)

<span class="hljs-comment">// invoke a method</span>
acc1.deposit(BigDecimal(<span class="hljs-string">"234.56"</span>))

<span class="hljs-comment">// change the value of a property</span>
acc1.balance = BigDecimal(<span class="hljs-string">"567.89"</span>)</code></pre>
<h2>Member Visibility</h2>
<p>Now <code>balance</code> needs to be a <code>var</code> since it changes. But some might be disappointed at how it can be modified from outside the class. One solution would be to make it a <code>private var</code> as follows</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span> </span>(<span class="hljs-keyword">val</span> number: String, <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> balance: BigDecimal) {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">deposit</span><span class="hljs-params">(amount: <span class="hljs-type">BigDecimal</span>)</span></span> {
        balance += amount
    }
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(amount: <span class="hljs-type">BigDecimal</span>)</span></span> {
        <span class="hljs-keyword">if</span> (balance &#x3C; amount) {
            <span class="hljs-keyword">throw</span> Exception(<span class="hljs-string">"Insufficient funds in the account"</span>)
        }
        balance -= amount
    }
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">somewhereElse</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> acc1 = Account(<span class="hljs-string">"123"</span>, BigDecimal(<span class="hljs-string">"456.70"</span>))

    <span class="hljs-comment">// The following wouldn't compile</span>
    acc1.balance = BigDecimal(<span class="hljs-string">"567.89"</span>)

    <span class="hljs-comment">// But neither would the following line</span>
    println(acc1.balance)
}</code></pre>
<p>What if you wanted it to be read-only from outside the class but read-write within the class? You could choose to use the following approach of passing in a parameter to the constructor, using it to declare another property within the body of the class and then declaring that variable to have a private setter. Note that in this case <code>initBalance</code> is simply a parameter passed to the constructor (since it is not declared as either a <code>val</code> or a <code>var</code>), and can be accessed in a read only fashion only during the construction stage. (Thus other methods cannot use this parameter)</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span> </span>(<span class="hljs-keyword">val</span> number: String, initBalance: BigDecimal) {
    <span class="hljs-keyword">var</span> balance = initBalance
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">deposit</span><span class="hljs-params">(amount: <span class="hljs-type">BigDecimal</span>)</span></span> {
        balance += amount
    }

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(amount: <span class="hljs-type">BigDecimal</span>)</span></span> {
        <span class="hljs-keyword">if</span> (balance &#x3C; amount) {
            <span class="hljs-keyword">throw</span> Exception(<span class="hljs-string">"Insufficient funds in the account"</span>)
        }
        balance -= amount
    }
}</code></pre>
<h2>Multiple constructors</h2>
<p>Now let us assume that we wish to allow the constructor to use a String based value for balance though the balance property on the account should continue to be a BigDecimal. You could modify the class as follows.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span> </span>(<span class="hljs-keyword">val</span> number: String, initBalance: String) {
    <span class="hljs-keyword">var</span> balance = BigDecimal(initBalance)
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">deposit</span><span class="hljs-params">(amount: <span class="hljs-type">BigDecimal</span>)</span></span> {
        balance += amount
    }
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(amount: <span class="hljs-type">BigDecimal</span>)</span></span> {
        <span class="hljs-keyword">if</span> (balance &#x3C; amount) {
            <span class="hljs-keyword">throw</span> Exception(<span class="hljs-string">"Insufficient funds in the account"</span>)
        }
        balance -= amount
    }
}</code></pre>
<p>Here <code>balance</code> is being initialised by constructing a <code>BigDecimal</code> using the <code>String</code> value. But we know if the value passed in is not a number, a <code>NumberFormatException</code> will be thrown. But we can't see that in the constructor declaration anywhere. Huh?</p>
<p>I won't dwell long on that, but note that Kotlin (unlike Java) does <em>NOT</em> use checked exceptions. Any method could throw any exception at any point in time and it does not have to be documented as a part of the method signature. A fuller discussion of this is beyond the scope of this post, but it should be stated that the conventional wisdom tends towards preferring unchecked exceptions and kotlin supports that style of programming.</p>
<p>Now let us assume we wish to have both types of constructors, one taking the initial balance as a <code>String</code> and another as a BigDecimal. Each class can have one primary and zero or more secondary constructors, each one of them eventually calling the primary constructor via the keyword <code>this</code>. Note the parameter lists to secondary constructors cannot declare properties using <code>val</code> or <code>var</code> since these are anyways in turn declared by the primary constructor.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span> </span>(<span class="hljs-keyword">val</span> number: String, initBalance: BigDecimal) {
    <span class="hljs-keyword">constructor</span>(number: String, initBalance: String) :
        <span class="hljs-keyword">this</span>(number, BigDecimal(initBalance))

    <span class="hljs-keyword">var</span> balance = initBalance
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">deposit</span><span class="hljs-params">(amount: <span class="hljs-type">BigDecimal</span>)</span></span> {
        balance += amount
    }
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(amount: <span class="hljs-type">BigDecimal</span>)</span></span> {
        <span class="hljs-keyword">if</span> (balance &#x3C; amount) {
            <span class="hljs-keyword">throw</span> Exception(<span class="hljs-string">"Insufficient funds in the account"</span>)
        }
        balance -= amount
    }
}</code></pre>
<p>So far our constructors have been only initialising properties. But what if you wanted them to do more. I have shown the way to do so by adding additional <code>println()</code> statements during both the primary and secondary construction phases as below.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span> </span>(<span class="hljs-keyword">val</span> number: String, initBalance: BigDecimal) {
    init {
        println(<span class="hljs-string">"Into primary constructor"</span>)
    }
    <span class="hljs-keyword">constructor</span>(number: String, initBalance: String) :
        <span class="hljs-keyword">this</span>(number, BigDecimal(initBalance)) {
        println(<span class="hljs-string">"Into secondary constructor"</span>)
    }

    <span class="hljs-keyword">var</span> balance = initBalance
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">deposit</span><span class="hljs-params">(amount: <span class="hljs-type">BigDecimal</span>)</span></span> {
        balance += amount
    }
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(amount: <span class="hljs-type">BigDecimal</span>)</span></span> {
        <span class="hljs-keyword">if</span> (balance &#x3C; amount) {
            <span class="hljs-keyword">throw</span> Exception(<span class="hljs-string">"Insufficient funds in the account"</span>)
        }
        balance -= amount
    }
}</code></pre>
<p>As can be seen the non property initialisation of primary constructor can be done in the <code>init{...}</code> block. Similarly secondary constructors can also include a block at the end which lists out the necessary statements to be performed.</p>
<h2>Data Classes</h2>
<p>Very often we need basic classes which are primarily place holders for a collection of different values. Though java does not have an equivalent, in C, you would have called it a <code>struct</code> and in scala you would call it a <code>case class</code>. In Kotlin we have <code>data class</code>. eg.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span></span>(<span class="hljs-keyword">val</span> x: <span class="hljs-built_in">Double</span>, <span class="hljs-keyword">val</span> y: <span class="hljs-built_in">Double</span>)</code></pre>
<p>These classes are tailored for using them as collection of other properties.</p>
<ul>
<li>A data class automatically generates a sensible <code>equals()/hashcode()</code> functions for the class based on the properties declared in the primary constructor.</li>
<li>A sensible <code>toString()</code> is automatically provided</li>
<li>Another helper method <code>copy()</code> to selectively override some property values when creating a copy is also automatically provided.</li>
<li>You can also use a data class similar to a record of values easily since it also generates <code>component1()</code>, <code>component2()</code>, ... <code>componentN()</code> functions which can treat the class as a record of sequence of properties (in the same order as declared in the primary constructor).</li>
</ul>
<p>Lets take a usage at a sample usage of the class above</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> p1 = Point(<span class="hljs-number">1.1</span>,<span class="hljs-number">2.2</span>)
println(p1)
println(p1.x)
println(p1.component1())

<span class="hljs-keyword">val</span> p2 = p1.copy(x=<span class="hljs-number">3.3</span>)
println(p2)

<span class="hljs-keyword">val</span> (x, y) = p1
println(<span class="hljs-string">""</span> + x + <span class="hljs-string">":"</span> + y)</code></pre>
<p>The output for the above will be as follows</p>
<pre><code>Point(x=1.1, y=2.2)
1.1
1.1
Point(x=3.3, y=2.2)
1.1:2.2
</code></pre>
<p>Note, how a second copy (<code>p2</code>) was easily created from the first while allowing the ability to override a few values. Also how the <code>point</code> object can be destructured into its component values, in this case <code>val</code>s <code>x</code> and <code>y</code>. If the <code>Point</code> class had 3 properties, we would have had to provide 3 variables on the left hand side of the assignment operator for it to succeed</p>
<h2>Enum classes</h2>
<p>Let us go back to the Account class example. Let us assume we wanted to add an account type member. Account type can either be <code>Savings</code> or <code>Current</code> (aka Checking). In order to allow the capability we will declare an enum class</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountType</span> </span>{
    Savings, Current
}</code></pre>
<p>Now we can go ahead and modify the Account class as follows</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span> </span>(<span class="hljs-keyword">val</span> number: String, initBalance: BigDecimal, <span class="hljs-keyword">val</span> type: AccountType){ ... }

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">somewhereElse</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> acc1 = Account(<span class="hljs-string">"123"</span>, BigDecimal(<span class="hljs-string">"456.7"</span>),AccountType.Savings)
    println(acc1.type)
}</code></pre>
<p>Now let us take a look at some of the sample usages of the enum class</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">somewhereElse</span><span class="hljs-params">()</span></span> {
    <span class="hljs-comment">// Iterate through all the enums</span>
    <span class="hljs-keyword">for</span>( accType <span class="hljs-keyword">in</span> AccountType.values()) {
        println(accType)
    }

    <span class="hljs-comment">// Every enum instance has two properties: name and ordinal</span>
    println(AccountType.Savings.name)
    println(AccountType.Current.ordinal)

    <span class="hljs-comment">// You can recreate an enum instance based on a String</span>
    println(AccountType.valueOf(<span class="hljs-string">"Savings"</span>))
}</code></pre>
<p>This program will result in the following output</p>
<pre><code>Savings
Current
Savings
1
Savings
</code></pre>
<p>Thus as you can see, <em>You could iterate through all the enum types by getting an array of all its possible types using</em> Every enum instance has two properties, a <code>name</code> which is a string and an <code>ordinal</code> which allows the enum values to be used a set of ordered values and allows them to be comparable. The name of course is the name as was provided in the declaration and ordinal is the sequence in the declaration of values. * You can use the string value of the enum to obtain an enum instance using <code>valueOf()</code></p>
<p>Finally you can provide additional properties to each of the enum instances as follows</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Color</span></span>(r: <span class="hljs-built_in">Int</span>, g: <span class="hljs-built_in">Int</span>, b: <span class="hljs-built_in">Int</span>) {
    Red(<span class="hljs-number">255</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>),
    Green(<span class="hljs-number">0</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0</span>),
    Blue(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">255</span>)
}</code></pre>
<p>We have looked at the basics of classes in this post. We will look at inheritance next.</p>
]]></description><link>http://blog.dhananjaynene.com/2016/04/exercises-in-kotlin-part-5-classes/</link><guid isPermaLink="true">http://blog.dhananjaynene.com/2016/04/exercises-in-kotlin-part-5-classes/</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Dhananjay Nene]]></dc:creator><pubDate>Fri, 29 Apr 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[Exercises in Kotlin: Part 4 - Control flows and return]]></title><description><![CDATA[<p>After <a href="http://blog.dhananjaynene.com/2016/04/exercises-in-kotlin-part-3-functions/">Exercises in Kotlin: Part 3 - Functions</a> we now take a look at control flows and actually doing some basic exercises.</p>
<h2>if/else</h2>
<p>As mentioned earlier, <code>if/else</code> is not just a statement but can also be used as an operator (in lieu of the ternary <code>? :</code> operator.</p>
<p>As an example, a familiar way to have if/else statements would be as follows.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">greeting</span><span class="hljs-params">(hours: <span class="hljs-type">Int</span>)</span></span>: String {
    <span class="hljs-keyword">var</span> greeting: String = <span class="hljs-literal">null</span>
    <span class="hljs-keyword">if</span> (hours &#x3C; <span class="hljs-number">12</span>) {
        greeting = <span class="hljs-string">"Good Morning"</span>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hours &#x3C; <span class="hljs-number">16</span>) {
        greeting = <span class="hljs-string">"Good Afternoon"</span>
    } <span class="hljs-keyword">else</span> {
        greeting = <span class="hljs-string">"Good Night"</span>
    }
    <span class="hljs-keyword">return</span> greeting
}</code></pre>
<p>But since if/else can be an expression as well, another way to write the function above would be</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">greeting2</span><span class="hljs-params">(hours: <span class="hljs-type">Int</span>)</span></span>: String =
    <span class="hljs-string">"Good "</span> + <span class="hljs-keyword">if</span> (hours &#x3C; <span class="hljs-number">12</span>) {
        <span class="hljs-string">"Morning"</span>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hours &#x3C; <span class="hljs-number">16</span>) {
        <span class="hljs-string">"Afternoon"</span>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-string">"Night"</span>
    }</code></pre>
<h2>when</h2>
<p>There is another expression that can be used instead of multiple nested if/else expressions or situations where you might use a switch/case block in Java. Using <code>when</code> the function above could be written as</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">greeting3</span><span class="hljs-params">(hours: <span class="hljs-type">Int</span>)</span></span>: String =
    <span class="hljs-string">"Good "</span> + <span class="hljs-keyword">when</span> {
        hours &#x3C; <span class="hljs-number">12</span> -> <span class="hljs-string">"Morning"</span>
        hours &#x3C; <span class="hljs-number">16</span> -> <span class="hljs-string">"Afternoon"</span>
        <span class="hljs-keyword">else</span> -> <span class="hljs-string">"Night"</span>
    }</code></pre>
<p>Note that <code>when</code> is an expression and evaluates to a value (in the case above it would be "Morning", "Afternoon" or "Night". You could also use it more conventionally just to write other blocks of code eg.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">greeting4</span><span class="hljs-params">(hours: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Unit</span> {
 <span class="hljs-keyword">when</span> {
        hours &#x3C; <span class="hljs-number">12</span> -> {
            println(<span class="hljs-string">"Morning"</span>)
        }
        hours &#x3C; <span class="hljs-number">16</span> -> {
            println(<span class="hljs-string">"Afternoon"</span>)
        }
        <span class="hljs-keyword">else</span> -> {
            println(<span class="hljs-string">"Night"</span>)
        }
    }
}</code></pre>
<p>As you can note, there is no break statement (unlike switch case), and the right hand side of the conditions can be blocks which consist of multiple statements. If used as a part of a when expression, the value returned by a block is the one returned by the last expression in the block.</p>
<p>When used as an expression, the compiler expects the conditions to be exhaustive and thus many times you might need to add an else block. However the else block is not required when used as a statement.</p>
<p>There are many other things you can do including checking the actual instance or just the value as shown in the rather arbitrary example below</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">anotherWhen</span><span class="hljs-params">(any: <span class="hljs-type">Any</span>)</span></span>: Any =
    <span class="hljs-keyword">when</span>(any) {
        (any <span class="hljs-keyword">is</span> <span class="hljs-built_in">Int</span> &#x26;&#x26; any &#x3C; <span class="hljs-number">10000</span>) -> <span class="hljs-string">"Small Number"</span>
        <span class="hljs-keyword">is</span> <span class="hljs-built_in">Int</span> -> <span class="hljs-string">"Big Number"</span>
        <span class="hljs-keyword">is</span> String -> <span class="hljs-string">"A string"</span>
        <span class="hljs-keyword">else</span> -> <span class="hljs-string">"Its just another Any"</span>
    }</code></pre>
<p>You might note that in the first condition, the right hand side of the condition ie. (any &#x3C; 10000) actually compiles, because the compiler is able to figure out that any will be an Int if reaches the comparison with 10000 and allows it to be used as an Int. This smart casting is actually quite nice and helps save on verbose typecast statements (or for that matter explicit typecasts) when used in when expressions as above.</p>
<h2>while and do-while</h2>
<p>The familiar constructs of <code>while</code> and <code>do while</code> are also available. eg.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">countDown</span><span class="hljs-params">(n: <span class="hljs-type">Int</span>)</span></span> {
    <span class="hljs-keyword">var</span> counter = n
    <span class="hljs-keyword">while</span>(counter >= <span class="hljs-number">0</span>) {
        println(counter)
        counter--
    }
}</code></pre>
<p>Note that in kotlin the while block will not allow you to perform an assignment within the while expression unlike java code. eg. <code>while((n = next()) > 0)</code> will not compile. In some of these situations you might actually find the <code>do while</code> construct useful. eg. the val n declared within the do while block remains in scope while evaluating the while expression.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">do</span> {
    <span class="hljs-keyword">val</span> n = next()
    <span class="hljs-comment">// do something</span>
} <span class="hljs-keyword">while</span>(n > <span class="hljs-number">0</span>)</code></pre>
<h2>for loop</h2>
<p>The for loop is much nicer and often more helpful than in Java. eg. to print each character in a string you could write</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">for</span>(c <span class="hljs-keyword">in</span> <span class="hljs-string">"String"</span>) {
    println(c)
}</code></pre>
<p>One of the useful ability of for loop is to iterate over a range which can be written as <code>startValue..endValue</code> eg</p>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">// will print 100, 101, 102... 110</span>
<span class="hljs-keyword">for</span> (n <span class="hljs-keyword">in</span> <span class="hljs-number">100.</span><span class="hljs-number">.110</span>) {
    println(n)
}</code></pre>
<p>There are many other aspects of the for loop which are better covered after some other topics, so other sample usages will be taken up later.</p>
<h2>break and continue</h2>
<p><code>break</code> and <code>continue</code> are also available and continue to have the same meaning as in java. For more advanced uses such as breaking to a or returning to a label, see <a href="https://kotlinlang.org/docs/reference/returns.html">Returns and jumps</a> from the kotlin reference guide.</p>
<h2>Exercise - Counting Sundays</h2>
<p>Here's an exercise for you to try out. (Note: the solution follows immediately after, so you might wish to avoid reading it if you want to attempt to do the exercise yourself first).</p>
<p>This one comes from <a href="http://blog.dhananjaynene.com/2016/04/exercises-in-kotlin-part-4-control-flows-and-return/">Project Euler</a> Exercise #19</p>
<p>The problem is stated as follows</p>
<pre><code class="hljs language-kotlin">You are given the following information, but you may prefer to <span class="hljs-keyword">do</span> some research <span class="hljs-keyword">for</span> yourself.


<span class="hljs-number">1</span> Jan <span class="hljs-number">1900</span> was a Monday.
Thirty days has September,
April, June and November.
All the rest have thirty-one,
Saving February alone,
Which has twenty-eight, rain or shine.
And on leap years, twenty-nine.
A leap year occurs on any year evenly divisible <span class="hljs-keyword">by</span> <span class="hljs-number">4</span>, but not on a century unless it <span class="hljs-keyword">is</span> divisible <span class="hljs-keyword">by</span> <span class="hljs-number">400.</span>

How many Sundays fell on the first of the month during the twentieth century (<span class="hljs-number">1</span> Jan <span class="hljs-number">1901</span> to <span class="hljs-number">31</span> Dec <span class="hljs-number">2000</span>)?</code></pre>
<p>One of the possible solutions to this problem is described below</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sundaysInTwentiethCentury</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span> {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">daysInMonth</span><span class="hljs-params">(month: <span class="hljs-type">Int</span>, year: <span class="hljs-type">Int</span>)</span></span> = <span class="hljs-keyword">when</span>(month) {
        <span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>,<span class="hljs-number">12</span> -> <span class="hljs-number">31</span>
        <span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>,<span class="hljs-number">11</span> -> <span class="hljs-number">30</span>
        <span class="hljs-number">2</span> -> <span class="hljs-keyword">when</span> {
            year % <span class="hljs-number">400</span> == <span class="hljs-number">0</span> -> <span class="hljs-number">29</span>
            year % <span class="hljs-number">100</span> == <span class="hljs-number">0</span> -> <span class="hljs-number">28</span>
            year % <span class="hljs-number">4</span> == <span class="hljs-number">0</span> -> <span class="hljs-number">29</span>
            <span class="hljs-keyword">else</span> -> <span class="hljs-number">28</span>
        }
        <span class="hljs-keyword">else</span> -> <span class="hljs-keyword">throw</span> Exception(<span class="hljs-string">"Invalid Month <span class="hljs-subst">${month}</span>"</span>)
    }
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">daysInYear</span><span class="hljs-params">(year: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> {
        <span class="hljs-keyword">var</span> days = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span>(month <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.12</span>) {
            days += daysInMonth(month, year)
        }
        <span class="hljs-keyword">return</span> days
    }
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dayOfWeekAfter</span><span class="hljs-params">(currentDow: <span class="hljs-type">Int</span>, numberOfDays: <span class="hljs-type">Int</span>)</span></span> = ((currentDow<span class="hljs-number">-1</span>) + numberOfDays) % <span class="hljs-number">7</span> + <span class="hljs-number">1</span>
    <span class="hljs-keyword">var</span> weekDayOnFirstOfMonth = dayOfWeekAfter(<span class="hljs-number">2</span>, daysInYear(<span class="hljs-number">1900</span>))
    <span class="hljs-keyword">var</span> totalSundays = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> (year <span class="hljs-keyword">in</span> <span class="hljs-number">1901.</span><span class="hljs-number">.2000</span>) {
        <span class="hljs-keyword">for</span>(month <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.12</span>) {
            <span class="hljs-keyword">if</span> (weekDayOnFirstOfMonth == <span class="hljs-number">1</span>) totalSundays++
            weekDayOnFirstOfMonth = dayOfWeekAfter(weekDayOnFirstOfMonth, daysInMonth(month,year))
        }
    }
    <span class="hljs-keyword">return</span> totalSundays
}</code></pre>
]]></description><link>http://blog.dhananjaynene.com/2016/04/exercises-in-kotlin-part-4-control-flows-and-return/</link><guid isPermaLink="true">http://blog.dhananjaynene.com/2016/04/exercises-in-kotlin-part-4-control-flows-and-return/</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Dhananjay Nene]]></dc:creator><pubDate>Wed, 27 Apr 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[Writing Concise Code With Kotlin]]></title><description><![CDATA[<p>One of the major selling points of Kotlin is its <em>concise and expressive syntax</em>. But in how far does Kotlin actually allow you to write more concise code? Let’s look at four ways it accomplishes this.</p>
<h2>Data Classes</h2>
<p>In Java, you sometimes create classes which act simply as data containers without much additional functionality. This may be the case, for example, when following the <a href="http://martinfowler.com/bliki/ValueObject.html">Value Object Pattern</a> proposed by Martin Fowler. Let’s look at an Address class that just stores all data associated with a specific address:</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Address</span> </span>{
     <span class="hljs-keyword">private</span> String street;
     <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> streetNumber;
     <span class="hljs-keyword">private</span> String postCode;
     <span class="hljs-keyword">private</span> String city;
     <span class="hljs-keyword">private</span> Country country;

     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Address</span><span class="hljs-params">(String street, <span class="hljs-keyword">int</span> streetNumber, String postCode, String city, Country country)</span> </span>{
         <span class="hljs-keyword">this</span>.street = street;
         <span class="hljs-keyword">this</span>.streetNumber = streetNumber;
         <span class="hljs-keyword">this</span>.postCode = postCode;
         <span class="hljs-keyword">this</span>.city = city;
         <span class="hljs-keyword">this</span>.country = country;
     }

     <span class="hljs-meta">@Override</span>
     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>{
         <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
         <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;

         Address address = (Address) o;

         <span class="hljs-keyword">if</span> (streetNumber != address.streetNumber) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
         <span class="hljs-keyword">if</span> (!street.equals(address.street)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
         <span class="hljs-keyword">if</span> (!postCode.equals(address.postCode)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
         <span class="hljs-keyword">if</span> (!city.equals(address.city)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
         <span class="hljs-keyword">return</span> country == address.country;

     }

     <span class="hljs-meta">@Override</span>
     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>{
         <span class="hljs-keyword">int</span> result = street.hashCode();
         result = <span class="hljs-number">31</span> * result + streetNumber;
         result = <span class="hljs-number">31</span> * result + postCode.hashCode();
         result = <span class="hljs-number">31</span> * result + city.hashCode();
         result = <span class="hljs-number">31</span> * result + (country != <span class="hljs-keyword">null</span> ? country.hashCode() : <span class="hljs-number">0</span>);
         <span class="hljs-keyword">return</span> result;
     }

     <span class="hljs-meta">@Override</span>
     <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>{
         <span class="hljs-keyword">return</span> <span class="hljs-string">"Address{"</span> +
                 <span class="hljs-string">"street='"</span> + street + <span class="hljs-string">'\''</span> +
                 <span class="hljs-string">", streetNumber="</span> + streetNumber +
                 <span class="hljs-string">", postCode='"</span> + postCode + <span class="hljs-string">'\''</span> +
                 <span class="hljs-string">", city='"</span> + city + <span class="hljs-string">'\''</span> +
                 <span class="hljs-string">", country="</span> + country +
                 <span class="hljs-string">'}'</span>;
     }

     <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getStreet</span><span class="hljs-params">()</span> </span>{
         <span class="hljs-keyword">return</span> street;
     }

     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setStreet</span><span class="hljs-params">(String street)</span> </span>{
         <span class="hljs-keyword">this</span>.street = street;
     }

     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getStreetNumber</span><span class="hljs-params">()</span> </span>{
         <span class="hljs-keyword">return</span> streetNumber;
     }

     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setStreetNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> streetNumber)</span> </span>{
         <span class="hljs-keyword">this</span>.streetNumber = streetNumber;
     }

     <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPostCode</span><span class="hljs-params">()</span> </span>{
         <span class="hljs-keyword">return</span> postCode;
     }

     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPostCode</span><span class="hljs-params">(String postCode)</span> </span>{
         <span class="hljs-keyword">this</span>.postCode = postCode;
     }

     <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getCity</span><span class="hljs-params">()</span> </span>{
         <span class="hljs-keyword">return</span> city;
     }

     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCity</span><span class="hljs-params">(String city)</span> </span>{
         <span class="hljs-keyword">this</span>.city = city;
     }

     <span class="hljs-function"><span class="hljs-keyword">public</span> Country <span class="hljs-title">getCountry</span><span class="hljs-params">()</span> </span>{
         <span class="hljs-keyword">return</span> country;
     }

     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCountry</span><span class="hljs-params">(Country country)</span> </span>{
         <span class="hljs-keyword">this</span>.country = country;
     }
 }</code></pre>
<p>Phew, that’s a lot of code for such a simple data class. If there was a method in there that adds any actual functionality, all the boilerplate code would greatly distract from that method. Consequently, the class is <strong>less readable and less searchable</strong>. For an immutable Address class, the amount of boilerplate would be a little less frustrating because it would then only contain getters but no setters.</p>
<p>Now, you can generate this kind of boilerplate code pretty fast with a modern IDE. That’s not a problem. The major advantage of Kotlin here really is readability: Kotlin makes it much clearer on the first view what’s actually going on – and doesn’t distract you from the important parts with boring boilerplate code.</p>
<p><strong>So let’s look at the equivalent class in Kotlin:</strong></p>
<pre><code class="hljs language-kotlin"> <span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Address</span></span>(<span class="hljs-keyword">var</span> street: String,
                    <span class="hljs-keyword">var</span> streetNumber: <span class="hljs-built_in">Int</span>,
                    <span class="hljs-keyword">var</span> postCode: String,
                    <span class="hljs-keyword">var</span> city: String,
                    <span class="hljs-keyword">var</span> country: Country)</code></pre>
<p>That’s it. In most cases, a simple data class like this is a one-liner but to make it more readable, I split up the properties of the class in the above example. This simple data class declaration generates a constructor, getters &#x26; setters, hashCode(), equals(), toString(), and also adds some additional convenience methods for you.</p>
<p>Want to create an <em>immutable</em> data class instead? Easy, just use the val keyword instead of var:</p>
<pre><code class="hljs language-kotlin"> <span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Address</span></span>(<span class="hljs-keyword">val</span> street: String,
                    <span class="hljs-keyword">val</span> streetNumber: <span class="hljs-built_in">Int</span>,
                    <span class="hljs-keyword">val</span> postCode: String,
                    <span class="hljs-keyword">val</span> city: String,
                    <span class="hljs-keyword">val</span> country: Country)</code></pre>
<p>In Kotlin, val is used to create immutable variables whereas var creates mutable variables. Above, we use the same syntax to define mutable and immutable properties for classes using var and val respectively.</p>
<p>Now, let’s look at a language concept that doesn’t save us quite as much code but is really handy as well.</p>
<h2>Smart Casts</h2>
<p>In Java, you often have to cast objects in situations where the compiler could actually do this for you because it’s clear that the object can be cast. Consider the following example:</p>
<pre><code class="hljs language-kotlin"> <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cast</span> </span>{

     static void printString(String str) {
         System.<span class="hljs-keyword">out</span>.println(str);
     }

     <span class="hljs-keyword">public</span> static void main(String[] args) {
         Object hello = <span class="hljs-string">"Hello, World!"</span>;

         <span class="hljs-keyword">if</span> (hello instanceof String) {
             printString((String) hello);
         }
     }
 }</code></pre>
<p>If we tried to change printString((String) hello) to just printString(hello), the Java compiler would yell at us because hello is of type Object.</p>
<p>Now, the compiler could actually prove that hello is a suitable actual parameter for the formal parameter str of the method printString(String str). As you may have thought, Kotlin does this for us:</p>
<pre><code class="hljs language-kotlin"> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printString</span><span class="hljs-params">(str: <span class="hljs-type">String</span>)</span></span> {
     println(str)
 }

 <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&#x3C;<span class="hljs-type">String</span>>)</span></span> {
     <span class="hljs-keyword">val</span> hello: Any = <span class="hljs-string">"Hello, World!"</span>

     <span class="hljs-keyword">if</span> (hello <span class="hljs-keyword">is</span> String) {
         printString(hello)
     }
 }</code></pre>
<p>Note that Kotlin’s Any type is the equivalent of Java’s Object, just like “is” is the equivalent of instanceOf, and that we can create package-level functions in Kotlin (that is, they are not nested inside a class or interface).</p>
<p>This is called <strong>Smart Casts</strong> in Kotlin. Admittedly, this doesn’t safe you tons of code, but still it’s super convenient.</p>
<p>Smart casts are by no means limited to the example above. Whenever the compiler can prove that it is safe to cast the object appropriately, it will:</p>
<pre><code class="hljs language-kotlin"> <span class="hljs-comment">// Smart cast #1</span>
 <span class="hljs-keyword">if</span> (hello !<span class="hljs-keyword">is</span> String) <span class="hljs-keyword">return</span>
 printString(hello)  <span class="hljs-comment">// Smart cast</span>

 <span class="hljs-comment">// ---------------------</span>
 <span class="hljs-comment">// Smart cast #2</span>
 <span class="hljs-keyword">when</span>(hello) {
     <span class="hljs-string">"Some value"</span> -> println(<span class="hljs-string">"Then do something"</span>)
     <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.10</span> -> println(<span class="hljs-string">"This would be printed of hello were an integer between 1 and 10."</span>)
     <span class="hljs-keyword">is</span> String -> {
         println(<span class="hljs-string">"hello is of type String, this block will be run"</span>)
         printString(hello)  <span class="hljs-comment">// Smart cast</span>
     }
     <span class="hljs-keyword">else</span> -> println(<span class="hljs-string">"This is the default case."</span>)
 }

 <span class="hljs-comment">// ---------------------</span>
 <span class="hljs-comment">// Smart cast #3</span>
 <span class="hljs-keyword">if</span> (hello <span class="hljs-keyword">is</span> String &#x26;&#x26; hello.first().isLetter()) {  <span class="hljs-comment">// Smart cast after &#x26;&#x26;</span>
     println(<span class="hljs-string">"The string starts with a letter"</span>)
 }

 <span class="hljs-comment">// ---------------------</span>
 <span class="hljs-comment">// Smart cast #4</span>
 <span class="hljs-keyword">if</span> (hello !<span class="hljs-keyword">is</span> String || hello.last().isDigit()) {  <span class="hljs-comment">// Smart cast after ||</span>
     println(<span class="hljs-string">"This will not be printed."</span>)
 }</code></pre>
<p>In smart cast #1, it’s clear that hello must be a string. Otherwise the control flow wouldn’t even reach that point due to the return statement in the preceding line.</p>
<p>In smart cast #2, you can see a when-expression in Kotlin. Inside this, you can not only check for specific values but also for the type of the object. In the case block associated with the condition “hello is String”, Kotlin will again use smart casts on the hello object.</p>
<p>Smart casts #3 and #4 make use of lazy evaluation. In smart cast #3, the second part of the condition (after &#x26;&#x26;) will not be checked if the first part is already false (because then the whole condition must be false). Thus, in the second part, the hello object must be of type String because otherwise, Kotlin wouldn’t even evaluate that second part (just like Java).</p>
<p>Similarly, in smart cast #4, if hello were not of type String, the first part would already be true so that the second part would not be evaluated. Therefore, hello must be of type String whenver the second part is evaluated – and Kotlin knows that.</p>
<h2>Functional Programming</h2>
<p>Similar to Java 8 which introduced functional language elements such as lambda expressions (function literals), Kotlin comes with functional capabilities baked in. You may be used to function literals like these in Java 8:</p>
<pre><code class="hljs language-kotlin"> <span class="hljs-keyword">public</span> static void main(String[] args) {
     List&#x3C;String> genres = Arrays.asList(<span class="hljs-string">"Action"</span>, <span class="hljs-string">"Comedy"</span>, <span class="hljs-string">"Thriller"</span>);
     List&#x3C;String> myKindOfMovies = genres.stream().filter(s -> s.length() > <span class="hljs-number">6</span>).map(s -> s + <span class="hljs-string">" Movie"</span>).collect(Collectors.toList());
     System.<span class="hljs-keyword">out</span>.println(myKindOfMovies);  <span class="hljs-comment">// Output: [Thriller Movie]</span>
 }</code></pre>
<p>The Stream API introduced in Java 8 can be convenient in many cases where you have to do some quick pipe-and-filter style processing. It can often make your code much more concise because you don’t have to use explicit for-each loops all the time.</p>
<p>Kotlin makes this even easier. By convention, for lambda expressions with only one parameter, Kotlin creates an implicit parameter called “it” so that you can skip typing the parameter:</p>
<pre><code class="hljs language-kotlin"> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&#x3C;<span class="hljs-type">String</span>>)</span></span> {
     <span class="hljs-keyword">val</span> genres = listOf(<span class="hljs-string">"Action"</span>, <span class="hljs-string">"Comedy"</span>, <span class="hljs-string">"Thriller"</span>)
     <span class="hljs-keyword">val</span> myKindOfMovies = genres.filter { it.length > <span class="hljs-number">6</span> }.map { it + <span class="hljs-string">" Movie"</span> }
     println(myKindOfMovies)
 }</code></pre>
<p>Note that there is actually another convention here. Whenever the last parameter of a method is a lambda expression, we can put it <em>behind</em> the parentheses of the method call. In the example above, both lambda expressions are the <em>only</em> parameters so that you can skip the parentheses altogether.</p>
<p>Also, we don’t have to use a collect() method at the end, the myKindOfMovies variables now stores an Iterable<String>. We can also make that explicit if we want to:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> myKindOfMovies: Iterable&#x3C;String> = genres.filter { it.length > <span class="hljs-number">6</span> }.map { it + <span class="hljs-string">" Movie"</span> }</code></pre>
<p>Next, we’ll see <strong>how to define a singleton in Kotlin in a single line:</strong></p>
<h2>Objects as Singletons</h2>
<p>There are many ways to create a singleton, some of which are not suitable in concurrent environments or don’t hold up against serialization attacks. Let’s look at the most common way to create a singleton in Java:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>{
     <span class="hljs-keyword">private</span> static Singleton theInstance = new Singleton();

     <span class="hljs-keyword">private</span> Singleton() {
     }

     <span class="hljs-keyword">public</span> static Singleton getInstance() {
         <span class="hljs-keyword">return</span> theInstance;
     }
 }</code></pre>
<p>This creates a class with a private constructor so that we can control which instances of it are created. Since we want to have only one object of this class at any given time, we create that instance as a private attribute and allow retrieving it from the outside using getInstance(). That way, there can never be more than one instance of this object (nasty tricks using reflection or serialization aside).</p>
<p>In Kotlin, we can create such a singleton in a single line by using the object keyword:</p>
<pre><code class="hljs language-kotlin"> <span class="hljs-keyword">object</span> KotlinSingleton {}</code></pre>
<p>Pretty neat, huh? In contrast to the normal habit of defining classes, this defines a single <em>object,</em> which is semantically the same as a singleton – a class of which there should always be only one object. Such object declarations in Kotlin are initialized lazily, just like you may do it for a singleton in Java (even though it’s not the case in the example above).</p>
<p>In both Kotlin and Java you can choose to make your singleton/object immutable or not.</p>
<p>I want to mention that <strong>there is a better way to create singletons in Java as well</strong>: create an enum with only a single type! Joshua Bloch – one of the developers of the Java Collections Framework (amongst others) – advocates this in his very recommendable book “Effective Java”. Why? Well, enums give you all serialization machinery for free and prevent multiple instances even in the face of sophisticated serialization and reflection attacks – without you having to do anything for it. Arguably, they are also very concise:</p>
<pre><code class="hljs language-kotlin"> <span class="hljs-keyword">enum</span> EnumSingleton {
     INSTANCE
 }</code></pre>
<p>This approach can nearly even keep up with the conciseness of Kotlin.</p>
<p>Of course you are free to add properties and methods to Kotlin objects, just as you are free to add attributes and methods to Java enums.</p>
<h2>Closing Words</h2>
<p>I hope this quick overview gave you some more understanding of the Kotlin programming language and how it handles some of the more annoying aspects of Java in more convenient ways. Kotlin’s syntax is generally rather concise but still perfectly expressive (“data class ...”, “object ...”, “{ it.length > 6 }”) which makes your code more readable and thus maintainable.</p>
<p>If you’re interested in learning more about the Kotlin programming language, you can check out my <a href="http://petersommerhoff.com/dev/kotlin/kotlin-beginner-tutorial/">10 tutorial videos for Kotlin</a>. They give you a gentle introduction to the language and help you with the setup to get started (don’t worry, it’s not that much). Alternatively, you can also jump ahead and <a href="https://www.udemy.com/kotlin-course/?couponCode=AMAZINGREADERS25">check out the full Kotlin course hosted on Udemy</a>. The link contains a 50% discount coupon for my blog readers.</p>
]]></description><link>http://petersommerhoff.com/dev/kotlin/kotlin-concise-code/</link><guid isPermaLink="true">http://petersommerhoff.com/dev/kotlin/kotlin-concise-code/</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Peter Sommerhoff]]></dc:creator><pubDate>Sun, 24 Apr 2016 19:02:00 GMT</pubDate></item><item><title><![CDATA[Type safe JavaFX CSS with TornadoFX]]></title><description><![CDATA[<iframe width="960" height="480" src="https://www.youtube.com/embed/rjc8_HGHy3c" frameborder="0" allowfullscreen></iframe>
]]></description><link>https://www.youtube.com/watch?v=rjc8_HGHy3c</link><guid isPermaLink="true">https://www.youtube.com/watch?v=rjc8_HGHy3c</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[TornadoFx]]></category><dc:creator><![CDATA[Edvin Syse]]></dc:creator><pubDate>Sun, 24 Apr 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[JDK7/8 features in Kotlin 1.0]]></title><description><![CDATA[<p>Currently it's rather inconvenient to use those methods of mapped builtin types, that were added in JDK8. These include <code>Collection.stream()</code>, <code>Map.getOrDefault(K, V)</code>, etc. We have several long-standing issues related in our tracker: <a href="https://youtrack.jetbrains.com/issue/KT-9194">KT-9194</a>, <a href="https://youtrack.jetbrains.com/issue/KT-5175">KT-5175</a> and <a href="https://youtrack.jetbrains.com/issue/KT-10864">KT-10864</a>.</p>
<p>This happens because Kotlin targets JDK 1.6 as the minimum JDK version, so it can't expose those members of builtin types that are not available in JDK 1.6.
We plan to remove the limitation in Kotlin 1.1 by exposing all builtin type members available in the target platform (excluding some blacklisted exceptions), but as a short-term fix we could provide a way to call these methods via extensions.</p>
<p>We have collected those extensions in a small Kotlin library: <a href="https://github.com/Kotlin/kotlinx.support">kotlinx.support</a>.
It consists of two artifacts: <strong>kotlinx-support-jdk8</strong> and <strong>kotlinx-support-jdk7</strong>. The former has a dependency on the latter, so if you target JDK8 you could only reference kotlinx-support-jdk8 and have the latter as a transitive dependency.</p>
<p>These artifacts are available for downloading from the maven repository on bintray <a href="https://bintray.com/kotlin/kotlinx.support/kotlinx.support">https://bintray.com/kotlin/kotlinx.support/kotlinx.support</a> and also on jcenter <a href="https://bintray.com/bintray/jcenter?filterByPkgName=kotlinx.support">https://bintray.com/bintray/jcenter?filterByPkgName=kotlinx.support</a>.</p>
<h3>kotlinx-support-jdk8</h3>
<p>This library provides extensions to call default methods of collection interfaces introduced in JDK8.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">import</span> kotlinx.support.jdk8.collections.*
<span class="hljs-keyword">import</span> kotlinx.support.jdk8.text.*

<span class="hljs-comment">// some quite more verbose way to say 'listOf&#x3C;String>().flatMap { it.asIterable() }'</span>
<span class="hljs-keyword">val</span> chars = listOf(<span class="hljs-string">"abc"</span>, <span class="hljs-string">"def"</span>).stream()
                .flatMap { it.chars().boxed().map { it.toChar() } }
                .collect(Collectors.toList&#x3C;<span class="hljs-built_in">Char</span>>())</code></pre>
<h3>kotlinx-support-jdk7</h3>
<p>This library exposes <code>Throwable</code> methods to work with suppressed exceptions, and introduces <a href="https://youtrack.jetbrains.com/issue/KT-5899">long-awaited</a> <code>use</code> extension for <code>AutoCloseable</code>. Note that this <code>use</code> being imported explicitly has precedence over <code>use</code> from Standard Library and thus can be used for <code>Closeable</code> as well.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">import</span> kotlinx.support.jdk7.use

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Resource</span></span>(<span class="hljs-keyword">val</span> faultyClose: <span class="hljs-built_in">Boolean</span> = <span class="hljs-literal">false</span>) : Closeable {

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">if</span> (faultyClose)
            <span class="hljs-keyword">throw</span> IOException(<span class="hljs-string">"Close failed"</span>)
    }
}

<span class="hljs-comment">// the IOException thrown by 'close' would be added</span>
<span class="hljs-comment">// to the list of suppressed exceptions of IllegalStateException</span>
<span class="hljs-comment">// thrown from lambda passed to 'use'</span>
<span class="hljs-keyword">val</span> result = Resource(faultyClose = <span class="hljs-literal">true</span>).use {
    <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">"operation failed"</span>)
}</code></pre>
]]></description><link>https://discuss.kotlinlang.org/t/jdk7-8-features-in-kotlin-1-0/1625</link><guid isPermaLink="true">https://discuss.kotlinlang.org/t/jdk7-8-features-in-kotlin-1-0/1625</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Ilya Gorbunov]]></dc:creator><pubDate>Thu, 21 Apr 2016 19:36:00 GMT</pubDate></item><item><title><![CDATA[Kotlin + Android]]></title><description><![CDATA[<p><a href="https://speakerdeck.com/dmytrodanylyk/kotlin-plus-android">Slides</a></p>
]]></description><link>https://speakerdeck.com/dmytrodanylyk/kotlin-plus-android</link><guid isPermaLink="true">https://speakerdeck.com/dmytrodanylyk/kotlin-plus-android</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Android]]></category><dc:creator><![CDATA[Dmytro Danylyk]]></dc:creator><pubDate>Thu, 21 Apr 2016 11:08:00 GMT</pubDate></item><item><title><![CDATA[Kotlin + Android First Impressions]]></title><description><![CDATA[<p>I am a huge Android fanboy, and have been one ever since the Nexus One came out. The Android OS has evolved so much and into so many variations. Almost a year ago, one of the Android developers I follow on Twitter was pushing for Kotlin to be the main language for Android. What was more interesting was it was retweeted by an Android Developer from Google. Fast forward to around this time, and the guys behinds IntelliJ announce 1.0 of Kotlin.</p>
<p>I decided to see what the big hype was about on Kotlin. Consider this blog as a first impression rather than a review.</p>
<h2>Going from Java to Kotlin</h2>
<p><a href="https://github.com/Kotlin">Kotlin</a> (for the most part) is similar to Groovy and Scala, as it runs on a JVM. It can also be compiled to JavaScript.</p>
<p>I took the time to learn the syntax by first going to its official website. It’s advertised that Kotlin should be easy to pick up if you already code in Java, and it is interoperable with existing Java frameworks. I’ve been a Java developer most of my life, so I figured it wouldn’t be too hard to learn Kotlin.</p>
<p>The <a href="https://kotlinlang.org/">official website</a> had a nice tutorial section for it. Here are a couple of cool things about the syntax I liked:</p>
<ul>
<li>Types are defined after the variable name.
In Java, you would declare variables with the type first then the variable name like <code>private int x;</code> while the Kotlin equivalent is <code>var x: Int</code>.
The type can also be inferred <code>var x = 1 //is Int initialized to 1</code>.</li>
<li>Variables can be declared as nullable with <code>?</code>.
For example: <code>y?.length</code>. If y is null, then return null. Otherwise return <code>y.length</code>.</li>
<li>Smart Casts! If a variable is of certain type, it is already cast to that type.
For example: <code>if (a is String) print(a.length)</code></li>
</ul>
<p>There are a lot more that I liked, but to keep this blog short, I suggest you check out <a href="https://kotlinlang.org/">the official website</a>.</p>
<h2>Kotlin in Android Studio</h2>
<p>It has been a while since I played around with the Android API. The last time I messed around with an Android app was around the time Android was known as “Jelly Bean.”</p>
<p>So, that said, I had to familiarize myself with the newer APIs such as <a href="http://developer.android.com/reference/android/support/v7/widget/RecyclerView.html">RecyclerView</a> and new UI elements from the Design Support Library. Luckily, since Android Studio is from the same guys who did Kotlin, it was easy to integrate Kotlin into the SDK.</p>
<p>First, I created a new project in Android Studio which created a default main activity. Then with the Android Studio Kotlin plugin, I am able to invoke an action to convert from Java to Kotlin. This will convert the Java code thats autogenerated in MainActivity.java to Kotlin in MainActivity.kt. It will also add the Kotlin dependency to your build.gradle.</p>
<h2>Put away that Butterknife</h2>
<p>A nice Kotlin feature worth mentioning is that within an Activity or Fragment, you don’t have to call on findViewById to get a View widget. Simply refer to it by id.</p>
<p>So, instead of <code>TextView myTextView = (TextView) findViewById(R.id.myTextView)</code>, you can simply refer to the TextView widget by <code>myTextView</code>. Kotlin will get the reference to that view.</p>
<h2>So, overall?</h2>
<p>Rather than making, say, a Hello World app or an app with a generic List view, I decided to try out creating an app that plays sounds using MediaPlayer API to challenge myself.</p>
<p><img src="https://www.javacodegeeks.com/wp-content/uploads/2016/04/Kotlin.png" alt="Kotlin"></p>
<p>During my experience with it as I coded the activities, inflating layouts, and RecyclerView adapters, I think I spent more time going back to the Android API documentation than I did with Kotlin. At first I had to refer back to the Kotlin docs to look up stuff until I got use to the syntax.</p>
<p>What I liked most about Kotlin was there were less lines of code. When comparing things I would do in Java that would take a couple of lines, I could accomplish the same in Kotlin with just one line. Less lines of code is pleasant to my tiring eyes. Plus, less boilerplate which is helpful, especially in Android.</p>
<h2>Anko</h2>
<p>You could also use <a href="https://github.com/Kotlin/anko">Anko</a> which is a UI library written in Kotlin. Instead of XML, Anko does the UI in DSL. I heard much praise for this tool. But as I started playing around with Kotlin, I wanted to be more familiar with Android’s default XML layout UI.</p>
<p>Maybe one day I’ll write another blog on Anko or something :).</p>
<h2>The future...</h2>
<p>So what are the chances that Kotlin will indeed be the official, main go-to when coding in Android?</p>
<p>There have been rumors that Google is seeking to stray away from Java for Android development, there have been reports that <a href="http://thenextweb.com/dd/2016/04/07/google-facebook-uber-swift/">Google is looking into adopting Apple’s Swift language</a>. However, that same report also stated that Google isn’t considering Kotlin because of its long build times.</p>
<p>With all that said, if you’re an existing Java developer looking into something new or looking into developing Android apps, I would suggest to look into Kotlin and give it a try.</p>
]]></description><link>https://www.javacodegeeks.com/2016/04/kotlin-android-first-impressions.html</link><guid isPermaLink="true">https://www.javacodegeeks.com/2016/04/kotlin-android-first-impressions.html</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Android]]></category><dc:creator><![CDATA[Keyhole Software]]></dc:creator><pubDate>Wed, 20 Apr 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[Exercises in Kotlin: Part 3 - Functions]]></title><description><![CDATA[<p>We looked at a bit of syntax and variable declarations in the last post <a href="http://blog.dhananjaynene.com/2016/04/exercises-in-kotlin-part-2-high-level-syntax-and-variables/">Exercises in Kotlin: Part 2 - High level syntax and Variables</a>. We explore functions in this post. Here's how a typical function in Kotlin would look like.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">add</span><span class="hljs-params">(first: <span class="hljs-type">Int</span>, second: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> {
    <span class="hljs-comment">// will not compile</span>
    <span class="hljs-comment">// first = first + 2. Because first is a val and cannot be reassigned</span>
    <span class="hljs-keyword">return</span> first + second
}</code></pre>
<p>As noted earlier, the arguments are declared with the names followed by the types. Also even though <code>val</code> is not specified, each argument is automatically a <code>val</code> and can not be reassigned within the function. Also the return type is specified after the argument list followed by a colon.</p>
<p>In this case, since the body of the function is an expression it can also alternatively be specified as</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">addExpr</span><span class="hljs-params">(first: <span class="hljs-type">Int</span>, second: <span class="hljs-type">Int</span>)</span></span> = first + second</code></pre>
<p>Note in particular that the curly brackets are replaced by <code>=</code>. And because the compiler can infer the return type, it is no longer required to provide it (though it would work just as well if you did provide one)</p>
<h3>Functions can have default arguments</h3>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">powerOf</span><span class="hljs-params">(value: <span class="hljs-type">Double</span>, power: <span class="hljs-type">Double</span> = <span class="hljs-number">2.0</span>)</span></span> = Math.pow(value, power)</code></pre>
<p>The second argument <code>power</code> is no longer required to be specified, (when not specified its value will default to 2.0. Thus allowing both the following statements</p>
<pre><code class="hljs language-kotlin">powerOf(<span class="hljs-number">3.0</span>)         <span class="hljs-comment">// This will return 9.0</span>
powerOf(<span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>)    <span class="hljs-comment">// This will return 81.0</span></code></pre>
<p>This makes it convenient to require fewer overloaded functions. The order of the arguments needs to be retained, and all the arguments after the ones specified will need to have default values. While this makes a lot of defaulting easy, it still is a little problematic for selectively overriding defaults for only few of the arguments. This is helped by the next feature.</p>
<h3>Arguments can also be named</h3>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">contrived</span><span class="hljs-params">(first: <span class="hljs-type">String</span> = <span class="hljs-string">"First"</span>,
              second: <span class="hljs-type">String</span> = <span class="hljs-string">"Second"</span>,
              third: <span class="hljs-type">String</span> = <span class="hljs-string">"Third"</span>,
              fourth: <span class="hljs-type">String</span> = <span class="hljs-string">"Fourth"</span>,
              fifth: <span class="hljs-type">String</span> = <span class="hljs-string">"Fifth"</span>)</span></span> =
        first + <span class="hljs-string">" "</span> + second + <span class="hljs-string">" "</span> + third + <span class="hljs-string">" "</span> + fourth + <span class="hljs-string">" "</span> + fifth

<span class="hljs-comment">// ....</span>

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">someOtherFunction</span><span class="hljs-params">()</span></span> {
    contrived(second=<span class="hljs-string">"2nd"</span>, fourth=<span class="hljs-string">"4th"</span>)
    <span class="hljs-comment">// the above returns "First 2nd Third 4th Fifth"</span>
}</code></pre>
<p>As shown in the example above using a combination of default and named arguments we can choose to have smaller function invocations by specifying only the non defaults. Thus only the arguments whose default values need to be overridden, making the code both terse and more readable</p>
<h3>Functions can have variable arguments</h3>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">showStrings</span><span class="hljs-params">(suffix: <span class="hljs-type">String</span>, <span class="hljs-keyword">vararg</span> items: <span class="hljs-type">String</span>)</span></span> {
    <span class="hljs-keyword">for</span>(item <span class="hljs-keyword">in</span> items) {
        print(item + <span class="hljs-string">" "</span>)
    }
    print(suffix)
    println()
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">somewhereElse</span><span class="hljs-params">()</span></span> {
    showStrings(<span class="hljs-string">"!"</span>, <span class="hljs-string">"Hello"</span>, <span class="hljs-string">"World"</span>) <span class="hljs-comment">// prints "Hello World !"</span>
}</code></pre>
<p>Function can have variable number of arguments so long as all of them are of the same type. The type of the declared argument then becomes an array of that type. Thus in the above example, <code>items</code> is an array of String or <code>Array&#x3C;String></code>.</p>
<p>The above function also introduces you to a for statement when used with an array. The syntax is very simple and natural, <code>for itemVar in arrayVar { ... }</code></p>
<p>(<em>I imagine there can be only one <code>vararg</code> type argument and that has to be declared at the end but never attempted to do anything differently</em>)</p>
<h3>Functions can have nested functions</h3>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">showStrings2</span><span class="hljs-params">(suffix: <span class="hljs-type">String</span>, <span class="hljs-keyword">vararg</span> items: <span class="hljs-type">String</span>)</span></span>: String {
    <span class="hljs-keyword">val</span> sb = StringBuffer()
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">appendToBuffer</span><span class="hljs-params">(item: <span class="hljs-type">String</span>)</span></span> {
        sb.append(item)
        sb.append(<span class="hljs-string">" "</span>)
    }
    <span class="hljs-keyword">for</span>(item <span class="hljs-keyword">in</span> items) { appendToBuffer(item) }
    appendToBuffer(suffix)
    <span class="hljs-keyword">return</span> sb.toString()
}

....

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">somewhereElse</span><span class="hljs-params">()</span></span> {
    showStrings2(<span class="hljs-string">"!"</span>, <span class="hljs-string">"Hello"</span>, <span class="hljs-string">"World"</span>) <span class="hljs-comment">// returns "Hello World !"</span>
}</code></pre>
<p>As shown above, <code>appendToBuffer</code> is a nested function (called local function) It can access variables in the parent functions namespace (in the above situation - <code>sb</code>.).</p>
<h3>Aside: if - else can also be an expression</h3>
<p>In java, <code>if</code>-<code>else</code> is a statement. And has a complementary ternary operator <code>? :</code> which is an expression. Kotlin merges both by allowing use of <code>if</code> - <code>else</code> as an expression, and such if/else expressions can be used as a part of the function expression body (or a part of regular block bodies as well). eg.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isBlankString</span><span class="hljs-params">(arg: <span class="hljs-type">String</span>)</span></span> = <span class="hljs-keyword">if</span> (arg.trim() == <span class="hljs-string">""</span>) <span class="hljs-literal">true</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">false</span></code></pre>
<p>For an if/else to be an expression, both if and else branches have to be specified and followed by an expression each</p>
<h3>Functions can be tail recursive.</h3>
<p>Yes! They can be.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">factorial</span><span class="hljs-params">(n: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> {
    tailrec <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">factorial</span><span class="hljs-params">(accumulator: <span class="hljs-type">Int</span>, n: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> = <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) accumulator <span class="hljs-keyword">else</span> factorial(accumulator * n, n - <span class="hljs-number">1</span>)
    <span class="hljs-keyword">return</span> factorial(<span class="hljs-number">1</span>, n)
}</code></pre>
<p>If a function is written in a form that lends itself to <a href="https://en.wikipedia.org/wiki/Tail_call">tail recursion</a> the compiler generates optimised code that uses a loop based version which no longer risks a stack overflow.</p>
<h3>Extension functions.</h3>
<p>This is a very interesting and very useful feature to Kotlin. It is the ability to seemingly externally add a method to a class. Thus the function <code>isBlankString</code> introduced above could be rewritten as</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">isBlankString</span><span class="hljs-params">()</span></span> = <span class="hljs-keyword">this</span>.trim() == <span class="hljs-string">""</span>

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">somewhereElse</span><span class="hljs-params">()</span></span> {
    <span class="hljs-string">" "</span>.isBlankString() <span class="hljs-comment">// returns true</span>
}</code></pre>
<p>Note that in an extension function, you can use <code>this</code> to refer to the receiver of the function (in this case the String object on whom the <code>isBlankString</code> function is called). Also that the receiver class is resolved statically and not dynamically. So if you had an extension function defined for a <code>Base</code> class and a <code>Derived</code> class that inherits from <code>Base</code>, and called it on a variable declared of type <code>Base</code> but actually referencing an instance of type <code>Derived</code> the <code>Base</code> version of the extension function will be called.</p>
<h3>Infix functions</h3>
<p>Class member functions or extension functions with a single argument, can in turn be declared as infix which allows from syntactic sugar in terms of how that function is invoked. Thus the function</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">infix</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">toThePowerOf</span><span class="hljs-params">(n: <span class="hljs-type">Int</span>)</span></span> = Math.pow(<span class="hljs-keyword">this</span>.toDouble(), n.toDouble()).toInt()</code></pre>
<p>could be invoked using either of the two ways, the latter becoming feasible only because of the keyword <code>infix</code> being used in the function declaration above.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-number">5.</span>toThePowerOf(<span class="hljs-number">3</span>)
<span class="hljs-number">5</span> toThePowerOf <span class="hljs-number">3</span></code></pre>
<h3>Higher order functions</h3>
<p>Higher order functions are functions which take functions as parameters or as a return type. For that let us first understand how a function can be alternatively represented as a variable using a function type.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">double</span><span class="hljs-params">(n: <span class="hljs-type">Int</span>)</span></span> = n * <span class="hljs-number">2</span></code></pre>
<p>What if we wish to represent the function above as a variable. We need to understand the type of the function. In this case it happens to be of the type which takes a single <code>Int</code> and returns an <code>Int</code>. Knowing that we can now declare it as a variable</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> doubleAsArg = { n : <span class="hljs-built_in">Int</span> -> n * <span class="hljs-number">2</span>}</code></pre>
<p>The way to invoke the function above would be similar to the way double is invoked</p>
<pre><code class="hljs language-kotlin">doubleAsArg(<span class="hljs-number">5</span>) <span class="hljs-comment">// would return 10</span></code></pre>
<p>But the more interesting capability that is now possible is that you can write a function which takes another function as an argument, and in turn pass doubleAsArg as an argument to the newly written function. eg.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">twice</span><span class="hljs-params">(function: (<span class="hljs-type">Int</span>)</span></span> -> <span class="hljs-built_in">Int</span>, arg: <span class="hljs-built_in">Int</span>) = function(function(arg))

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">somewhereElse</span><span class="hljs-params">()</span></span> {
    twice(doubleAsArg,<span class="hljs-number">5</span>) <span class="hljs-comment">// will return 20</span>
}</code></pre>
<p><code>doubleAsArg</code> could have been also declared using an alternative syntax as follows. For all practical purposes they are identical. However the declaration below makes the function type very explicit (it was inferred in the declaration above)</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> doubleAsArgRedux: (<span class="hljs-built_in">Int</span>) -> <span class="hljs-built_in">Int</span> = { n -> n * <span class="hljs-number">2</span>}</code></pre>
<h4>Aside: Function Types</h4>
<p>Just like <code>String</code>, <code>Int</code> etc, since functions are also things that can be passed around, they also have types. As is shown above, doubleAsArg above has the type <code>(Int) -> Int</code>. In general a function taking n arguments each of type Type1..TypeN, and returning a type TypeReturn will have the type <code>(Type1, Type2,..TypeN) -> TypeReturn</code></p>
<h3>Lambdas</h3>
<p>A lambda function is a function that is not declared upfront but is passed in immediately to another function. In the situation below the function that is passed as the first argument to the function twice is a lambda. A lambda expression is always surrounded by curly braces, its parameters (if any) are declared before -> while the body goes after -> (if required).</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">somewhereElse</span><span class="hljs-params">()</span></span> {
    twice({n: <span class="hljs-built_in">Int</span> -> n * <span class="hljs-number">10</span>}, <span class="hljs-number">5</span>) <span class="hljs-comment">// returns 500</span>
}</code></pre>
<p>Note that for a lambda function the declaration of the parameter types is optional, and there is no way to declare the return type of the function (it has to be inferred). And it is always wrapped with curly braces. Thus the general syntax for a lambda function with n arguments is</p>
<pre><code class="hljs language-kotlin">{ p1: Type1, p2: Type2 .. pn: TypeN -> <span class="hljs-comment">/* do something */</span> }</code></pre>
<p>Note that the lambda function body is an expression and does not allow a return statement. It could consist of multiple statements and/or branches so long as they end with an expression. So the following is a valid lambda.</p>
<pre><code class="hljs language-kotlin">{ n: <span class="hljs-built_in">Int</span> -> <span class="hljs-keyword">val</span> twoN = <span class="hljs-number">2</span> * n; <span class="hljs-keyword">if</span> (twoN &#x3C; <span class="hljs-number">100</span>) twoN * <span class="hljs-number">2</span> <span class="hljs-keyword">else</span> twoN * <span class="hljs-number">3</span>}</code></pre>
<h3>Single parameter lambdas</h3>
<p>If a lambda has a single argument and its type can be inferred, then the argument declaration along with its type and the subsequent <code>-></code> can be omitted. In such a case that parameter will have the default name <code>it</code>.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> quadruple: (<span class="hljs-built_in">Int</span>) -> <span class="hljs-built_in">Int</span> = { it * <span class="hljs-number">4</span>}</code></pre>
<h3>Anonymous functions</h3>
<p>An anonymous function is a function with no name. For obvious reasons you cannot declare it by itself. But you could say use it as the right hand side of an assignment to a variable or pass it as an argument to another function eg.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> triple = <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(n: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> = n * <span class="hljs-number">3</span>

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">somewhereElse</span><span class="hljs-params">()</span></span> {
    twice(triple, <span class="hljs-number">5</span>)
    twice(<span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(n: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> { <span class="hljs-keyword">return</span> n * <span class="hljs-number">3</span>}, <span class="hljs-number">5</span>)
}</code></pre>
<p>This is particularly useful when the return type cannot be contextually inferred</p>
<h3>Closures</h3>
<p>Note that local functions, lambda functions and anonymous functions can access variables declared in their outer scope, ie. their closure. They can also modify such variables (assuming they are vars).</p>
<h3>Receivers</h3>
<p>Lambdas and anonymous functions can be used as extension functions as well. Their function type then is <code>ReceiverType.(p1: Type1 .. pn: TypeN) -> ReturnType</code></p>
<h3>Alternative invocation syntax</h3>
<p>If a function has one or more arguments, but exactly one argument which is of a function type, then it can be invoked with an alternative syntax where the function is not specified within the parenthesis, but is instead specified after them wrapped in curly braces.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doubleAndThen</span><span class="hljs-params">(n: <span class="hljs-type">Int</span>, then: (<span class="hljs-type">Int</span>)</span></span> -> <span class="hljs-built_in">Int</span>): <span class="hljs-built_in">Int</span> = then(n * <span class="hljs-number">2</span>)

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">somewhereElse</span><span class="hljs-params">()</span></span> {
    doubleAndThen(<span class="hljs-number">5</span>) { it * <span class="hljs-number">5</span> } <span class="hljs-comment">// returns 50</span>
}</code></pre>
<h3>Inline functions</h3>
<p>You can specifically request that a function be inlined using the <code>inline</code> keyword. eg. you could've alternatively declared the <code>doubleAndThen</code> function above as</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doubleAndThen</span><span class="hljs-params">(n: <span class="hljs-type">Int</span>, then: (<span class="hljs-type">Int</span>)</span></span> -> <span class="hljs-built_in">Int</span>): <span class="hljs-built_in">Int</span> = then(n * <span class="hljs-number">2</span>)</code></pre>
<p>In this case the compiler will emit the function (and the lambda passed to it) inlined at the call site where doubleAndThen is called. This causes your compiled code to grow in size but could pay off in performance.</p>
<p>If you do not want a particular lambda passed to the function as inlined, then you could mark it as noinline. eg.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doubleAndThen</span><span class="hljs-params">(n: <span class="hljs-type">Int</span>, <span class="hljs-keyword">noinline</span> then: (<span class="hljs-type">Int</span>)</span></span> -> <span class="hljs-built_in">Int</span>): <span class="hljs-built_in">Int</span> = then(n * <span class="hljs-number">2</span>)</code></pre>
<p>If a function is inlined, then the lambdas passed to it are allowed to have a <code>return</code></p>
<p>The next post in the series is <a href="http://blog.dhananjaynene.com/2016/04/exercises-in-kotlin-part-4-control-flows-and-return/">Exercises in Kotlin: Part 4 - Control flows and return</a></p>
]]></description><link>http://blog.dhananjaynene.com/2016/04/exercises-in-kotlin-part-3-functions/</link><guid isPermaLink="true">http://blog.dhananjaynene.com/2016/04/exercises-in-kotlin-part-3-functions/</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Dhananjay Nene]]></dc:creator><pubDate>Wed, 20 Apr 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[Exercises in Kotlin: Part 2 - High level syntax and Variables]]></title><description><![CDATA[<p>This post first discusses the code that was written so far in the last post, <a href="http://blog.dhananjaynene.com/2016/04/exercises-in-kotlin-part-1-getting-started/">Exercises in Kotlin: Part 1 - Getting Started</a>. Subsequently it focuses on the basic syntax of variables, discusses a bit about packaging and also about Type Inference</p>
<h2>A review of code so far</h2>
<p>Let us take a look at the code we wrote so far in the last blog post <a href="http://blog.dhananjaynene.com/2016/04/exercises-in-kotlin-part-1-getting-started/">first part of this series</a> and glean what we can from the same.</p>
<h3>helloworld.kt</h3>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">package</span> com.example.kotlin.learning

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&#x3C;<span class="hljs-type">String</span>>)</span></span> {
    println(<span class="hljs-string">"Hello World!"</span>)
}
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">greetings</span><span class="hljs-params">()</span></span> = <span class="hljs-string">"Hello World!"</span></code></pre>
<p>Some of the things that can be noted from this program are follows</p>
<ul>
<li><em>Similar package convention</em>: Kotlin follows similar package naming conventions as Java.</li>
<li><em>Standalone functions</em>: Yes, Kotlin has them. That means there is no requirement to have a class just in order to wrap functions, that frankly have no reasons to be part of a class.</li>
<li><em>Keyword</em> <code>fun</code>: Functions are declared using the keyword <code>fun</code>.</li>
<li><em>Variable declaration order</em>: When declaring variables (or arguments to a function as in this case of the arguments to <code>main</code>), the order of declaration is reversed, with the type specification <em>following</em> the variable/argument name and a colon used to separate the two.</li>
<li><em>Array is a generic type</em>: Arrays are not represented by <code>[]</code> but a generic type <code>Array&#x3C;T></code> instead where <code>T</code> is the type whose array is being represented. Thus at a syntactic level there is no necessity for using <code>[]</code> for arrays.</li>
<li>There is a helper function called <code>println()</code> similar to <code>System.out.println()</code></li>
<li><em>Semicolon as a statement terminator is optional</em>: A semi-colon does not seem to be mandatory</li>
<li><em>Optional function return types</em>: Return type of the function is not required. to be specified if the return type is a <em>Unit</em>. Which is why the function <code>main</code> does not require a return type declaration.</li>
<li><em>Alternative function representation</em>: As the function declaration for <code>greetings()</code> shows, function bodies can be substituted by expressions if the separator <code>=</code> is used between the function declaration and the expression. When the function body is specified as an expression, the compiler will attempt to infer the return type and in most cases no return type declaration will be required.</li>
</ul>
<h3>testgreet.kt</h3>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">package</span> com.example.kotlin.learning

<span class="hljs-keyword">import</span> org.junit.Test
<span class="hljs-keyword">import</span> org.junit.Assert.assertEquals

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestGreet</span></span>() {
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">testGreetings</span><span class="hljs-params">()</span></span> {
        assertEquals(<span class="hljs-string">"Greeting should be 'Hello World!'"</span>,
                <span class="hljs-string">"Hello World!"</span>, greetings())
    }
}</code></pre>
<p>From this we can glean the following</p>
<ul>
<li><em>Class declaration</em>: A Class declaration is similar to java in the sense it starts with the keyword <code>class</code> followed by the class name. The class body is also wrapped within <code>{</code> and <code>}</code>.</li>
<li><em>Constructor</em>: There is no explicit constructor that <em>seems</em> to be required. That is not true. The parenthesis after the class name, in this case with empty content, are in fact the argument list for the primary constructor. More details about that later.</li>
<li><em>Method declarations</em>: Methods are also declared using the <code>fun</code> keyword.</li>
<li><em>Annotations</em>: Annotations can also be used just like they are used in java (in this case the <code>@Test</code> annotation.</li>
</ul>
<p>The above gives us some sort of understanding about Kotlin syntax, Let us look at a few more examples to flesh out some of the more commonly used details. This has a main function. So you can copy this code into a file and compile and run it.</p>
<h2>Example 1 : Comments and variables</h2>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">/**
* This is a comment
*/</span>

<span class="hljs-comment">/*
   So is
   this */</span>

<span class="hljs-comment">// As is this</span>

<span class="hljs-keyword">val</span> PI = <span class="hljs-number">3.14159</span>

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">circleArea</span><span class="hljs-params">(r: <span class="hljs-type">Double</span>)</span></span> = PI * r * r

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&#x3C;<span class="hljs-type">String</span>>)</span></span> {
    <span class="hljs-keyword">var</span> radius: <span class="hljs-built_in">Double</span> = <span class="hljs-number">1.0</span>
    <span class="hljs-keyword">val</span> increment = <span class="hljs-number">1</span>
    <span class="hljs-comment">// increment = increment + 1 &#x3C;-- will not compile since increment is a val</span>
    println(<span class="hljs-string">"The radius of a circle with radius <span class="hljs-subst">${radius}</span> is <span class="hljs-subst">${circleArea(radius)}</span>"</span>)
    radius = radius + increment
    println(<span class="hljs-string">"The radius of a circle with radius <span class="hljs-subst">${radius}</span> is <span class="hljs-subst">${circleArea(radius)}</span>"</span>)
}</code></pre>
<p>The output of the above program is</p>
<pre><code class="hljs language-kotlin">The radius of a circle with radius <span class="hljs-number">1.0</span> <span class="hljs-keyword">is</span> <span class="hljs-number">3.14159</span>
The radius of a circle with radius <span class="hljs-number">2.0</span> <span class="hljs-keyword">is</span> <span class="hljs-number">12.56636</span></code></pre>
<p>Note the following:</p>
<h4>Comments</h4>
<ul>
<li>Kotlin follows the same syntax for comments as Java does. Enough said.</li>
</ul>
<h4>Primitive types</h4>
<ul>
<li>Kotlin has primitive types. Though they are not named identical to the ones in Java. They are in fact the same names with the first character capitalised viz Boolean, Byte, Int, Long, Float, Double etc. (not sure if there is an exception to that).</li>
<li>There are member methods available for these primitives unlike Java. Thus you can call a <code>toString()</code> on an <code>Int</code></li>
<li>Although they seem to be like objects, their storage space is the same as primitives in Java <em>unless</em> they are declared as <em>nullable</em> (more about that later) or used by generic classes in which case their storage is like boxed primitives.</li>
</ul>
<h4>Variables</h4>
<ul>
<li>As mentioned earlier, variables can be declared at the top level (eg <code>PI</code>)</li>
<li>Functions can also have local variables. eg. <code>radius</code> and <code>increment</code></li>
<li>Variables are of two types. <code>val</code> ie. read-only variables and <code>var</code> ie. read-write variables. In Java all variables by default are read-write and those that are to be treated as read-only are marked using the keyword <code>final</code>. However in Kotlin it is required to use one of the two keywords <code>val</code> or <code>var</code> explicitly. The statement <code>// increment = increment + 1</code> was commented out, because since <code>increment</code> is a <code>val</code> such a statement would not compile. <code>radius</code> on the other hand being a <code>var</code> can change its value, as is done at <code>radius = radius + increment</code>.</li>
<li>A predominantly functional style of programming will almost always use <code>val</code>s and rarely if any <code>var</code>s. The rationale for that is beyond the scope of this post.</li>
<li>A variable may or may not have an explicitly type declared. The compiler will attempt to infer it based on the value it is initialised to. However often that may not be feasible, and the programmer may be required to specify the type explicitly.</li>
</ul>
<h4>Parameters</h4>
<ul>
<li>Parameter declarations for functions are similar to a variable declaration. However they are not preceded by a <code>val</code> or a <code>var</code>. They are always <code>val</code>s. They always need an explicit type declaration.</li>
<li>A function may return no value whatsoever (represented using the type <code>Unit</code>). The return type of the functional is optional for functions having an expression body (as in case of <code>circleArea</code>) or functions that have a block body but have a <code>Unit</code> return type. In other situatons the compiler will not attempt to infer the return type, and the programmer is required to provide it explicitly.</li>
</ul>
<h4>String templates</h4>
<ul>
<li>String interpolation is supported by allowing expressions to be embedded in strings using the ${<code>expr</code>} syntax as in the arguments to <code>println()</code>. This feature is called string templates in Kotlinspeak</li>
</ul>
<h2>(Optional) Some more advanced aspects about variables</h2>
<p>There are some nuanced aspects of variables that you might use only occasionally. These are discussed here. You could chose to skip this section and instead move on to the next post since these might entangle you into learning and thinking about infrequently leveraged capabilities.</p>
<p>Consider the following code, which is an extended version of the code we saw earlier. It is kind of a little odd, but has been deliberately constructed to talk about the advanced features.</p>
<pre><code class="hljs language-kotlin">const <span class="hljs-keyword">val</span> PI = <span class="hljs-number">3.14159</span>

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">circleArea</span><span class="hljs-params">(r: <span class="hljs-type">Double</span>)</span></span> = PI * r * r

<span class="hljs-keyword">var</span> defRadius = <span class="hljs-number">5.0</span>

<span class="hljs-keyword">var</span> defaultRadius: <span class="hljs-built_in">Double</span>
    <span class="hljs-keyword">get</span>() = defRadius
    <span class="hljs-keyword">set</span>(value) { defRadius = value }

<span class="hljs-keyword">val</span> area: <span class="hljs-built_in">Double</span>
    <span class="hljs-keyword">get</span>() = circleArea(defaultRadius)

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&#x3C;<span class="hljs-type">String</span>>)</span></span> {
    <span class="hljs-keyword">var</span> radius = <span class="hljs-number">1.0</span>
    <span class="hljs-keyword">val</span> increment = <span class="hljs-number">1</span>
    println(<span class="hljs-string">"The radius of a circle with radius <span class="hljs-subst">${radius}</span> is <span class="hljs-subst">${circleArea(radius)}</span>"</span>)
    radius = radius + increment
    println(<span class="hljs-string">"The radius of a circle with radius <span class="hljs-subst">${radius}</span> is <span class="hljs-subst">${circleArea(radius)}</span>"</span>)
    println(<span class="hljs-string">"The radius of a circle with radius 5.0 is <span class="hljs-subst">${area}</span>"</span>)
    defaultRadius = <span class="hljs-number">6.0</span>
    println(<span class="hljs-string">"The radius of a circle with radius 6.0 is <span class="hljs-subst">${area}</span>"</span>)
}</code></pre>
<p>The output of the code above is as follows</p>
<pre><code class="hljs language-kotlin">The radius of a circle with radius <span class="hljs-number">1.0</span> <span class="hljs-keyword">is</span> <span class="hljs-number">3.14159</span>
The radius of a circle with radius <span class="hljs-number">2.0</span> <span class="hljs-keyword">is</span> <span class="hljs-number">12.56636</span>
The radius of a circle with radius <span class="hljs-number">5.0</span> <span class="hljs-keyword">is</span> <span class="hljs-number">78.53975</span>
The radius of a circle with radius <span class="hljs-number">6.0</span> <span class="hljs-keyword">is</span> <span class="hljs-number">113.09723999999999</span></code></pre>
<p>Things to be noted.</p>
<ul>
<li><em>getters</em>: Variables can have getter functions as shown for the variable <code>area</code> above. Frankly, not sure why they would be used for top level variables. Though I could imagine them to be used to work around variable visibility constraints by having a private var being accessible as a read-only variable function from another file by using a getter function.</li>
<li><em>setters</em>: We can also similarly use setters as in the case of <code>defaultRadius</code>. Again this is a bit of a contrived example, since one could have just as easily directly used <code>defRadius</code>. However do note, getters and setters to tend to be more useful when used with class member variables, a topic we will get to later.</li>
<li><em>const variables</em>: Variables can be prefixed with a const as in case of <code>PI</code> above. However this capability is restricted to top level variables only. In addition such variables have to be initialised to a <code>String</code> or a primitive type. and may not have a custom getter. In turn such consts can be used as parameters to annotations.</li>
<li><em>package namespaces and visibility</em>: Just like top level functions, you can also have top level variables/constants being declared. Also note that all the standalone functions get declared in the namespace of the package. So if you have multiple files with the same package and also same function (or top level variable) names, that will be treated as an error since one of them will end up attempting to redeclare the other. On the other hand if you declare a top level variable as private, it is not private to that package namespace, but is instead treated as private within a file</li>
</ul>
<p>We shall be reviewing functions in the next post <a href="http://blog.dhananjaynene.com/2016/04/exercises-in-kotlin-part-3-functions/">Exercises in Kotlin: Part 3 - Functions</a></p>
]]></description><link>http://blog.dhananjaynene.com/2016/04/exercises-in-kotlin-part-2-high-level-syntax-and-variables/</link><guid isPermaLink="true">http://blog.dhananjaynene.com/2016/04/exercises-in-kotlin-part-2-high-level-syntax-and-variables/</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Dhananjay Nene]]></dc:creator><pubDate>Tue, 19 Apr 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[Exercises in Kotlin: Part 1 - Getting Started]]></title><description><![CDATA[<p>Kotlin is an exciting new language I have been working with for a couple of months now. I believe it has a lot of features going for it, and I think many will be benefited from learning a bit more about it. Hence this series of posts.</p>
<p>This post helps you with getting the necessary software installed on your desktop for compiling and running kotlin code</p>
<h2>Presumed Audience :</h2>
<p>The reader is presumed to have a reasonable working knowledge of Java. While one of the reasons Kotlin is particularly exciting is because it is such a useful language for the Android platform, the early parts of this series shall focus on the desktop based JVMs. Since those learnings are common irrespective of whether you wish to use Kotlin for desktop/server or Android programming.</p>
<p>It is also assumed that the reader has working java development kit installed on his desktop. Most or all of the discussion about syntax will also likely compare Kotlin with Java.</p>
<h2>Information :</h2>
<p>Some of the useful sites for Kotlin are</p>
<ul>
<li><a href="https://kotlinlang.org/">Kotlin Programming Language</a> : Language Home page.</li>
<li><a href="https://kotlinlang.org/docs/reference/">Kotlin Reference</a> : Reference - Kotlin Programming Language</li>
<li><a href="https://www.jetbrains.com/idea/">Intellij Idea</a> : IDE with built in kotlin support. From the same authors who bring you kotlin, ie. JetBrains</li>
<li><a href="https://github.com/JetBrains/kotlin-eclipse">Kotlin Eclipse Plugin</a> : Kotlin plugin for eclipse. <em>Note: I haven't used it myself</em></li>
</ul>
<h2>Getting started using an IDE</h2>
<p><em>Note: if you do not prefer to use an IDE and are likely to code using text editors and build and run using command line, you can skip this section entirely and go to <a href="#cmdline">Command Line Usage</a></em></p>
<p>Go to the Intellij idea page above and download the latest version. You can choose to download the community version. It has the necessary support for Kotlin. You may alternatively choose to use the Eclipse plugin described above, but I haven't used it so cannot help with getting it to work. Install the intellij idea ide and launch it. In case unsure how to do so, consult the <a href="https://www.jetbrains.com/help/idea/2016.1/installing-and-launching.html">official guide</a> for downloading, installing and launching the ide.</p>
<p>Start a new project. Click on gradle in the left hand column. You should reach the new project dialog box as follows</p>
<p><img src="http://blog.dhananjaynene.com/images/kotlin/kotlin-1-new-project.png" alt="Intellij Idea New Project Dialog"></p>
<p>I always use the gradle build tool, so I end up making the selections as shown. Select any appropriate JVM between 1.6 and 1.8 (built in one should do). You could use the dialog as shown above. You should next see a dialog box for groupid/artifactid as required by gradle (these mean the same thing as they do for maven, so fill up some group id eg. <code>com.example.kotlin</code> and artifactid eg. <code>learning</code>). The rest of this post assumes these two values, so if you use different values, please replace them appropriately in the code as necessary.</p>
<p><img src="http://blog.dhananjaynene.com/images/kotlin/kotlin-3-groupid-artifactid.png" alt="Specify groupid and artifactid"></p>
<p>On the next two screens you could choose the defaults or customise as necessary</p>
<p><img src="http://blog.dhananjaynene.com/images/kotlin/kotlin-4-project-config.png" alt="Project Configuration"></p>
<p><img src="http://blog.dhananjaynene.com/images/kotlin/kotlin-5-project-configuration-2.png" alt="Project Configuration 2"></p>
<p>Since gradle defaults to maven like directory structures, let us create the directory necessary for our work using the groupid/artifactid used earlier and maven conventions. Select the "<em>learning</em>" folder at the top of the left pane, and select from main or right click menu, File -> New Directory and specify the directory as follows. (If the menu options File -> New Directory do not appear, you have selected the wrong "<em>learning</em>", select the one at the top of the left pane, not the one in the toolbar above it).</p>
<p><img src="http://blog.dhananjaynene.com/images/kotlin/kotlin-6-create-directory.png" alt="Create source directory"></p>
<p>Similarly also create another directory for writing our test cases</p>
<p><img src="http://blog.dhananjaynene.com/images/kotlin/kotlin-7-create-test-directory.png" alt="Create test directory"></p>
<p>You should see the appropriate packages for the main and test areas appear in the left hand pane as follows</p>
<p><img src="http://blog.dhananjaynene.com/images/kotlin/kotlin-8-ide-view.png" alt="IDE View"></p>
<p>Right click on the package name under the src/main/kotlin directory and select "New Kotlin File/Class". It will pop up a dialog where you can enter helloworld</p>
<p><img src="http://blog.dhananjaynene.com/images/kotlin/kotlin-9-new-file-dialog.png" alt="New file dialog"></p>
<p>This will create a new file "<em>helloworld.kt</em>" and open it into your ide</p>
<p><img src="http://blog.dhananjaynene.com/images/kotlin/kotlin-10-new-file.png" alt="New file"></p>
<p>Enter the following code in the just opened file</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">package</span> com.example.kotlin.learning

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&#x3C;<span class="hljs-type">String</span>>)</span></span> {
    println(<span class="hljs-string">"Hello World!"</span>)
}</code></pre>
<p>Run the program using "Run -> Run". It will pop up a very small dialog box, select HelloWorldKt from it. (You could also use Alt-Shift-F10 instead of Run -> Run, though not sure if the same key bindings work across operating systems, though thats what it is on Linux). This is the canonical Hello World program for Kotlin. Don't worry about understanding the syntax yet. We will get to it in the very next post, this post is to get you started.</p>
<p>One more thing to do is to get a sample test case running. So, let us add a function to the file we just created that we shall be testing, as follows</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">greetings</span><span class="hljs-params">()</span></span> = <span class="hljs-string">"Hello World!"</span></code></pre>
<p>Next, select the package in the src/test/kotlin directory, and after a right click select "New -> Kotlin File/Class". This time select the name as "<em>testgreet</em>", which will create a new file called <em>testgreet.kt</em>. Add the following code to the file.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">package</span> com.example.kotlin.learning

<span class="hljs-keyword">import</span> org.junit.Test
<span class="hljs-keyword">import</span> org.junit.Assert.assertEquals

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestGreet</span></span>() {
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">testGreetings</span><span class="hljs-params">()</span></span> {
        assertEquals(<span class="hljs-string">"Greeting should be 'Hello World!'"</span>,
                <span class="hljs-string">"Hello World!"</span>, greetings())
    }
}</code></pre>
<p>Again select "Run -> Run..." or (Alt-Shift-F10 or equivalent). This will pop up a small dialog box. Select TestGreet. This will run the test case and should show an all green bar near the bottom of your IDE as shown in the image below.</p>
<p><img src="http://blog.dhananjaynene.com/images/kotlin/kotlin-11-run-test.png" alt="Kotlin Run Test"></p>
<p>Now, we shall repeat the exercise using text editors and command line for building and running the program. Even if you <em>always</em> use IDEs, I very much recommend that you at least do the remainder of the activities described on this post at least once. It is always helpful to have a general sense of what is happening at a command line level. However if you skip it, or it doesn't work for you for whatever reason, it won't constrain you from being able to continue with the rest of this series.</p>
<p>In either case, I shall not be covering the Intellij Idea IDE any further. If you are new to it or to the Eclipse plugin, learning it is beyond the scope of this series of posts, so I encourage you to play around with them, since that is likely to be useful as we go further along in this series.</p>
<h2>Installation for command line usage</h2>
<p>The instructions for working with Kotlin from the command line are documented on the page <a href="https://kotlinlang.org/docs/tutorials/command-line.html">Working with the Command Line Compiler</a></p>
<p>Goto <a href="https://github.com/JetBrains/kotlin/releases/latest">Kotlin latest release</a> to download the Kotlin compiler. It will likely be a file called <code>kotlin-compiler-&#x3C;version>.zip</code>. The current version is 1.0.1-2 at the point in time this post was written. Unzip the file into an appropriate directory. And ensure that the executables kotlin and kotlinc (or their windows equivalent with the .bat extensions) are in your path.</p>
<p>Create a work directory for this exercise and change directory to it.</p>
<p>Create a file <em>helloworld.kt</em> with the following content.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">package</span> com.example.kotlin.learning

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&#x3C;<span class="hljs-type">String</span>>)</span></span> {
    println(<span class="hljs-string">"Hello World!"</span>)
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">greetings</span><span class="hljs-params">()</span></span> = <span class="hljs-string">"Hello World!"</span></code></pre>
<p>Compile it using the command</p>
<pre><code class="hljs language-bash">$ kotlinc helloworld.kt</code></pre>
<p>Notice that it will have created a file <em>com/example/kotlin/learning/HelloworldKt.class</em>. This is the compiled <em>.class</em> file. It is Java byte code though you wouldn't be able to run it as you might be used to just yet. In fact go ahead and try to run it as follows</p>
<pre><code class="hljs language-bash">$ java com.example.kotlin.learning.HelloworldKt</code></pre>
<p>It will fail because you do not have the necessary kotlin runtime jar in your classpath. You should've seen an error message similar to the one below</p>
<pre><code class="hljs language-kotlin">Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">"main"</span> java.lang.NoClassDefFoundError: kotlin/jvm/<span class="hljs-keyword">internal</span>/Intrinsics
        at com.example.kotlin.learning.HelloworldKt.main(helloworld.kt)
Caused <span class="hljs-keyword">by</span>: java.lang.ClassNotFoundException: kotlin.jvm.<span class="hljs-keyword">internal</span>.Intrinsics
        at java.net.URLClassLoader.findClass(URLClassLoader.java:<span class="hljs-number">381</span>)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="hljs-number">424</span>)
        at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:<span class="hljs-number">331</span>)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="hljs-number">357</span>)
        ... <span class="hljs-number">1</span> more</code></pre>
<p>That runtime is located in the kotlin zip you had just downloaded. Let us point the classpath to it and attempt to run the program again. (Replace <code>&#x3C;folder_where_you_unzipped_kotlin_zip></code> below with the appropriate directory where you had unzipped the file you downloaded)</p>
<pre><code class="hljs language-bash">$ java -cp &#x3C;folder_<span class="hljs-built_in">where</span>_you_unzipped_kotlin_zip>/kotlinc/lib/kotlin-runtime.jar:. com.example.kotlin.learning.HelloworldKt</code></pre>
<p>You should see "Hello World!" getting printed to the console. Kotlin provides an easier way to do this as well, so let us repeat the process, just a little differently.</p>
<p>Compile the source again, but this time create a .jar file</p>
<pre><code class="hljs language-bash">$ kotlinc helloworld.kt -include-runtime <span class="hljs-_">-d</span> helloworld.jar</code></pre>
<p>Now run it as follows</p>
<pre><code class="hljs language-bash">$ java -jar helloworld.jar</code></pre>
<p>The program should run and "Hello World!" should get printed to the console.</p>
<p>Now let us run the test case. Create a file <em>testgreet.kt</em> as follows</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">package</span> com.example.kotlin.learning

<span class="hljs-keyword">import</span> org.junit.Test
<span class="hljs-keyword">import</span> org.junit.Assert.assertEquals

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestGreet</span></span>() {
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">testGreetings</span><span class="hljs-params">()</span></span> {
        assertEquals(<span class="hljs-string">"Greeting should be 'Hello World!'"</span>,
                <span class="hljs-string">"Hello World!"</span>, greetings())
    }
}</code></pre>
<p>Now for compiling and running this you will need the jar for junit (which in turn requires hamcrest). The instructions for that are provided on the <a href="https://github.com/junit-team/junit4/wiki/Download-and-Install">Download and Install - junit4 wiki</a> page. For now just go ahead and download the two following jars for junit and hamcrest.</p>
<ul>
<li><a href="http://search.maven.org/remotecontent?filepath=junit/junit/4.12/junit-4.12.jar">junit jar</a></li>
<li><a href="http://search.maven.org/remotecontent?filepath=org/hamcrest/hamcrest-all/1.3/hamcrest-all-1.3.jar">hamcrest jar</a></li>
</ul>
<p>You will have downloaded <em>junit-4.12.jar</em> and <em>hamcrest-all-1.3.jar</em>. Move both of them into your current directory after download.</p>
<pre><code class="hljs language-bash">$ kotlinc helloworld.kt -cp junit-4.12.jar -include-runtime <span class="hljs-_">-d</span> helloworld.jar</code></pre>
<pre><code class="hljs language-bash">$ java -cp junit-4.12.jar:hamcrest-all-1.3.jar:helloworld.jar org.junit.runner.JUnitCore com.example.kotlin.learning.TestGreet</code></pre>
<p>You should see something like the follows (the time obviously could vary) that indicates success.</p>
<pre><code class="hljs language-kotlin">JUnit version <span class="hljs-number">4.12</span>
.
Time: <span class="hljs-number">0.004</span>

OK (<span class="hljs-number">1</span> test)</code></pre>
<p>You should also be aware that Kotlin has a REPL that you can run using the command <code>kotlinc-jvm</code> as follows</p>
<pre><code class="hljs language-kotlin">$ kotlinc-jvm
Welcome to Kotlin version <span class="hljs-number">1.0</span><span class="hljs-number">.1</span><span class="hljs-number">-2</span> (JRE <span class="hljs-number">1.8</span><span class="hljs-number">.0</span>_77-b03)
Type :help <span class="hljs-keyword">for</span> help, :quit <span class="hljs-keyword">for</span> quit
>>> println(<span class="hljs-string">"Hello World!"</span>)
Hello World!
>>></code></pre>
<p>Congratulations you are now able to compile and run Kotlin programs. In the next post in this series, we shall attempt to understand the code that we just wrote, and explore the Kotlin language further.</p>
]]></description><link>http://blog.dhananjaynene.com/2016/04/exercises-in-kotlin-part-1-getting-started/</link><guid isPermaLink="true">http://blog.dhananjaynene.com/2016/04/exercises-in-kotlin-part-1-getting-started/</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Dhananjay Nene]]></dc:creator><pubDate>Mon, 18 Apr 2016 05:32:00 GMT</pubDate></item><item><title><![CDATA[Code improvements with Kotlin]]></title><description><![CDATA[<p><a href="https://kotlinlang.org/"><img src="https://blog.frankel.ch/wp-content/resources/code-improvement-kotlin/icon_Kotlin.png"></a>This week, I tried to improve my pet Android application developed in Kotlin. As I was very new to Kotlin when I started it, most of the code just looks like Java written in Kotlin.</p>
<h3>Starting simple</h3>
<p>Here’s one such snippet, that needs to initialize both a template message and its argument:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> messageTemplate: String
<span class="hljs-keyword">val</span> params: Array &#x3C;any><span class="hljs-keyword">when</span> (shownCount) {
    <span class="hljs-number">0</span> -> {
        messageTemplate = noItem
        params = arrayOf&#x3C;any>()
    }
    <span class="hljs-number">1</span> -> {
        messageTemplate = itemShowSingle
        params = arrayOf&#x3C;any>(totalCount)
    }
    <span class="hljs-keyword">else</span> -> {
        messageTemplate = itemShowCount
        params = arrayOf(shownCount, totalCount)
    }
}</code></pre>
<h4>Pair</h4>
<p>Kotlin versions after M3 don’t offer <code>Tuple</code> anymore, but specialized versions like <code>Pair</code> and <code>Triple</code> in the <em>stdlib</em>. Also, the <code>to()</code> extension function can create such pairs on the fly, without resorting to the constructor.</p>
<h4>Destructuring declarations</h4>
<p>Kotlin allows to initialize multiple variables at once when the function returns a <code>Pair</code>, a <code>Triple</code> or any <em>data</em> class for that matter.</p>
<p>This is the new improved code:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> (messageTemplate, params) = <span class="hljs-keyword">when</span> (shownCount) {
    <span class="hljs-number">0</span> -> noItem to arrayOf()
    <span class="hljs-number">1</span> -> itemShowSingle to arrayOf(totalCount)
    <span class="hljs-keyword">else</span> -> itemShowCount to arrayOf(shownCount, totalCount)
}</code></pre>
<h3><em>stdlib</em> also known as Kotlin’s toolbelt</h3>
<p>A common task in Android is to send data to the SQLite database through <code>ContentValues</code> instances. Naive Java ports look like the following snippet:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> taskValues = ContentValues()
taskValues.put(T_NAME_COL, task.name)
taskValues.put(T_DESC_COL, task.description)
taskValues.put(T_PRIO_COL, task.priority)
taskValues.put(T_DONE_COL, <span class="hljs-keyword">if</span> (task.done) <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>)
taskValues.put(T_LIST_COL, list.id)
<span class="hljs-keyword">if</span> (task.imagePath != <span class="hljs-literal">null</span>) {
    taskValues.put(T_IMG_COL, task.imagePath.toString())
}</code></pre>
<p>Kotlin’s <em>stdlib</em> provides a number of interesting functions.</p>
<h4>apply()</h4>
<p><code>apply()</code> is an extension function set on <code>Any</code> type. It accepts a null-returning function as a parameter, applies it to the receiver and return the later. Note that in the scope of the lambda, <code>this</code> is the receiver.</p>
<h4>let()</h4>
<p><code>let()</code> is another extension function set on <code>Any</code> type. It accepts a transforming function as a parameter and calls it with the receiver as the parameter.</p>
<h4>Null-safe call operator</h4>
<p>The <code>.?</code> operator will only called the right-hand operand if the left-hand operand is not null. It’s Kotlin’s idiomatic way for null checking</p>
<p>Using them in combination gives the following code:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> taskValues = ContentValues().apply {
    put(T_NAME_COL, task.name)
    put(T_DESC_COL, task.description)
    put(T_PRIO_COL, task.priority)
    put(T_DONE_COL, <span class="hljs-keyword">if</span> (task.done) <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>)
    put(T_LIST_COL, list.id)
    task.imagePath?.let { put(T_IMG_COL, it.toString()) }
}</code></pre>
<h3>Going further</h3>
<p>Another common Android task it to read data stored in UI components:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> id = nameView.tag <span class="hljs-keyword">as</span> <span class="hljs-built_in">Long</span>?
<span class="hljs-keyword">if</span> (id != <span class="hljs-literal">null</span>) {
    task.id = id
}</code></pre>
<h4>Safe cast</h4>
<p>Casts are handled in Kotlin with the <code>as</code> operator. However, nullable and non-nullable types don’t belong to the same hierarchy. Hence, if one casts <code>null</code> to a non-nullable type, a <code>ClassCastException</code> will be thrown at runtime. To avoid that, us the <code>as?</code> smart cast operator.</p>
<p>Using <code>let()</code> and the <code>.?</code> operator in conjunction with smart cast produces the next improvement:</p>
<pre><code class="hljs language-kotlin">(nameView.tag <span class="hljs-keyword">as</span>? <span class="hljs-built_in">Long</span>)?.let { task.id = it }</code></pre>
<h3>The whole shebang</h3>
<p>The final common snippet is related to querying SQLite databases. Basically, the usual flow is to create the object, create the cursor, iterate over it to read values and set object’s attributes from them. It looks like this:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">findById</span><span class="hljs-params">(id: <span class="hljs-type">Long</span>)</span></span>: Task {
    <span class="hljs-keyword">val</span> cursor = readableDatabase.rawQuery(<span class="hljs-string">"SELECT A LOT FROM TABLE"</span>, arrayOf(id.toString()))
    cursor.moveToFirst()
    <span class="hljs-keyword">val</span> name = cursor.getString(<span class="hljs-number">1</span>)
    <span class="hljs-keyword">val</span> description = cursor.getString(<span class="hljs-number">2</span>)
    <span class="hljs-keyword">val</span> imagePath = cursor.getString(<span class="hljs-number">3</span>)
    <span class="hljs-keyword">val</span> task = Task(name, description)
    <span class="hljs-keyword">if</span> (!cursor.isNull(<span class="hljs-number">4</span>)) {
        <span class="hljs-keyword">val</span> date = cursor.getLong(<span class="hljs-number">4</span>)
        task.alarm = Date(date)
    }
    cursor.close()
    task.id = id
    <span class="hljs-keyword">if</span> (imagePath != <span class="hljs-literal">null</span>) {
        task.imagePath = Uri.parse(imagePath)
    <span class="hljs-keyword">return</span> task
}</code></pre>
<h4>Local functions</h4>
<p>Methods in Java are about visibility and scoping. Basically, if one wants a method not reused in other classes, one sets the <em>private</em> visibility. If this method is used only in another method, it just pollutes the class namespace. Embedded functions are a way to declare a function inside another one to avoid this pollution. Kotlin (as well as Scala) allows that.</p>
<h4>with()</h4>
<p>Another useful function from <em>stdlib</em> is with(). Available on any type, it takes 2 parameters: the first is the receiver, the second a transforming function and calls the later on the former.</p>
<p>Combining those with some of the above features can improve the code a lot:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">findById</span><span class="hljs-params">(id: <span class="hljs-type">Long</span>)</span></span>: Task {

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">toTask</span><span class="hljs-params">(cursor: <span class="hljs-type">Cursor</span>)</span></span>: Task {
        with(cursor) {
            moveToFirst()
            <span class="hljs-keyword">val</span> name = getString(<span class="hljs-number">1</span>)
            <span class="hljs-keyword">val</span> description = getString(<span class="hljs-number">2</span>)
            <span class="hljs-keyword">val</span> imagePath = getString(<span class="hljs-number">3</span>)
            <span class="hljs-keyword">return</span> Task(name, description).apply {
                <span class="hljs-keyword">if</span> (!isNull(<span class="hljs-number">4</span>)) {
                    <span class="hljs-keyword">val</span> date = getLong(<span class="hljs-number">4</span>)
                    <span class="hljs-keyword">val</span> alarm = Date(date)
                    <span class="hljs-keyword">this</span>.alarm = alarm
                }
                <span class="hljs-keyword">this</span>.id = id
                imagePath?.let { <span class="hljs-keyword">this</span>.imagePath = Uri.parse(it) }
                close()
            }
        }
     }

    <span class="hljs-keyword">return</span> readableDatabase.rawQuery(
            <span class="hljs-string">"SELECTA LOT FROM TABLE"</span>,
            arrayOf(id.toString())).let { toTask(it) }
}</code></pre>
<h3>Conclusion</h3>
<p>Learning a new programming language is easy: many books promise to do that in 21 days. The hard part is how to write idiomatic code in that new language. This is a long and arduous journey, that needs a lot of reading such idiomatic code, writing “bad” code yourself and improving it over the course of many iterations.</p>
<p><strong>To go further:</strong></p>
<ul>
<li><a href="https://kotlinlang.org/docs/reference/multi-declarations.html">Destructuring Declarations</a></li>
<li><a href="https://kotlinlang.org/docs/reference/typecasts.html#smart-casts">Smart Casts</a></li>
<li>sdtlib functions <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/#functions">reference</a></li>
<li><a href="https://kotlinlang.org/docs/reference/null-safety.html#safe-calls">Safe calls</a></li>
<li><a href="https://kotlinlang.org/docs/reference/functions.html#local-functions">Local functions</a></li>
</ul>
]]></description><link>https://blog.frankel.ch/code-improvement-kotlin</link><guid isPermaLink="true">https://blog.frankel.ch/code-improvement-kotlin</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Nicolas Frankel]]></dc:creator><pubDate>Sun, 17 Apr 2016 16:23:00 GMT</pubDate></item><item><title><![CDATA[Few thoughts about Kotlin and why I like it so much]]></title><description><![CDATA[<p>It doesn't matter how many languages you have learnt, learning yet another one is always a wonderful experience. I have been working for a couple of months with Kotlin. Have got one app to ready for production state and another in the works.</p>
<p>To cut to the chase, I am really impressed by this language. As in really really impressed. And so I decided that I should write a few posts that can help readers get a better idea and learn about this language. So I started writing out the series and am already onto the third post now. But as I was writing it, I realised what I was writing was really about the mechanics of the language. Not so much about its spirit. Cos when one gets into the tactical nitty gritty details, one tends to miss the forest for the trees. So I decided to pen that here before I start that series (next week), and here's my few thoughts about why I really enjoy the language.</p>
<p>One of the reasons there is a lot of enthusiasm with the language is because it can be readily used for programming to the Android platform. That is how I ended up learning it. But very soon, my enthusiasm spread into the desktop/server space where I think Kotlin deserves a shout out for a very very credible effort.</p>
<p>[ EDIT: Deleted a few paragraphs]</p>
<p>So what does Kotlin bring to the table?</p>
<ul>
<li>Runs on the JVM</li>
<li>Is extremely good at interoperating with existing java code and libraries.</li>
<li>Statically typed (thus far far easier to refactor)</li>
<li>Has a bit more evolved type system than Java.</li>
<li>Is much safer than Java. Nullability is a first class compiler level construct - something that helps address a large number of likely defects aka the billion dollar bug). There is a lot to write home about here.</li>
<li>Has a clear system of distinguishing between mutable and immutable structures. While it doesn't make an opinionated stand in favour of immutability, it gives you the programmer enough helpful constructs to chart your course down that path.</li>
<li>Has support for type inference which helps reduce your boiler plate and keeps code shorter</li>
<li>Has a wonderful story to tell in terms of it providing programmers an ability to write extension functions to existing classes (or for that matter even primitives).</li>
<li>Support for Higher Order Functions, Higher kinded types</li>
<li>Support for Android programming and JavaScript execution engine (experimental).</li>
</ul>
<p>Does that make it the better language? I personally think it has achieved amongst the best set of tradeoffs that are attractive to me (obviously YMMV). And here's why I enjoy it so much.</p>
<ul>
<li>Its expressivity is comparable to and superior than python keeping your code short and sweet</li>
<li>It being a statically typed language helps enormously speed up refactoring exercises. Even though I have been using it for only two months, I went through at least two brutal refactoring cycles and found Kotlin code to be a pleasure to change.</li>
<li>It is safer, lot lot safer than python / java and delegates one of the most frequent tasks of programming ie. null checking to the compiler. Thats a huge effort of the back along with reduction in number of probable defects. Surely nothing to complain about here. And believe me this is a big big plus point.</li>
<li>Uses the JVM which is a fine and fast runtime engine</li>
<li>It is easy to learn. I actually went through the reference from start to end in 2 days and was a half decent programmer in about a weeks time. Since then I have written functional libraries for Option, Either, Stack, List, HTTP Clients, XML parsing helper libraries, rather complex X.509 certificate trust chain verifiers and a complete Java FX based app. Have started playing around with more functional constructs such as currying, functors etc. Look forward to working more with typeclasses. I just don't think I could have had such a pace of progress with any other language.</li>
<li>It is non opinionated. For XML parsing I wanted to ensure very low memory footprint because I wanted to use it on android. I was able to write a library which heavily used mutation even as it maintained very low memory usage by keeping extra object allocation counts down. For another situation I wanted to use immutable functional paradigm, and Kotlin happily let me create my own Option/Either/List classes and use that paradigm end to end. It doesn't get in your way. And focuses on getting work done.</li>
<li>I have been interfacing with a large number of java libraries. The interoperability has been an absolute breeze. It is actually refreshing to go through that experience. Doesn't matter if you are dealing with HTTP client APIs, integrating into a Slack HTTP service, interfacing with Java PKCS API, Kotlin does it easily and safely.</li>
</ul>
<p>In a nutshell, I can write code that is safer, shorter, uses better building blocks, is easier to grok, gives me all the nice capabilities such as HOFs, lambdas, pretty competent type system that gives me all the feedback necessary when writing code and makes refactoring a breeze, and interoperates nicely and leverages the JVM universe.</p>
]]></description><link>http://blog.dhananjaynene.com/2016/04/few-thoughts-about-kotlin-and-why-i-like-it-so-much/</link><guid isPermaLink="true">http://blog.dhananjaynene.com/2016/04/few-thoughts-about-kotlin-and-why-i-like-it-so-much/</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Dhananjay Nene]]></dc:creator><pubDate>Fri, 15 Apr 2016 15:44:00 GMT</pubDate></item><item><title><![CDATA[Kotlin for Scala Developers]]></title><description><![CDATA[<p>At <a href="/about">51zero</a> we pride ourselves on being flexible when it comes to language choice. Java, Scala, C#, and more recently, <a href="https://kotlinlang.org/">Kotlin</a>.  Kotlin is a JVM language developed by Jetbrains (the people behind IntelliJ amongst other things) and recently has just reached version 1.0 public. We’ve even ported ScalaTest over to Kotlin in the guise of <a href="https://github.com/kotlintest/kotlintest">KotlinTest</a> (of which we’ll do a blog soon).</p>
<p>There are some great articles already published on the main features of Kotlin, for example <a href="http://petersommerhoff.com/dev/kotlin/kotlin-for-java-devs/">here</a>, <a href="https://medium.com/@octskyward/why-kotlin-is-my-next-programming-language-c25c001e26e3#.8e0v3qg1x">here</a> and <a href="https://opencredo.com/kotlin/">here</a>, which are useful introductions for Java developers wishing to look at a different language. This blog is for Scala developers interested in having a play with Kotlin, where we review features of Scala you use every day, and their equivalents, or closest features, are in Kotlin.</p>
<h2>Data classes vs Case classes</h2>
<p>One of the main selling points of Scala when you first start to use it over Java is the use of case classes to take away all the boilerplate from Java beans. (Quite why Java didn't add this years ago I have no idea, surely the addition of an annotation that the compiler can pick up on wouldn't break existing code). But anyway, Kotlin has the same case class functionality in the form of data classes. The minor difference is that Kotlin won’t automatically infer the constructor parameters to be fields, so you must declare them as either val or var.  Eg, the following scala case class:</p>
<pre><code class="hljs language-scala"><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name: <span class="hljs-type">String</span>, age: <span class="hljs-type">Int</span></span>)</span></code></pre>
<p>Would become:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>(<span class="hljs-keyword">val</span> name: String, <span class="hljs-keyword">val</span> age: <span class="hljs-built_in">Int</span>)</code></pre>
<p>The automatic derivation of equals(), hashCode() etc works in the same way as Scala.</p>
<h2>Implicit Conversions</h2>
<p>Kotlin doesn’t support implicits as such but it does allow us to achieve one common use of implicits, which is the <em>pimp-my-library</em> pattern. In Scala, when we want to invoke foo() on a type A which contains no foo() method, the compiler will check in the appropriate scopes for an implicit method that accepts an A and returns a type B which does have the foo() method. So we create another type B, which contains all the extra methods we want for A, and then add a conversion from A to B (or mark B as an implicit class that accepts an A).  In Kotlin we can use extension methods defined on A directly.</p>
<p>So the scala code:</p>
<pre><code class="hljs language-scala"><span class="hljs-keyword">implicit</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RichString</span>(<span class="hljs-params">str: <span class="hljs-type">String</span></span>) </span>{

 <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverse</span></span>: <span class="hljs-type">String</span> = ...

 <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">take</span></span>(k: <span class="hljs-type">Int</span>): <span class="hljs-type">String</span> = ...

}</code></pre>
<p>Becomes this Kotlin code:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">reverse</span><span class="hljs-params">()</span></span> = ... <span class="hljs-comment">// the “string” is available as “this”</span>

<span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">take</span><span class="hljs-params">(k: <span class="hljs-type">Int</span>)</span></span> = ...</code></pre>
<p>Allows us to invoke this as <code>"hello".reverse()</code></p>
<p>This works for generic types too.</p>
<h2>Option</h2>
<p>Kotlin doesn't have an Option type provided by the SDK (other than the Optional type available in Java 8) instead focusing on offering null safety as a first class feature. Whether you prefer this over the Haskell inspired Options is a matter of preference. I’ll explain a way to do something very common with options.</p>
<p>Often given an option returning method, you want to map over the result before calling getOrElse or something similar. The equivalent in Kotlin would be the ?. operator which says, if the value is null, keep it null, otherwise execute the method. So this</p>
<pre><code class="hljs language-scala">map.get(<span class="hljs-string">"key"</span>).map(_.foo)</code></pre>
<p>Would become</p>
<pre><code class="hljs language-kotlin">map.<span class="hljs-keyword">get</span>(<span class="hljs-string">"key"</span>)?.foo</code></pre>
<p>Getting the value out of the option in Scala usually involves a getOrElse or a fold. In Kotlin we would use the so called Elvis operator (am I the only one that thinks this name is ridiculous! Let's call it the getOrElse operator). So this</p>
<pre><code class="hljs language-scala">option.getOrElse(<span class="hljs-number">-1</span>)</code></pre>
<p>would become</p>
<pre><code class="hljs language-kotlin">value ?: <span class="hljs-number">-1</span></code></pre>
<h2>Property access</h2>
<p>In Scala, we can access methods that declare a single empty parameter list without the parenthesis, so that methods and fields can both appear as properties. Eg,</p>
<pre><code class="hljs language-scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>{

 <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wibble</span></span>(): <span class="hljs-type">String</span> = <span class="hljs-string">"wibble"</span>

}</code></pre>
<p>Can be invoked as either foo.wibble or foo.wibble()</p>
<p>In Kotlin, we can do something similar for methods that adopt the java-bean standard. So if you have a method called fun getName() then we can do foo.name and that will be compiled into a call to the getName() function.</p>
<p>Kotlin provides something similar for setters. If there is a method called setName(str: String) then we can invoke this as either <code>foo.setName("moo")</code> or <code>foo.name = "moo"</code>. The second form will be compiled into the first form.</p>
<h2>Operator Overloading</h2>
<p>Scala allows us to declare methods with almost any operators to make (for what its proponents would argue) richer and more readable symbols for methods where operators make sense (the canonical example tends to be matrices, vectors or complex numbers). The opponents would say you end up with things like <a href="http://www.flotsam.nl/dispatch-periodic-table.html">this</a>. Personally, I don’t mind either way.</p>
<p>Kotlin allows us to override some operators, but only ones predefined. Eg, plus, minus etc. To do this we just declare a method with the name that matches the symbol, and annotate the function declaration with the keyword operator. Eg</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">plus</span><span class="hljs-params">(vector: <span class="hljs-type">Vector</span>)</span></span>: Vector = ...</code></pre>
<p>The full list of supported operators can be found <a href="https://kotlinlang.org/docs/reference/operator-overloading.html">here</a>.</p>
<h2>Pattern Matching</h2>
<p>Kotlin unfortunately doesn't support full pattern matching, so you cannot do things like</p>
<pre><code class="hljs language-scala">person <span class="hljs-keyword">match</span> {
 <span class="hljs-keyword">case</span> <span class="hljs-type">Person</span>(<span class="hljs-string">"bobby"</span>, age) =>
 <span class="hljs-keyword">case</span> _ =>
}</code></pre>
<p>There is a limited form of extraction, which you can read about later, and there is a replacement for switch which allows matching on types and invocation of functions on the argument. This uses the keyword when, eg,</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">when</span>(obj) {
 <span class="hljs-keyword">is</span> String -> <span class="hljs-comment">// matches on the type</span>
 parseInt(obj) -> <span class="hljs-comment">// invoked method parseInt</span>
 <span class="hljs-keyword">else</span> -> <span class="hljs-comment">// otherwise</span>
}</code></pre>
<p>There is a neat way to use when’s as a replacement for if-else-if chains, you just use when without an argument, as such</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">when</span> {
 person.name == <span class="hljs-string">"bobby"</span> ->
 x.isOdd() ->
 <span class="hljs-keyword">else</span> ->

}</code></pre>
<h2>Apply method</h2>
<p>In Scala, methods named apply() do not need to have the method name in order to be invoked, eg</p>
<pre><code class="hljs language-scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Foo</span> </span>{
 <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>() = println(<span class="hljs-string">"hello"</span>)
 <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>(str: <span class="hljs-type">String</span>) = println(str)
}</code></pre>
<p>Can be invoked simply as Foo() or Foo(“hello”)</p>
<p>In Kotlin, the equivalent is to name the method invoke() with the additional operator annotation, eg</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">object</span> Foo {
 <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invoke</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">"hello"</span>)
 <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invoke</span><span class="hljs-params">(str: <span class="hljs-type">String</span>)</span></span> = println(str)
}</code></pre>
<p>And then we can do the same, Foo() or Foo(“hello”)</p>
<h2>Anonymous Lambda Parameter</h2>
<p>In scala we can refer to the lambda parameter using an underscore, eg list.map(_.name) which is very concise and very readable. Kotlin doesn’t offer a direct equivalent but there is an implicit <strong>it</strong> parameter available: list.map { <strong>it</strong>.name }.</p>
<p>This has the drawback that its ever so slightly more verbose, but offers the advantage that you can use it in multiple places, eg, in Scala we can’t do</p>
<pre><code class="hljs language-scala">list.map(_.firstname + _.lastname)</code></pre>
<p>but instead must introduce a parameter</p>
<pre><code class="hljs language-scala">list.map(x => x.firstname + x.lastname)</code></pre>
<p>In Kotlin we can use the <strong>it</strong> parameter multiple times, eg</p>
<pre><code class="hljs language-kotlin">list.map { it.firstname + it.lastname }</code></pre>
<h2>Companion objects</h2>
<p>Companion objects are supported in Kotlin using slightly different syntax. Instead of declaring an object with the same name, declare an object with the keyword companion inside the class itself.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>{
 <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> {
   <span class="hljs-comment">// methods here</span>
 }
}</code></pre>
<h2>Extractors</h2>
<p>While kotlin doesn’t have extractors as such, it does support a limited form of extraction called desugaring declarations which go some way to performing the same job. Any class that implements the functions component1(), component2(), and so on (similar to the product() provided by Scala’s Product1, Product2, ProductN traits) can be desugared into component variables. For example</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> person = Person(<span class="hljs-string">"billy"</span>, <span class="hljs-number">21</span>)
<span class="hljs-keyword">val</span> (name, age) = person</code></pre>
<p>Which is compiled into</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> person = Person(<span class="hljs-string">"billy"</span>, <span class="hljs-number">21</span>)
<span class="hljs-keyword">val</span> name = person.component1()
<span class="hljs-keyword">val</span> age = person.component2()</code></pre>
<p>In Scala, case classes automatically extend the appropriate ProductN trait. In Kotlin data classes automatically implement the appropriate componentN() functions.</p>
<p>This also works in for statements, replacing the scala code:</p>
<pre><code class="hljs language-scala"><span class="hljs-keyword">for</span> ((a,b) &#x3C;- person) { }</code></pre>
<p>With the almost identical</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">for</span> ((a,b) <span class="hljs-keyword">in</span> person) { }</code></pre>
<p>That’s all for now. Hopefully this article provides some hints and tips for Scala developers who are interested in exploring a little bit of Kotlin.</p>
]]></description><link>http://www.51zero.com/blog/2016/4/14/kotlin-for-scala-developers</link><guid isPermaLink="true">http://www.51zero.com/blog/2016/4/14/kotlin-for-scala-developers</guid><category><![CDATA[Scala]]></category><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Stephen Samuel]]></dc:creator><pubDate>Thu, 14 Apr 2016 15:44:00 GMT</pubDate></item><item><title><![CDATA[Kotlin Post-1.0 Roadmap]]></title><description><![CDATA[<p>It’s been almost two months since Kotlin 1.0 was released, and the team is now switching from stabilisation and bug fixes to new feature work, so it’s a great time to talk about our plans for the future.</p>
<p>We’ve already published our <a href="http://blog.jetbrains.com/kotlin/2016/03/kotlins-android-roadmap/">Android roadmap</a>, but there are many other areas where we’re applying our efforts. Our current development is organised in two main branches:</p>
<ul>
<li><strong>Kotlin 1.0.x</strong> which will be a series of releases containing bug fixes, updates to tooling, IDE support and other areas which do not affect the core language. 1.0.x releases will be published on a regular basis once every several weeks.</li>
<li><strong>Kotlin 1.1</strong> which will contain major new language features, along with all the improvements from the 1.0.x branch. This will be a feature-driven release, and we aren’t announcing any specific time frame for it.</li>
</ul>
<p>Let’s look at the plans for each area in more detail, starting with the big ones.</p>
<h2>New Language Features</h2>
<p>Before we can start talking about specific features, the <strong>big disclaimer</strong>: everything we’re talking about here is still in the design phase, and features may end up being changed dramatically or dropped entirely as we move forward with the design, implementation and feedback gathering process. So, no guarantees.</p>
<h3>async/await/yield</h3>
<p>The most important feature that we’re designing right now is support for <strong>coroutines</strong> (async/await/yield). By now, the async/await pattern has found its way into many different languages, including C#, Python and Dart, and we want to support this in Kotlin as well. However, that’s not the end of the story: we want to put the specific code execution semantics into the library, rather than the compiler.</p>
<p>The compiler will take care of transforming the function used as a coroutine into a form allowing to suspend and resume its execution. The actual execution of a coroutine (the initial invocation, as well as resuming the execution after a suspension point) will be the responsibility of the support library. Therefore, the same mechanism will allow us to support many different patterns: generators (<code>yield</code>), asynchronously executed functions (<code>async</code>/<code>await</code>), Go-like channels and goroutines, as well as potentially others which haven’t even been invented yet.</p>
<p>Note that we’re still in the process of estimating the effort needed to implement this feature, and we don’t know whether it would be reasonable to support it in the 1.1 timeframe or it would be postponed to a later release.</p>
<h3>Other Language Features</h3>
<p>We’ve received quite a lot of feedback from Kotlin 1.0, and we were quite happy to see that a lot of the requests were asking for the same features. We’ve chosen the ones that come up the most often, and have prioritised them for Kotlin 1.1. Those we’re reasonably sure about are:</p>
<ul>
<li>
<p><strong>Data class hierarchy support</strong> will remove many of the current restrictions on data class inheritance, for example, allowing you to represent an algebraic data type as a series of data classes nested in a sealed class:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> </span>{
    <span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>(<span class="hljs-keyword">val</span> x: X, <span class="hljs-keyword">val</span> y: Y) : C() { ... }
}</code></pre>
</li>
<li><strong>Type aliases</strong> will allow to assign a short name to a type (for example, a function type, or a generic type with a long signature):
<code>typealias MouseEventHandler = (MouseEvent) -> Unit</code></li>
<li><strong>Destructuring in lambdas</strong> will allow you to easily unpack a data class instance or another object supporting the destructuring protocol when it’s passed as a parameter to a lambda:
<code>myMap.forEach { (key, value) -> println(key+value) }</code></li>
<li><strong>Bound method references</strong> will allow to create a method reference that invokes a method on a specific object instance, and doesn’t require passing it as a parameter:
<code>letters.filter("abc"::contains)</code></li>
<li><strong>Local delegated properties</strong> will allow you to define a local variable as a delegated property:
<code>fun foo() { val x by lazy { ... } }</code></li>
</ul>
<h2>Java 8/9 Support</h2>
<p>As of version 1.0, Kotlin targets Java 6 only. This means that the generated bytecode does not make use of any features added in Java 7 or 8, and the standard library only exposes the APIs that existed in Java 6.</p>
<p>Over the course of 1.0.x and 1.1 releases and beyond, we plan to remove these restrictions, and to give you the choice of the JVM version that you’re targeting. Java 6 is still going to be supported, but if you choose to target Java 8, we’ll make use of that. The standard library will let you use the new Java 8 APIs, such as the stream API, and the compiler will use the newer bytecode features, such as the support for default methods in interfaces. We also plan to support Project Jigsaw (the JDK 9 module system) by the time JDK 9 is released.</p>
<h2>JavaScript Support</h2>
<p>When we started finalizing the 1.0 release, we decided to suspend work on JavaScript support and to focus on the JVM as the main supported platform for the release. Now that 1.0 is out, we’ve resumed work on JS, and we’re moving towards our goal of letting you write the business logic of your application only once and to run it both on the backend and in the user’s browser.</p>
<p>Our main priorities for the short term are filling in the missing language features and better integration with the overall JavaScript infrastructure (starting with support for JS module systems). We also plan to leverage the huge set of strongly-typed API definitions for most major JS libraries, which has been accumulated by the TypeScript community. We’ll provide a tool to convert those definitions into Kotlin code, letting you use the libraries from Kotlin with a fully typed API and very little effort spent on integration.</p>
<h2>IDE Features</h2>
<p>In the IDE space, our current priorities are as follows:</p>
<ul>
<li><strong>Framework support</strong>: We plan to extend the unparalleled level of Java enterprise framework support offered by IntelliJ IDEA Ultimate so that it works equally well for Kotlin. This will be a gradual process happening in parallel inside IntelliJ IDEA and inside the Kotlin plugin; the first batch of Spring support features is already available in Kotlin 1.0.2 EAP.</li>
<li><strong>Intentions and Quickfixes:</strong> In our view, one of the main roles of an IDE is teaching you how to use the language well and helping you get back to speed if you make a mistake, by providing code improvement suggestions and automatic quickfixes. Kotlin 1.0 already contains a nice set of tools in this area, and we’re going to expand on it in the 1.0.x and 1.1 updates. As one example, we’re building tools that can convert imperative-style loops into code written in the functional style, using functions such as map and filter.</li>
<li><strong>Other Improvements:</strong> Other things on our roadmap include new refactorings such as Inline Method, a more robust and flexible formatter, support for diagrams for Kotlin code, and more.</li>
</ul>
<h2>Other Tooling Improvements</h2>
<p>The Android roadmap post already mentioned some of the improvements that we plan to make in our tools, such as support for incremental compilation with Gradle and support for Android Lint checks. Both of these features are already available in Kotlin 1.0.2 EAP, and will receive further improvements later on.</p>
<h2>Summary</h2>
<p>As you can see, there are quite a lot of exciting things coming, and there’s plenty of opportunity for you to get involved. Stop by our <a href="http://kotlinslackin.herokuapp.com/">Slack chat</a>, try out the <a href="https://discuss.kotlinlang.org/c/eap">EAP builds</a>, file <a href="http://youtrack.jetbrains.com/issues/KT">issues</a> – the future of Kotlin depends on you, our users, and we’re always happy to hear anything that you have to say.</p>
]]></description><link>http://blog.jetbrains.com/kotlin/2016/04/kotlin-post-1-0-roadmap/</link><guid isPermaLink="true">http://blog.jetbrains.com/kotlin/2016/04/kotlin-post-1-0-roadmap/</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Dmitry Jemerov]]></dc:creator><pubDate>Thu, 14 Apr 2016 12:34:00 GMT</pubDate></item><item><title><![CDATA[Making Android Development Easier]]></title><description><![CDATA[<h4>Taking Ideas From The Front-End Web</h4>
<p>If you’ve done Android, you know how quickly your code can grow in complexity as you build out your app. Java is known for boilerplates, and UI-related code (XML &#x26; Java combined) will probably take the most of your code. In this post, I’m proposing new solution to make Android UI development much easier and less time consuming. It encourages patterns that may be new for Android, but it existed for long while in front-end development.</p>
<p>Android SDK has a remarkable UI framework that allows you to build user interfaces in clear and concise way using XML. The layout system is very well thought out, you can build any kind of complex interface using it. But due to the dynamic aspects of user interfaces and the evolving UI design patterns nowadays, building UI becomes more complicated than just writing XML and it will involve a lot of Java &#x26; XML writing.</p>
<h4><strong>Front-End Web vs Android Development</strong></h4>
<p>When compared to mobile or desktop app development in general, I consider web as the easiest platform for building user interfaces. I was impressed by how the front-end community recently created impressive tools that made front-end development much easier and more disciplined. From Grunt, Gulp, Bower, Babel, ES6 to SASS, Bootstrap to React or Angular. There are also so many good patterns that existed in front-end development. Web existed for more than 20 years, so it’s only natural that they have reached this level of maturity when it comes to building UIs.</p>
<p>Thanks to the brilliant XML layouts in Android, I realized there’s a resemblance between Android and front-end web. You can think of XML as the HTML, and Java as the JavaScript. Except in Android we’re at the point of pre-jQuery, we still don’t have the frameworks that allow us to quickly build and manage UI. Android layout system is very flexible, and it provides great opportunities to create such frameworks. We have to take advantage of that and take it to the next level. The patterns used for front-end development are not exclusive to web, we can apply them on Android.</p>
<p>Just to clarify, Android &#x26; Java community has written amazing libraries that also made Android development much easier. Just put Retrofit, RxJava, Realm and Kotlin together to create magic, you will be saving a great amount of time writing code. However there are many other challenges that are yet to be solved. This has motivated me build a UI framework inspired by the front-end web. Today, I finally published my <a href="https://github.com/maannajjar/lattekit">LatteKit</a> framework and made it public in github. But before checking it out, please let me take you through the the problems the framework should solve.</p>
<h4><strong>Identifying The Problem</strong></h4>
<p>As I started mulling the idea of creating UI framework, I needed to identify the problems that needed to be solved by my framework. There must be real problems to solve, I didn’t want this to be just an attempt to copy the web. I tried making a small app in Android &#x26; web app in order to help me see the things that made Android more complicated. Below are the major points I found:</p>
<p><strong>1- Non-streamlined UI development</strong></p>
<p>From design perspective, your app consists of screens that contain set of UI elements. However, it becomes very complicated when you start building the UI in Android. In Android, there are many different types of components that are directly or indirectly related to building the UI. For example, we have Activity that may contains View widgets (subclasses of android.view.View) and/or Fragments, we also have ListViews and Adapters. Each one of those component has a different way to create and manage, passing data between those components can be very different. Fragments work with Bundles, ListView (and others) require Adapters, Activities need Intents, ..etc. Those components have clear purpose and function, but at the end of the day they all play the same part in building the layout tree. All the internals should be abstracted so the components are used in uniform and streamlined way.</p>
<p><strong>2- Styling UI components</strong></p>
<p>Styling UI views are done via XML, but not always. Styling in XML may cause a lot of boilerplate. Sometimes you may end up creating 2–3 xml files to achieve single styling objective. Sometimes you’re forced to subclass a certain View in java. For example, if you need to create a circular ImageView, you will have to subclass it and override the drawing method. In Web those are all done in CSS using simple CSS properties.</p>
<p><strong>3- View Re-usability and Separation of Concerns</strong></p>
<p>Many times you will need to group views together that perform specific UI function. You can do that by either using <code>&#x3C;include></code> tag or by subclassing some ViewGroup class and inflating your xml there. Using <code>&#x3C;include></code> tag alone is not real solution because you will still have to write related Java code in the user code (e.g. in Fragment or Activity). Subclassed custom Views are difficult to manage (for example, if you want your custom view to have some certain custom attributes you will have to define those attributes in attrs.xml, then you will have to capture them in the constructor by reading AttributeSet.) They introduce more boilerplate that sometimes it’s not worth writing a whole subclass of View, you end up writing most your layout in the fragment or activity. When you decide to refactor, the code will be intermingled and hard to move out to its own class.</p>
<p><strong>4- Majority of apps contain ListView/RecyclerViews/ViewPager. Writing Adapters is a waste of time</strong></p>
<p>Adapter based Views are basically container views that show repeated UI elements. In web, all it takes is to write a loop which iterates through your dataset and render the UI elements. In Android (and similarly in iOS), you have to a define new Adapter class that will manually create the UI elements and bind the data. This was done for optimization purposes, Adapters help you recycle re-usable views. I understand the need to use Adapters for optimization, but there’s so much repeated pattern when writing Adapters that can be abstracted and make using ListViews (and others) easier.</p>
<h4>Designing The Solution</h4>
<p>I’ll present below my attempt to solve the problems above. My goal is not to create a new UI toolkit, but rather build a framework on top of Android layout system. The framework will manage views behind the scene and abstract many aspects of the underlying Android API. I established some general principles that I should follow while designing my framework</p>
<p><strong>1- The framework shouldn’t introduce new complicated concepts to Android developers</strong></p>
<p>It should serve a single purpose: allow you to build the UI and get out of the way. No complicated APIs to learn. Android developer should find it very easy to adapt to the framework.</p>
<p><strong>2- The framework should provide uniform and concise way to build UI</strong></p>
<p>There should be only one way to build a layout. The framework shouldn’t provide different and confusing alternatives to build certain UI elements.</p>
<p><strong>3- Defining a View should only mean writing one file, and with minimum boilerplate</strong></p>
<p>You shouldn’t be jumping between xml and java files.</p>
<p><strong>4- The framework should use proven patterns to build UIs</strong></p>
<p>I shouldn’t be creating my own pattern to build UIs, there are tons of proven patterns that already worked and I don’t need to get too creative and invent something totally new.</p>
<p>I started testing different frameworks used for front-end development. Two popular frameworks that caught my attention are Angular and React. I was very impressed by React and its simplicity. It doesn’t introduce new concepts and it has low learning curve. All you need to know is HTML &#x26; JavaScript and basic details about the lifecycle of React components. It introduces the concept of virtual DOM, and provides a way to bind data. You can read more about it here <a href="https://facebook.github.io/react/">https://facebook.github.io/react/</a>. React model also fits perfectly with my 4 principles. They do have React Native which is framework to build for mobile including Android. However, it introduces new concepts and it relies on JavaScript which is strange to Android. Also, you will have to write bridges between Java &#x26; JavaScript if you want to use Android’s API.</p>
<p><strong>Plain Java Won’t Work</strong></p>
<p>While designing my framework. I decided that I shouldn’t be using plain Java for many reasons. First, it will introduce many boilerplates that will defeat the purpose of the framework. Second, for technical reasons I needed some features that Java can’t offer.</p>
<p>Luckily there’s Kotlin, which is becoming a rising start in Android development. Kotlin is modern JVM language that provides modern language features which are missing in Java. It heavily reduces the boilerplate code and it’s interoperable with Java. It works great with Android and it’s supported in Android Studio (Kotlin was created by JetBrains, the maker of IntelliJ IDEA).</p>
<h4><strong>And LatteKit Was Born...</strong></h4>
<p>There’s so much to talk about LatteKit and how I built it. The concept should be clear though. If you know minimal Kotlin &#x26; CSS with Android knowledge, you should be able to pick up the concept quickly. I created a quick example &#x26; documentation in the github repository. There is also a full sample which shows how much lines of code you will save when using the library, it’s really a lot. Available at:</p>
<p><a href="https://github.com/maannajjar/lattekit">https://github.com/maannajjar/lattekit</a></p>
<p>Please take a look, try it out and let me know what you think. Keep in mind that this a first release, the core functionality is complete but there are many things left to do in the roadmap.</p>
<p>Below is a quick sample I built using the library , you can view the source code in the github repo which shows the minimal line of codes needed.</p>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/800/1*fULW0kZcUOPcPOmm5QMaBQ.png"></p>
<p>I’ll dedicate another post about the patterns to use with LatteKit &#x26; Kotlin, which will make building Android apps very quickly and with the minimal effort. I’m happy with what I have accomplished so far, I’m also not taking full credit for the idea because it was inspired by React which proved to work really well in the web.</p>
]]></description><link>https://medium.com/@maannajjar/progressive-android-ui-development-28d281dbe21b#.g8c7xq81a</link><guid isPermaLink="true">https://medium.com/@maannajjar/progressive-android-ui-development-28d281dbe21b#.g8c7xq81a</guid><category><![CDATA[Android]]></category><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Maan Najjar]]></dc:creator><pubDate>Mon, 11 Apr 2016 20:06:00 GMT</pubDate></item><item><title><![CDATA[Keddit — Part 7: Infinite Scroll: Higher-Order functions & Lambdas]]></title><description><![CDATA[<p><img src="https://d262ilb51hltx0.cloudfront.net/max/2000/1*coKbXMpkG8Fc1NJtM6Jp4w.png"></p>
<h3>Content</h3>
<ul>
<li><a href="https://medium.com/@juanchosaravia/learn-kotlin-while-developing-an-android-app-introduction-567e21ff9664">Introduction: A few words about this</a></li>
<li><a href="https://medium.com/@juanchosaravia/learn-kotlin-while-developing-an-android-app-part-1-e0f51fc1a8b3">Part 1:</a> <a href="https://medium.com/@juanchosaravia/learn-kotlin-while-developing-an-android-app-part-1-e0f51fc1a8b3">Configuring Android Studio with Kotlin</a></li>
<li><a href="https://medium.com/@juanchosaravia/learn-kotlin-while-developing-an-android-app-part-2-e53317ffcbe9">Part 2: MainActivity.kt: Syntax, Null Safety and more...</a></li>
<li><a href="https://medium.com/@juanchosaravia/keddit-part-3-extension-functions-android-extensions-and-more-faa7d232f232">Part 3: NewsFragment.kt: Extension Functions, Android Extensions...</a></li>
<li><a href="https://medium.com/@juanchosaravia/keddit-part-4-recyclerview-delegate-adapters-data-classes-with-kotlin-9248f44327f7">Part 4: RecyclerView — Delegate Adapters &#x26; Data Classes with Kotlin</a></li>
<li><a href="https://medium.com/@juanchosaravia/keddit-part-5-kotlin-rxjava-rxandroid-105f95bfcd22">Part 5: Kotlin, RxJava &#x26; RxAndroid</a></li>
<li><a href="https://medium.com/@juanchosaravia/keddit-part-6-api-retrofit-kotlin-d309074af0">Part 6: API — Retrofit &#x26; Kotlin</a></li>
<li><a href="https://medium.com/@juanchosaravia/keddit-part-7-infinite-scroll-higher-order-functions-lambdas-3a11fbd5090e">Part 7: Infinite Scroll: Higher-Order functions &#x26; Lambdas</a></li>
<li>Part 8: Orientation Change (Parcelables &#x26; Data Classes)</li>
<li>Part 9: Unit &#x26; Integration Tests</li>
</ul>
<h3>Part 7: Infinite Scroll: Higher-Order functions &#x26; Lambdas</h3>
<p>Thanks to all the previous stories we have a small Reddit client App that <strong>shows the Top news from Reddit</strong> and what we need now is to allow the user to see not only the first 10 news but the next news that also belongs to this Top Reddit news. That’s why we introduce here the Infinite Scroll.</p>
<p>The implementation of the infinite scroll was inspired by <a href="http://msobhy.me/2015/09/05/infinite_scrolling_recyclerview/">this article</a> and the author is <a href="https://twitter.com/@mSobhy90">Mohamed Sobhy</a>. I made just a few changes to provide an example of Higher-Order functions and passing a lambda expression as parameter.</p>
<h3>Higher-Order Functions</h3>
<blockquote>
<p>A higher-order function is a function that takes functions as parameters, or returns a function.</p>
</blockquote>
<p>Well, lets see how Kotlin allows you to pass functions as parameter or return it with some examples.</p>
<p>This function “<strong>logExecution</strong>” allows you to pass a function as parameter and log before and after the execution of this function.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">logExecution</span><span class="hljs-params">(func: ()</span></span> -> <span class="hljs-built_in">Unit</span>) {
    Log.d(<span class="hljs-string">"tag"</span>, <span class="hljs-string">"before executing func"</span>)
    func()
    Log.d(<span class="hljs-string">"tag"</span>, <span class="hljs-string">"after executing func"</span>)
}</code></pre>
<h4>func: ()-> Unit</h4>
<p>As you already know, “<strong>func</strong>” is the name of the parameter and “<strong>() -> Unit</strong>” is the “type” of the parameter, in this case, we are saying that <strong>func</strong> will be a function that <strong>doesn’t receive any parameter and doesn’t return any value</strong> (remember that Unit works like void in Java).</p>
<p>You can call this function by passing a lambda expression that must not receive or return any value, like in this way:</p>
<pre><code class="hljs language-kotlin">logExecution( { Log.d(<span class="hljs-string">"tag"</span>, <span class="hljs-string">"I'm a function"</span>) } )</code></pre>
<p>but also Kotlin allows you to remove the parenthesis if there is only one function parameter or if the last parameter is a function:</p>
<pre><code class="hljs language-kotlin">logExecution { Log.d(<span class="hljs-string">"tag"</span>, <span class="hljs-string">"I'm a function"</span>) }</code></pre>
<p>If we change the <strong>logExecution</strong> signature to receive another parameter and we put the function parameter at the end, we can do this:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">// added tag parameter:</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">logExecution</span><span class="hljs-params">(tag: <span class="hljs-type">String</span>, func: ()</span></span> -> <span class="hljs-built_in">Unit</span>) { ... }

<span class="hljs-comment">// call in this way:</span>
logExecution(<span class="hljs-string">"tag"</span>) { Log.d(<span class="hljs-string">"tag"</span>, <span class="hljs-string">"I'm a function"</span>) }</code></pre>
<p>or:</p>
<pre><code class="hljs language-kotlin">logExecution(<span class="hljs-string">"tag"</span>) {
    Log.d(<span class="hljs-string">"tag"</span>, <span class="hljs-string">"I'm a function"</span>)
}</code></pre>
<p>Also you can make the function to receive and return values:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">logExecution</span><span class="hljs-params">(func: (<span class="hljs-type">String</span>, String)</span></span> -> <span class="hljs-built_in">Int</span>) {
    <span class="hljs-keyword">val</span> thisIsAnInt = func(<span class="hljs-string">"Hello"</span>, <span class="hljs-string">"World"</span>)
}</code></pre>
<p>As you can see Kotlin gives you a lot of power with Higher-Order functions. Also this allows you to remove a lot of Android ceremonies that requires you to initialize things before to execute something or never forget to close a cursor, and much more.</p>
<h4>Async function example</h4>
<p>Lets see a practical example. We are going to create a new function that receives a function and execute it in another thread:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runAsync</span><span class="hljs-params">(func: ()</span></span> -> <span class="hljs-built_in">Unit</span>) {
    Handler().post(Runnable { func() })
}</code></pre>
<p>Now we can execute a function outside of the Main UI Thread easily:</p>
<pre><code class="hljs language-kotlin">runAsync {
    <span class="hljs-comment">// i.e.: save something in the Database</span>
}</code></pre>
<h4>Is Lollipop example</h4>
<p>Maybe you want to run some specific code for Lollipop devices and instead of doing the regular if check, you can use this function:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isLollipopOrAbove</span><span class="hljs-params">(func: ()</span></span> -> <span class="hljs-built_in">Unit</span>) {
    <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
        func()
    }
}</code></pre>
<p>and use it in this way:</p>
<pre><code class="hljs language-kotlin">isLollipopOrAbove {
    <span class="hljs-comment">// run lollipop specific code safely</span>
}</code></pre>
<h3>Infinite Scroll</h3>
<p>Ok lets see how we can take advantages of this new concept and create our infinite scroll behaviour.</p>
<p>The RecyclerView allows you to set a Scroll Listener so I created this <a href="https://github.com/juanchosaravia/KedditBySteps/blob/master/app/src/main/java/com/droidcba/kedditbysteps/commons/InfiniteScrollListener.kt">InfiniteScrollListener</a> and I defined the signature of this class in this way:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InfiniteScrollListener</span></span>(
        <span class="hljs-keyword">val</span> func: () -> <span class="hljs-built_in">Unit</span>,
        <span class="hljs-keyword">val</span> layoutManager: LinearLayoutManager)
                 : RecyclerView.OnScrollListener() {...}</code></pre>
<p>What we are doing here is to receive a function parameter that will be invoked every time we get to the end of the RecyclerView (<a href="https://github.com/juanchosaravia/KedditBySteps/blob/master/app/src/main/java/com/droidcba/kedditbysteps/commons/InfiniteScrollListener.kt#L36">see line 36 for more details</a>). In fact, it will be called before to reach the end of the list, you can set a threshold that will make our function to be invoked a few items before and in this way you provide a better experience and not making the user to see all the time the loader that more news were requested.</p>
<p>The function that we are going to pass as parameter is a function that request more news and update the NewsAdapter with the new received news:</p>
<pre><code class="hljs language-kotlin">news_list.addOnScrollListener(
   InfiniteScrollListener({ requestNews() }, linearLayout)
)</code></pre>
<p><strong>requestNews()</strong> is a function that we already have in our code, I update it to use pagination and request the next available news from Reddit.</p>
<p>As you may notice, I’m not passing requestNews() <strong>but inside a lambda expression</strong>. This is because the compiler will not take it as a function parameter but as a function that needs to be executed and use the return type of this function as the value that we are passing to the InfiniteScrollListener. As the return type of requestNews is “Unit”, it doesn’t match the InfiniteScrollListener parameter expected which is “()->Unit”, so this code will not compile except if you put this into the lambda expression that match perfectly the required parameter.</p>
<h4>Commit:</h4>
<p>Here you have all the code added to include Infinite Scroll behaviour:</p>
<p><a href="https://github.com/juanchosaravia/KedditBySteps/commit/3bedf81ad25aecf24aacc224c6591072eccf5b73">https://github.com/juanchosaravia/KedditBySteps/commit/3bedf81ad25aecf24aacc224c6591072eccf5b73</a></p>
<h3>Conclusion</h3>
<p>We are now able to scroll and see more news from Reddit Top list. All the details can be reviewed in the previous commit.</p>
<p>Higher-Order functions is an incredible feature and hope it is more clear now with these examples. I invite you to post other examples if you feel inspired.</p>
<p>See you in the next story!</p>
<p><strong>Twitter</strong>: <a href="https://twitter.com/juanchosaravia">https://twitter.com/juanchosaravia</a></p>
]]></description><link>https://medium.com/@juanchosaravia/keddit-part-7-infinite-scroll-higher-order-functions-lambdas-3a11fbd5090e#.cdsuea4kc</link><guid isPermaLink="true">https://medium.com/@juanchosaravia/keddit-part-7-infinite-scroll-higher-order-functions-lambdas-3a11fbd5090e#.cdsuea4kc</guid><category><![CDATA[Android]]></category><category><![CDATA[Kotlin]]></category><category><![CDATA[Keddit]]></category><dc:creator><![CDATA[Juan Ignacio Saravia]]></dc:creator><pubDate>Sat, 09 Apr 2016 15:36:00 GMT</pubDate></item><item><title><![CDATA[The Kobalt diaries: Automatic Android SDK management]]></title><description><![CDATA[<p><img src="http://beust.com/pics/sdk-manager.png">
<strong>The dreaded SDK Manager</strong></p>
<p>Android has always had a weird dependency mechanism. On the JVM (and therefore, Android), we have this great Maven repository system which is leveraged by several tools (Gradle and Kobalt on Android) and which allows us to add dependencies with simple additions to our build files. This is extremely powerful and it has undoubtedly been instrumental in increasing the JVM’s popularity. This system works for pretty much any type of applications and dependencies.</p>
<p>Except for Android libraries.</p>
<p>The Android support libraries (and I’m using “support” loosely here to include all such libraries and not just the one that Google calls “support”) are not available on any of the Maven repositories. They are not even available on Google’s own repository. Instead, you need to use a special tool to download them, and once you do that, they land on your local drive as a local Maven repository, which you then need to declare to Gradle so you can finally add the dependencies you need.</p>
<p>I suspect the reason why these libraries are not available in a straight Maven repo is that you need to accept licenses before you can use them, but regardless, this separate download management makes building Android applications more painful, especially for build servers (Travis, Jenkins) which need to be configured specifically for these builds.</p>
<p>The graphical tool used to download this repository, called “SDK Manager”, is also a command tool called <code>"android"</code> that can be invoked without the GUI, and inspired by <a href="https://github.com/JakeWharton/sdk-manager-plugin">Jake Wharton’s sdk-manager-plugin</a>, I set out to implement automatic SDK management for <a href="http://beust.com/kobalt">Kobalt</a>.</p>
<p>Once I became more comfortable with the esoteric command line syntax used by the <code>"android"</code> tool, adding it to the Kobalt Android plug-in was trivial, and as a result, Kobalt is now able to completely install a full Android SDK from scratch.</p>
<p>In other words, all you need in your project is a simple Android configuration in your <code>Build.kt</code> file:</p>
<pre><code class="hljs language-kotlin">android {
    compileSdkVersion = <span class="hljs-string">"23"</span>
    buildToolsVersion = <span class="hljs-string">"23.0.1"</span>
    <span class="hljs-comment">// ...</span>
}

dependencies {
    compile(<span class="hljs-string">"com.android.support:appcompat-v7:aar:23.0.1"</span>)
}</code></pre>
<p>The Kobalt Android plug-in will then automatically download everything you need to create an <code>apk</code> from this simple build file:</p>
<ul>
<li>If <code>$ANDROID_HOME</code> is specified, use it and make sure a valid SDK is there. If that environment variable is not specified, install the SDK in a default location (<code>~/.android-sdk</code>).</li>
<li>If no Build Tools are installed, install them.</li>
<li>Then go through all the Google and Android dependencies for that project and install them as needed.</li>
<li>And a few other things...</li>
</ul>
<p>A typical run on a clean machine with nothing installed will look like this:</p>
<pre><code class="hljs language-bash">$ ./kobaltw assemble
...
Android SDK not found at /home/travis/.android/android-sdk-linux, downloading it
Couldn<span class="hljs-string">'t find /home/travis/.android/android-sdk-linux/build-tools/23.0.1, downloading it
Couldn'</span>t find /home/travis/.android/android-sdk-linux/platform-tools, downloading it
Couldn<span class="hljs-string">'t find /home/travis/.android/android-sdk-linux/platforms/android-23, downloading it
Couldn'</span>t find Maven repository <span class="hljs-keyword">for</span> extra-android-m2repository, downloading it
Couldn<span class="hljs-string">'t find Maven repository for extra-google-m2repository, downloading it
...
          ===========================
          | Building androidFlavors |
          ===========================
------ androidFlavors:clean
------ androidFlavors:generateR
------ androidFlavors:compile
  Java compiling 4 files
------ androidFlavors:proguard
------ androidFlavors:generateDex
------ androidFlavors:signApk
Created androidFlavors/kobaltBuild/outputs/apk/androidFlavors.apk</span></code></pre>
<p>Obviously, these downloads will not happen again unless you modify the dependencies in your build file.</p>
<p>I’m hopeful that Google will eventually make these support libraries available on a real remote Maven repository so we don’t have to jump through these hoops any more, but until then, Kobalt has you covered.</p>
<p>This feature is available in the latest <a href="https://github.com/cbeust/kobalt-android"><code>kobalt-android</code> plug-in</a> as follows:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> p = plugins(<span class="hljs-string">"com.beust:kobalt-android:0.81"</span>)</code></pre>
]]></description><link>http://beust.com/weblog/2016/04/09/the-kobalt-diaries-automatic-android-sdk-management/</link><guid isPermaLink="true">http://beust.com/weblog/2016/04/09/the-kobalt-diaries-automatic-android-sdk-management/</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Kobalt]]></category><dc:creator><![CDATA[Cédric Beust]]></dc:creator><pubDate>Sat, 09 Apr 2016 04:58:00 GMT</pubDate></item><item><title><![CDATA[Android And Kotlin]]></title><description><![CDATA[<p><strong>Kotlin</strong> – one of the popular programming languages built on top of Java that runs on JVM. Thanks to JetBrains support and excellent IDE integration, it’s an ideal choice for Android development. 100% Java compatibility, interoperability and no runtime overhead is just the beginning of a long list of strengths. Kotlin is supposed to be a subset of SCALA, has clear benefits for developers on one hand and keeps short compile times on the other.</p>
<p>As a <strong>mobile team</strong> we got interested in Kotlin a few months before its final release which gave us time to test it thoroughly before production use. The language has some clear advantages for an <strong>Android programmer</strong> – it enables migration from Java projects that have been under development for some time already. Java &#x26; Kotlin <strong>coexistence</strong> simplifies Kotlin introduction as only new functionality is written in JetBrain’s new language leaving all the legacy code untouched.</p>
<p>Transitioning gives the developer an opportunity to use lambdas, new syntax for data objects, extension functions to easily expand Android SDK’s classes functionality and infix notation to write DSL-like structures. Almost all the libraries you use today will work with Kotlin thanks to 100% Java compatibility. The same is true for Android SDK classes – all of them will seamlessly work with the new programming language. Kotlin gives you more choice when it comes to reflection, creating documentation and being null-pointer safe. Android works great with it out of the box so you won’t need to change your development habits.</p>
<p>Our production project in Kotlin turned out to be a success after 4 months of development. We had <strong>0 bugs related to Kotlin as a programming language</strong>. Our code footprint is almost <strong>30%</strong> smaller thanks to JetBrain’s, we benefit from nullpointer safety, closures, translated enums, data objects and use infix notation for logging and displaying Snackbars.</p>
<h2>Kotlin Developer Starter in Android projects</h2>
<iframe src="https://www.slideshare.net/slideshow/embed_code/key/2IrMDNtY8cRKrJ" width="427" height="356" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen=""></iframe>
<p><strong><a href="https://www.slideshare.net/BartoszKosarzycki/kotlin-developer-starter-in-android-projects" title="Kotlin Developer Starter in Android projects">Kotlin Developer Starter in Android projects</a></strong> from <strong><a href="http://www.slideshare.net/BartoszKosarzycki">Bartosz Kosarzycki</a></strong></p>
<p>This presentation is a Developer Starter – a set of hand-picked information allowing a person with no knowledge of Kotlin to start writing basic Android activities and set up a kotlin-based Android project. It starts with language background, reasons for its creation and advantages. Then presents basic use cases, syntax, structures and patterns. Later on Kotlin is presented in Android context. Simple project structure, imports and Kotlin usage with Android SDK is explained. In the end cost of Kotlin compilation is presented and the language is compared to SCALA and SWIFT.</p>
<h2>Kotlin advanced – language reference for android developers</h2>
<iframe src="https://www.slideshare.net/slideshow/embed_code/key/fPQ0XeGdMBpMqK" width="427" height="356" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen=""></iframe>
<p><strong><a href="https://www.slideshare.net/BartoszKosarzycki/kotlin-advanced-language-reference-for-android-developers" title="Kotlin advanced - language reference for android developers">Kotlin advanced – language reference for android developers</a></strong> from <strong><a href="http://www.slideshare.net/BartoszKosarzycki">Bartosz Kosarzycki</a></strong></p>
<p>Second talk on Kotlin language we had at STXNext. We try go deeper into language specifics and look at the positive impact new syntax can have on boilerplate removal and readability improvement.</p>
<p>Kotlin really shines in Android development when one looks at “Enum translation”, “Extension functions”, “SAM conversions”, “Infix notation”, “Closures” and “Fluent interfaces” applied to lists. The talk, however, compares language-specifics of Java &#x26; Kotlin in terms of “Type Variance”, “Generics” and “IDE tools” as well.</p>
<p><img src="https://stxnext.com/wp-content/uploads/2016/03/bartosz-kosarzycki-author.jpg"></p>
<h3>Bartosz Kosarzycki</h3>
<p>Senior developer focused on new technologies and particularly interested in mobile development. Has 3 years experience in Android platform. Bartosz enjoys problem solving, is a huge fan of Agile methodologies and functional programming. For some time already is vividly interested in JVM-based languages like Scala &#x26; Kotlin.</p>
]]></description><link>https://stxnext.com/blog/android-and-kotlin/</link><guid isPermaLink="true">https://stxnext.com/blog/android-and-kotlin/</guid><category><![CDATA[Android]]></category><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Bartosz Kosarzycki]]></dc:creator><pubDate>Thu, 07 Apr 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[Kotlin Digest 2016.Q1]]></title><description><![CDATA[<p>Welcome the Kotlin Digest of Q1 2016. It was in this quarter that Kotlin 1.0 was released, and naturally the number of articles and coverage received has substantially increased.
We want to thank everyone for their contributions, and highlight some of the most notable articles and blog posts.</p>
<p><center><img src="http://i0.wp.com/blog.jetbrains.com/kotlin/files/2016/04/2016Q1Cover.png?resize=640%252C320" alt="2016Q1Cover"></center></p>
<p>By the way, you can <a href="http://kotlinslackin.herokuapp.com/">join us on slack</a> and subscribe to the <em>#feed</em> channel, where we push quite a bit of interesting content as it appears.</p>
<h1>General Articles</h1>
<ul>
<li><a href="https://dzone.com/articles/kotlin-10-is-now-available">Kotlin 1.0 Is Now Available and the Newest JVM Language Is a Breeze</a></li>
<li>Two Q&#x26;A of Kotlin’s project lead Andrey Breslav on <a href="https://dzone.com/articles/a-qa-with-andrey-breslav-on-kotlin">DZone</a> and <a href="http://www.infoq.com/news/2016/02/kotlin-10-released">InfoQ</a></li>
<li><a href="https://opencredo.com/kotlin/">Kotlin: a new JVM language you should try</a> by <a href="https://twitter.com/rafalgancarz">Rafal Gancarz</a></li>
<li><a href="https://www.linkedin.com/pulse/kotlin-ying-yang-programming-languages-eric-kolotyluk">Kotlin: The Ying and Yang of Programming Languages</a> by <a href="https://www.linkedin.com/in/eric-kolotyluk-7462253?trk=pulse-det-athr_prof-art_hdr">Eric Kolotyluk</a></li>
<li><a href="https://yobriefca.se/blog/2016/02/24/kotlin-2-years-on/">Kotlin – 2 Years On</a> by <a href="https://twitter.com/kouphax">James Hughes</a></li>
</ul>
<h1>Android</h1>
<ul>
<li><a href="http://antonioleiva.com/kotlin-awesome-tricks-for-android/">Kotlin awesome tricks for Android</a> by Antonio Leiva (author of <a href="https://leanpub.com/kotlin-for-android-developers">Kotlin for Android Developers</a> book)</li>
<li>Series of posts <a href="https://medium.com/@CodingDoug/kotlin-android-a-brass-tacks-experiment-part-1-3e5028491bcc#.d0dy6mji7">Kotlin &#x26; Android: A Brass Tacks Experiment</a> by <a href="https://www.linkedin.com/in/doug-stevenson-95509b22">Doug Stevenson</a> (Developer Advocate in Google)</li>
<li><a href="https://realm.io/news/getting-started-with-kotlin-and-anko/">Getting Started with Kotlin and Anko on Android</a> by <a href="https://twitter.com/donnfelker">Donn Felker</a> from Realm</li>
<li><a href="https://www.linkedin.com/in/raperez">Roberto Perez</a> shared his expirience in <a href="https://medium.com/@robj.perez/creating-an-androidwear-watchface-using-kotlin-e5f725813fa9">creating an AndroidWear watchface using Kotlin</a></li>
</ul>
<h1>Web Development</h1>
<ul>
<li>Two great posts by <a href="https://twitter.com/sdeleuze">Sébastien Deleuze</a> from Spring: <a href="https://spring.io/blog/2016/02/15/developing-spring-boot-applications-with-kotlin">Developing Spring Boot applications with Kotlin</a> and <a href="https://spring.io/blog/2016/03/20/a-geospatial-messenger-with-kotlin-spring-boot-and-postgresql">A Geospatial Messenger with Kotlin, Spring Boot and PostgreSQL</a></li>
<li>Three-part article by <a href="https://twitter.com/mikegehard">Mike Gehard</a> from Pivotal: <a href="http://engineering.pivotal.io/post/spring-boot-application-with-kotlin/">The Journey of a Spring Boot application from Java 8 to Kotlin: The Application Class</a></li>
<li><a href="https://twitter.com/nicolas_frankel">Nicolas Frankel</a> wrote about his <a href="https://dzone.com/articles//playing-with-spring-boot-vaadin-and-kotlin">experiments with Spring Boot, Vaadin, and Kotlin</a></li>
<li><a href="https://medium.com/@dime.kotevski/writing-a-restful-backend-using-kotlin-and-spring-boot-9f162c96e428">Writing a RESTful backend using Kotlin and Spring Boot</a> by <a href="https://twitter.com/dimitar_">Dimitar Kotevski</a></li>
<li><a href="https://medium.com/@gz_k/rest-api-plumbing-with-kotlin-b161af052178">Rest API plumbing with kotlin</a> by <a href="https://twitter.com/gz_k">Gaëtan Zoritchak</a></li>
</ul>
<h1>Ecosystem</h1>
<ul>
<li><a href="https://dzone.com/articles/a-new-javafx-app-framework-for-kotlin-tornadofx">TornadoFX</a> — a new JavaFX app framework for Kotlin</li>
<li><a href="http://inaka.net/blog/2016/01/25/killertask-the-solution-to-asynctask-implementation/">KillerTask</a> — a solution to AsyncTask implementation</li>
<li><a href="http://blog.bradcampbell.nz/introducing-paperparcel/">PaperParcel</a> — a new annotation processor that automatically generates type-safe <a href="http://developer.android.com/intl/es/reference/android/os/Parcelable.html">Parcelable</a> boilerplate code for Kotlin and Java</li>
<li><a href="http://tomstechnicalblog.blogspot.ru/2016/02/kotlin-rxjava-what-rxjava-should-be.html">Kotlin + RxJava = Functional Powerhouse</a></li>
<li><a href="https://medium.com/@ahmedrizwan/kotlin-retrofit-rxandroid-realm-39d7be5dc9dc">Kotlin : Retrofit + RxAndroid + Realm</a></li>
<li><a href="http://michaelevans.org/blog/2016/02/17/using-dagger-1-and-kotlin/">Using Dagger 1 and Kotlin</a></li>
<li><a href="http://obviam.net/index.php/libgdx-and-kotlin/">Using libGDX with Kotlin</a> and <a href="http://obviam.net/index.php/libgx-and-kotlin-2d-platformer-prototyping/">creating a simple 2D platformer</a></li>
</ul>
<h1>Features overwiew</h1>
<ul>
<li><a href="http://petersommerhoff.com/dev/kotlin/kotlin-for-java-devs/">Kotlin for Java Developers: 10 Features You Will Love About Kotlin</a></li>
<li><a href="http://blog.jooq.org/2016/03/31/10-features-i-wish-java-would-steal-from-the-kotlin-language/">10 Features I Wish Java Would Steal From the Kotlin Language</a></li>
<li><a href="https://medium.com/@dime.kotevski/kotlin-love-at-first-line-7127befe240f#.kan4x5dyg">Kotlin — Love at first line</a></li>
<li><a href="https://objectpartners.com/2016/02/23/an-introduction-to-kotlin/">An Introduction to Kotlin</a></li>
<li><a href="http://www.endran.nl/blog/kotlin-super-seeding-the-language-we-love-2">Kotlin, superseding the language we love</a></li>
<li><a href="https://medium.com/math-camp-engineering/kotlin-3e963864db9e#.4hxqlfnvn">Kotlin, the somewhat obscure modern Android-friendly programming language</a></li>
</ul>
<h1>Technical</h1>
<ul>
<li><a href="http://blog.jooq.org/2016/02/22/a-very-peculiar-but-possibly-cunning-kotlin-language-feature/">A Very Peculiar, but Possibly Cunning Kotlin Language Feature</a></li>
<li><a href="https://blog.frankel.ch/solving-the-josephus-problem-in-kotlin">Solving the Josephus problem in Kotlin</a> &#x26; <a href="https://blog.frankel.ch/feedback-jospehus-problem">update</a></li>
<li><a href="http://blog.dennislysenko.com/2016/01/22/kotlin-easily-storing-a-list-in-sharedpreferences-with-custom-accessors/">Kotlin: Easily storing a list in SharedPreferences with Custom Accessors</a></li>
<li><a href="http://vishnurajeevan.com/2016/02/13/Using-Kotlin-Extensions-for-Rx-ifying/">Using Kotlin Extensions for Rx-ifying</a></li>
<li><a href="http://makingiants.com/blog/using-mockito-for-unit-tests-with-kotlin-1x/">Using Mockito for unit testing with Kotlin (1/x)</a></li>
<li><a href="https://medium.com/@sergii/using-kotlin-for-tests-in-android-6d4a0c818776">Using Kotlin For Tests in Android</a></li>
</ul>
<h1>Kotlin series</h1>
<ul>
<li>
<p><a href="https://twitter.com/juanchosaravia">Juan Saravia</a> started his series of stories about learning Kotlin, while developing an Android App</p>
<ul>
<li><a href="https://medium.com/@juanchosaravia/learn-kotlin-while-developing-an-android-app-introduction-567e21ff9664">Introduction: A few words about this</a></li>
<li><a href="https://medium.com/@juanchosaravia/learn-kotlin-while-developing-an-android-app-part-1-e0f51fc1a8b3">Part 1: Configuring Android Studio with Kotlin</a></li>
<li><a href="https://medium.com/@juanchosaravia/learn-kotlin-while-developing-an-android-app-part-2-e53317ffcbe9">Part 2: MainActivity.kt: Syntax, Null Safety and more...</a></li>
<li><a href="https://medium.com/@juanchosaravia/keddit-part-3-extension-functions-android-extensions-and-more-faa7d232f232">Part 3: NewsFragment.kt: Extension Functions, Android Extensions...</a></li>
<li><a href="https://medium.com/@juanchosaravia/keddit-part-4-recyclerview-delegate-adapters-data-classes-with-kotlin-9248f44327f7">Part 4: RecyclerView — Delegate Adapters &#x26; Data Classes with Kotlin</a></li>
<li><a href="https://medium.com/@juanchosaravia/keddit-part-5-kotlin-rxjava-rxandroid-105f95bfcd22">Part 5: Kotlin, RxJava &#x26; RxAndroid</a></li>
<li><a href="https://medium.com/@juanchosaravia/keddit-part-6-api-retrofit-kotlin-d309074af0">Part 6: API — Retrofit &#x26; Kotlin</a></li>
</ul>
</li>
<li>
<p>Kotlin Month series by Jacob Zimmerman</p>
<ul>
<li><a href="https://programmingideaswithjake.wordpress.com/2016/02/27/kotlin-month-post-1-assorted-features/">Post 1: Assorted Features</a></li>
<li><a href="https://programmingideaswithjake.wordpress.com/2016/03/05/kotlin-month-post-2-inheritance-and-defaults/">Post 2: Inheritance and Defaults</a></li>
<li><a href="https://programmingideaswithjake.wordpress.com/2016/03/13/kotlin-month-post-3-safety/">Post 3: Safety</a></li>
<li><a href="https://programmingideaswithjake.wordpress.com/2016/03/19/kotlin-month-post-4-properties/">Post 4: Properties</a></li>
</ul>
</li>
<li>
<p>by <a href="https://github.com/cirorizzo">Ciro Rizzo</a>:</p>
<ul>
<li><a href="http://www.cirorizzo.net/2016/01/23/kotlin-at-glance/">My Kotlin Adventure</a></li>
<li><a href="http://www.cirorizzo.net/2016/02/03/kotlin-code/">Kotlin Coding</a></li>
<li>Building a Kotlin project (<a href="http://www.cirorizzo.net/2016/03/04/building-a-kotlin-project/">part 1</a> and <a href="http://www.cirorizzo.net/2016/03/04/building-a-kotlin-project-2/">part 2</a>)</li>
</ul>
</li>
</ul>
]]></description><link>http://blog.jetbrains.com/kotlin/2016/04/kotlin-digest-2016-q1/</link><guid isPermaLink="true">http://blog.jetbrains.com/kotlin/2016/04/kotlin-digest-2016-q1/</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Digest]]></category><dc:creator><![CDATA[Roman Belov]]></dc:creator><pubDate>Wed, 06 Apr 2016 15:37:00 GMT</pubDate></item><item><title><![CDATA[Kotlin DSL: Anko]]></title><description><![CDATA[<p><a href="https://docs.google.com/presentation/d/12mkyGQZO22kf0_6kp2K6xyFdpg0nBLqGtNcVR-cV4M8/pub">Kotlin DSL: Anko</a></p>
]]></description><link>https://docs.google.com/presentation/d/12mkyGQZO22kf0_6kp2K6xyFdpg0nBLqGtNcVR-cV4M8/pub</link><guid isPermaLink="true">https://docs.google.com/presentation/d/12mkyGQZO22kf0_6kp2K6xyFdpg0nBLqGtNcVR-cV4M8/pub</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Android]]></category><dc:creator><![CDATA[@maciekjanusz]]></dc:creator><pubDate>Wed, 06 Apr 2016 08:54:00 GMT</pubDate></item><item><title><![CDATA[Kotlin: Practical Experience]]></title><description><![CDATA[<p>Kotlin 1.0.0 was officially released in February this year. Kotlin is a new language from JetBrains (of IntelliJ IDEA and ReSharper fame). It was originally announced in 2011 when a development version was made available to the public. While it can be compiled to JavaScript, the primary target is the JVM, and one of its core goals is 100% Java interoperability.</p>
<p>I have spent some time recently experimenting with Kotlin. There are many features of the language to enjoy when comparing against Java, terseness being high in the list. However, this post primarily serves to highlight a few gotchas that caught me out in the hopes that others may save some time when dealing with similar issues. While this may seem a slightly negative approach for a blog post, my goal is to offer a more practical take instead of only mentioning all the cool things you can do.</p>
<p>I really like Kotlin, I think it has a place in Java development regardless of whether you’re writing server-side or client-side, and regardless of your Java version. Kotlin’s internal API is based on Java 6 which allows Kotlin to be compatible with Android.</p>
<h2>Java 8 Compatibility</h2>
<p>As mentioned, Kotlin is internally dependent on Java 6, which places restrictions on what Java library types and language features Kotlin itself can use. This means any new types and methods added in Java 7 or 8 are not available to the Kotlin standard library, however if your target VM is Java 8 then your Kotlin code can make use of the newer Java features.</p>
<h3>Java 8 Streams</h3>
<p>A major addition that was introduced by Java 8 was the Stream API. This API typically makes full use of Java 8’s lambdas to allow users to write code similar to .NET’s LINQ. Since Kotlin is compatible with Java 6, they offer an equivalent through their standard library so that it is available regardless of the underlying version of Java. Below is a simple comparison of the Java 8 stream API and Kotlin’s equivalent standard library:</p>
<pre><code class="hljs language-java">List&#x3C;Integer> list = <span class="hljs-keyword">new</span> ArrayList&#x3C;>();
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &#x3C; <span class="hljs-number">50</span>; i++) {
    list.add(i);
}

List&#x3C;Integer> filtered = list.stream()
        .filter(x -> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)
        .collect(toList());</code></pre>
<pre><code class="hljs language-java">val list = (<span class="hljs-number">0</span>..<span class="hljs-number">49</span>).toList()
val filtered = list
        .filter( { x -> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> } )</code></pre>
<p>There are a few things about Kotlin lambdas that I found confusing at first. Lambdas must always appear between curly brackets. This can make the lambda look like a standard block, but once you get used to it, it starts to make sense. There are a few special cases that can be applied to the code above to simplify it further. If the last argument to a method is a lambda, then the lambda definition can be moved outside of the method parentheses, and if the remaining method parentheses are then empty, they can be removed. Furthermore, if the lambda has a single parameter then the parameter declaration can be removed along with the arrow, and the parameter can be referred to by <code>it</code>. Applying these rules to the code above simplifies it as follows:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> list = (<span class="hljs-number">0.</span><span class="hljs-number">.49</span>).toList()
<span class="hljs-keyword">val</span> filtered = list
        .filter { it % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> }</code></pre>
<p>A key thing to be aware of is that the code shown above is entirely implemented by the Kotlin standard libraries and is therefore independent of Java 8 streams. This is achieved through standard library extension methods.</p>
<h4>Lazy Streams</h4>
<p>There are subtle differences between the Java and Kotlin code above. Java is using lazy streams - the filter lambda is only applied once the call to <code>collect</code> is made. The Kotlin example however is eager, which is why the call to filter immediately returns a list.</p>
<p>There are ways to make Kotlin lazy, the main option would be to first convert the list to a <code>Sequence</code> and apply the lambdas to that instead. Sequences are evaluated lazily allowing a pipeline to be defined before the underlying lambdas are executed. The Kotlin code would then be as follows:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> list = (<span class="hljs-number">0.</span><span class="hljs-number">.49</span>).toList().asSequence()
    .filter { it % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> }
    .toList()</code></pre>
<p>This is only worth considering if the pipeline consists of more than the filter operation.</p>
<h4>Parallel Streams</h4>
<p>Something I ran into was the wish to use Java 8’s parallel streams. Kotlin’s standard library does not include its own parallel stream mechanism, and it is not clear where to start when consulting Kotlin’s standard library.</p>
<p>In Java one would either call <code>List.parallelStream()</code> or call <code>parallel()</code> directly on a stream. The subsequent pipeline will then be applied in parallel, and the results collected at the end. The issue is that typically in Kotlin lists are referenced via the Kotlin collection interfaces, even if the runtime instances are actually plain Java classes. This means the following code would not compile because the Kotlin collection interfaces do not know about the <code>stream()</code> methods or <code>Stream</code> interface.</p>
<pre><code class="hljs language-kotlin">listOf(<span class="hljs-string">"One"</span>, <span class="hljs-string">"Two"</span>, <span class="hljs-string">"Three"</span>).parallelStream()</code></pre>
<p>Considering these are Java 8 classes means it’s not surprising that there is currently no way for Kotlin to include a stream equivalent in their standard library - doing so would require them to reimplement a Kotlin stream equivalent for supporting Java 6 and 7, and then somehow have it use Java 8’s Stream API if running under a Java 8 VM. In fact Kotlin used to have their own <code>Stream</code> type before Java 8, but replaced it with <code>Sequence</code> shortly before finalising the 1.0.0 release.</p>
<p>One workaround is to implement extension methods for the <code>kotlin.collections.Collection</code> interface as follows:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&#x3C;T></span> Collection<span class="hljs-type">&#x3C;T></span>.<span class="hljs-title">stream</span><span class="hljs-params">()</span></span>: Stream&#x3C;T> {
    <span class="hljs-meta">@Suppress(<span class="hljs-meta-string">"PLATFORM_CLASS_MAPPED_TO_KOTLIN"</span>, <span class="hljs-meta-string">"UNCHECKED_CAST"</span>)</span>
    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span> <span class="hljs-keyword">as</span> java.util.Collection&#x3C;T>).stream()
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&#x3C;T></span> Collection<span class="hljs-type">&#x3C;T></span>.<span class="hljs-title">parallelStream</span><span class="hljs-params">()</span></span>: Stream&#x3C;T> {
    <span class="hljs-meta">@Suppress(<span class="hljs-meta-string">"PLATFORM_CLASS_MAPPED_TO_KOTLIN"</span>, <span class="hljs-meta-string">"UNCHECKED_CAST"</span>)</span>
    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span> <span class="hljs-keyword">as</span> java.util.Collection&#x3C;T>).parallelStream()
}</code></pre>
<p>This will allow the <code>stream()</code> and <code>parallelStream()</code> methods to be invoked directly on any Kotlin collection. Note the nasty suppression of warnings though. Firstly IDEA provides a generally good hint that you should probably not be using the <code>java.util.Collection</code> class directly - this is because it is normally hidden behind the Kotlin collection interfaces. The second warning is the unchecked cast which is unavoidable - the main issue is the generic type T which has been erased by Java. It is not possible to use Kotlin’s inlined reification feature in these methods either because we’re referring to the Java type that is already erased. This workaround is referenced from a <a href="https://youtrack.jetbrains.com/issue/KT-5175">bug-report</a> posted for Java 8 streams on Kotlin’s bug tracker. This issue was posted when Kotlin still had its own <code>Stream</code> class. While the issue is not resolved (a subsequent release of Kotlin may see a more elegant solution), the removal of Kotlin’s <code>Stream</code> class makes the above workaround possible.</p>
<p>Another issue arises when collecting the results. In Java I would collect a stream to a list using <code>collect(Collectors.toList())</code>, Java is usually able to infer the types correctly, however because we’re using Kotlin which defines its own collection types, things are not as smooth. Here is a function definition that uses the <code>stream()</code> extension method defined above:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">toIntList</span><span class="hljs-params">(strings:<span class="hljs-type">List</span>&#x3C;<span class="hljs-type">String</span>>)</span></span>:List&#x3C;<span class="hljs-built_in">Int</span>> {
    <span class="hljs-keyword">return</span> strings.stream()
        .map { it.toInt() }
        .collect(Collectors.toList&#x3C;<span class="hljs-built_in">Int</span>>())
}</code></pre>
<p>The trick is to just make the type explicit when using <code>Collectors.toList</code>. There are some alternative workarounds posted to this <a href="http://stackoverflow.com/questions/35721528/how-can-i-call-collectcollectors-tolist-on-a-java-8-stream-in-kotlin/35722167#35722167">Stack Overflow question</a>. The update message posted claiming the issue is fixed in Kotlin 1.0.1 is not entirely accurate - I still find I need to make the types explicit when using collectors.</p>
<h3>SAM Types</h3>
<p>A nice feature demonstrated in the above code is the fact that Kotlin lambdas are compatible with Java’s Single Abstract Method (SAM) interfaces. This can be seen above where a Kotlin lambda is supplied directly to Java’s <code>Stream.map</code> method. The Kotlin compiler automatically generates an adapter function to convert the Kotlin lambda to the desired SAM interface type. Sometimes however this requires a bit of assistance, especially to resolve ambiguity. An example is when using Java 8’s <code>CompletebleFuture</code>:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">get</span><span class="hljs-params">(url:<span class="hljs-type">String</span>, ex: <span class="hljs-type">Executor</span>)</span></span>:CompletableFuture&#x3C;String> {
    <span class="hljs-keyword">return</span> CompletableFuture.supplyAsync( Supplier { downloadURL(url) }, ex)
}</code></pre>
<p>This method takes a string and Java executor, and returns a <code>CompletableFuture</code> containing the URL’s content. It assumes there is a synchronous <code>downloadURL</code> method available. Because the <code>supplyAsync</code> Java method takes the lambda as the first parameter, followed by the executor parameter, we can’t use the Kotlin shortcut of pushing the lambda outside of the <code>supplyAsync</code> parentheses. To create the correct SAM we prefix the Kotlin lambda with the name of the SAM type we require - in this case a <code>java.util.function.Supplier</code>.</p>
<h3>Try-with-resources</h3>
<p>This is actually a Java 7 feature, but still applies when using Java 8. In Java we may do the following to copy from an input stream to an output stream. This example relies on Guava to save some nasty iteration, but demonstrates how in Java we can declare multiple <code>AutoCloseable</code> instances in a single try-with-resources declaration. When the try block completes, <code>AutoCloseable.close()</code> will be called on each reference.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">try</span> (InputStream input = new FileInputStream(<span class="hljs-string">"SourceFile"</span>); OutputStream output = new FileOutputStream(<span class="hljs-string">"TargetFile"</span>)) {
    ByteStreams.copy(input, output); <span class="hljs-comment">// using Guava</span>
}</code></pre>
<p>Kotlin’s approach is not to add special language constructs, but instead to provide an API: <code>use()</code> is simply an extension method on <code>Closeable</code>. The following code is the Kotlin equivalent:</p>
<pre><code class="hljs language-kotlin">FileInputStream(<span class="hljs-string">"SourceFile"</span>).use { input ->
    FileOutputStream(<span class="hljs-string">"TargetFile"</span>).use { output ->
        input.copyTo(output)
    }
}</code></pre>
<p>Note that we have to nest the second <code>use</code> method call to include the second resource declaration, which also means we can’t use the implicit <code>it</code> parameter because we have to differentiate between <code>input</code> and <code>output</code>.</p>
<p>We also cannot use <code>AutoCloseable</code> which was only introduced in Java 7, so this restricts the usage to <code>Closeable</code> implementations only. The only workaround for the <code>AutoCloseable</code> case at the moment is to implement one’s own <code>use</code> extension method for <code>AutoCloseable</code>. JetBrains have indicated they are looking at this, though this goes back at least to 2014. I guess it wasn’t seen as something that had to be fixed by 1.0.0, especially since a proper fix introduces the need for Kotlin to be able to target newer versions of Java as well as keep working for Java 6.</p>
<p>Another issue is that <code>use</code> is currently not able to use <code>Throwable.addSuppressed(Thowable)</code> for the case where an Exception is being thrown but the close call in the finally block throws its own exception, because this method was also only added in Java 7 specifically for supporting the try-with-resources construct. The source for Kotlin’s <code>use</code> includes a TODO item for this and correctly swallows the exception from close so that it doesn’t mask the original exception, hopefully a better solution will be forthcoming. This issue is <a href="https://discuss.kotlinlang.org/t/kotlin-needs-try-with-resources/214">discussed here</a>.</p>
<h2>Java Annotations</h2>
<p>This is one particular case I encountered when trying to use Java’s XML binding API (JAXB), however this would affect other annotation processing libraries as well.</p>
<p>Consider the following Kotlin class:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@XmlRootElement(name = <span class="hljs-meta-string">"contact"</span>)</span>
<span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Contact</span></span>(
        <span class="hljs-meta">@XmlAttribute</span> <span class="hljs-keyword">var</span> firstName:String? = <span class="hljs-literal">null</span>,
        <span class="hljs-meta">@XmlAttribute</span> <span class="hljs-keyword">var</span> lastName: String? = <span class="hljs-literal">null</span>
)</code></pre>
<p>I have already tried to cover the basics: by making all the fields nullable and providing null as the default argument, the resulting class will have an empty constructor, as required by JAXB. I have also annotated the root element, and the attributes. But when I try and parse an XML file, I see the following trace:</p>
<pre><code class="hljs language-kotlin">Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">"main"</span> com.sun.xml.<span class="hljs-keyword">internal</span>.bind.v2.runtime.IllegalAnnotationsException: <span class="hljs-number">2</span> counts of IllegalAnnotationExceptions
Class has two properties of the same name <span class="hljs-string">"firstName"</span>
    <span class="hljs-keyword">this</span> problem <span class="hljs-keyword">is</span> related to the following location:
        at <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> java.lang.String blog.Contact.getFirstName()
        at blog.Contact
    <span class="hljs-keyword">this</span> problem <span class="hljs-keyword">is</span> related to the following location:
        at <span class="hljs-keyword">private</span> java.lang.String blog.Contact.firstName
        at blog.Contact
Class has two properties of the same name <span class="hljs-string">"lastName"</span>
    <span class="hljs-keyword">this</span> problem <span class="hljs-keyword">is</span> related to the following location:
        at <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> java.lang.String blog.Contact.getLastName()
        at blog.Contact
    <span class="hljs-keyword">this</span> problem <span class="hljs-keyword">is</span> related to the following location:
        at <span class="hljs-keyword">private</span> java.lang.String blog.Contact.lastName
        at blog.Contact</code></pre>
<p>It looks like the attribute annotation is being applied to both the public getter as well as the private field, for both the <code>firstName</code> and <code>lastName</code> properties. This is primarily fallout from Kotlin’s conciseness. In the <code>Contact</code> class above, the parameters are both constructor arguments as well as property declarations. Since a Kotlin property will be compiled into a getter, setter and backing field, the annotations are applied based on a choice from the Target annotation from the underlying annotation implementation. The best workaround here was to be explicit about what the <code>XmlAttribute</code> annotation should apply to - this can be done using annotation use-site targets as follows:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@XmlRootElement(name = <span class="hljs-meta-string">"contact"</span>)</span>
<span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Contact</span></span>(
        <span class="hljs-meta">@get:XmlAttribute</span> <span class="hljs-keyword">var</span> firstName:String? = <span class="hljs-literal">null</span>,
        <span class="hljs-meta">@get:XmlAttribute</span> <span class="hljs-keyword">var</span> lastName: String? = <span class="hljs-literal">null</span>
)</code></pre>
<p>Inserting <code>get:</code> before the annotation name will apply the annotation to the Java getter method, and this resolves the annotation/field clash. The full list of use-site targets can be found <a href="https://kotlinlang.org/docs/reference/annotations.html#annotation-use-site-targets">here</a>.</p>
<p>One more thing I found - for this simple case it is possible to fix the issue by adding <code>@XmlAccessorType(XmlAccessType.FIELD)</code> to the root element instead, however once I had more complex XML the <code>IllegalAnnotationsException</code> would just be pushed down to one of the deeper classes.</p>
<h2>Type-Safe Builders</h2>
<p>One of the features of Kotlin that caught my eye at the start was the concept of type-safe builders. The example included in the <a href="https://kotlinlang.org/docs/reference/type-safe-builders.html">official documentation</a> shows how an HTML document can be built. Once you have the builder code in place, you can use it as follows:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> html = html {
    head {
        title { +<span class="hljs-string">"Document Title"</span> }
    }
    body {
        h1 { +<span class="hljs-string">"A Nice H1 Heading"</span> }
        p {
            +<span class="hljs-string">"The wordy first paragraph including a "</span>
            a(href = <span class="hljs-string">"http://kotlinlang.org"</span>) { +<span class="hljs-string">"link"</span> }
            b { +<span class="hljs-string">" as well as some bold text"</span> }
        }
    }
}</code></pre>
<p>I liked this because the structure of the resulting document was reflected in the structure of the code. This is made possible by a combination of features:</p>
<ul>
<li>Lambdas must always be defined between curly braces.</li>
<li>If the last argument to a method is a lambda, it can be appended after the method parentheses (which in turn can be omitted when empty).</li>
<li><em>Function type with receiver</em> lambda arguments.</li>
</ul>
<p>Looking at the example code again in light of these 3 features, the code is actually just a set of nested method invocations taking a lambda as a parameter. Each lambda is a function type with receiver, which is similar to an extension function. The receiver (<code>this</code>) can be optionally omitted as it can with an extension method.</p>
<p>It took me a bit of effort to understand initially, so I suggest reading the official documentation to get a better idea. Once I understood the underlying concepts I was ready to start writing my own set of builders to support creation of a UI. This is where I came up against an issue with the type-safe builder pattern.</p>
<p>The issue is as follows - each time you define a nested lambda, it collects the scope of its parent invocations - all the way to the root. In the html example above, it means that the following will compile and generate no warnings, but the result will be confusing:</p>
<pre><code class="hljs language-kotlin">html {
    head {
        title { +<span class="hljs-string">"Document Title"</span> }
    }
    body {
        h1 { +<span class="hljs-string">"A Nice H1 Heading"</span> }
        p {
            +<span class="hljs-string">"The wordy first paragraph including a "</span>
            body {
                h1 { +<span class="hljs-string">"This is unexpected"</span> }
            }
            a(href = <span class="hljs-string">"http://kotlinlang.org"</span>) { +<span class="hljs-string">"link"</span> }
            b { +<span class="hljs-string">" as well as some bold text"</span> }
        }
    }
}</code></pre>
<p>You can see I’ve added an extra <code>body</code> call within the deepest <code>p</code>. From thinking of this as a type-safe builder of an html document, this should not be possible, since it should not be possible to add a body element at that level. It would be nice if compilation failed. However, if we forget about the html side of things, and just think of this as a bunch of nested closures, then it makes sense. A closure has access to the variables of the outer scope in addition to the current scope. This nested closure effectively has implicit access to all the <code>this</code> keywords up the chain. If we explicitly insert the qualified <code>this</code> keywords, it looks as follows:</p>
<pre><code class="hljs language-kotlin">html {
    <span class="hljs-keyword">this</span>.head {
        <span class="hljs-keyword">this</span>.title { +<span class="hljs-string">"Document Title"</span> }
    }
    <span class="hljs-keyword">this</span>.body {
        <span class="hljs-keyword">this</span>.h1 { +<span class="hljs-string">"A Nice H1 Heading"</span> }
        <span class="hljs-keyword">this</span>.p {
            +<span class="hljs-string">"The wordy first paragraph including a "</span>
            <span class="hljs-keyword">this</span><span class="hljs-symbol">@html</span>.body {
                <span class="hljs-keyword">this</span>.h1 { +<span class="hljs-string">"This is unexpected"</span> }
            }
            <span class="hljs-keyword">this</span>.a(href = <span class="hljs-string">"http://kotlinlang.org"</span>) { +<span class="hljs-string">"link"</span> }
            <span class="hljs-keyword">this</span>.b { +<span class="hljs-string">" as well as some bold text"</span> }
        }
    }
}</code></pre>
<p>You can see the qualified <code>this@html</code> reference - this is also implicitly available, but the point is that the second <code>body</code> invocation is actually being made against the root html instance, and not against the the paragraph instance that is implied. This leads to the following html document being generated:</p>
<pre><code class="hljs language-html"><span class="hljs-tag">&#x3C;<span class="hljs-name">html</span>></span>
  <span class="hljs-tag">&#x3C;<span class="hljs-name">head</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">title</span>></span>
      Document Title
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">title</span>></span>
  <span class="hljs-tag">&#x3C;/<span class="hljs-name">head</span>></span>
  <span class="hljs-tag">&#x3C;<span class="hljs-name">body</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">h1</span>></span>
      This is unexpected
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">h1</span>></span>
  <span class="hljs-tag">&#x3C;/<span class="hljs-name">body</span>></span>
  <span class="hljs-tag">&#x3C;<span class="hljs-name">body</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">h1</span>></span>
      A Nice H1 Heading
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">h1</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span>
      The wordy first paragraph including a
      <span class="hljs-tag">&#x3C;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"http://kotlinlang.org"</span>></span>
        link
      <span class="hljs-tag">&#x3C;/<span class="hljs-name">a</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">b</span>></span>
         as well as some bold text
      <span class="hljs-tag">&#x3C;/<span class="hljs-name">b</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
  <span class="hljs-tag">&#x3C;/<span class="hljs-name">body</span>></span>
<span class="hljs-tag">&#x3C;/<span class="hljs-name">html</span>></span></code></pre>
<p>The reason the second <code>body</code> actually appears first is because the nested body is completed (and added to the document) before the first <code>body</code> is completed. This is confusing behaviour and is unfortunately simply the result of Kotlin’s closures behaving correctly. A workaround may be to prefix all the invocations by the unqualified <code>this</code> keyword. If you do this you will find a compiler error is then generated when you try make a call to <code>this.body</code> from inside <code>p</code>, however the resulting code looks messier, and it is still possible to forget the <code>this</code> prefix.</p>
<p>I’ve only found the following Stack Overflow question and answer <a href="http://stackoverflow.com/questions/34834739/wrong-this-being-used-in-nested-closures#34836287">here</a>, where the principle engineer at JetBrains confirms the issue, and hints that a future Kotlin version may add a modifier to restrict a lambda from having access to enclosing scopes.</p>
<p>I may wait and see where this goes before embracing type-safe builders. I like the idea - especially how it could be used to implement a DSL for creating a UI, however I think this would cause a usage issue.</p>
<h2>Conclusion</h2>
<p>Overall I have had a very positive experience. I quickly adapted to the Kotlin syntax and enjoyed using it. The issues I’ve raised in this post should not be viewed in a negative light - for every issue I’ve raised here there are countless times I found myself impressed at how Kotlin integrates cohesively with Java. My main reason for creating this post is to collect my experiences for future reference, and hopefully to help people who run into the same issues.</p>
]]></description><link>http://blog.scottlogic.com/2016/04/04/practical-kotlin.html</link><guid isPermaLink="true">http://blog.scottlogic.com/2016/04/04/practical-kotlin.html</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Allen Wallis]]></dc:creator><pubDate>Mon, 04 Apr 2016 21:54:00 GMT</pubDate></item><item><title><![CDATA[Kotlin’s killer features]]></title><description><![CDATA[<p>SUMMARY: Kotlin is a new JVM language fully interoperable with Java bytecode. It is clearly inspired by Scala, but has a different design philosophy, a much gentler learning curve and some really helpful features like null-safe types.</p>
<h2>The Importance of TIOBE</h2>
<p>How much value should one place in the TIOBE index? What is it really worth? Let me answer that question after I have checked the rating of my favourite programming language.</p>
<p>Here’s something that must irk all hard-core Scala afficionados: although it has been around for over twelve years and boasts some superior features, it hasn’t made much of a dent in Java’s dominance. In fact it takes a modest 30th place, well behind the Latin that is Fortran and (you may shudder) COBOL. Don’t get me wrong: I like Scala. It deserves much more adoption than it gets at present, so why doesn’t it? My suspicion is that its supposed benefits are not compelling enough to entice people to climb its steep learning curve. Functional programming is hard and not a likely selling point for the average programmer</p>
<p><a href="https://blog.codecentric.de/files/2016/04/Screen-Shot-2016-04-04-at-06.53.46.png"><img src="https://blog.codecentric.de/files/2016/04/Screen-Shot-2016-04-04-at-06.53.46.png" alt="Screen Shot 2016-04-04 at 06.53.46"></a></p>
<p>Although this post is about <a href="http://kotlinlang.org/">Kotlin</a>, I feel I have to mention <a href="http://www.scala-lang.org/">Scala</a>, because it nevertheless has been an inspiration for the designers at Jetbrains. They have taken the good parts, left out/re-thought some of the hard stuff and added some new features. “If you are happy with Scala, you most likely do not need Kotlin”, <a href="https://kotlinlang.org/docs/reference/comparison-to-scala.html">they even admit,</a> but I actually disagree. I like Scala, but after trying out Kotlin for no more than ten hours I can confidently say I like Kotlin better. Admittedly it says more about me as a programmer than about the languages per se, so I invite you to make up your own mind. Maybe it’s the fact that the official Kotlin documentation is only 144 pages. It would take some really fine print to cover all about Scala in the same number of pages.</p>
<h2>Do we need a new language anyway?</h2>
<p>Not really. All modern languages are Turing complete. It’s just that I like to code and some languages give me far greater pleasure than others.</p>
<p>But now that you mention it, there <em>is</em> actually a lot about Java that will continue to annoy us for many years to come, or at least for as long as old source code — written in the days before we all had mobile phones, for heaven’s sake — must keep running on every new JVM generation. If the historical development of Java is of a dirt track road evolved into a motorway, it’s a motorway that allows horse-drawn carriages simply because some teams didn’t get round to retiring their old horses.</p>
<p><a href="https://blog.codecentric.de/files/2016/04/carriage.jpg"><img src="https://blog.codecentric.de/files/2016/04/carriage.jpg" alt="Twenty years of sources, one JVM?"></a></p>
<p>Twenty years of sources, one JVM?</p>
<p>Backward compatibility means we can’t rethink bad ideas or implement new stuff truly elegantly. It has given us gems like:</p>
<ul>
<li>raw types and type erasure</li>
<li>Checked exceptions. No language has implemented it ever since, it must be a bad idea.</li>
<li>Covariant arrays: I give you a bag of apples, you treat it as a bag of fruit, replace an apple with a pear and hand it back to me: runtime mayhem. Mutable collections should be invariant.</li>
<li>Object wrappers for primitives, because that’s the only way collection types can contain them. And we all know autoboxing is the source of some of the worst NullPointers.</li>
<li>And since the compiler likes you to spell things out rather than infer them, Java source remains more verbose than needed. It’s mitigated somewhat by the autocompletion prowess of modern IDEs, but only somewhat.</li>
</ul>
<p>There are clear merits to backward compatibility, but they’re getting less pressing now that the IT world is (rightly) leaving behind the days of monolithic development. One virtual machine shouldn’t have to compile and run the fruits of ten years worth of coding. If we want to make bigger strides in language development we should look beyond Java the language. JVM languages like Scala and Kotlin throw out the bathwater of raw types and let us keep the baby.</p>
<h2>Life saving versus labour saving features</h2>
<p>Many features that are commonly touted to win people over to Scala — or to Kotlin in due course —  are what I would term ‘labour saving’. Obvious examples are the code that can be inferred by the compiler and is therefore redundant and best left out. Type inference in variable declarations as well as compiler-generated getters/setters/equals/hashCode (the data qualifier on a class declaration) all save wear on your keyboard.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Greeter</span></span>(<span class="hljs-keyword">val</span> name: String) {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">greet</span><span class="hljs-params">()</span></span> {
        println(<span class="hljs-string">"Hello, <span class="hljs-subst">$name</span>"</span>)
    }
}</code></pre>
<p>Java is extremely conservative with such compiler inference. A more sophisticated device is operator overloading, i.e. using arithmetic operators for method calls on your own classes, defined like this:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dollar</span></span>(<span class="hljs-keyword">val</span> cents: <span class="hljs-built_in">Int</span>) {
    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">plus</span><span class="hljs-params">(cts: <span class="hljs-type">Int</span>)</span></span>: Dollar = Dollar(cents + cts)
    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">plus</span><span class="hljs-params">(money: <span class="hljs-type">Dollar</span>)</span></span>: Dollar = Dollar(cents + money.cents)
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">toString</span><span class="hljs-params">()</span></span> = <span class="hljs-string">"$"</span> + (cents.toFloat() / <span class="hljs-number">100.0</span>)
}</code></pre>
<p>We can now use the plus operator (and minus, unary, etc.) to add either integers or other Dollar objects and receive a new Dollar object back.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> oneDollarTwenty = Dollar(<span class="hljs-number">100</span>) + Dollar(<span class="hljs-number">20</span>)
<span class="hljs-keyword">val</span> alsoOneDollarTwenty = Dollar(<span class="hljs-number">100</span>) + <span class="hljs-number">20</span></code></pre>
<p>Extension methods are another great feature. Similar to Scala’s implicit methods, they let you add methods on a per-use basis to classes otherwise closed to extension, typically numeric types or other primitives (like Scala, there are no real primitives; everything is an object).</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">plus</span><span class="hljs-params">(money: <span class="hljs-type">Dollar</span>)</span></span>: Dollar = money.plus(<span class="hljs-keyword">this</span>)</code></pre>
<p>All three combined they let you do things like this:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> p1 = Dollar(<span class="hljs-number">1200</span>)
<span class="hljs-keyword">val</span> p2 = Dollar(<span class="hljs-number">800</span>)
println(p1 + p2 + <span class="hljs-number">3</span>)<span class="hljs-comment">// invokes p1.plus(p2).plus(3)</span>
println(<span class="hljs-number">3</span> + p1 + p2)<span class="hljs-comment">// invokes 3.plus(p1).plus(p2)</span></code></pre>
<p>The combination of type inference, operator overloading and extension methods can be very neat and very confusing at the same time:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> totalPrice = <span class="hljs-number">3</span> + currentPrice() * orderTotal()</code></pre>
<p>I can’t blame you for thinking that totalPrice must be a numeric value, but there’s no way to be sure. The <em>only</em> way to use these features wisely is if you also take even better care than normal in naming or add a type declaration where it isn’t strictly required. Cutting out redundancy is great, but it means the code that’s left should be perfectly self-documenting. It’s your sacred duty as a clean coder. Promise?</p>
<h2>What’s a real killer feature anyway?</h2>
<p>I suppose the greatest language features let you do things you couldn’t do before. Those are very few. Failing that, making a programmer’s life happier comes a very good second. Saving keystrokes is one thing, but I believe true killer features are the ones that:</p>
<ul>
<li>Help you prevent mistakes due to your own sloppiness.</li>
<li>Implement fundamental concepts intuitively.</li>
</ul>
<h2>The Billion dollar mistake made right</h2>
<p>The true killer feature for me is Kotlin’s null-safe types. It’s the best solution to tackle null references, a.k.a <a href="https://en.wikipedia.org/wiki/Null_pointer">the Billion dollar mistake</a> and the hated NullPointerException. The NPE is so pernicious that its abreviation doesn’t even need explaining in commit logs. And it’s all due to our own sloppiness! We know how to avoid it, following <a href="https://en.wikipedia.org/wiki/Robustness_principle">Postel’s law</a>: don’t return null references and always check your arguments for nullity, especially when invoked from the outside world. Yeah right.</p>
<p>Kotlin takes the only sensible route: the type system simply refuses to compile code that tries to assign or return null:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> name: String = <span class="hljs-literal">null</span> <span class="hljs-comment">// tries to assign null, won't compile</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span></span> : String = <span class="hljs-literal">null</span> <span class="hljs-comment">// tries to return null, won't compile</span></code></pre>
<p>If you need nullability you have to ask Kotlin nicely. Every Foo class has a corresponding Foo? type to be used for null references.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span></span> : String? = <span class="hljs-literal">null</span>
<span class="hljs-keyword">val</span> name: String? = getName()</code></pre>
<p>Nullable types require special care. You can’t treat them the same way as non-nullable types, and that’s a very good thing. Since every method call on a nullable type could cause an NPE, the compiler forces you to use the so-called Elvis operator when the result of the call is assigned to a non-null type:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> nameOrBruce: String = getName() ?: <span class="hljs-string">"Bruce"</span>
<span class="hljs-keyword">val</span> nameOrNull: String? = getName()</code></pre>
<p>The first variable is non-null, therefore we must provide an alternative in case getName() returns null. That’s not needed for the second assignment, since nameOrNull is of a nullable type. The Elvis operator prevents NPEs also in chained calls (from the offical docs):</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> name: String? = bob?.department?.head?.name</code></pre>
<p>If any of these calls returns null, the rest is skipped. But of course you know better than to write such trainwreck statements (Law of Demeter).</p>
<p>We’ve had the Optional wrapper pattern in many different flavours as a better way to avoid null references. It’s been in the standard library since Java 8. Kotlin’s types are better by far:</p>
<ul>
<li>They’re more conscise: Optional wrappers add verbosity in creating and unwrapping.</li>
<li>Optionals don’t offer compile-time safety at all: you can still return and pass null where an Optional is expected and get the same hated NPE.</li>
<li>The Optional pattern is just a design pattern. It’s not an integral language feature.</li>
</ul>
<p>But my greatest objection to the Optional pattern is that it is so flipping <em>optional</em>. Kotlin has made the right decision: only allow null if you explicitly ask for it. This is not a labour saving measure: it actually eliminates the opportunity for errors while forcing you to think more deeply about about design. Do you really need to return null from your method? Isn’t there a better way to signal such special cases? (There is by the way: check out sealed classes, similar to Scala’s case classes).</p>
<p>It will indeed be a cold day in hell before something like this makes it into the Java language, as long as backward compatibility stays non-negiotionable.</p>
<h2>A bag of apples isn’t always a bag of fruit</h2>
<p>Java’s use of wildcards in parameterized types must be one of the least understood and least liked features. It boils down to this: if a juicer <em>produces</em> only apple juice, I may safely call it a fruit juice dispenser (covariance). If the same machine <em>accepts</em> all kinds of fruit, I may safely call it an apple juicer, while you call it a pear juicer (contra-variance).  In code, the dispenser is all about return types (what goes out), while the juicer is about input. In Java, if I want the flexibility to parameterize my juicer with different types of fruit, I have to do this:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Juicer</span> </span>{
    T dispense();
}</code></pre>
<p>This lets me make a Juicer<AppleJuice> and a Juice<CarrotJuice>, but it doesn’t let me do this:</p>
<pre><code class="hljs language-kotlin">Dispenser applejuiceDispenser = new Dispenser();
Dispenser juiceDispenser = applejuiceDispenser;<span class="hljs-comment">//wont' compile</span></code></pre>
<p>unless I use the wildcard in the type declaration:</p>
<pre><code class="hljs language-kotlin">Dispenser&#x3C; extends Juice> juiceDispenser = applejuiceDispenser;</code></pre>
<p>In Kotlin parameterized types are also invariant, but you can enhance the type declaration with <strong>in</strong> or <strong>out</strong> to signal contravariance and covariance, respectively. A juicer has fruit coming in and juice coming out. It can be expressed with two interfaces</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Dispense</span>&#x3C;<span class="hljs-type">out T</span>> </span>{
<span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">tap</span><span class="hljs-params">()</span></span>: T
}
<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Squeezer</span>&#x3C;<span class="hljs-type">in T</span>> </span>{
<span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">squeeze</span><span class="hljs-params">(fruit: <span class="hljs-type">T</span>)</span></span>
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FruitJuicer</span></span>() : Squeezer, Dispenser {
 [...]
}</code></pre>
<p>Since the in and out sides of the parameterization are in different interfaces, I can use these more freely and not be constrained by invariance:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">var</span> appleJuicer : Dispenser = FruitJuicer()
<span class="hljs-keyword">var</span> elstarJuicer : Dispenser = FruitJuicer()
elstarJuicer = appleJuicer; <span class="hljs-comment">//Won't compile, not covariant</span>
appleJuicer = elstarJuicer; <span class="hljs-comment">//OK</span>

<span class="hljs-keyword">var</span> appleSqueezer : Squeezer = FruitJuicer()
<span class="hljs-keyword">var</span> elstarSqueezer: Squeezer = FruitJuicer()
elstarSqueezer = appleSqueezer; <span class="hljs-comment">//OK, contravariant</span></code></pre>
<p>Since the apple squeezer takes all kinds of apples, it’s okay to put only elstars in it. (if you didn’t know an elstar is an apple you should probably look at your eating habits). While this feature does not eliminate runtime goofs to the degree that nullable types do, I think it’s a very elegant solution to a fundamental programming concept that Java didn’t really solve intuitively.</p>
<h2>Summary</h2>
<p>I hope to have convinced you that newcomer Kotlin has some really helpful features. Having experienced Scala well beyond the Hello World stage myself, I promise you with confidence that Kotlin is much easier to master. If you’re looking for greater productivity and sheer joy of coding, it’s well worth a try. Last but not least and no surprise, the IDE support in IntelliJ is excellent, coming from Jetbrains.</p>
]]></description><link>https://blog.codecentric.de/en/2016/04/kotlins-killer-features/</link><guid isPermaLink="true">https://blog.codecentric.de/en/2016/04/kotlins-killer-features/</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Jasper Sprengers]]></dc:creator><pubDate>Mon, 04 Apr 2016 10:00:00 GMT</pubDate></item><item><title><![CDATA[Exploring Delegation in Kotlin]]></title><description><![CDATA[<p>I’m a huge fan of interfaces in Java and also of composition over inheritance. Inheritance is some magic wiring with tight coupling that creates lots of friction when evolving a code base. I’ve written about interfaces before several times, for example <a href="http://codemonkeyism.com/how-to-improve-programming-with-interfaces/">here</a> or <a href="http://codemonkeyism.com/generation-java-programming-style/">here</a>. Looking at Kotlin I wanted to see what I can do with interfaces and composition.</p>
<p>Take this example:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HasName</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>:String
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>(): HasName {
   <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>:String = <span class="hljs-string">"Stephan"</span>
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&#x3C;<span class="hljs-type">String</span>>)</span></span> {
  <span class="hljs-keyword">val</span> p = Person()
  <span class="hljs-comment">// Prints 'Stephan'</span>
  println(p.getName())
}</code></pre>
<p>Why would one introduce a <code>HasName</code> interface in this case? It reduces dependencies and coupling. This makes reasoning about code easier and speeds up compilation, especially incremental compilation.</p>
<p>How would we use the <code>HasName</code> interface? A function that checks for a good name could look like this:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">goodName</span><span class="hljs-params">(p:<span class="hljs-type">Person</span>)</span></span>:<span class="hljs-built_in">Boolean</span> {
  <span class="hljs-keyword">return</span> p.getName() == <span class="hljs-string">"Stephan"</span>
}</code></pre>
<p>Now the function depends on the whole of person, not just the name part. The function can not operate on a lot of things, just persons. What about other things with <code>Name</code>, like Dogs? Rewritting the code to</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">goodName</span><span class="hljs-params">(n:<span class="hljs-type">HasName</span>)</span></span>:<span class="hljs-built_in">Boolean</span> {
   <span class="hljs-keyword">return</span> n.getName() == <span class="hljs-string">"Stephan"</span>
}</code></pre>
<p>makes the function more reusable.</p>
<p>Inside our <code>Person class</code> we have the code for the <code>HasName</code> functionality. It woud be nicer to be able to reuse the functionality from somewhere else.</p>
<p>In Kotlin we can delegate Interfaces to objects:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HasName</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>:String
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NameMixin</span></span>(<span class="hljs-keyword">val</span> n:String): HasName {
  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span></span> = n
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>(n:NameMixin): HasName <span class="hljs-keyword">by</span> n {
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&#x3C;<span class="hljs-type">String</span>>)</span></span> {
    <span class="hljs-keyword">val</span> p = Person(NameMixin(<span class="hljs-string">"Stephan"</span>))
    <span class="hljs-comment">// Prints 'Stephan'</span>
    println(p.getName())
}</code></pre>
<p>This looks a little unnatural to me, as the user of the <code>Person class</code> needs to know about the <code>NameMixin</code>. See if we can do better</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>(n:String): HasName <span class="hljs-keyword">by</span> NameMixin(n) {
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&#x3C;<span class="hljs-type">String</span>>)</span></span> {
  <span class="hljs-keyword">val</span> p = Person(<span class="hljs-string">"Stephan"</span>)
  <span class="hljs-comment">// Prints 'Stephan'</span>
  println(p.getName())
}</code></pre>
<p>looks cleaner as the consumer of <code>Person</code> does not know about <code>NameMixin</code>.</p>
<p>Kotlin can also use data classes (Thanks to Christian Helmbold for pointing this out).</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HasName</span> </span>{
    <span class="hljs-keyword">val</span> name: String
}

<span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NameMixin</span></span>(<span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> name: String) : HasName

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>(named : HasName) : HasName <span class="hljs-keyword">by</span> named</code></pre>
<p>If we want to have more control, we can use a Factory inside <code>Person</code>.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>(n:String): HasName <span class="hljs-keyword">by</span> Person.name(n) {
  <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> Name {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">name</span><span class="hljs-params">(n:<span class="hljs-type">String</span>)</span></span> = NameMixin(n)
  }
}</code></pre>
<p>The name of the <code>companion object</code>, in this case <code>Name</code>, is optional but helps to structure the factory methods.</p>
<p>The mixin can be accessed with <code>this</code>:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>(n:String): HasName <span class="hljs-keyword">by</span> Person.name(n) {
  ...
  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isStephan</span><span class="hljs-params">()</span></span>:<span class="hljs-built_in">Boolean</span> {
    <span class="hljs-comment">// Access name property</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getName() == <span class="hljs-string">"Stephan"</span>
  }
}</code></pre>
<p>Using a <code>companion object</code> with a factory method is better, because it gives us more control in the creation of the Mixin. But the control is not optimal. I wish we had something like</p>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">// Not working Kotlin code!</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>(n:String): HasName {
    <span class="hljs-keyword">val</span> name delegates from HasName
}</code></pre>
<p>where I have access to name and more control over it. It would also be nice to have a way to access other Mixins from a Mixin. But overall, some nice functionality in Kotlin.</p>
]]></description><link>http://codemonkeyism.com/exploring-delegation-in-kotlin/</link><guid isPermaLink="true">http://codemonkeyism.com/exploring-delegation-in-kotlin/</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[@codemonkeyism]]></dc:creator><pubDate>Mon, 04 Apr 2016 09:49:00 GMT</pubDate></item><item><title><![CDATA[Experimental: Kotlin and mutation testing]]></title><description><![CDATA[<p><a href="https://kotlinlang.org/"><img src="https://blog.frankel.ch/wp-content/resources/experimental-kotlin-mutation-testing/icon_Kotlin.png"></a>Since about a year and a half, I do a <a href="https://player.vimeo.com/video/105758362">lot</a> <a href="https://youtu.be/uC_8l69ArXs">of</a> <a href="https://youtu.be/biLyXaJwO3c">presentations</a> on <a href="https://en.wikipedia.org/wiki/Mutation_testing">Mutation Testing</a>. In those, my point is to show that <a href="https://en.wikipedia.org/wiki/Code_coverage">Code Coverage</a>‘s only benefit is that it’s easy to compute but that it’s meaningless – hence Mutation Testing.</p>
<p>Since some time, I’ve been interested in <a href="http://kotlinlang.org">Kotlin</a>, a language from JetBrains that runs on the JVM. It’s only natural that I wanted to check how Mutation Testing could be applied to the Kotlin language. As Kotlin is too young to have its own dedicated mutation testing tool, I used <a href="http://pitest.org">Pit</a>, a Java dedicated tool. I didn’t expected much, here are my findings.</p>
<p>I started with a <a href="https://github.com/nfrankel/mutationtesting-kotlin">Kotlin-port</a> of my demo project. It has two simple classes and an associated test for each. In the first one, assertion is missing and in the second, the boundary condition of the &#x3C; operator is not tested. This is the perfect use-case for Mutation Testing. It’s a Maven project, so the command is quite straightforward:</p>
<pre><code class="hljs language-bash">mvn org.pitest:pitest-maven:mutationCoverage</code></pre>
<p>Interestingly enough, this works perfectly well, in terms of mutation coverage execution, but also regarding referencing the lines that are the source of the problem.</p>
<p><img src="https://blog.frankel.ch/wp-content/resources/experimental-kotlin-mutation-testing/duplicatemath.png">
<img src="https://blog.frankel.ch/wp-content/resources/experimental-kotlin-mutation-testing/lowpredicate.png"></p>
<p>I wanted to go further, to use a <em>real</em> project. The Kotlin folks were kind enough to redirect me to <a href="https://github.com/Kotlin/ktor">KTor</a>, a Kotlin-based web framework. I tried the same command, but limited on a single module – ktor-features/ktor-server-sessions (I have no clue what it does, that is not relevant anyway). Aye, there’s the rub.</p>
<p>First, Pit cannot correctly parse the generated bytecode at some places:</p>
<pre><code>PIT >> WARNING : Found more than one mutation similar on same line in a finally block. Can't correct for inlining.
</code></pre>
<p>Worse, there are a lot of timeout errors. Since there’s some threading involved, that’s not really a blocker.</p>
<pre><code>PIT >> WARNING : Slave exited abnormally due to TIMED_OUT
</code></pre>
<p>For this project, reports are really long, but some errors are really similar to what you’d expect from Java code, for example:</p>
<pre><code>removed call to kotlin/jvm/internal/Intrinsics::checkParameterIsNotNull → NO_COVERAGE
</code></pre>
<p>Here’s a sample of the report:</p>
<p><img src="https://blog.frankel.ch/wp-content/resources/experimental-kotlin-mutation-testing/pullablelinkedlist.png"></p>
<p>Again, Pit is able to bind the real lines to the problems found. Isn’t life good? If you stop at this point, it probably is. But running Pit on another project – say, ktor-features/ktor-locations fails miserably.</p>
<pre><code>The class org.jetbrains.ktor.locations.Locations$WhenMappings does not contain a source debug information. All classes must be compiled with source and line number debug information
</code></pre>
<p>It seems using the <code>when</code> construct in Kotlin generates an inner class that doesn’t contain debug information, which Pit need to works its magic. Let’s exclude the offending class and its inner mappings class:</p>
<pre><code>mvn org.pitest:pitest-maven:mutationCoverage -DexcludedClasses=org.jetbrains.ktor.locations.Locations*
</code></pre>
<p>It works again and produces expected results:</p>
<p><img src="https://blog.frankel.ch/wp-content/resources/experimental-kotlin-mutation-testing/conversionservice.png"></p>
<p>There are no mutation testing tools for Kotlin (yet), and considering Java ecosystem’s history, there might never be one. However, mutation testing is an invaluable tool to assert the real quality of your tests. Even if Pit is not a perfect match for Kotlin, it would be foolish to discard it.</p>
]]></description><link>https://blog.frankel.ch/experimental-kotlin-mutation-testing</link><guid isPermaLink="true">https://blog.frankel.ch/experimental-kotlin-mutation-testing</guid><category><![CDATA[Testing]]></category><category><![CDATA[Mutation Testing]]></category><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Nicolas Frankel]]></dc:creator><pubDate>Sun, 03 Apr 2016 15:36:00 GMT</pubDate></item><item><title><![CDATA[10 Features I Wish Java Would Steal From the Kotlin Language]]></title><description><![CDATA[<p>This article is overdue. After the hype around the <a href="https://blog.jetbrains.com/kotlin/2016/02/kotlin-1-0-released-pragmatic-language-for-jvm-and-android/">release of Kotlin 1.0</a> has settled, let’s have a serious look at some Kotlin language features that we should have in Java as well.</p>
<p>In this article, I’m not going to wish for unicorns. But there are some low hanging fruit (as far as I naively can see), which could be introduced into the Java language without great risk. While you’re reading this article, be sure to copy paste examples to <a href="http://try.kotlinlang.org">http://try.kotlinlang.org</a>, an online REPL for Kotlin</p>
<h2>1. Data class</h2>
<p>Language designers hardly ever agree on the necessity and the feature scope of what a class is. In Java, curiously, every class always has <em>identity</em> a concept that is not really needed in 80% – 90% of all real world Java classes. Likewise, <a href="http://blog.jooq.org/2016/01/12/if-java-were-designed-today-the-synchronizable-interface/">a Java class always has a monitor on which you can synchronize</a>.</p>
<p>In most cases, when you write a class, you really just want to group values, like Strings, ints, doubles. For instance:</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>{
    <span class="hljs-keyword">final</span> String firstName;
    <span class="hljs-keyword">final</span> String lastName;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">JavaPerson</span><span class="hljs-params">(...)</span> </span>{
        ...
    }
    <span class="hljs-comment">// Getters</span>
    ...
 
    <span class="hljs-comment">// Hashcode / equals</span>
    ...
 
    <span class="hljs-comment">// Tostring</span>
    ...
 
    <span class="hljs-comment">// Egh...</span>
}</code></pre>
<p>By the time you’ve finished typing all of the above, your fingers will no longer be. Java developers have implemented ugly workarounds for the above, like IDE code generation, or <a href="https://projectlombok.org">lombok</a>, which is the biggest of all hacks. In a better Java, nothing in Lombok would really be needed.</p>
<p>As, for instance, if Java had Kotlin’s <a href="https://kotlinlang.org/docs/reference/data-classes.html">data classes</a>:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>(
  <span class="hljs-keyword">val</span> firstName: String,
  <span class="hljs-keyword">val</span> lastName: String
)</code></pre>
<p>The above is all we need to declare the equivalent of the previous Java code. Because a data class is used to store data (duh), i.e. values, the implementation of things like <code>hashCode()</code>, <code>equals()</code>, <code>toString()</code> is obvious and can be provided by default. Furthermore, data classes are first class tuples, so they can be used as such, e.g. to destructure them again in individual references:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> jon = Person(<span class="hljs-string">"Jon"</span>, <span class="hljs-string">"Doe"</span>) 
<span class="hljs-keyword">val</span> (firstName, lastName) = jon</code></pre>
<p>In this case, we may hope. <a href="https://en.wikipedia.org/wiki/Project_Valhalla_(Java_language)">Valhalla / Java 10</a> is being designed and with it, <a href="http://cr.openjdk.java.net/~jrose/values/values-0.html">value types</a>. We’ll see how many features will be provided on the JVM directly, and in the Java language. This will certainly be an exciting addition.</p>
<p>Notice how <code>val</code> is possible in Kotlin: <a href="http://blog.jooq.org/2016/03/10/java-as-new-local-variable-type-inference/">Local variable type inference. This is being discussed for a future Java version right now</a>.</p>
<h2>2. Defaulted parameters</h2>
<p>How many times do you overload an API like the following:</p>
<pre><code class="hljs language-java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Stream</span>&#x3C;<span class="hljs-title">T</span>> </span>{
    <span class="hljs-function">Stream&#x3C;T> <span class="hljs-title">sorted</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function">Stream&#x3C;T> <span class="hljs-title">sorted</span><span class="hljs-params">(Comparator&#x3C;? <span class="hljs-keyword">super</span> T> comparator)</span></span>;
}</code></pre>
<p>The above are exactly the same JDK <code>Stream</code> operations. The first one simply applies <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html#naturalOrder--"><code>Comparator.naturalOrder()</code></a> to the second one. <a href="https://kotlinlang.org/docs/reference/functions.html">So we could write the following, in Kotlin</a>:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sorted</span><span class="hljs-params">(comparator : <span class="hljs-type">Comparator</span>&#x3C;<span class="hljs-type">T</span>>
         = Comparator.naturalOrder()</span></span>) : Stream&#x3C;T></code></pre>
<p>The advantage of this isn’t immediately visible, when there is only one defaulted parameter. But imagine a function with tons of optional parameters:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">reformat</span><span class="hljs-params">(str: <span class="hljs-type">String</span>,
             normalizeCase: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">true</span>,
             upperCaseFirstLetter: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">true</span>,
             divideByCamelHumps: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">false</span>,
             wordSeparator: <span class="hljs-type">Char</span> = <span class="hljs-string">' '</span>)</span></span> {
...
}</code></pre>
<p>Which can be called in any of the following ways:</p>
<pre><code class="hljs language-kotlin">reformat(str)
reformat(str, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">'_'</span>)
reformat(str,
  normalizeCase = <span class="hljs-literal">true</span>,
  upperCaseFirstLetter = <span class="hljs-literal">true</span>,
  divideByCamelHumps = <span class="hljs-literal">false</span>,
  wordSeparator = <span class="hljs-string">'_'</span>
)</code></pre>
<p>The power of defaulted parameters is that they are especially useful when passing arguments by name, rather than by index. This is currently not supported in the JVM, which until Java 8, doesn’t retain the parameter name at all (<a href="https://docs.oracle.com/javase/tutorial/reflect/member/methodparameterreflection.html">in Java 8, you can turn on a JVM flag for this</a>, but with all of Java’s legacy, you shouldn’t rely on this yet).</p>
<p>Heck, this feature is something I’m using in PL/SQL every day. Of course, <a href="http://blog.jooq.org/2016/02/11/dear-api-designer-are-you-sure-you-want-to-return-a-primitive/">in Java, you can work around this limitation by passing a parameter object</a>.</p>
<h2>3. Simplified instanceof checks</h2>
<p>If you will, this is really an instanceof switch. Some people may claim that this stuff is evil, bad OO design. Nja nja. I say, this happens every now and then. And apparently, in Java 7, string switches were considered sufficiently common to modify the language to allow them. Why not instanceof switches?</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> hasPrefix = <span class="hljs-keyword">when</span>(x) {
  <span class="hljs-keyword">is</span> String -> x.startsWith(<span class="hljs-string">"prefix"</span>)
  <span class="hljs-keyword">else</span> -> <span class="hljs-literal">false</span>
}</code></pre>
<p>Not only is this doing an instanceof switch, it is doing it in the form of an assignable expression. <a href="https://kotlinlang.org/docs/reference/control-flow.html">Kotlin’s version of this <code>when</code> expression is powerful</a>. You can mix any sort of predicate expressions, similar to SQL’s <code>CASE</code> expression. For instance, this is possible as well:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">when</span> (x) {
  <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.10</span> -> print(<span class="hljs-string">"x is in the range"</span>)
  <span class="hljs-keyword">in</span> validNumbers -> print(<span class="hljs-string">"x is valid"</span>)
  !<span class="hljs-keyword">in</span> <span class="hljs-number">10.</span><span class="hljs-number">.20</span> -> print(<span class="hljs-string">"x is outside the range"</span>)
  <span class="hljs-keyword">else</span> -> print(<span class="hljs-string">"none of the above"</span>)
}</code></pre>
<p>Compare to SQL (not implemented in all dialects):</p>
<pre><code class="hljs language-sql">CASE x
  WHEN BETWEEN 1 AND 10 THEN 'x is in the range'
  WHEN IN (<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> validNumbers) <span class="hljs-keyword">THEN</span> <span class="hljs-string">'x is valid'</span>
  <span class="hljs-keyword">WHEN</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">10</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">20</span> <span class="hljs-string">'x is outside the range'</span>
  <span class="hljs-keyword">ELSE</span> <span class="hljs-string">'none of the above'</span>
<span class="hljs-keyword">END</span></code></pre>
<p>As you can see, only SQL is more powerful than Kotlin.</p>
<h2>4. Map key / value traversal</h2>
<p>Now this could really be done very easily only with syntax sugar. Granted, having <a href="http://blog.jooq.org/2016/03/10/java-as-new-local-variable-type-inference/">local variable type inference</a> would already be a plus, but check this out</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> map: Map&#x3C;String, <span class="hljs-built_in">Int</span>> = ...</code></pre>
<p>And now, you can do:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">for</span> ((k, v) <span class="hljs-keyword">in</span> map) {
    ...
}</code></pre>
<p>After all, most of the time when traversing a map, it’ll be by <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html#entrySet--"><code>Map.entrySet()</code></a>. Map could have been enhanced to extend <code>Iterable&#x3C;Entry&#x3C;K, V>></code> in Java 5, but hasn’t. That’s really a pity. After all, it has been enhanced in Java 8 to allow for internal iteration over the entry set in Java 8 via <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html#forEach-java.util.function.BiConsumer-"><code>Map.forEach()</code></a>:</p>
<pre><code class="hljs language-kotlin">map.forEach((k, v) -> {
    ...
});</code></pre>
<p>It’s not too late, JDK gods. You can still let <code>Map&#x3C;K, V> extend Iterable&#x3C;Entry&#x3C;K, V>></code></p>
<h2>5. Map access literals</h2>
<p>This one is something that would add tons and tons of value to the Java language. We have arrays, like most other languages. And like most other languages, we can access array elements by using square brackets:</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">int</span>[] array = { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> };
<span class="hljs-keyword">int</span> value = array[<span class="hljs-number">0</span>];</code></pre>
<p>Note also the fact that we have array initialiser literals in Java, which is great. So, why not also allow for accessing map elements with the same syntax?</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> map = hashMapOf&#x3C;String, <span class="hljs-built_in">Int</span>>()
map.put(<span class="hljs-string">"a"</span>, <span class="hljs-number">1</span>)
println(map[<span class="hljs-string">"a"</span>])</code></pre>
<p>In fact, <code>x[y]</code> is just syntax sugar for a method call backed by <code>x.get(y)</code>. This is so great, we have immediately proceeded with renaming our <code>Record.getValue()</code> methods in jOOQ to <code>Record.get()</code> (leaving the old ones as synonyms, of course), such that you can now dereference your database record values as such, in Kotlin</p>
<pre><code class="hljs language-kotlin">ctx.select(a.FIRST_NAME, a.LAST_NAME, b.TITLE)
   .from(a)
   .join(b).on(a.ID.eq(b.AUTHOR_ID))
   .orderBy(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
   .forEach {
       println(<span class="hljs-string">"""<span class="hljs-subst">${it[b.TITLE]}</span>
               by <span class="hljs-subst">${it[a.FIRST_NAME]}</span> <span class="hljs-subst">${it[a.LAST_NAME]}</span>"""</span>)
   }</code></pre>
<p>Since jOOQ holds all column type information on individual record columns, you can actually know in advance that <code>it[b.TITLE]</code> is a String expression. Great, huh? So, not only can this syntax be used with JDK maps, it can be used with any library that exposes the basic <code>get()</code> and <code>set()</code> methods.</p>
<p>Stay tuned for more jOOQ and Kotlin examples here:
<a href="https://github.com/jOOQ/jOOQ/blob/master/jOOQ-examples/jOOQ-kotlin-example/src/main/kotlin/org/jooq/example/kotlin/FunWithKotlinAndJOOQ.kt">https://github.com/jOOQ/jOOQ/blob/master/jOOQ-examples/jOOQ-kotlin-example/src/main/kotlin/org/jooq/example/kotlin/FunWithKotlinAndJOOQ.kt</a></p>
<h2>6. Extension functions</h2>
<p>This one is a controversial topic, and I can perfectly understand when language designers stay clear of it. But every now and then, <a href="https://kotlinlang.org/docs/reference/extensions.html">extension functions</a> are very useful. The Kotlin syntax here is actually just for a function to pretend to be part of the receiver type:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> MutableList<span class="hljs-type">&#x3C;Int></span>.<span class="hljs-title">swap</span><span class="hljs-params">(index1: <span class="hljs-type">Int</span>, index2: <span class="hljs-type">Int</span>)</span></span> {
  <span class="hljs-keyword">val</span> tmp = <span class="hljs-keyword">this</span>[index1] <span class="hljs-comment">// 'this' corresponds to the list</span>
  <span class="hljs-keyword">this</span>[index1] = <span class="hljs-keyword">this</span>[index2]
  <span class="hljs-keyword">this</span>[index2] = tmp
}</code></pre>
<p>This will now allow for swapping elements in a list:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> l = mutableListOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
l.swap(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>)</code></pre>
<p>This would be very useful for libraries like <a href="https://github.com/jOOQ/jOOL">jOOλ</a>, which extends the Java 8 <code>Stream</code> API by wrapping it in a jOOλ type (<a href="https://github.com/amaembo/streamex">another such library is StreamEx</a>, with a slightly different focus). The jOOλ <code>Seq</code> wrapper type is not really important, as it pretends to be a <code>Stream</code> on steroids. It would be great, if jOOλ methods could be put onto <code>Stream</code> artificially, just by importing them:</p>
<pre><code class="hljs language-java">list.stream()
    .zipWithIndex()
    .forEach(System.out::println);</code></pre>
<p>The <code>zipWithIndex()</code> method isn’t really there. The above would just translate to the following, less readable code:</p>
<pre><code class="hljs language-java">seq(list.stream())
    .zipWithIndex()
    .forEach(System.out::println);</code></pre>
<p>In fact, extension methods would even allow to bypass wrapping everything explicitly in a <code>stream()</code>. For instance, you could then do:</p>
<pre><code class="hljs language-java">list.zipWithIndex()
    .forEach(System.out::println);</code></pre>
<p>As all of jOOλ’s method could be designed to also be applied to <code>Iterable</code>.</p>
<p>Again, this is a controversial topic. For instance, because</p>
<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr"><a href="https://twitter.com/lukaseder">@lukaseder</a> that does not allow for virtual dispatch. Extension methods are not virtual.</p>&mdash; Rafael Winterhalter (@rafaelcodes) <a href="https://twitter.com/rafaelcodes/status/692652876959711232">January 28, 2016</a></blockquote>
<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
<p>While giving the illusion of being virtual, extension functions really are just sugared static methods. It’s a significant risk for object oriented application design to engage in that trickery, which is why this feature probably won’t make it into Java.</p>
<h2>7. Elvis operator</h2>
<p>Optional is meh. It’s understandable that an <code>Optional</code> type needed to be introduced in order to abstract over the absence of primitive type values, which cannot be null. We now have things like <a href="https://docs.oracle.com/javase/8/docs/api/java/util/OptionalInt.html"><code>OptionalInt</code></a>, e.g. to model things like:</p>
<pre><code class="hljs language-kotlin">OptionalInt result =
IntStream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
         .filter(i -> i > <span class="hljs-number">3</span>)
         .findFirst();
 
<span class="hljs-comment">// Agressive programming ahead</span>
result.orElse(OR_ELSE);</code></pre>
<p>Optional is a monad</p>
<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">Also Google seems to be a bit confused about what a Monad is ... <a href="http://t.co/eJp9jY9cwG">pic.twitter.com/eJp9jY9cwG</a></p>&mdash; Mario Fusco (@mariofusco) <a href="https://twitter.com/mariofusco/status/389450525466296320">October 13, 2013</a></blockquote>
<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
<p>Yes. It allows you to <code>flatMap()</code> the absent value.</p>
<p><img src="http://s0.wp.com/wp-content/mu-plugins/wpcom-smileys/o_O.svg" alt="o_O"></p>
<p>Sure, if you want to do sophisticated functional programming, you’ll start typing <code>map()</code> and <code>flatMap()</code> everywhere. Like today, when we’re typing getters and setters. Along will come lombok generating flatmapping calls, and Spring will add some <a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/core/annotation/AliasFor.html"><code>@AliasFor</code> style annotation</a> for flatmapping. And only the enlightened will be able to decipher your code.</p>
<p>When all we needed was just a <a href="https://kotlinlang.org/docs/reference/null-safety.html">simple null safety operator</a> before getting back to daily business. Like:</p>
<pre><code class="hljs language-kotlin">String name = bob?.department?.head?.name</code></pre>
<p>I really like this type of pragmatism in Kotlin. Or do you prefer (flat)mapping?</p>
<pre><code class="hljs language-java">Optional&#x3C;String> name = bob
    .flatMap(Person::getDepartment)
    .map(Department::getHead)
    .flatMap(Person::getName);</code></pre>
<p>Can you read this? I cannot. Neither can I write this. If you get this wrong, you’ll get boxoxed.</p>
<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">“<a href="https://twitter.com/EmrgencyKittens">@EmrgencyKittens</a>: cat in a box, in a box. <a href="http://t.co/ta976gqiQs">pic.twitter.com/ta976gqiQs</a>”   And I think flatMap</p>&mdash; Channing Walton (@channingwalton) <a href="https://twitter.com/channingwalton/status/447778554114502657">March 23, 2014</a></blockquote>
<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
<p>Of course, <a href="http://blog.jooq.org/2016/03/15/ceylon-might-just-be-the-only-language-that-got-nulls-right/">Ceylon is the only language that got nulls right</a>. But Ceylon has tons of features that Java will not get before version 42, and I’m not wishing for unicorns. I’m wishing for the elvis operator, which could be implemented in Java too. The above expression is just syntax sugar for:</p>
<pre><code class="hljs language-java">String name = <span class="hljs-keyword">null</span>;
<span class="hljs-keyword">if</span> (bob != <span class="hljs-keyword">null</span>) {
    Department d = bob.<span class="hljs-function">department
    <span class="hljs-title">if</span> <span class="hljs-params">(d != <span class="hljs-keyword">null</span>)</span> </span>{
        Person h = d.head;
        <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span>)
            name = h.name;
    }
}</code></pre>
<p>What can possibly be wrong with that simplification?</p>
<h2>8. Everything is an expression</h2>
<p>Now this might just be a unicorn. I don’t know if there is a JLS / parser limitation that will forever keep us in the misery of prehistoric distinction between statement and expression.</p>
<p>At some point in time, people have started using statements for things that yield side-effects, and expressions for more functional-ish things. It is thus not surprising, that all <code>String</code> methods are really expressions, operating on an immutable string, returning a new string all the time.</p>
<p>This doesn’t seem to go well with, for instance, <code>if-else</code> in Java, which is expected to contain blocks and statements, each possibly yielding side-effects.</p>
<p>But is that really a requirement? Can’t we write something like this in Java as well?</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> max = <span class="hljs-keyword">if</span> (a > b) a <span class="hljs-keyword">else</span> b</code></pre>
<p>OK, we have this weird conditional expression using <code>?:</code>. But what about Kotlin’s <code>when</code> (i.e. Java’s <code>switch</code>)?</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> hasPrefix = <span class="hljs-keyword">when</span>(x) {
  <span class="hljs-keyword">is</span> String -> x.startsWith(<span class="hljs-string">"prefix"</span>)
  <span class="hljs-keyword">else</span> -> <span class="hljs-literal">false</span>
}</code></pre>
<p>Isn’t that much more useful than the following equivalent?</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">boolean</span> hasPrefix;
 
<span class="hljs-keyword">if</span> (x <span class="hljs-keyword">instanceof</span> String)
    hasPrefix = x.startsWith(<span class="hljs-string">"prefix"</span>);
<span class="hljs-keyword">else</span>
    hasPrefix = <span class="hljs-keyword">false</span>;</code></pre>
<p>(yes, I know about <code>?:</code>. I just find <code>if-else</code> easier to read, and I don’t see why that should be a statement, not an expression. Heck, in Kotlin, even <code>try</code> is an expression, not a statement:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> result = <span class="hljs-keyword">try</span> {
    count()
} <span class="hljs-keyword">catch</span> (e: ArithmeticException) {
    <span class="hljs-keyword">throw</span> IllegalStateException(e)
}</code></pre>
<p>Beautiful!</p>
<h2>9. Single expression functions</h2>
<p>Now this. This would save so much time reading and writing simple glue code. And in fact, we already have the syntax in annotations. Check out Spring’s magical <a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/core/annotation/AliasFor.html">@AliasFor</a> annotation, for instance. It yields:</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> AliasFor {
    <span class="hljs-meta">@AliasFor</span>(<span class="hljs-string">"attribute"</span>)
    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> ""</span>;
    <span class="hljs-meta">@AliasFor</span>(<span class="hljs-string">"value"</span>)
    <span class="hljs-function">String <span class="hljs-title">attribute</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> ""</span>;
}</code></pre>
<p>Now, if you squint really hard, these are just methods yielding constant values, because annotations are just interfaces with generated byte code for their implementations. We can discuss syntax. Of course, this irregular usage of <code>default</code> is weird, given that it was not re-used in Java 8 for default methods, but I guess Java always needs the extra syntax so developers feel alive as they can better feel their typing fingers. That’s OK. We can live with that. But then again, why do we have to? Why not just converge to the following?</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> AliasFor {
    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> </span>= <span class="hljs-string">""</span>;
    <span class="hljs-function">String <span class="hljs-title">attribute</span><span class="hljs-params">()</span> </span>= <span class="hljs-string">""</span>;
}</code></pre>
<p>And the same also for class / interface default methods?</p>
<pre><code class="hljs language-java"><span class="hljs-comment">// Stop pretending this isn't an interface</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AliasFor</span> </span>{
    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> </span>= <span class="hljs-string">""</span>;
    <span class="hljs-function">String <span class="hljs-title">attribute</span><span class="hljs-params">()</span> </span>= <span class="hljs-string">""</span>;
}</code></pre>
<p>Now <em>that</em> would look nice. But given Java’s existing syntax, this might just be a unicorn, so let’s move on to...</p>
<h2>10. Flow-sensitive typing</h2>
<p>Now <em>this</em>. THIS!</p>
<p><a href="http://blog.jooq.org/2016/02/16/an-ingenious-workaround-to-emulate-sum-types-in-java/">We’ve blogged about sum types before.</a> Java has sum types with exceptions since Java 7:</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">try</span> {
    ...
}
<span class="hljs-keyword">catch</span> (IOException | SQLException e) {
    <span class="hljs-comment">// e can be of type IOException and/or SQLException</span>
    <span class="hljs-comment">// within this scope</span>
}</code></pre>
<p>But Java, unfortunately, doesn’t have flow-sensitive typing. Flow-sensitive typing is of the essence in a language that supports sum types, but it is also useful otherwise. For instance, in Kotlin:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">when</span> (x) {
    <span class="hljs-keyword">is</span> String -> println(x.length)
}</code></pre>
<p>We don’t need to cast, obviously, because we already checked that <code>x is String</code>. Conversely, in Java:</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">if</span> (x <span class="hljs-keyword">instanceof</span> String)
    System.out.println(((String) x).length());</code></pre>
<p>Aaagh, all this typing. IDE autocompletion is smart enough to offer a contextual type’s methods already and then generate the unnecessary cast for you. But it would be great if this was never needed, every time we explicitly narrow a type using control flow structures.</p>
<p><a href="https://en.wikipedia.org/wiki/Flow-sensitive_typing">For more info, see this wikipedia entry about flow sensitive typing</a>. A feature that could absolutely be added to the Java language. After all, we already got flow-sensitive final local variables since Java 8.</p>
<h2>11. (Bonus) Declaration site variance</h2>
<p><a href="https://kotlinlang.org/docs/reference/generics.html">Last but not least, better generics via declaration site variance</a>. Many other languages know this, for instance also C#’s <a href="https://msdn.microsoft.com/en-us/library/9eekhta0(v=vs.110).aspx"><code>IEnumerable</code></a>:</p>
<p>public interface IEnumerable<out T> : IEnumerable</p>
<p>The keyword <code>out</code> here means that the generic type <code>T</code> is <em>produced</em> from the type <code>IEnumerable</code> (as opposed to <code>in</code>, which stands for consumption). In C#, Scala, Ceylon, Kotlin, and many other languages, we can declare this on the type declaration, rather than on its usage (although, many languages allow for both). In this case, we say that <code>IEnumerable</code> is covariant with its type <code>T</code>, which means again that <code>IEnumerable&#x3C;Integer></code> is a subtype of <code>IEnumerable&#x3C;Object></code></p>
<p>In Java, this isn’t possible, which is why we have a <a href="http://stackoverflow.com/q/4288084/521799">bazillion question by Java newbies on Stack Overflow</a>. Why can’t I...</p>
<pre><code class="hljs language-java">Iterable&#x3C;String> strings = Arrays.asList(<span class="hljs-string">"abc"</span>);
Iterable&#x3C;Object> objects = strings; <span class="hljs-comment">// boom</span></code></pre>
<p>In languages like Kotlin, the above would be possible. After all, why shouldn’t it? A thing that can produce strings can also produce objects, and we can even use it in this way in Java:</p>
<pre><code class="hljs language-java">Iterable&#x3C;String> strings = Arrays.asList(<span class="hljs-string">"abc"</span>);
<span class="hljs-keyword">for</span> (Object o : strings) {
    <span class="hljs-comment">// Works!</span>
}</code></pre>
<p>The lack of declaration site variance has made a lot of APIs very intelligible. Consider <code>Stream</code>:</p>
<pre><code class="hljs language-java">&#x3C;R> <span class="hljs-function">Stream&#x3C;R> <span class="hljs-title">flatMap</span><span class="hljs-params">(Function&#x3C;? <span class="hljs-keyword">super</span> T, ? extends Stream&#x3C;? extends R>> mapper)</span></span>;</code></pre>
<p>This is just noise. A function is contravariant with its argument type and covariant with its result type <em>by nature</em> a better definition of <code>Function</code> or <code>Stream</code> would be:</p>
<pre><code class="hljs language-java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Function</span>&#x3C;<span class="hljs-title">in</span> <span class="hljs-title">T</span>, <span class="hljs-title">out</span> <span class="hljs-title">R</span>> </span>{}
<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Stream</span>&#x3C;<span class="hljs-title">out</span> <span class="hljs-title">T</span>> </span>{}</code></pre>
<p>If this were possible, all that <code>? super</code> and <code>? extends</code> garbage could be removed without losing any functionality.</p>
<p>In case you’re wondering what I’m even talking about?<img src="http://s1.wp.com/wp-content/mu-plugins/wpcom-smileys/simple-smile.svg" alt=":)"></p>
<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">Covariance and contravariance explained. Source: <a href="https://t.co/2S4ChNeAvq">https://t.co/2S4ChNeAvq</a> <a href="https://t.co/BfOME8puj2">pic.twitter.com/BfOME8puj2</a></p>&mdash; Lukas Eder (@lukaseder) <a href="https://twitter.com/lukaseder/status/686917793472753665">January 12, 2016</a></blockquote>
<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
<p>The great news is, this is being discussed for a (near) future version of Java:
<a href="http://openjdk.java.net/jeps/8043488">http://openjdk.java.net/jeps/8043488</a></p>
<h2>Conclusion</h2>
<p>Kotlin is a promising language, even if it is very late to a game that already seems to have been decided, not in favour of alternative languages on the JVM. Nonetheless, it is a very interesting language to learn from, and with a lot of very good decisions made about some simple things.</p>
<p>Some of these decisions will hopefully be picked up by the Java language gods and integrated into Java. This list here shows some features that might be “easy” to add.</p>
<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr"><a href="https://twitter.com/shipilev">@shipilev</a> <a href="https://twitter.com/lukaseder">@lukaseder</a> And then it&#39;s yacc-shaving from there!</p>&mdash; Brian Goetz (@BrianGoetz) <a href="https://twitter.com/BrianGoetz/status/708350584294920193">March 11, 2016</a></blockquote>
<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
<p>More info about Kotlin idioms:
<a href="https://kotlinlang.org/docs/reference/idioms.html">https://kotlinlang.org/docs/reference/idioms.html</a></p>
]]></description><link>http://blog.jooq.org/2016/03/31/10-features-i-wish-java-would-steal-from-the-kotlin-language/</link><guid isPermaLink="true">http://blog.jooq.org/2016/03/31/10-features-i-wish-java-would-steal-from-the-kotlin-language/</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Java]]></category><dc:creator><![CDATA[Lukas Eder]]></dc:creator><pubDate>Thu, 31 Mar 2016 12:10:00 GMT</pubDate></item><item><title><![CDATA[Ubuntu Make 16.03 Released With Eclipse JEE And IntelliJ IDEA EAP Support, More]]></title><description><![CDATA[<p><a href="https://github.com/ubuntu/ubuntu-make">Ubuntu Make</a> is a command line tool created by Canonical, which allows installing various development tools on Ubuntu. It can be used to install Android Studio, Unity3D, IntelliJ IDEA, Firefox Development Edition, Node.js and much more.</p>
<p><strong>Ubuntu Make 16.03, released today, adds support for <a href="http://www.eclipse.org/downloads/packages/eclipse-ide-java-ee-developers/mars2">Eclipse JEE</a> and <a href="https://www.jetbrains.com/support/eap/">IntelliJ IDEA EAP</a>, as well as for the <a href="https://kotlinlang.org/">Kotlin compiler</a>, along with various fixes, such as:</strong></p>
<ul>
<li>fix Unity3D on lts mesa;</li>
<li>fix VSCode license page due to server changes;</li>
<li>fix Android-NDK not working due to server changes (download is now for 64bit only);</li>
<li>fix Clang support due to server changes;</li>
<li>fix Intellij .desktop file.</li>
</ul>
<p>A complete changelog can be found <a href="https://github.com/ubuntu/ubuntu-make/blob/master/debian/changelog">HERE</a>.</p>
<p><img src="https://2.bp.blogspot.com/-IxqVQB8bEqM/Vvu4uaN9s4I/AAAAAAAAXeY/LC8Uj6BECD8_GBY0DIDpho0-BxlUVDFVA/s1600/ubuntumake-eclipse-jee-ide.png" alt="Ubuntu Make Eclipse Java EE IDE"></p>
<p>To install the the newly added Eclipse JEE in Ubuntu using the latest Ubuntu Make (after installing Ubuntu Make, obviously), use the following command:</p>
<p><code>umake ide eclipse-jee</code></p>
<p>For IntelliJ IDEA EAP, use:</p>
<p><code>umake ide idea --eap</code></p>
<p>To install the Kotlin language compiler, use:</p>
<p><code>umake kotlin kotlin-lang</code></p>
<p>If you want to remove any package installed using Ubuntu Make, simply append "--remove" to the command you used to install it. For example, to remove eclipse-jee, you would use:</p>
<p><code>umake ide eclipse-jee --remove</code></p>
<p>To see all Ubuntu Make can do, type:</p>
<pre><code class="hljs language-bash">umake --help
<span class="hljs-comment"># and</span>
man umake</code></pre>
<h2>Install Ubuntu Make</h2>
<p>Ubuntu Make is available in the official Ubuntu repositories (starting with Ubuntu 15.04) however, it's not the latest version, as you can see <a href="https://launchpad.net/ubuntu/+source/ubuntu-make">HERE</a> (though the latest Ubuntu Mate 16.03 will probably make it into Ubuntu 16.04 Xenial Xerus).</p>
<p><strong>To install the latest Ubuntu Make, in Ubuntu (16.04, 15.10 and 14.04), Linux Mint 17.x and derivatives, you can use its PPA. Add the PPA and install Ubuntu Make by using the following commands:</strong></p>
<pre><code class="hljs language-bash">sudo add-apt-repository ppa:ubuntu-desktop/ubuntu-make
sudo apt-get update
sudo apt-get install ubuntu-make</code></pre>
<p>If you want to help with the Ubuntu Make development, report bugs, etc., check out its <a href="https://github.com/ubuntu/ubuntu-make">GitHub page</a>.</p>
<p><em>via <a href="http://blog.didrocks.fr/post/Ubuntu-Make-16.03-features-Eclipse-JEE%252C-Intellij-EAP%252C-Kotlin-and-a-bunch-of-fixes!2">didrocks</a></em></p>
]]></description><link>http://www.webupd8.org/2016/03/ubuntu-make-1603-released-with-eclipse.html</link><guid isPermaLink="true">http://www.webupd8.org/2016/03/ubuntu-make-1603-released-with-eclipse.html</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Ubuntu]]></category><dc:creator><![CDATA[Alin Andrei]]></dc:creator><pubDate>Wed, 30 Mar 2016 14:56:00 GMT</pubDate></item><item><title><![CDATA[Kotlin’s Android Roadmap]]></title><description><![CDATA[<h2>Introduction</h2>
<p>One of the most interesting pieces of news we’ve all seen recently is Google announcing <a href="http://developer.android.com/preview/j8-jack.html">(limited) Java 8 support for Android N</a> with the Jack compiler for Java. Naturally, our users are curious about how these news affect them, and this blog post outlines our plans and our vision for Kotlin’s place in the Android development world in light of Google’s announcements.</p>
<h3>Kotlin’s Roadmap for Android</h3>
<p>We pay a lot of attention to making Kotlin a good tool for Android development. In the next few releases (1.0.X) we will continue improving our toolchain and libraries. Our current efforts are focused on three main areas: speeding up the development workflow, reducing the size of the runtime library and providing more complete tooling support.</p>
<h4>Development Workflow</h4>
<p>To speed up the development workflow, <strong>incremental compilation</strong> is coming to Kotlin’s Gradle plugin. This will improve the build times considerably: when a source file is changed, we’ll only recompile this particular file and those files really depending on it, not the whole module.</p>
<p>The next thing we plan to do to improve Android build performance is providing an integration with Android’s new <strong><a href="http://tools.android.com/tech-docs/jackandjill">Jack and Jill toolchain</a></strong>. Right now there are some issues that prevent Jack from handling Kotlin-generated bytecode correctly (<a href="https://code.google.com/p/android/issues/detail?id=196084">196084</a> and <a href="https://code.google.com/p/android/issues/detail?id=203531">203531</a>), but we plan to work together with the Google team to either resolve the issues or provide workarounds on our side. Once this is done, we’ll be able to translate only changed class files using Jill during incremental compilation, as opposed to translating all class files every time (which is the only possible behavior in the old Android tooling).</p>
<p>Last, but not least: <strong>Instant Run</strong>. Currently, Cold Swap works fine for Kotlin, but Warm and Hot Swap require some further investigation. We’ll do what we can to get them fixed ASAP. In the meantime, <a href="https://zeroturnaround.com/software/jrebel-for-android/">JRebel for Android</a> works fine with Kotlin already.</p>
<h4>Runtime Size</h4>
<p>We are planning several improvements to <strong>reduce the methods count</strong> of kotlin-stdlib. Our current result is 7’191: <img src="https://img.shields.io/badge/Methods%20count-core:%206289%20%7C%20deps:%20902-e91e63.svg" alt="http://www.methodscount.com/?lib=org.jetbrains.kotlin%3Akotlin-stdlib%3A1.0.0"></p>
<p>Optimizing top-level functions representation in multi-file facade classes and moving inline-only functions out of the runtime-available binary will win us several thousand methods.</p>
<h4>Tooling Support</h4>
<p>The main thing missing from Kotlin 1.0’s Android support story is <strong>Lint Checks</strong>, and we’re happy to announce that they are coming to Kotlin. We have already implemented all the checks available in Android Studio 1.5 (planning to publish them in Kotlin 1.0.2), and the new 2.0 checks are on the way. Our Lint checks are built on top of a common representation of Kotlin and Java code, and we plan to contribute that representation to the Android SDK, so that new checks added in future versions of the Android SDK will work with Kotlin out of the box.</p>
<p>More Android-specific IDE support, such as a <em>New Kotlin Activity</em> action, code insight and navigation features, and others will also be added gradually as 1.0.X releases are published.</p>
<h3>Kotlin and Java 8</h3>
<p>Java 8 has been around for quite a while now, and thus many of our users, those who are not doing Android development, have chosen Kotlin over Java 8 and are happy about it. Now that Android has official support for the Java 8 language features, how does that change the decision of choosing between Kotlin and Java?</p>
<p>First of all, while Java 8 does bring lambdas to Android, there are important differences between the way the Android toolchain supports lambdas on existing platform versions (that don’t run the N release) and the way Kotlin supports lambdas. To understand the difference, let’s see how the following simple code snippets are compiled:</p>
<p>Kotlin: <code>list.forEach { process(it) }</code>
Java 8: <code>list.forEach(it -> process(it))</code></p>
<p>Java’s version is a tiny bit longer, but let’s not focus on that. Instead, let’s see what happens under the hood. Starting with Java:</p>
<ul>
<li>in Android’s Java 8 every lambda is compiled to a class, which has two methods: constructor and the actual body (affecting the method count of your application);</li>
<li>this class is later instantiated at runtime, in many cases — every time the <code>forEach</code> is called (creating pressure on the garbage collector);</li>
<li>and to access it, Java uses a polymorphic call to <code>Consumer.accept</code>, which may happen on every iteration in a tight loop (affecting performance, because the runtime cannot always inline such calls).</li>
</ul>
<p>Kotlin, on the other hand, supports inline functions, and <code>forEach</code> is one such function. When you use an inline function with a lambda, both the body of the function and the lambda are inlined at the call site. As a result:</p>
<ul>
<li>the bytecode of the lambda is inserted directly into the bytecode of the calling method, so the method count does not increase;</li>
<li>executing the code does not allocate any objects, so there is no garbage collector pressure;</li>
<li>the resulting bytecode does not contain any polymorphic method calls, ensuring the best possible execution speed at runtime.</li>
</ul>
<p>Bottomline: lambdas in Java 8 on Android are not at all free, and one should probably think twice every time and choose between good code and performance. In Kotlin, you don’t have to make such compromises, and you can use lambdas as much as you need to express the ideas in your code.</p>
<p>And of course, Kotlin has many other language features which are not available in any version of Java. Just to list a few:</p>
<ul>
<li>Support for <strong>null-safety</strong> prevents most of the NullPointerException problems in your code, saving you from the dreaded “Unfortunately, application has stopped” message;</li>
<li><strong>Properties, primary constructors and data classes</strong> greatly reduce the amount of boilerplate in the code representing the data model of your application:
<code>data class User(val name: String, val groupId: String = "default")</code></li>
<li><strong>Delegated properties</strong> allow to extract the common logic in property getters and setters and to put that into a library:
<code>val imageData by lazy { loadData(imageFile) }</code></li>
</ul>
<p>And the DSL construction features of Kotlin give you an entirely new level of flexibility in building your application which is simply not available in Java. For example, it gives you the option to replace XML layouts with an embedded DSL and to describe the UI of your application in the same language as the rest of the code, with full access to the abstraction features of the language. Here’s how this can be accomplished using the <a href="https://github.com/kotlin/anko">Anko library</a>:</p>
<pre><code class="hljs language-kotlin">verticalLayout {
    <span class="hljs-keyword">val</span> name = editText()
    button(<span class="hljs-string">"Say Hello"</span>) {
        onClick { toast(<span class="hljs-string">"Hello, <span class="hljs-subst">${name.text}</span>!"</span>) }
    }
}</code></pre>
<p>As you see, Kotlin has lots and lots of things to offer to make you more productive, beyond what Java 8 can offer to a Java 6 developer. And it’s also easy to learn, with <a href="https://kotlinlang.org/docs/reference/">comprehensive documentation</a>, <a href="http://blog.jetbrains.com/kotlin/2016/03/kotlin-educational-plugin/">interactive exercises</a> and books covering both <a href="https://www.manning.com/books/kotlin-in-action">Kotlin in general</a> and the use of <a href="https://leanpub.com/kotlin-for-android-developers">Kotlin for Android development</a>. So if you haven’t tried Kotlin yet, now is as good time as any!</p>
]]></description><link>http://blog.jetbrains.com/kotlin/2016/03/kotlins-android-roadmap/</link><guid isPermaLink="true">http://blog.jetbrains.com/kotlin/2016/03/kotlins-android-roadmap/</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Android]]></category><dc:creator><![CDATA[Dmitry Jemerov]]></dc:creator><pubDate>Wed, 30 Mar 2016 12:40:00 GMT</pubDate></item><item><title><![CDATA[Rest API plumbing with kotlin]]></title><description><![CDATA[<h3>Rest API plumbing with kotlin</h3>
<p>As a startup developper, I spend a lot of my time dealing with REST APIs. It can be internal APIs for our web applications or external APIs for integration with online services (email, documents, ...). For both uses, Kotlin features help a lot. Lets see how.</p>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/800/1*hzb7OdfBZ9vYEosTTfLddg.png">
<em>Internal and external REST calls</em></p>
<h4>Internal APIs</h4>
<p>Regardless the web framework we use (my preferred one is currently <em>Ember.js</em>) the client/server communication is commonly implemented via a REST API exchanging data in JSON.</p>
<p>We define our API by specifying URLs and the JSON Format. URLs’ definition is managed by the web framework. As for the JSON format, jackson is a good solution for serializing POJOs. The structure of the JSON object is defined by the POJOs property names. To be sure to have an API independent of our domain objects, we need to have specific classes for the client-server communication.</p>
<p>Jackson is a nice framework that converts java classes to JSON seamlessly. The main problem with java is the verbosity of those POJOs classes. Even basic javabeans with no logic and no method seems bloated.</p>
<p>In the other hand, Kotlin data classes are really concise and allow generally to define data objects in a single line.</p>
<p>For all JSON inputs and outputs, we can have the data classes contained in the same file/class as the Rest Controller.</p>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/800/1*xdUrq3OnbITKiS4yXQhBnw.png">
<em>Kotlin files that contains both the controller and the data classes</em></p>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/800/1*XVMVPgmMzeBa4dBCa0TGAA.png">
<em>Defining a PUT call with spring and kotlin</em></p>
<p>The Nullabillity type system of Kotlin gives more control and information on the input/output format. In the example above, the documentId can be null by specification.</p>
<p>In that call, the client expects an empty JSON object (?!). We can provide it by returning an instance of the <em>Empty</em> class.</p>
<p>For inputs, we need to use <a href="https://github.com/FasterXML/jackson-module-kotlin">jackson’s Kotlin</a> module. It manages the constructor calls to avoid creating unnecessary empty constructors.</p>
<p>In less than 20 lines of kotlin we have defined our REST call, the URL and the format.</p>
<h4>External APIs and the bounded context pattern</h4>
<p>Beyond the issue of connecting with an external API and the technical part of it (remote calls, authentication,...) as developers we have to manage the <a href="http://martinfowler.com/bliki/BoundedContext.html"><strong>Bounded Context pattern</strong></a>.</p>
<p>The external system has its own domain model, which makes sense in its context, but is certainly different from our model/context.</p>
<p>For example, the representation of Google Files in Google Drive is different from our file domain.</p>
<p>When retrieving objects from the external API we have to <strong>transform those objects in our own model</strong>. The transformation must deal with the values (retrieved or not) and the type of (generally different) properties .</p>
<p>Imagine the following naive class for my domain file:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyFile</span></span>(
   <span class="hljs-keyword">val</span> name:String,
   <span class="hljs-keyword">val</span> creationDate: Instant,
   <span class="hljs-keyword">val</span> modificationDate:Instant)</code></pre>
<p>In the <a href="https://developers.google.com/resources/api-libraries/documentation/drive/v2/java/latest/">Google API</a> dates are using <em>com.google.api.client.util.DateTime</em> type for creation and modification dates.</p>
<p>A first conversion function could be:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">gFileToMyFile</span><span class="hljs-params">(gFile: <span class="hljs-type">File</span>)</span></span> = MyFile(
    gFile.title,
    Instant.ofEpochMilli(gFile.createdDate.value),
    Instant.ofEpochMilli(gFile.modifiedDate.value))</code></pre>
<p>It’s quite verbose and hard to read. We can improve the code by implementing a <strong>property extension</strong> on the google DateTime class:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> DateTime.instant: Instant
    <span class="hljs-keyword">get</span>() = Instant.ofEpochMilli(value)</code></pre>
<p>The DateTime class now has a new property simplifying the previous code snippet:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">gFileToMyFile</span><span class="hljs-params">(gFile: <span class="hljs-type">File</span>)</span></span> = MyFile(
    gFile.title,
    gFile.createdDate.instant,
    gFile.modifiedDate.instant)</code></pre>
<p>We can go further and <strong>replace this function</strong> with an <strong>extension function</strong> on the Google File class to call the transformation directly on the Google File instances.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> File.<span class="hljs-title">toMyFile</span><span class="hljs-params">()</span></span> = MyFile(
    title,
    createdDate.instant,
    modifiedDate.instant)</code></pre>
<p>Converting a single Google File is now as easy as:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> myFile = gFile.toMyFile()</code></pre>
<p>And the conversion of a list of files is done by mapping the original list using a function reference:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> myFiles = gFiles.map ( File::toMyFile )</code></pre>
<p>Implementing the 2 conversions (<em>Google DateTime => java Instant</em> and <em>Google File => MyFile)</em> with small <strong>extensions</strong> results in much more readable code.</p>
<p><strong>For both uses, managing internal and external APIs, Kotlin appears to be</strong> <a href="https://blog.jetbrains.com/kotlin/2016/02/kotlin-1-0-released-pragmatic-language-for-jvm-and-android/"><strong>a great tool</strong></a><strong>.</strong></p>
]]></description><link>https://medium.com/@gz_k/rest-api-plumbing-with-kotlin-b161af052178#.tdrmb8p5w</link><guid isPermaLink="true">https://medium.com/@gz_k/rest-api-plumbing-with-kotlin-b161af052178#.tdrmb8p5w</guid><category><![CDATA[Spring]]></category><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Gaetan Zoritchak]]></dc:creator><pubDate>Tue, 29 Mar 2016 09:19:00 GMT</pubDate></item><item><title><![CDATA[Creating an AndroidWear watchface using Kotlin]]></title><description><![CDATA[<h3>Creating an AndroidWear watchface using Kotlin</h3>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/600/1*78W0Fk8Ca3OGCdZiebTvSw.png"></p>
<p>Last week we released our <a href="https://play.google.com/store/apps/details?id=com.meronapps.lcdmodularwatchface">latest watch face</a> for Android Wear, and it is a little bit special, it is the first done using something different from Java. It is entirely written in Kotlin. In this post I would like to share our experiences while building it and how doing in the language created by Jetbrains has improved the development process.</p>
<p>To add a little bit of context, <a href="http://meronapps.com">we are</a> a Madrid based small company which, among other things, have been doing a lot of wearables applications, we have worked with Pebble, Sony smartwatch, Samsung’s Tizen, Apple Watch and, of course, Android Wear. In our Google’s OS take on watches, this is our seventh watch face, and all of them were developed using the ubiquitous Java.</p>
<p>If you don’t know Kotlin, it is a open sourced language designed by Jetbrains, yes, they are the ones behind the powerful IntelliJ Idea, the IDE which powers Android Studio. Kotlin is yet another language for the JVM and brings a lot of fresh air to JVM development. Since it does not uses any “strange” things like AOT compilation or bytecode generation, it is fully interoperable with Java and it works wherever Java works, so it does in Android. If you haven’t took it a look, I recommend you to do it, you can get started at <a href="https://kotlinlang.org/">https://kotlinlang.org/</a></p>
<p>Once we did the introductions, let’s go to the heart of the post, the learnings from our watch face development.</p>
<h4>Ready for Production</h4>
<p>During the development of the watchface, Kotlin 1.0 was officially released, but truth is said, everything worked perfectly. Developer tools are formed by several packages, and all of them worked pretty well even though they were beta versions, which became stable afterwards.</p>
<p>Android Studio Kotlin plugin works pretty well, it helps you with code completion, syntax highlighting, code navigation, code conversion from Java and all the candies you can expect from a mature IDE.</p>
<p>Kotlin’s Android gradle plugin was perfectly integrated with Android, you just click on Run, and it works on your phone, zero problems. There is just a single issue, the new feature from the Android build tools, Instant Run, doesn’t work yet. This was somehow expected, if you know how it works by patching the dex file, it is expected that the compilation process of Kotlin might has some problems with it.</p>
<p>Since we started using Kotlin when it was about to reach 1.0, the language itself is pretty stable, the syntax changes, if any, didn’t have any impact in our code, we didn’t have any problems the compiler and standard library either.</p>
<h4>Fully interoperable with Java</h4>
<p>One of the pillars of this language is that it is fully compatible with all the existing Java code, it means that you can use all Android libraries, and if you already have libraries and code, you can call it without any problems nor changes.</p>
<p>This feature is key to adopt Kotlin in your new developments, in fact, we started by using some of our libraries which we have developed for all of our projects. What it happened, is that we converted all those libraries to Kotlin and now our previous projects are using a library written using kotlin code.</p>
<h4>No more <em>if (foo != null)</em> and less NullPointerException</h4>
<p>If you are a java developer, you probably have suffered the curse of writing <em>if (foo != null)</em> thousand of times, and when you forget it, a <em>NullPointerException</em> will remind you to write it.</p>
<p>Kotlin tries to eliminate this infamous check with some syntax sugar. If a variable can be null, you need to explicit say it, you cannot assign a null to a <em>String</em> type, but you can do it to a <em>String?</em>. (note the question mark at the end). You cannot dereference a <em>?</em> variable without explicitly unwrapping it either by using !! or by using a <em>?</em> at the end. If a variable is null and you use a <em>?</em> at the end, it won’t crash with a NPE. That means you can write <em>rectangle?.size?.width?</em>, if rectangle or size is null, nothing happens.</p>
<h4>Fill your listeners using cool lambdas</h4>
<p>When it comes to java, you know that you are going to put in use you typing skills. Chances are that you are using a modern IDE and it will save you a little bit from that pain, but all the boilerplate code is there.</p>
<p>If you write Applications which respond to events like an Android application or an UI app, this is particularly notorious when you need to write control <em>Listeners</em>. Kotlin does magic in this side, if you need to implement an Interface which has only one method, you can use a Kotlin lambda to do it, saving you hundreds of characters and making your code more expressive with less useless decorations. Let’s see an example to show this better</p>
<pre><code class="hljs language-java"><span class="hljs-comment">// Java (129 characters of boilerplate code)</span>

view.setOnClickListener(<span class="hljs-keyword">new</span> OnClickListener() {
  <span class="hljs-meta">@Override</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>{
    <span class="hljs-comment">// Do something cool</span>
  }
});</code></pre>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">// Kotlin (37 characters to do exactly the same)</span>

view.onClick { <span class="hljs-comment">// Do something cool }</span></code></pre>
<h4>No more findViewById</h4>
<p>This point is specifically related with Android. Kotlin has a library called Android Extensions which will save you from typing useless code.</p>
<p>When I started in Android Programming some years ago, I hated why I needed to write so many <em>findViewById()</em> and hated more the typecast of that method. For non Android programmers, that method returns a generic <em>View</em> and you probably will need to cast it to a <em>Button</em> or a <em>TextView</em> to do something useful with it. Among other cool things, the Android Extensions library allows you to use any view from a layout just by using its id. You only need to import the layout like it was another class and all ids will be visible in your code magically.</p>
<pre><code class="hljs language-java"><span class="hljs-comment">// Java</span>

TextView tv = ((TextView)findViewById(R.id.my_textview)).setText(“Java y u make me write so much!”)</code></pre>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">// Kotlin</span>

<span class="hljs-keyword">import</span> kotlinx.android.synthetic.main_layout.*
my_textview.text = <span class="hljs-string">"isn’t kotlin cool?"</span></code></pre>
<h4>Syntax sugar</h4>
<p>Kotlin has a lot more to offer in terms of making your code more readable and allowing you to type less. Java getters and setters are automatically converted to properties, instead of write <em>person.getName()</em> or <em>setName(“”)</em>, Kotlin allows you call that java code by writing <em>person.name</em> or <em>person.name = “”.</em></p>
<p>Like modern languages, you don’t need to write the type of a variable when the compiler can infer the type, which can be done most of the times.</p>
<p>Assignments can contain a conditional expresions, Kotlin has mutable and inmutable references, I usually feel safer when a variable is inmutable, sometimes, the value of a variable depends on some condition, and this could force you to make the variable mutable. I think this is better explained by this piece of code.</p>
<pre><code class="hljs language-java"><span class="hljs-comment">// Java</span>

String greeting = <span class="hljs-keyword">null</span>;
<span class="hljs-keyword">if</span> (isDaytime()) {
  greeting = “Good Morning”;
} <span class="hljs-keyword">else</span> {
  greeting = “good Evening”;
}</code></pre>
<p>Kotlin allows you to write it in this way:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> greeting = <span class="hljs-keyword">if</span> (isDaytime()) {
  “Good Morning”
} <span class="hljs-keyword">else</span> {
  “Good Evening”
}</code></pre>
<p>Using this code, greeting is inmutable and you don’t need to check if it is null when using this variable.</p>
<h4>Vibrant community</h4>
<p>One of the important things when using a new technology is the how its users communicate themselves. Kotlin community is great, you only need to connect to its slack channels and you will be able to talk with the developers of the language. Moreover, an increasing number of projects are starting to be developed using Kotlin, so you can share your experiences with others and learn by talking with them.</p>
<h4>Conclusions</h4>
<p>I could be talking about the features of Kotlin which we used while developing the watch face for hours, things like the functional features of Kotlin, the pattern matching of “switch” clauses, the bugs that optional types and immutability has saved us time of debugging and so on. In our experience choosing of Kotlin has been a great decision, it made our code more readable and one of the most important outcomes, we enjoyed a lot while developing the application which at the end is all that matters, isn’t it? :).</p>
]]></description><link>https://medium.com/@robj.perez/creating-an-androidwear-watchface-using-kotlin-e5f725813fa9#.xcftwvys6</link><guid isPermaLink="true">https://medium.com/@robj.perez/creating-an-androidwear-watchface-using-kotlin-e5f725813fa9#.xcftwvys6</guid><category><![CDATA[Android]]></category><category><![CDATA[Android Wear]]></category><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Roberto Perez]]></dc:creator><pubDate>Mon, 28 Mar 2016 09:19:00 GMT</pubDate></item><item><title><![CDATA[Writing a RESTful backend using Kotlin and Spring Boot]]></title><description><![CDATA[<h3>Writing a RESTful backend using Kotlin and Spring Boot</h3>
<p>Being here, I guess you already have an idea what a <a href="https://en.wikipedia.org/wiki/Representational_state_transfer">RESTful</a> <a href="https://en.wikipedia.org/wiki/Front_and_back_ends">backend</a> is and at least have heard of <a href="https://kotlinlang.org">Kotlin</a> and <a href="http://projects.spring.io/spring-boot/">Spring [Boot]</a>. Beside that you will also need to know what is <a href="http://gradle.org">Gradle</a> and download <a href="https://www.jetbrains.com/idea/">IntelliJ IDEA</a>. If not — click those few links and find out more before continuing.</p>
<p>At the end of this tutorial you will have a running RESTful backend packed inside a Jar together with an embedded Tomcat web server.</p>
<p>I will start this tutorial by answering the two questions that may be on your mind:</p>
<h4><strong><em>Why Kotlin?</em></strong></h4>
<p>Because I’m <a href="https://medium.com/@dime.kotevski/kotlin-love-at-first-line-7127befe240f#.ojez0fkcn">in love with Kotlin</a>. And also because Kotlin (Java) has a great ecosystem and a huge community.</p>
<h4><strong><em>Why Spring Boot?</em></strong></h4>
<p>Because Spring is a great [web] framework and the Boot part of Spring Boot makes it even better. With Spring Boot things just work. No need to write dreadful configurations. You can, but you don’t need to (at least in our case). You just include it as a dependency, annotate a class or two and you are good to go.</p>
<p>We will create a very simple library management system. The system will be able to list all books available. It will allow us to add new books. For simplicity we will have all the data in memory and won’t use any databases.</p>
<p>Let’s start by creating the project. First open your IDE (preferably IntelliJ IDEA, because it has great support for Kotlin) and create a new Gradle project. In the same window, select Kotlin as a framework.</p>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/800/1*bpAXXUEixZni9Mfy5pJwvg.png">
<em>"New project" window</em></p>
<p>On the next screen you need to choose an ArtifactID and GroupID for your project. Those two things are the identification of your project in the Gradle world. Most often those IDs are the Java package of your application. In this tutorial I’ll use <strong>si.dime.kotlin.tutorials.rest.booklibrary</strong> as the main Java package and <strong>si.dime.kotlin.tutorials.rest</strong> as GroupID and <strong>booklibrary</strong> as ArtifactID. After hitting the Finish button you should have the project opened in your IDE.</p>
<p><strong>NOTE:</strong> At the time of writing this tutorial, the IntelliJ IDEA CE 15.0.4 has a bug, which generates a broken <strong>build.gradle</strong> file. The content of the correct file is:</p>
<pre><code class="hljs language-groovy">group <span class="hljs-string">'si.dime.kotlin.tutorials.rest'</span>
version <span class="hljs-string">'1.0-SNAPSHOT'</span>

buildscript {
    ext.kotlin_version = <span class="hljs-string">'1.0.0'</span>

    repositories {
        mavenCentral()
    }
    dependencies {
        classpath <span class="hljs-string">"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"</span>
    }
}

apply <span class="hljs-string">plugin:</span> <span class="hljs-string">'java'</span>
apply <span class="hljs-string">plugin:</span> <span class="hljs-string">'kotlin'</span>

sourceCompatibility = <span class="hljs-number">1.8</span>

repositories {
    mavenCentral()
}

sourceSets {
    main.java.srcDirs += <span class="hljs-string">'src/main/kotlin'</span>
}

dependencies {
    compile <span class="hljs-string">"org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version"</span>
}</code></pre>
<p>We will start with the good old HelloWorld app just so you can see how incredibly simple is to get a Spring Boot application up-and-running.</p>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/600/1*wV3aghlZYkzlJEiFr-kiyw.png">
<em>The project’s directory structure</em></p>
<p>First create the needed directory structure for your source files. Inside the project directory create the <strong>src/main/kotlin</strong> directories. You can do that directly from IDEA by right clicking on your project’s root directory and selecting New → Directory. After that create your base Java package by right clicking New → Package on the <strong>kotlin</strong> directory. Your project structure should something like the one on the left.</p>
<p>Let’s finally write some code. Create your main Application class by right clicking on your package and selecting New → Kotlin File/Class. Name your file App and click Ok. Inside the file we’ll write the main function:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&#x3C;<span class="hljs-type">String</span>>)</span></span> {
    println(<span class="hljs-string">"Hello Kotlin!"</span>)
}</code></pre>
<p>We are ready to run our HelloWorld app. Right click inside the editor and click <strong><em>Run ‘YOUR_PACKAGE_NAME’</em></strong><em>.</em></p>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/800/1*CZaMzHFYklRk4tWWCjhiWw.png"></p>
<p><em>Running the application from IntelliJ IDEA</em></p>
<p>After clicking on Run, on the bottom of your screen you should get</p>
<pre><code>Hello Kotlin!

Process finished with exit code 0
</code></pre>
<p>Now the fun part begins. We have our HelloWorld application in Kotlin and it’s time to “convert” it to a Spring Boot application. It’s amazingly easy.</p>
<p>First we will add the Spring Boot dependency to our project. At this point you should know that Gradle is a build system and that it has great dependency management. Adding dependencies is simple as adding a line in your <strong>build.gradle</strong> file. For SpringBoot we’ll need a few lines in our <strong>build.gradle</strong> file <strong>(not settings.gradle)</strong>.</p>
<pre><code class="hljs language-kotlin">group <span class="hljs-string">'si.dime.kotlin.tutorials.rest'</span>
version <span class="hljs-string">'1.0-SNAPSHOT'</span>

buildscript {
    ext.kotlin_version = <span class="hljs-string">'1.0.0'</span>

    repositories {
        mavenCentral()
    }
    dependencies {
        classpath(<span class="hljs-string">"org.springframework.boot:spring-boot-gradle-plugin:1.2.6.RELEASE"</span>)
        classpath <span class="hljs-string">"org.jetbrains.kotlin:kotlin-gradle-plugin:<span class="hljs-subst">$kotlin_version</span>"</span>
    }
}

apply plugin: <span class="hljs-string">'java'</span>
apply plugin: <span class="hljs-string">'kotlin'</span>
apply plugin: <span class="hljs-string">'spring-boot'</span>

sourceCompatibility = <span class="hljs-number">1.8</span>

repositories {
    mavenCentral()
}

sourceSets {
    main.java.srcDirs += <span class="hljs-string">'src/main/kotlin'</span>
}

dependencies {
    compile <span class="hljs-string">"org.jetbrains.kotlin:kotlin-stdlib:<span class="hljs-subst">$kotlin_version</span>"</span>
    compile(<span class="hljs-string">"org.springframework.boot:spring-boot-starter-web:1.3.3.RELEASE"</span>)
}</code></pre>
<p>After adding the dependency we need to refresh our Gradle configuration. To do that click on the <strong>Refresh</strong> button on the <em>Gradle tool window</em>. (The <em>Gradle tool window</em> can be activated from the main menu View → Tool windows → Gradle.</p>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/800/1*K5doUTtJTNVf-nAv2MHxQA.png">
<em>The Gradle Tool Window</em></p>
<p>Now we are ready to write the application’s main class. Open the <strong>App.kt</strong> file and define the App class. The class needs to be <strong>open</strong> because Spring needs its configuration classes <strong>open (not final)</strong>. And annotate the class with the <strong>@SpringBootApplication</strong> annotation</p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>{
}</code></pre>
<p>The final thing to do is change our main method. Replace the <em>println()</em> line with:</p>
<pre><code class="hljs language-kotlin">SpringApplication.run(App::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>, <span class="hljs-type">*args)</span></span></code></pre>
<p>The line above boots Spring and starts everything (including the embedded web server). Your <strong>App.kt</strong> file should look like this:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>{
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&#x3C;<span class="hljs-type">String</span>>)</span></span> {
    SpringApplication.run(App::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>, <span class="hljs-type">*args)</span></span>
}</code></pre>
<p>When you run the application, you should see a lot of output in the console at the bottom of the screen. The last line should say that the application has been successfully started.</p>
<pre><code class="hljs language-kotlin">Started AppKt <span class="hljs-keyword">in</span> <span class="hljs-number">2.306</span> seconds (JVM running <span class="hljs-keyword">for</span> <span class="hljs-number">2.628</span>)</code></pre>
<p>And that’s it. It’s that easy to convert a simple HelloWorld application to a SpringBoot web application with an embedded web server. We already have our application running on our embedded Tomcat server. If you open your browser and type <a href="http://localhost:8080"><strong>http://localhost:8080</strong></a>in the address bar, you will get a <em>HTTP 404</em> page. That’s because our application doesn’t know how to do anything.</p>
<p>Just for fun we’ll write a simple controller that prints <strong><em>Hello SpringBoot</em></strong><em>.</em> Create a new Kotlin class and name it <strong><em>HelloSpringBootController</em></strong>. Annotate that class with @RestController. This annotation tells Spring that this class is a REST controller and knows how to handle web requests. The next thing to do is to write the actual method that prints the <strong><em>Hello SpringBoot</em></strong> line.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@RequestMapping(value = <span class="hljs-meta-string">"/"</span>)</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">helloSpringBoot</span><span class="hljs-params">()</span></span> = <span class="hljs-string">"Hello SpringBoot"</span></code></pre>
<p>The method just returns the “Hello SpringBoot” string. The <strong>@RequestMapping</strong> annotation registers this method as a request handler and maps it to the <strong>“<em>/”</em> </strong>url. Your class should look like this:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@RestController</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloSpringBootController</span> </span>{

    <span class="hljs-meta">@RequestMapping(value = <span class="hljs-meta-string">"/"</span>)</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">helloSpringBoot</span><span class="hljs-params">()</span></span> = <span class="hljs-string">"Hello SpringBoot"</span>
}</code></pre>
<p>After restarting the application and refreshing your browser, you should see “Hello SpringBoot” in your browser.</p>
<p>At this point you can safely remove the <strong>HelloSpringBootController</strong> because we won’t be using it anymore.</p>
<p>We’ll start coding our book library system with the class that represents a Book. Create a new Kotlin file and name it <strong>Book</strong>.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span></span>() {
    lateinit <span class="hljs-keyword">var</span> ISBN: String
    lateinit <span class="hljs-keyword">var</span> title: String
    lateinit <span class="hljs-keyword">var</span> author: String
    <span class="hljs-keyword">var</span> coverURL: String? = <span class="hljs-literal">null</span>

    <span class="hljs-keyword">constructor</span>(
       ISBN: String,
       title: String,
       author: String,
       coverURL: String? = <span class="hljs-literal">null</span>): <span class="hljs-keyword">this</span>() {

          <span class="hljs-keyword">this</span>.ISBN = ISBN
          <span class="hljs-keyword">this</span>.title = title
          <span class="hljs-keyword">this</span>.author = <span class="hljs-meta">@author</span>
          <span class="hljs-keyword">this</span>.coverURL = coverURL
    }
}</code></pre>
<p>It’s pretty self-explanatory. It defines that every Book will have a required ISBN, a required title, a required author and an optional cover URL.</p>
<p>Because we’ll have all of our data in-memory, we’ll need something that’ll act like a database. For that purpose we’ll create a spring’s <strong>component</strong>. A <strong>component</strong> in Spring is an object which its lifecycle is managed by Spring. Additionally these components can be <strong>injected/autowired</strong> into class properties using Spring’s Dependency Injection system.</p>
<p>We’ll create our BooksDatabase component by creating a new Kotlin file and defining the following class:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@Component</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BooksDatabase</span> </span>{

    <span class="hljs-comment">// All of our books will live here</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> books = mutableListOf&#x3C;Book>()
}</code></pre>
<p>Because our data will live only in-memory, and the data won’t be persisted, we’ll need to somehow manually fill our list of books every time the application starts. Here comes in handy the <strong>@PostConstruct</strong> Spring annotation. This annotation tells to Spring that it needs to call this method right after it creates its instance and because our BooksDatabase component is a singleton (all of <strong>@Component</strong> annotated classes are singletons) we will “fill” our database just once, at application startup. So we need to write a method that fills our books list with initial data and annotates it with the <strong>@PostConstruct</strong> method.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@PostConstruct</span>
<span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> {

    <span class="hljs-comment">// Fill our "database"</span>
    books.add(Book(
     <span class="hljs-string">"0765326353"</span>,
     <span class="hljs-string">"The Way of Kings"</span>,
     <span class="hljs-string">"Brandon Sanderson"</span>,
     coverURL = <span class="hljs-string">"https://d.gr-assets.com/books/1448127430l/7235533.jpg"</span>))

    books.add(Book(
     <span class="hljs-string">"0345391802"</span>,
     <span class="hljs-string">"The Hitchhiker's Guide to the Galaxy"</span>,
     <span class="hljs-string">"Douglas Adams"</span>,
     coverURL = <span class="hljs-string">"https://d.gr-assets.com/books/1327656754l/11.jpg"</span>))

    books.add(Book(
     <span class="hljs-string">"076531178X"</span>,
     <span class="hljs-string">"Mistborn: The Final Empire"</span>,
     <span class="hljs-string">"Brandon Sanderson"</span>,
     coverURL = <span class="hljs-string">"https://d.gr-assets.com/books/1437254833l/68428.jpg"</span>))
}</code></pre>
<p>The next thing we need to do, are the methods for accessing the data from our database. We’ll need one for retrieving the data and one for inserting new items.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">/**
 * Returns a list of all books
 */</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getBooks</span><span class="hljs-params">()</span></span> = books

<span class="hljs-comment">/**
 * Adds the given book only if a book with
 * the same ISBN doesn't already exist.
 *
 * <span class="hljs-doctag">@return</span>  true - if the book was successfully added
 *          false - otherwise
 */</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">addBook</span><span class="hljs-params">(book: <span class="hljs-type">Book</span>)</span></span>: <span class="hljs-built_in">Boolean</span> {
    books.firstOrNull { it.ISBN == book.ISBN }?.let {
        <span class="hljs-comment">// A book with the same ISBN exist</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    }

    <span class="hljs-comment">// If we get to this line -</span>
    <span class="hljs-comment">// that means a book with the same ISBN</span>
    <span class="hljs-comment">// doesn't exist.</span>
    books.add(book)
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
}</code></pre>
<p>This completes our in-memory database. We can now move on to writing the REST Controller.</p>
<p>We will start in the same way we did with the <strong>HelloSpringBootController.</strong> Create a new Kotlin Class and name it <strong>BooksController</strong>. After that annotate it with the <strong>@RestController</strong> annotation<strong>.</strong></p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@RestController</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BooksController</span> </span>{
}</code></pre>
<p>In this controller we will be needing the “database” we created. In order to use it, we will need to <strong>inject/autowire</strong> the single instance of our <strong>BooksDatabase</strong> class.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@RestController</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BooksController</span> </span>{

    <span class="hljs-comment">// Our books' database</span>
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> lateinit <span class="hljs-keyword">var</span> database: BooksDatabase
}</code></pre>
<p>Thanks to the <strong>@Autowired</strong> annotation and Spring’s DI, the <em>database</em> variable will point to the single instance of our BooksDatabase class. As in our database class we will need just two methods for accessing the data. The first will return a list of all the books and the second will add a new book to our database.</p>
<p>The first one is really simple:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@RequestMapping(<span class="hljs-meta-string">""</span>, method = arrayOf(RequestMethod.GET)</span>)
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">books</span><span class="hljs-params">()</span></span> = database.getBooks()</code></pre>
<p>After this point we are able to test our backend in a browser. After starting the application you can open <a href="http://localhost:8080/">http://localhost:8080/</a> in a browser and you should get the list of books we have in our database in JSON format.</p>
<pre><code class="hljs language-kotlin">[
  {
    “title”: “The Way of Kings”,
    “author”: “Brandon Sanderson”,
    “coverURL”: “https:<span class="hljs-comment">//d.gr-assets.com/books/1448127430l/7235533.jpg",</span>
    “isbn”: “<span class="hljs-number">0765326353</span>”
  },

  {
    “title”: “The Hitchhiker’s Guide to the Galaxy”,
    “author”: “Douglas Adams”,
    “coverURL”: “https:<span class="hljs-comment">//d.gr-assets.com/books/1327656754l/11.jpg",</span>
    “isbn”: “<span class="hljs-number">0345391802</span>”
  },

  {
    “title”: “Mistborn: The Final Empire”,
    “author”: “Brandon Sanderson”,
    “coverURL”: “https:<span class="hljs-comment">//d.gr-assets.com/books/1437254833l/68428.jpg",</span>
    “isbn”: “<span class="hljs-number">076531178</span>X”
  }
]</code></pre>
<p>As you can see, we don’t have to worry about the format of the output. Spring is clever enough to figure out that we are returning an object (or a list of objects) from our method and serialise that to JSON.</p>
<p>I guess you already figured it out that our application doesn’t allow duplicate books in our database. So we will need to find a way to inform the user when he tries to do that. According to the RESTfull specifications, when that happens, we will need to return the <strong>HTTP 409 — Conflict</strong> status back to the user. Luckily for us, Spring has a simple way of doing that.</p>
<p>First we will need to define an exception with a special Spring annotation, that defines the HTTP error code and later in our <strong>addBook</strong> method, we will just have to throw that exception in case the user tries to insert a duplicate item.</p>
<p>Let’s start with our exception. Create a new Kotlin class named <strong>DuplicateItemException</strong>:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@ResponseStatus(value = HttpStatus.CONFLICT, reason = <span class="hljs-meta-string">"Duplicate item."</span>)</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DuplicateItemException</span>: <span class="hljs-type">RuntimeException</span></span>() {}</code></pre>
<p>Now we are ready to write our <strong>addBook</strong> method.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@RequestMapping(<span class="hljs-meta-string">""</span>, method = arrayOf(RequestMethod.POST)</span>)
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">addBook</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> book: <span class="hljs-type">Book</span>)</span></span> =
     <span class="hljs-keyword">if</span> (database.addBook(book)) book
     <span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span> DuplicateItemException()</code></pre>
<p>We have the same situation as before. Spring will automatically convert our returned Book object to JSON or in the case of a duplicate item, it will return the <strong>409 HTTP status</strong>. Also it will automatically convert the request body (thanks to the <strong>@RequestBody</strong> annotation) to an instance of our Book class.</p>
<p>For testing this method, I recommend you the <a href="https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop?hl=en">POSTMAN chrome app</a>.</p>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/800/1*iipcrRPPaBIWiajaVelBIw.png"></p>
<p>It’s important to set the HTTP method to <strong>POST</strong>, the content type to <strong>JSON</strong> and the body of the request. After hitting the <em>Send</em> button you should get the same book data in your response. In case you are trying to insert a duplicate item you should get an <strong>HTTP 409</strong> status.</p>
<p>If you try to fetch the list of books after you added a new book, you should get the newly added book at the end of the list.</p>
<p>Now that we have all to code written, we want to be able to run our server independently of our IDE. This is also a no-brainer, thanks to Gradle. Just open your terminal and cd to the project’s directory. To build our project and create a runnable JAR with an embedded web server (Tomcat in our case) we will need to fire-up Gradle:</p>
<pre><code class="hljs language-groovy">./gradlew clean bootRepackage</code></pre>
<p>After the build has completed, our executable JAR will be located in <strong><em>build/libs</em></strong><em>.</em> So to start our server we just need to start our JAR file:</p>
<pre><code class="hljs language-bash">java -jar build/libs/booklibrary-1.0-SNAPSHOT.jar</code></pre>
<p>After a few seconds, you should see an output similar to:</p>
<pre><code class="hljs language-kotlin">Started AppKt <span class="hljs-keyword">in</span> <span class="hljs-number">2.207</span> seconds (JVM running <span class="hljs-keyword">for</span> <span class="hljs-number">2.532</span>)</code></pre>
<p><strong>That’s it!</strong> We now have a fully functional RESTfull backend. In the near future I’ll try to write a couple of more tutorials that focus on writing an Android and iOS apps that use this backend.</p>
<h4>Disclaimer</h4>
<p>Yes, I’m a big Sanderson’s fan :)</p>
]]></description><link>https://medium.com/@dime.kotevski/writing-a-restful-backend-using-kotlin-and-spring-boot-9f162c96e428#.9oucop3xg</link><guid isPermaLink="true">https://medium.com/@dime.kotevski/writing-a-restful-backend-using-kotlin-and-spring-boot-9f162c96e428#.9oucop3xg</guid><category><![CDATA[Spring]]></category><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Dimitar Kotevski]]></dc:creator><pubDate>Tue, 22 Mar 2016 21:04:00 GMT</pubDate></item><item><title><![CDATA[How to Hot Deploy Java/Kotlin classes in Dev]]></title><description><![CDATA[<p>One thing the majority of JVM developers find annoying is having to constantly restart their container. Make a small change, restart Tomcat/Jetty, wait 30+ seconds for code to build / compile (or several minutes in the case of large monolithic projects), see results; repeat.</p>
<p>Compared to Dart which auto-reloads your changes as soon as you hit save, this is very inefficient and kills productivity.</p>
<p>There's a commercial solution available called <a href="http://zeroturnaround.com/software/jrebel/">JRebel</a> that aims to solve this problem, I took it for a test drive for a couple of weeks and managed to cut down several hours rapidly increasing my productivity and leaving me with a lot less time to spend on Hashnode.</p>
<p><img src="https://res.cloudinary.com/hashnode/image/upload/v1458676272/k10afwmauljxts4kdek7.png" alt="title here"></p>
<p>Even though JRebel was saving me a lot of time and pretty much worked out of the box, I just couldn't justify the price tag - at almost $500 a year, converted to Rands, that's about the price of one month's rental in South Africa for a small flat - a bit heavy; all the time I'm saving, I'm paying over to them. Don't get me wrong, I enjoyed using JRebel, but the price tag is just too much when there are other solutions available.</p>
<p>There is an open-source alternative which works just as well for what I'm using it for - it's called <a href="https://github.com/spring-projects/spring-loaded#readme">Spring Loaded</a>. It probably won't cover everything that JRebel is doing, but I'm mostly busy in Spring, so it's perfect for my needs.</p>
<p>Download the <a href="http://repo.spring.io/release/org/springframework/springloaded/1.2.5.RELEASE/springloaded-1.2.5.RELEASE.jar">jar</a> file, throw it somewhere where you won't accidentally delete it, open your <code>~/.bash_profile</code> if you're using OSX or on Linux it would typically be your <code>~/.bashrc</code> and add the following line followed by restarting your terminal:</p>
<p><code>export MAVEN_OPTS="-javaagent:/absolute/path/Code/springloaded-1.2.5.RELEASE.jar -noverify"</code></p>
<p>Now when you run your application using the maven jetty plugin or maven tomcat plugin (<code>mvn jetty:run</code>), every time you compile a class, it will be reloaded for you without having to do <code>Ctrl + C</code> and restarting <code>mvn jetty:run</code>. In Eclipse this will happen automatically if you have auto build turned on, in IntellJ, just assign a shortcut to the compile command (I'm using <code>Cmd + S</code>), once you're done with your changes, simply hit <code>Cmd + S</code> and you can immediately see your changes without restarts.</p>
<p>Happy coding!!</p>
]]></description><link>https://hashnode.com/post/how-to-hot-deploy-javakotlin-classes-in-dev-cim3u5oen00fnek53ho7q1t0v</link><guid isPermaLink="true">https://hashnode.com/post/how-to-hot-deploy-javakotlin-classes-in-dev-cim3u5oen00fnek53ho7q1t0v</guid><category><![CDATA[Deploy]]></category><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Jan Vladimir Mostert]]></dc:creator><pubDate>Tue, 22 Mar 2016 19:55:00 GMT</pubDate></item><item><title><![CDATA[(RU) Андрей Бреслав и Дмитрий Жемеров о Kotlin 1.0 на jug.msk.ru]]></title><description><![CDATA[<p>17 марта 2016 года прошла встреча <a href="http://jug.msk.ru/">jug.msk.ru</a> с Андреем Бреславом и Дмитрием Жемеровым, посвящённая выпуску версии 1.0 языка программирования Kotlin. Далее рассказывается о прошедшей встрече подробнее.</p>
<p><img src="https://habrastorage.org/files/c29/a51/0ef/c29a510efb444bb4bc8b18f8ad740523.jpg" alt="КПВД"></p>
<p>О докладчиках</p>
<p>Андрей Бреслав ( <a href="https://habrahabr.ru/users/abreslav/">@abreslav</a> ) является архитектором языка <em>Kotlin</em>, занимаясь его разработкой в компании <em>JetBrains</em> с 2010 года.</p>
<p>Ниже приведён список видео докладов Андрея, которые удалось найти:</p>
<ul>
<li>«BrainStorm. Автоматизированная оптимизация аппаратно-программных архитектур» (<em>Computer Science клуб при ПОМИ РАН</em>, 2011: <a href="https://www.youtube.com/watch?v=wZXEhngRzMA">видео</a>)</li>
<li>«Синтаксический анализ для встроенных языков» (<em>Computer Science клуб при ПОМИ РАН</em>, 2011: <a href="https://www.youtube.com/watch?v=PARloe1mPkc">видео</a>)</li>
<li>«Project Kotlin» (<em>JUG.ru-2012</em>: <a href="https://www.youtube.com/watch?v=wjkaPXT_vY4&#x26;index=11&#x26;list=PLVe-2wcL84b8pj7VOoa-6L9Q0sDjibdoF">видео</a>)</li>
<li>«Функции и данные в Kotlin» (<em>FProg-12 в JetBrains</em>: <a href="https://www.youtube.com/watch?v=0AzLhiic0fM">видео</a>)</li>
<li>«Type-safe Web with Kotlin» (<em>JPoint 2013</em>: <a href="https://www.youtube.com/watch?v=6y-4xJWFLl4&#x26;index=10&#x26;list=PLVe-2wcL84b8pj7VOoa-6L9Q0sDjibdoF">видео</a>)</li>
<li>«Компромиссы, или Как проектируются языки программирования» (<em>Joker 2013</em>: <a href="https://www.youtube.com/watch?v=CX_K1r0Vklg&#x26;index=8&#x26;list=PLVe-2wcL84b8pj7VOoa-6L9Q0sDjibdoF">видео</a>)</li>
<li>«Компромиссы в разработке языков программирования» (<em>JPoint 2014</em>: <a href="https://www.youtube.com/watch?v=HE4yyPpUsy4&#x26;index=7&#x26;list=PLVe-2wcL84b8pj7VOoa-6L9Q0sDjibdoF">видео</a>)</li>
<li>«Kotlin для Android: коротко и ясно» (<em>Mobius 2014</em>: <a href="https://www.youtube.com/watch?v=VU_L2_XGQ9s&#x26;index=9&#x26;list=PLVe-2wcL84b8pj7VOoa-6L9Q0sDjibdoF">видео</a>)</li>
<li>«Язык Kotlin для платформы Java» (<em>JEEConf 2015</em>: <a href="https://www.youtube.com/watch?v=018n0aXiljc">видео</a>)</li>
<li>«Kotlin: Challenges in language design» (<em>Curry On, Prague 2015</em>: <a href="https://www.youtube.com/watch?v=zVZFv80l_lQ">видео</a>)</li>
<li>«Что делать?» (2015: <a href="https://www.youtube.com/watch?v=P_qrDQMBRzw">видео</a>)</li>
</ul>
<p>Два доклада я смотрел очно на конференциях, ещё один — в записи. К моему большому удивлению, последний в списке докладов является вовсе не техническим.</p>
<p>Дмитрий Жемеров ( <a href="https://habrahabr.ru/users/yole/">@yole</a> ) работает в <em>JetBrains</em> с 2003 года (на некоторое время уходил в <em>Google</em> и вернулся обратно), успев поучаствовать во многих проектах компании, в <em>IntelliJ IDEA</em> в частности. Сейчас Дмитрий руководит командой разработки <em>Kotlin</em> - плагина и пишет книгу <a href="https://www.manning.com/books/kotlin-in-action">Kotlin in Action</a> (в соавторстве со Светланой Исаковой).</p>
<p>На <a href="http://yole.ru">его сайте</a> перечислено ещё несколько персональных проектов (в т.ч. <a href="https://sourceforge.net/projects/syndirella/">Syndirella</a>, про которую <a href="https://radio-t.com/p/2016/02/20/podcast-484/">упоминал</a> недавно <a href="https://habrahabr.ru/users/bobuk/">@bobuk</a>).</p>
<p>Доклады Дмитрия, которые удалось найти:</p>
<ul>
<li>«Kotlin» (<em>Riviera DEV 2011</em>: <a href="https://www.youtube.com/watch?v=P0SisYQrosg">видео</a>)</li>
<li>«Kotlin» (<em>CZJUG-2013</em>: <a href="https://www.youtube.com/watch?v=acLBPytzpEI">видео</a>)</li>
<li>«Static types in JavaScript: what, how and why» (<em>JSConf EU 2013</em>: <a href="https://www.youtube.com/watch?v=0r9HPRJUaFo">видео</a>)</li>
<li>«Why Python Sucks» (<em>Europython 2013</em>: <a href="https://www.youtube.com/watch?v=PlXEsrhF1iE">видео</a>)</li>
<li>«SDK, Gradle, AndroidStudio» (<em>Онлайн школа Android-разработчиков-2015</em>: <a href="https://www.youtube.com/watch?v=ZyPgFuPwXoQ">видео</a>)</li>
<li>«Без слайдов: интервью с Дмитрием Жемеровым из JetBrains» (<em>Хабрахабр</em>: <a href="https://habrahabr.ru/company/jugru/blog/263905/">статья с видео</a>)</li>
<li>«Опыт использования Kotlin в JetBrains» (Joker 2015: <a href="https://www.youtube.com/watch?v=c1tf_zLGMKM&#x26;index=6&#x26;list=PLVe-2wcL84b8pj7VOoa-6L9Q0sDjibdoF">видео</a>)</li>
</ul>
<p>Из перечисленного смотрел только один доклад с конференции в записи и интервью из серии «Без слайдов».</p>
<p>Совсем недавно Андрей и Дмитрий вместе выступали с докладом «Kotlin 1.0» на встрече <em>JUG.ru</em> в Питере — <a href="https://habrahabr.ru/company/jugru/blog/278647/">статья с видео</a> доклада.</p>
<h4>О докладе</h4>
<p>До встречи в течение нескольких вечеров почитал <a href="https://kotlinlang.org/docs/reference/">описание языка</a>, посмотрел <a href="https://github.com/JetBrains/kotlin-examples">примеры</a>, попробовал писать код. Есть <a href="https://kotlinlang.org/docs/reference/using-ant.html">поддержка Ant</a> (уже анахронизм), <a href="https://kotlinlang.org/docs/reference/using-maven.html">Maven</a> и <a href="https://kotlinlang.org/docs/reference/using-gradle.html">Gradle</a>. Пользоваться языком достаточно приятно. Интеграция с <em>IntelliJ IDEA</em>, естественно, есть и весьма хорошая.</p>
<p>Успел послушать три выпуска подкастов, в которых отметились докладчики, представляя версию 1.0 языка <em>Kotlin</em>:</p>
<ul>
<li><a href="http://razbor-poletov.com/2016/02/episode-102.html">Разбор полётов, выпуск 102</a> (Дмитрий Жемеров)</li>
<li><a href="https://radio-t.com/p/2016/02/20/podcast-484/">Радио-Т, выпуск 484</a> (Дмитрий Жемеров)</li>
<li><a href="https://sdcast.ksdaemon.ru/2016/03/sdcast-41/">SDCast, выпуск 41</a> (Андрей Бреслав)</li>
</ul>
<p>Видео питерского выступления на <em>JUG.ru</em> ранее посмотреть тоже успел. В значительной степени содержание совпадало, но были и отличия. Последняя часть (вопросов и ответов), конечно же, полностью отличалась.</p>
<p><img src="https://habrastorage.org/files/ebc/899/747/ebc8997475c04c1c82bf59daf46f7d21.jpg"></p>
<p>Как и в Питере, выступление состояло из четырёх частей:</p>
<ul>
<li>вводная часть с рассказом о языке (Андрей Бреслав);</li>
<li>планы развития после версии 1.0 (Дмитрий Жемеров);</li>
<li>вопросы совместимости (Андрей Бреслав);</li>
<li>сессия вопросов и ответов.</li>
</ul>
<p>В перерыве слушатели могли пообщаться с докладчиками.</p>
<p><img src="https://habrastorage.org/files/e0d/ffc/356/e0dffc35632a4c43aade34c9f3efa386.jpg"></p>
<p>Предполагаю, что наиболее интересной частью и для Андрея с Дмитрием была сессия вопросов и ответов. Надеюсь, что для докладчиков тоже был некий элемент неожиданности, т.к. интересные вопросы были. Удивило, что уже есть люди (кроме <em>JetBrains</em>), активно использующие язык в промышленной эксплуатации.</p>
<p>Очень хорошо, что задающим вопросы давался микрофон — было слышно, что спрашивают. Записанное видео можно будет комфортно слушать, не напрягаясь при попытке расслышать вопросы.</p>
<p><img src="https://habrastorage.org/files/342/253/3f8/3422533f8cc548c8a83e2f03eff97409.jpg"></p>
<p>Спасибо Андрею Бреславу и Дмитрию Жемерову за интересный доклад, Андрею Когуню (<em>jug.msk.ru</em>, <em>КРОК</em>) и Роману Белову (<em>JetBrains</em>) — за организацию мероприятия.</p>
<p>Ссылки по теме доклада — языку <em>Kotlin</em>:</p>
<ul>
<li><a href="https://kotlinlang.org">основной сайт</a>;</li>
<li><a href="http://try.kotlinlang.org">Try Online</a>;</li>
<li><a href="https://kotlinlang.org/docs/reference/">описание языка</a>;</li>
<li>книги <a href="https://www.manning.com/books/kotlin-in-action">Kotlin in Action</a> и <a href="https://leanpub.com/kotlin-for-android-developers">Kotlin for Android Developers</a>;</li>
<li><a href="https://kotlinlang.org/docs/tutorials/koans.html">Kotlin Koans</a>;</li>
<li><a href="http://blog.jetbrains.com/kotlin/2016/03/kotlin-educational-plugin/">Kotlin Educational Plugin</a> (выпущен в день встречи, 17 марта).</li>
</ul>
<p>Фото и видео будут доступны <a href="http://vk.com/jugmsk">здесь</a> и <a href="https://plus.google.com/communities/115981831554057619568">здесь</a>. На рассылку о следующих встречах <em>jug.msk.ru</em> подписаться можно <a href="http://jug.msk.ru">здесь</a>.</p>
]]></description><link>https://habrahabr.ru/post/279667/</link><guid isPermaLink="true">https://habrahabr.ru/post/279667/</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Дмитрий Белобородов]]></dc:creator><pubDate>Tue, 22 Mar 2016 00:37:00 GMT</pubDate></item><item><title><![CDATA[A Geospatial Messenger with Kotlin, Spring Boot and PostgreSQL]]></title><description><![CDATA[<p>Following my first <a href="https://spring.io/blog/2016/02/15/developing-spring-boot-applications-with-kotlin">Kotlin blog post</a>, today I want introduce the new Spring Boot + Kotlin application I have developed for my upcoming <a href="http://www.springio.net/">Spring I/O 2016 conference</a> talk “Developing Geospatial Web Services with Kotlin and Spring Boot”.</p>
<h1>Dealing with native database functionalities</h1>
<p>One of the goal of this application is to see how to take advantage of native database functionalities like we do in NoSQL world. Here we want to use Geospatial support provided by <a href="http://postgis.net/">PostGIS</a>, the spatial database extender for <a href="http://postgresql.org/">PostgreSQL</a>. <a href="https://www.compose.io/articles/is-postgresql-your-next-json-database/">Native JSON support</a> could also be a good use case.</p>
<p>This Geospatial Messenger sample application is <a href="https://github.com/sdeleuze/geospatial-messenger">available on GitHub</a> in 2 flavors:</p>
<ul>
<li>The <code>master</code> branch uses <a href="https://github.com/JetBrains/Exposed">Exposed</a>, a Kotlin SQL library with a typesafe API created by JetBrains. It could be compared to <a href="https://github.com/querydsl/querydsl/tree/master/querydsl-sql">Query DSL SQL</a> or <a href="http://www.jooq.org/">jOOQ</a> but provides an idiomatic Kotlin API and does not require code generation.</li>
<li>The <a href="https://github.com/sdeleuze/geospatial-messenger/tree/spring-data-jdbc-repository"><code>spring-data-jdbc-repository</code></a> branch is using <code>spring-data-jdbc-repository</code>, a community project that allows to use Spring Data <a href="https://docs.spring.io/spring-data/data-commons/docs/current/api/org/springframework/data/repository/PagingAndSortingRepository.html"><code>PagingAndSortingRepository</code></a> API with raw SQL queries without JPA. I am using <a href="https://github.com/jirutka/spring-data-jdbc-repository/">this Jakub Jirutka fork</a> which is an improved version of <a href="https://github.com/nurkiewicz/spring-data-jdbc-repository">Tomasz Nurkiewicz original project</a>.</li>
</ul>
<p>A <a href="https://github.com/sebastianperruolo/spring-gis">Spring Data JPA + Hibernate Spatial variant</a> would be interesting, so feel free to contribute it with a pull request ;-) Kotlin Query DSL support would be also nice but this is currently not supported (please comment on <a href="https://github.com/querydsl/querydsl/issues/1828">this issue</a> if you are interested). In this blog post I will focus on the <a href="https://github.com/JetBrains/Exposed">Exposed</a> variant.</p>
<h1>A tour of Geospatial Messenger code</h1>
<p>Our domain model is described easily thanks to these 2 <a href="https://kotlinlang.org/docs/reference/data-classes.html">Kotlin data classes</a>:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Message</span></span>(
    <span class="hljs-keyword">var</span> content  : String,
    <span class="hljs-keyword">var</span> author   : String,
    <span class="hljs-keyword">var</span> location : Point? = <span class="hljs-literal">null</span>,
    <span class="hljs-keyword">var</span> id       : <span class="hljs-built_in">Int</span>?   = <span class="hljs-literal">null</span>
)

<span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span></span>(
    <span class="hljs-keyword">var</span> userName  : String,
    <span class="hljs-keyword">var</span> firstName : String,
    <span class="hljs-keyword">var</span> lastName  : String,
    <span class="hljs-keyword">var</span> location  : Point? = <span class="hljs-literal">null</span>
)</code></pre>
<p>Exposed allows us to describe the structure of our tables with a type-safe SQL API quite handy to use (autocomplete, refactoring and error prone):</p>
<pre><code class="hljs language-kotlin">    <span class="hljs-keyword">object</span> Messages : Table() {
        <span class="hljs-keyword">val</span> id       = integer(<span class="hljs-string">"id"</span>).autoIncrement().primaryKey()
        <span class="hljs-keyword">val</span> content  = text(<span class="hljs-string">"content"</span>)
        <span class="hljs-keyword">val</span> author   = reference(<span class="hljs-string">"author"</span>, Users.userName)
        <span class="hljs-keyword">val</span> location = point(<span class="hljs-string">"location"</span>).nullable()
    }

    <span class="hljs-keyword">object</span> Users : Table() {
        <span class="hljs-keyword">val</span> userName  = text(<span class="hljs-string">"user_name"</span>).primaryKey()
        <span class="hljs-keyword">val</span> firstName = text(<span class="hljs-string">"first_name"</span>)
        <span class="hljs-keyword">val</span> lastName  = text(<span class="hljs-string">"last_name"</span>)
        <span class="hljs-keyword">val</span> location  = point(<span class="hljs-string">"location"</span>).nullable()
    }</code></pre>
<p>It is interesting to notice that Exposed does not support natively PostGIS functionalities like geometry types or geospatial requests. That’s where <a href="https://kotlinlang.org/docs/reference/extensions.html">Kotlin extensions</a> shine, and allow with a few lines of code to add such support without requiring to use extended classes:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> Table.<span class="hljs-title">point</span><span class="hljs-params">(name: <span class="hljs-type">String</span>, srid: <span class="hljs-type">Int</span> = <span class="hljs-number">4326</span>)</span></span>: Column&#x3C;Point>
  = registerColumn(name, PointColumnType())

<span class="hljs-keyword">infix</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> ExpressionWithColumnType<span class="hljs-type">&#x3C;*></span>.<span class="hljs-title">within</span><span class="hljs-params">(box: <span class="hljs-type">PGbox2d</span>)</span></span> : Op&#x3C;<span class="hljs-built_in">Boolean</span>>
  = WithinOp(<span class="hljs-keyword">this</span>, box)</code></pre>
<p>Our repository is also quite short and very flexible, since it allows you to write any kind of SQL request even with complex <code>WHERE</code> clause with a type-safe SQL API. Currently we need to use <code>db.transaction{ }</code> wrapper, I have created Exposed issue <a href="https://github.com/JetBrains/Exposed/issues/25">#25</a> to be able to use regular <a href="http://docs.spring.io/autorepo/docs/spring/4.2.x/spring-framework-reference/html/transaction.html">Spring transaction management</a> with <a href="http://docs.spring.io/autorepo/docs/spring/4.2.x/spring-framework-reference/html/transaction.html#transaction-declarative-annotations"><code>@Transactional</code></a> annotation, feel free to add your +1 ;-)</p>
<p>Please notice that since we are using Spring Framework 4.3, we <a href="https://spring.io/blog/2016/03/04/core-container-refinements-in-spring-framework-4-3#implicit-constructor-injection-for-single-constructor-scenarios">no longer need to specify an <code>@Autowired</code> annotation in such single-constructor class</a>.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@Repository</span>
<span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserRepository</span></span>(<span class="hljs-keyword">val</span> db: Database) {

    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createTable</span><span class="hljs-params">()</span></span> = db.transaction {
        create(Users)
    }

    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">create</span><span class="hljs-params">(user: <span class="hljs-type">User</span>)</span></span> = db.transaction {
        Users.insert( toRow(user) )
    }

    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">updateLocation</span><span class="hljs-params">(u:<span class="hljs-type">String</span>, l: <span class="hljs-type">Point</span>)</span></span> = db.transaction {
        location.srid = <span class="hljs-number">4326</span>
        Users.update({Users.userName eq u}) { it[Users.location] = l}
    }

    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">findAll</span><span class="hljs-params">()</span></span> = db.transaction {
        Users.selectAll().map { fromRow(it) }
    }

    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">findByBoundingBox</span><span class="hljs-params">(box: <span class="hljs-type">PGbox2d</span>)</span></span> = db.transaction {
        Users.select { Users.location within box }.map { fromRow(it) }
    }

    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">deleteAll</span><span class="hljs-params">()</span></span> = db.transaction {
        Users.deleteAll()
    }

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">toRow</span><span class="hljs-params">(u: <span class="hljs-type">User</span>)</span></span>: Users.(UpdateBuilder&#x3C;*>) -> <span class="hljs-built_in">Unit</span> = {
        it[userName] = u.userName
        it[firstName] = u.firstName
        it[lastName] = u.lastName
        it[location] = u.location
    }

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fromRow</span><span class="hljs-params">(r: <span class="hljs-type">ResultRow</span>)</span></span> =
        User(r[Users.userName],
             r[Users.firstName],
             r[Users.lastName],
             r[Users.location])
}</code></pre>
<p>Controllers are also very concise and use Spring Framework 4.3 upcoming <code>@GetMapping</code> / <code>@PostMapping</code> annotations which are just method-specific shortcuts for <code>@RequestMapping</code> annotations:</p>
<pre><code class="hljs language-kotlin">    <span class="hljs-meta">@RestController</span>
    <span class="hljs-meta">@RequestMapping(<span class="hljs-meta-string">"/user"</span>)</span>
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span></span>(<span class="hljs-keyword">val</span> repo: UserRepository) {

        <span class="hljs-meta">@PostMapping</span>
        <span class="hljs-meta">@ResponseStatus(CREATED)</span>
        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> u: <span class="hljs-type">User</span>)</span></span> { repo.create(u) }

        <span class="hljs-meta">@GetMapping</span>
        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">list</span><span class="hljs-params">()</span></span> = repo.findAll()

        <span class="hljs-meta">@GetMapping(<span class="hljs-meta-string">"/bbox/{xMin},{yMin},{xMax},{yMax}"</span>)</span>
        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">findByBoundingBox</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> xMin:<span class="hljs-type">Double</span>,
                              <span class="hljs-meta">@PathVariable</span> yMin:<span class="hljs-type">Double</span>,
                              <span class="hljs-meta">@PathVariable</span> xMax:<span class="hljs-type">Double</span>,
                              <span class="hljs-meta">@PathVariable</span> yMax:<span class="hljs-type">Double</span>)</span></span>
                = repo.findByBoundingBox(
                            PGbox2d(Point(xMin, yMin), Point(xMax, yMax)))

        <span class="hljs-meta">@PutMapping(<span class="hljs-meta-string">"/{userName}/location/{x},{y}"</span>)</span>
        <span class="hljs-meta">@ResponseStatus(NO_CONTENT)</span>
        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">updateLocation</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> userName:<span class="hljs-type">String</span>,
                           <span class="hljs-meta">@PathVariable</span> x: <span class="hljs-type">Double</span>,
                           <span class="hljs-meta">@PathVariable</span> y: <span class="hljs-type">Double</span>)</span></span>
                = repo.updateLocation(userName, Point(x, y))
    }</code></pre>
<p>The client side is a pure HTML + Javascript application developed with <a href="http://openlayers.org/">OpenLayers</a> mapping library (see <a href="https://github.com/sdeleuze/geospatial-messenger/blob/master/src/main/resources/static/index.html">index.html</a> and <a href="https://github.com/sdeleuze/geospatial-messenger/blob/master/src/main/resources/static/map.js">map.js</a> for more details) that geolocalizes you and creates geolocalized messages sent/received to/from other users thanks to Server-Sent Events.</p>
<p><img src="https://raw.githubusercontent.com/sdeleuze/geospatial-messenger/master/screenshot.png" alt="Screenshot"></p>
<p>And last but not least, the REST API is fully tested and documented thanks to the awesome <a href="http://projects.spring.io/spring-restdocs/">Spring REST docs</a> project, see <a href="https://github.com/sdeleuze/geospatial-messenger/blob/master/src/test/kotlin/io/spring/messenger/MessageControllerTests.kt">MessageControllerTests</a> and <a href="https://github.com/sdeleuze/geospatial-messenger/blob/master/src/main/resources/static/index.html">index.adoc</a> for more details.</p>
<h1>Conclusion</h1>
<p>The main impression I had developing this application is that it was fun, efficient, with a high level of flexibility and safety provided by the SQL API and Kotlin type system and <a href="https://kotlinlang.org/docs/reference/null-safety.html">null safety</a>. The resulting Spring Boot application is a 18 MBytes self-contained executable jar with low memory consumption (the app can run with <code>-Xmx32m</code>!!!). Using Spring REST docs was also a pleasure, demonstrating again Kotlin nice Java interoperability.</p>
<p>The few pain points I have encountered (<a href="https://youtrack.jetbrains.com/issue/KT-11235">array annotation attributes</a>, <a href="https://youtrack.jetbrains.com/issue/KT-5175">Java 8 Stream support</a>, <a href="https://youtrack.jetbrains.com/issue/KT-6947">full callable reference support</a>), are planned to be fixed in Kotlin 1.1. Exposed library is still young and need to mature, but from my point of view it is promising and shows how Kotlin could be used for building type-safe DSL API (<a href="https://kotlinlang.org/docs/reference/type-safe-builders.html">this HTML type-safe builder</a> is also a good example).</p>
<p>And keep in mind that officially supported <a href="http://projects.spring.io/spring-data/">Spring Data projects</a> works well with Kotlin as shown in the <a href="https://github.com/sdeleuze/spring-boot-kotlin-demo">spring-boot-kotlin-demo</a> project in my <a href="https://spring.io/blog/2016/02/15/developing-spring-boot-applications-with-kotlin">previous blog post</a>.</p>
<p>If you happen to be in Barcelona mid May (never a bad time to be in Barcelona anyway!), don’t miss the chance to join the <a href="http://www.springio.net/">Spring I/O conference</a>. Also, the registration for <a href="http://springoneplatform.io/">SpringOne Platform</a> (early August, Las Vegas) has opened recently, in case you want to benefit from early bird ticket pricing. The latter is also still open for talk proposals. So if you’re interested to give a talk about Spring or Pivotal-related technologies, feel free to submit!</p>
]]></description><link>https://spring.io/blog/2016/03/20/a-geospatial-messenger-with-kotlin-spring-boot-and-postgresql</link><guid isPermaLink="true">https://spring.io/blog/2016/03/20/a-geospatial-messenger-with-kotlin-spring-boot-and-postgresql</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Spring]]></category><dc:creator><![CDATA[Sébastien Deleuze]]></dc:creator><pubDate>Sun, 20 Mar 2016 10:51:00 GMT</pubDate></item><item><title><![CDATA[Algebraic Data Types In Kotlin]]></title><description><![CDATA[<p>Lately I have been doing a good amount of reading on functional programming, specifically <a href="http://haskellbook.com/">Haskell</a> and <a href="http://elm-lang.org/">Elm</a>. As part of this reading, I've been exposed to the wonderful world of type systems more advanced than the ones that I am used to, i.e. the Java type system. Exposure to <a href="https://en.wikipedia.org/wiki/Algebraic_data_type">algebraic data types (ADTs)</a> is one of the things that I've enjoyed about these readings. In the rest of this article, I will demonstrate how ADTs can be used in the Kotlin type system to assure that you've handled all of the possible outcomes from a business use case. For those already familiar with the <a href="https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Either.html"><code>Either</code> type</a> much of this will be old news to you.</p>
<p>Algebraic data types allow me to create a closed set of possible options for a specific type in my domain.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreateSubscriptionResult</span> </span>{
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Success</span></span>(<span class="hljs-keyword">val</span> subscription: Subscription): CreateSubscriptionResult()
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Failure</span></span>(<span class="hljs-keyword">val</span> errors: List&#x3C;String>): CreateSubscriptionResult()
}</code></pre>
<p>In this case I am using the <a href="https://kotlinlang.org/docs/reference/classes.html#sealed-classes"><code>sealed</code> keyword</a> to tell the type system that there will not be any more possible outcomes for a <code>CreateSubscriptionResult</code>. Now I can use the <code>when</code> keyword to force the consumer of the <code>CreateSubscriptionResult</code> to make sure it handles all of the possible outcomes.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> (result) {
    <span class="hljs-keyword">is</span> CreateSubscriptionResult.Success ->
        <span class="hljs-comment">// Do something on success</span>
    <span class="hljs-keyword">is</span> CreateSubscriptionResult.Failure ->
        <span class="hljs-comment">// Do something on failure</span>
}</code></pre>
<p>Were I to omit one of the possible outcomes,</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> (result) {
    <span class="hljs-keyword">is</span> CreateSubscriptionResult.Success ->
        <span class="hljs-comment">// Do something on success</span>
}</code></pre>
<p>then the Kotlin compiler will tell me that I've forgotten something.</p>
<pre><code>when expression must be exhaustive, add necessary 'is Failure' branch or 'else' branch instead
</code></pre>
<p>Well isn't that nice. I now can use the type system to remind myself, and my fellow developers, that something is missing and keep those types of bugs from cropping up in my software without a lot of boilerplate code. If another outcome is added at some point, the compiler will tell me that and I can then figure out how to handle it.</p>
<p>By using the type system to do this, I enable a faster feedback loop than had I written a test for it. Yes I may still need a test for the logic inside of each branch but I would postulate that if I keep it simple enough (like a difference in response code) that a test may be overkill because of the type system assurance. I'll leave that decision up to you.</p>
<p>One place I have been experimenting with this type of pattern is in my <a href="https://github.com/mikegehard/user-management-evolution-kotlin/blob/master/applications/ums/src/main/kotlin/com/example/ums/subscriptions/SubscriptionsController.kt#L36-L47">Spring controllers</a>. I like how it makes the code that handles the outcomes easy to read and understand. Another benefit is that I now have an explicit contract between the use case and the consumer that outlines all of the possible outcomes for the use case. When I combine this contract with the <code>when</code> keyword, the compiler will enforce that the client either handles each outcome or decides to explicitly punt on some by using the <code>else</code> keyword.</p>
<p>Have some feedback? I'd love to hear it. Reach out to me on Twitter @mikegehard and we can have a conversation about it.</p>
]]></description><link>http://engineering.pivotal.io/post/algebraic-data-types-in-kotlin/</link><guid isPermaLink="true">http://engineering.pivotal.io/post/algebraic-data-types-in-kotlin/</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Functional Programming]]></category><dc:creator><![CDATA[Mike Gehard]]></dc:creator><pubDate>Sat, 19 Mar 2016 12:15:00 GMT</pubDate></item><item><title><![CDATA[Kotlin Month Post 4: Properties]]></title><description><![CDATA[<h2><strong>Intro</strong></h2>
<p>In this, the fourth and final post in the Kotlin Month series, we take a look at a widely overarching feature of Kotlin that is tightly coupled with a few other features: Properties. Besides the obvious benefits of properties that they provide in all languages, Kotlin has reusable properties via Delegated Properties as well as really clean syntax for distinguishing between read-only and full properties.</p>
<h2><strong><code>var</code> and <code>val</code> and Type Inference</strong></h2>
<p>Kotlin makes it very easy to create clean, expressive properties. <code>var</code> and <code>val</code> make it so we don’t have to <em>remember</em> to mark our fields as <code>final</code>. Depending on circumstances, the type might be able to be omitted as well.</p>
<h3><strong>More Concise Than Most Other Property Syntaxes</strong></h3>
<p>Kotlin’s properties are supremely concise in comparison to any other syntax that I’ve seen. Here’s why:</p>
<ul>
<li>In Kotlin, we never need to declare the backing fields for a property, although we can use a backing <em>property</em> for more complicated implementations when needed. If you ever need access to the backing field in the getter and setter methods, you simply refer to it as <code>field</code>.</li>
<li>In Kotlin, unless we’re actually defining an alternative implementation of <code>get</code> and <code>set</code>, we don’t need to type them; <code>var</code> and <code>val</code> are used to determine whether it’s read-only or read-write.</li>
<li>If the property is being initialized directly from the primary constructor without checks or changes, it can simply be declared in the parameter list of the primary constructor. See the <a href="https://kotlinlang.org/docs/reference/classes.html#constructors">official documentation on Kotlin’s constructors</a> for more information.</li>
<li>As mentioned earlier, we don’t even need to specify the type for the property if we’re assigning a value to it right away (this only applies to properties declared in the body of the class, as opposed to those declared in the primary constructor).</li>
<li><a href="https://kotlinlang.org/docs/reference/delegated-properties.html">Delegated properties</a>. If we end up using the same code for multiple properties’ getters and setters, we can extract that code into a delegated property, which is just a class that defines the <code>getValue(...)</code> operator function and, optionally, the <code>setValue(...)</code>] operator function. These work a lot like descriptors in Python, except there’s one per instance, rather than one per class. To use them, we use our normal in-body property definition, followed by <code>by</code> and an instance of the delegated property class. Some built-in delegated property types in Kotlin include <code>lazy</code>, which allows us to lazily instantiate the value in the property; <code>observable</code>, which makes the property observable; and using <code>Map</code>s via some extension functions.</li>
</ul>
<h3><strong>The Not-So-Great Parts</strong></h3>
<p>There are some not-so-great things about properties in Kotlin, though. The first of which is the fact that the class definition line can become unhelpfully long. This is because this one line contains <code>class</code>, the name of the class, any type parameters (generics), the primary constructor argument list, and any inheritance. Now, even when these are simple, the line can easily clear 80 characters if there are more than two properties in the constructor, especially if there’s some inheritance. It’s gets even longer if a visibility modifier needs to be applied to anything; to the class, to the constructor (which not only requires the visibility modifier, but also the <code>constructor</code> keyword to show that the modifier is applying to that), or to the properties – which are already longer than typical parameters because of the <code>val</code> or <code>var</code> keyword. Luckily, Kotlin has forgone the <code>extends</code> and <code>implements</code> keywords in favor of <code>:</code>. If we still used those keywords, those lines would be unbearably long.</p>
<p>Breaking up the class definition line into multiple lines helps, but it’s always a little awkward to have the inheritance stuff near the end. I’d kind of like to have it right after the class name and type parameters if we want. Oh well.</p>
<p>The other problem comes from the fact that there can potentially be two different places to define properties: in the primary constructor or in the class body. This can make it more difficult to find properties sometimes. I think a convention needs to be put out there that states that, if you have any (public?) properties that are defined in the class body, all properties should be defined there. It ends up with more typing (but still less than Java or C#, since you can set a property equal to a parameter in the primary constructor), but clarifies the code by having only one place to look for properties. None in the constructor? They must all be in the body, then. This also keeps private properties from lengthening the class definition line with the visibility modifier.</p>
<h2><strong>Kotlin Month Summary</strong></h2>
<p>We’ve looked at a lot of my favorite features of Kotlin, but there’s so much more to see, so if you’re not familiar with Kotlin, check out their documentation. It’s great, and is able to stay short by letting you assume that anything else they haven’t explained is just like in Java. I’ve read through the whole thing a couple times, actually; it’s really well written;</p>
<p>If there were only 4 things I could take from Kotlin and put into Java, they would be, in order of “importance”:</p>
<ol>
<li>Extension Methods</li>
<li>First-Class Delegation</li>
<li>Properties</li>
<li>Simple Primary Constructor (It would probably be done a bit differently than in Kotlin, just to work better with Java’s existing syntax and to hopefully avoid the really long class declaration line)</li>
</ol>
<h2><strong>Outro</strong></h2>
<p>So, this is the end of this post as well as the Kotlin Month! series. But this definitely isn’t the end of me praising Kotlin. In fact, I’ve submitted an abstract to do a talk on Kotlin at <a href="https://www.thatconference.com/">That Conference</a>. It’s a talk that does an introduction to Kotlin before (unless I decide to do it <em>while</em>) showing the steps involved in migrating Java code to Kotlin.</p>
<p>For those too lazy to click the link, That Conference is a dev conference from August 8 – 10 in Wisconsin Dells (a bit south of central Wisconsin). At an indoor themepark/waterpark. How cool is that. I hope to meet some of you guys there!</p>
]]></description><link>https://programmingideaswithjake.wordpress.com/2016/03/19/kotlin-month-post-4-properties/</link><guid isPermaLink="true">https://programmingideaswithjake.wordpress.com/2016/03/19/kotlin-month-post-4-properties/</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Jacob Zimmerman]]></dc:creator><pubDate>Sat, 19 Mar 2016 05:00:00 GMT</pubDate></item><item><title><![CDATA[Kotlin Educational Plugin]]></title><description><![CDATA[<p>We always said that Kotlin is really easy to learn. And it is! But it’s not only about the language: learning materials make a difference too. Today we are making another important step in this direction. We are happy to present Kotlin Educational Plugin.</p>
<p><a href="https://youtu.be/0ponbfQhESY">https://youtu.be/0ponbfQhESY</a></p>
<p>Kotlin Edu is a plugin for IntelliJ IDEA 2016.1 which lets you take learning courses. A course contains a number of tasks, and every task has several placeholders which you need to fill in correctly to solve it.</p>
<p>At the moment, there is only one course — the well-known Kotlin Koans, which has been available <a href="http://try.kotlinlang.org/koans">online</a> for some time and gained considerable popularity among Kotlin learners. The offline versions of the Koans has pretty similar user experience but with all strengths of refactorings and intention actions available in IntelliJ IDEA!</p>
<p>If you have any questions about Kotlin Koans, feel free to ask them in the <strong>#koans</strong> channel <a href="http://blog.jetbrains.com/kotlin/2016/03/kotlin-educational-plugin/kotlinslackin.herokuapp.com">in our Slack</a>.</p>
<p>P.S. If you want to create your own course, contact us directly via <a href="mailto:roman.belov@jetbrains.com">email</a>.</p>
]]></description><link>http://blog.jetbrains.com/kotlin/2016/03/kotlin-educational-plugin/</link><guid isPermaLink="true">http://blog.jetbrains.com/kotlin/2016/03/kotlin-educational-plugin/</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Education]]></category><dc:creator><![CDATA[Roman Belov]]></dc:creator><pubDate>Thu, 17 Mar 2016 14:47:00 GMT</pubDate></item><item><title><![CDATA[Using Kotlin For Tests in Android]]></title><description><![CDATA[<h3>Using Kotlin For Tests in Android</h3>
<p>Many developers are quite optimistic about Kotlin future for Android. It <a href="https://medium.com/@sergii/say-hello-to-kotlin-78d8afff14a#.423ivzn8q">sounds so sweet</a>: less verbose, more type-safety, zero-overhead null-safety, Java interop. But not everyone is ready to take a risk and start writing production code using new programming language. Indeed, it could be not mature enough and will add dependencies which increase method count of APK for more than 6.5K. But what if we’ll use Kotlin only for tests?</p>
<h4>Project setup</h4>
<p>So we can setup Kotlin plugin and related libraries to be only in <a href="https://docs.gradle.org/current/userguide/artifact_dependencies_tutorial.html"><em>testCompile</em> </a>dependencies scope. Here is what we should set in build.gradle:</p>
<pre><code class="hljs language-groovy">dependencies {
    compile fileTree(<span class="hljs-string">dir:</span> <span class="hljs-string">'libs'</span>, <span class="hljs-string">include:</span> [<span class="hljs-string">'*.jar'</span>])
    compile <span class="hljs-string">'com.android.support:appcompat-v7:23.2.0'</span>

    testCompile <span class="hljs-string">'junit:junit:4.12'</span>
    testCompile <span class="hljs-string">"org.jetbrains.kotlin:kotlin-stdlib:$kotlin_ver"</span>
    testCompile <span class="hljs-string">"org.jetbrains.kotlin:kotlin-test-junit:$kotlin_ver"</span>
}</code></pre>
<p>Another improtant detail in build.gradle is setting proper source sets to make Kotlin tests folders visible to compiler and IDE. Also we should make sure that Kotlin won’t be used in the production code:</p>
<pre><code class="hljs language-groovy">android {
    <span class="hljs-comment">//...</span>
    sourceSets {
        test.java.srcDirs += <span class="hljs-string">'src/test/kotlin'</span>
    }
}

afterEvaluate {
    android.sourceSets.all { sourceSet ->
        <span class="hljs-keyword">if</span> (!sourceSet.name.startsWith(<span class="hljs-string">"test"</span>))
        {
            sourceSet.kotlin.setSrcDirs([])
        }
    }
}</code></pre>
<h4>Example</h4>
<p>Let’s create a tiny Android app which will convert temperature from Celsius to Kelvin and Fahrenheit. Here I create ThermoConverter.java utility class which is quite easy to make unittestable.</p>
<p>Then we can add simple unit tests for the same functionality in <em>java</em> and <em>kotlin</em> source folders written in Java and Kotlin respectively. Android Studio will mark both <em>test/java</em> and <em>test/kotlin</em> folders with the proper color to indicate them as test packages.</p>
<p>Kotlin example unit test code could be as simple as the follows — it will be enough for our demo purposes.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThermoConverterTestKotlin</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> ALLOWED_DELTA = <span class="hljs-number">0.01</span>f

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">thermoTest</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">val</span> celsiusVal = <span class="hljs-number">232.778</span>f
        <span class="hljs-keyword">val</span> thermoModel = ThermoConverter.getTemperature(celsiusVal)
        assertEquals(celsiusVal, thermoModel.celsius, ALLOWED_DELTA)
        assertEquals(<span class="hljs-number">451</span>f, thermoModel.fahrenheit, ALLOWED_DELTA)
    }
}</code></pre>
<p>And here is the overall project structure:</p>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/800/1*shTe7vHBNQJLQOk1WBzZaQ.png"></p>
<p>What do we have now? With testCompile dependencies scope we’ve defined that dependencies won’t be included to the main APK file but will be used only for compilation tests sources. We are adding Kotlin source set to the default one used by java code so we can use the same package structure and can have the same package visibility.</p>
<p>Here is how tests result looks in Android Studio for both Java and Kotlin tests executed together:</p>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/800/1*P2ygs6-7S2Wwg33HZVZrFg.png"></p>
<p>You can note that on this screenshot the execution time of tests with the same logic in Java and Kotlin is different —the second one seems to be slower. I did several experiments and it seems that this slowdown happens only at the first time JVM loads required by Kotlin dependencies, so it won’t bring any significant performance lag at least for the small amount of code.</p>
<h4>Conclusion</h4>
<p>Now you know the one more way how to try Kotlin in your Android project without production dependencies overhead and with lower maintenance risks. You can find full project example on <a href="https://github.com/sergiiz/KotlinTestDemo">GitHub</a>.</p>
<p>Thanks to <a href="https://medium.com/u/ba532f5866b4">Antonio Gutierrez</a> for the original idea about possible Kotlin use-case for testing.</p>
<p><em>Update.</em> Gradle configuration improved to make sure that Kotlin won’t be used in the production code. Thanks to <a href="https://medium.com/u/7997a2275b27">Dale King</a>.</p>
]]></description><link>https://medium.com/@sergii/using-kotlin-for-tests-in-android-6d4a0c818776#.vx2bsqrbm</link><guid isPermaLink="true">https://medium.com/@sergii/using-kotlin-for-tests-in-android-6d4a0c818776#.vx2bsqrbm</guid><category><![CDATA[Android]]></category><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Sergii Zhuk]]></dc:creator><pubDate>Wed, 16 Mar 2016 23:00:00 GMT</pubDate></item><item><title><![CDATA[Kotlin 1.0.1 is Here!]]></title><description><![CDATA[<p>It’s been a month since we released Kotlin 1.0, and while our user base roughly doubled during this time, we prepared the first bugfix update.</p>
<p>Kotlin 1.0.1 starts a series of 1.0.X versions delivering safe bug fixes and performance improvements to the language (as well as other parts of the project), and new features to our tools and integrations. This time it’s only relatively small IDE features, but bigger things are on the horizon for 1.0.2 and later.</p>
<h2>Changes in 1.0.1</h2>
<p>Please find the full change log <a href="https://github.com/JetBrains/kotlin/blob/1.0.1/Changelog.md">here</a>. Some numbers and highlights:</p>
<ul>
<li>it’s 47 fixes in the compiler, library and Gradle plugin improvements (performance),</li>
<li>Compatibility with Gradle 2.12,</li>
<li>
<p>IDE features:</p>
<ul>
<li>Compatibility with IDEA 2016,</li>
<li>Kotlin Education Plugin (for IDEA 2016),</li>
<li><a href="https://youtrack.jetbrains.com/issue/KT-9752">KT-9752</a> More usable file chooser for “Move declaration to another file”,</li>
<li><a href="https://youtrack.jetbrains.com/issue/KT-9697">KT-9697</a> Move method to companion object and back,</li>
</ul>
</li>
<li>and 39 assorted fixes in the IDE.</li>
</ul>
<p>We thank the participants of the EAP who tried the preview builds and reported feedback. Please join the <a href="https://discuss.kotlinlang.org/t/kotlin-1-0-1-eap/1525">EAP</a> and let’s make Kotlin better together!</p>
]]></description><link>http://blog.jetbrains.com/kotlin/2016/03/kotlin-1-0-1-is-here/</link><guid isPermaLink="true">http://blog.jetbrains.com/kotlin/2016/03/kotlin-1-0-1-is-here/</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Release]]></category><dc:creator><![CDATA[Andrey Breslav]]></dc:creator><pubDate>Wed, 16 Mar 2016 19:54:00 GMT</pubDate></item><item><title><![CDATA[Kotlin recipes for Android (I): OnGlobalLayoutListener]]></title><description><![CDATA[<div class="et_post_meta_wrapper">
<h1>Kotlin recipes for Android (I): OnGlobalLayoutListener</h1>
<p><img src="http://i2.wp.com/antonioleiva.com/wp-content/uploads/2016/03/kotlin_logo_new.png?resize=800%252C320" alt="Kotlin recipes for Android (I): OnGlobalLayoutListener"></div></p>
<p>Today a mate asked me how he could do an <code>OnGlobalLayoutListener</code> properly without incurring in the need of too much boilerplate. This was a tricky question because of a couple of things, let’s see it a little more deeply.</p>
<h2>What is OnGlobalLayoutListener for?</h2>
<p>This listener is available for any view’s <code>ViewTreeObserver</code> and it’s quite often used to get a callback when the view is inflated and measured, and we already have a width and height available to do any kind of calculations, animations, etc.</p>
<p>Thanks to the awesome Java interoperability that Kotlin provides, we can do this on a very clean way using its simulated properties and lambdas for single-method interfaces:</p>
<pre><code class="hljs language-kotlin">recycler.viewTreeObserver.addOnGlobalLayoutListener {
    <span class="hljs-comment">// do whatever</span>
}</code></pre>
<p>What’s the issue here? To prevent leaks, a recommended practice is to remove the listener once you’ve finished using it. But we don’t have a reference to the object because we used a lambda, and a lambda is not exactly the same as an object.</p>
<p>We could still use the old-fashioned style, but a kitten dies every time we use an anonymous object directly in Kotlin. We are not changing to a nicer language if we still need to do things like this:</p>
<pre><code class="hljs language-kotlin">recycler.viewTreeObserver.addOnGlobalLayoutListener(
        <span class="hljs-keyword">object</span> : ViewTreeObserver.OnGlobalLayoutListener {
            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onGlobalLayout</span><span class="hljs-params">()</span></span> {
                recycler.viewTreeObserver.removeOnGlobalLayoutListener(<span class="hljs-keyword">this</span>);
                <span class="hljs-comment">// do whatever</span>
            }
        });</code></pre>
<h2>Finding a better alternative</h2>
<p>Ok, we know we don’t want that. But what can we do to make it better? We are forced to use the not-so-good-looking way, but a good alternative would be to hide this behind an extension function.</p>
<p>We will then create a new function for views that receives another function and creates and removes the listener by itself. Something like:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">waitForLayout</span><span class="hljs-params">(<span class="hljs-keyword">crossinline</span> f: ()</span></span> -> <span class="hljs-built_in">Unit</span>) = with(viewTreeObserver) {
    addOnGlobalLayoutListener(<span class="hljs-keyword">object</span> : ViewTreeObserver.OnGlobalLayoutListener {
        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onGlobalLayout</span><span class="hljs-params">()</span></span> {
            removeOnGlobalLayoutListener(<span class="hljs-keyword">this</span>)
            f()
        }
    })
}</code></pre>
<p>You can now just call the function and be sure that the listener is added and removed by itself. Besides, you’ll never forget about removing it anymore:</p>
<pre><code class="hljs language-kotlin">recycler.waitForLayout {
    <span class="hljs-comment">// do whatever</span>
}</code></pre>
<p>If you prefer, you could apply the extension function to the <code>ViewTreeObserver</code> instead of directly to the <code>View</code>. That’s up to you.</p>
<h2>But we can improve it</h2>
<p>This layout listener is usually used to do something after a view is measured, so you typically would need to wait until width and height are greater than 0. And we probably want to do something with the view that called it, so why don’t we <strong>convert the parameter function into an extension function</strong> too?</p>
<p>I also <strong>generified the function</strong> so that it can be used by any object that extends View and also be able to access to all its specific functions and properties from the function we’ll write.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&#x3C;T: View></span> T.<span class="hljs-title">afterMeasured</span><span class="hljs-params">(<span class="hljs-keyword">crossinline</span> f: <span class="hljs-type">T</span>.()</span></span> -> <span class="hljs-built_in">Unit</span>) {
    viewTreeObserver.addOnGlobalLayoutListener(<span class="hljs-keyword">object</span> : ViewTreeObserver.OnGlobalLayoutListener {
        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onGlobalLayout</span><span class="hljs-params">()</span></span> {
            <span class="hljs-keyword">if</span> (measuredWidth > <span class="hljs-number">0</span> &#x26;&#x26; measuredHeight > <span class="hljs-number">0</span>) {
                viewTreeObserver.removeOnGlobalLayoutListener(<span class="hljs-keyword">this</span>)
                f()
            }
        }
    })
}</code></pre>
<p>This <code>afterMeasured</code> function is very similar to the previous one, but you can use the properties and public methods of the view directly inside the lambda. We can, for instance, get the width of the recycler and set a layout with a dynamic number of columns depending on it.</p>
<pre><code class="hljs language-kotlin">recycler.afterMeasured {
    <span class="hljs-keyword">val</span> columnCount = width / columnWidth
    layoutManager = GridLayoutManager(context, columnCount)
}</code></pre>
<h2>Conclusion</h2>
<p>It’s true that there are still some things that don’t look nice when working with Android, even moving to Kotlin, but we can always find an alternative that improves readability and avoids boilerplate, by hiding this boilerplate behind other structures. At least you’ll have to only write it once and the rest of the code will look awesome!</p>
]]></description><link>http://antonioleiva.com/kotlin-ongloballayoutlistener/</link><guid isPermaLink="true">http://antonioleiva.com/kotlin-ongloballayoutlistener/</guid><category><![CDATA[Android]]></category><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Antonio Leiva]]></dc:creator><pubDate>Wed, 16 Mar 2016 00:52:00 GMT</pubDate></item><item><title><![CDATA[Kotlin : Retrofit + RxAndroid + Realm]]></title><description><![CDATA[<h3>Kotlin : Retrofit + RxAndroid + Realm</h3>
<p>In this article I thought I should cover some of the libraries (that I use regularly), like Retrofit and Realm in the context of Kotlin and Rx.</p>
<p>If you’re new to Retrofit... Then I suggest you visit this <a href="https://medium.com/@ahmedrizwan/rxandroid-and-retrofit-2-0-66dc52725fff#.51syz2rr5">article</a> — and things will (hopefully) be crystal clear! And if you’re new to Rx &#x26; Kotlin — go <a href="https://medium.com/@ahmedrizwan/rxandroid-and-kotlin-part-1-f0382dc26ed8#.i0smhvwlm">here</a>!</p>
<h4>So let’s begin : Kotlin + Rx + Retrofit + Realm</h4>
<p>If you’re anything like me, then you absolutely hate writing unnecessary code. <em>cough Java 6 cough</em>. And in my Android development experience, I’ve come across many situations where I was like — “But... Why?!”</p>
<p>In the context of Languages, I think Kotlin is definitely a life-saver. And libraries like Retrofit, Realm and RxAndroid also significantly reduce the amount of unnecessary code.</p>
<p>Horror story: I once came across a project, which had around <strong>12</strong> model classes aka POJOs. Then there were <strong>12</strong> Database (ORM) Table classes and there were also <strong>12</strong> Model-to-Database-Mapping classes. If you’re good at counting, you’ll notice... Those are <strong>36</strong> classes right there! And not only that, a change to the a single class meant, changing all 3 classes.</p>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/800/1*j31fbds0p0D_WwDim60TEQ.jpeg"></p>
<p><em>Yeah, that was me...</em></p>
<p>I suppose, even if we don’t use any ORMs, we still would be writing code for mapping the Models to the Database! And that’s no good!</p>
<p>So, what was the solution... Well... For me <strong>Realm</strong> + <strong>Retrofit</strong> was it... I added in <strong>RxAndroid</strong> to the mix later on, because Rx makes almost everything better and more delicious! And of course <strong>Kotlin</strong>, because...</p>
<blockquote>
<p>Kotlin is love... Kotlin is life...</p>
</blockquote>
<p>With the combination of these, those 36 classes would be represented in just 12 (as they should be). And not just that, code will be more concise and expressive because of Kotlin!</p>
<h3>Simple Example: Getting data from Github API</h3>
<p>Imagine an app which gets data from an API, stores/persists that data to the database and also displays it. A pretty common scenario, right?</p>
<p>This is what I’d be making... An extremely simple example... Which should hopefully cover the basics!</p>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/800/1*CLjgK7p_Cdro4oh0gu4_Qg.png"></p>
<p><em>Nothing fancy — Just plain old me and my github info!</em></p>
<p>Let me walk you through on how I would go about creating this app...</p>
<h4>Creating the Project and Enabling Kotlin</h4>
<p>The first thing we do is enable Kotlin in the project — Just make sure the Kotlin Plugin is installed in your Android Studio.</p>
<p>I created an Empty project with a single MainActivity — Went straight into the build.gradle file and... Triggered the action...</p>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/800/1*pI9K9b0ww9jAduIrjZ10eg.png"></p>
<p><em>Trigger Action and search for Configure Kotlin</em></p>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/800/1*jMre8FWu_02iHJRnNLaj0w.png"></p>
<p><em>Select the modules and click OK</em></p>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/800/1*w-WHqk_EDQm8uu09fTyTXg.png"></p>
<p><em>After clicking OK — this gets added to the build file — <em>Sync Changes</em></em></p>
<p>Cool! Now we can write code in Kotlin!</p>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/800/1*gUTF_1dfhJLGJbQZxiJ-nA.png"></p>
<p><em>MainActivity.java at the moment — Pretty standard stuff</em></p>
<p>We can (magically) convert the existing java code to Kotlin... By doing the following...</p>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/800/1*8p7TdBtxViZlM50nBGBdww.png"></p>
<p><em>Action: Convert Java File to Kotlin File</em></p>
<p>Now the MainActivity becomes...</p>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/800/1*jtzRyBq1Parb6TYzdsgwVw.png"></p>
<p><em>Holy mother of Kotlin!</em></p>
<h4>Adding Rx — Retrofit — Realm Dependencies</h4>
<p>Time to add some dependencies!</p>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/800/1*CAdkhnWaF0MeqwYHpqKo1Q.png"></p>
<p><em>I also use Databinding! Because cool people use Databinding!</em></p>
<p>Now you might be thinking what the hell is <strong>kapt</strong>? Well it’s an annotation processor built for Kotlin.</p>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/600/1*6MHRyDAF7oqrxhlf2LHwcg.png"></p>
<p><em>sudo add this to build.gradle</em></p>
<p>In our project we’ll also have to enable <strong>generateStubs</strong> as well for kapt, in order for it to generate code.</p>
<p>So... Now we have everything we need! Time to start coding!</p>
<h4>The Model</h4>
<p>The endpoint we’re dealing with...</p>
<p><code>https://api.github.com/users/ahmedrizwan</code></p>
<p>And the response...</p>
<pre><code class="hljs language-json">{
  <span class="hljs-attr">"login"</span>: <span class="hljs-string">"ahmedrizwan"</span>,
  <span class="hljs-attr">"id"</span>: <span class="hljs-number">4357275</span>,
  <span class="hljs-attr">"avatar_url"</span>: <span class="hljs-string">"https://avatars.githubusercontent.com/u/4357275?v=3"</span>,
  <span class="hljs-attr">"gravatar_id"</span>: <span class="hljs-string">""</span>,
  <span class="hljs-attr">"url"</span>: <span class="hljs-string">"https://api.github.com/users/ahmedrizwan"</span>,
  <span class="hljs-attr">"html_url"</span>: <span class="hljs-string">"https://github.com/ahmedrizwan"</span>,
  <span class="hljs-attr">"followers_url"</span>: <span class="hljs-string">"https://api.github.com/users/ahmedrizwan/followers"</span>,
  <span class="hljs-attr">"following_url"</span>: <span class="hljs-string">"https://api.github.com/users/ahmedrizwan/following{/other_user}"</span>,
  <span class="hljs-attr">"gists_url"</span>: <span class="hljs-string">"https://api.github.com/users/ahmedrizwan/gists{/gist_id}"</span>,
  <span class="hljs-attr">"starred_url"</span>: <span class="hljs-string">"https://api.github.com/users/ahmedrizwan/starred{/owner}{/repo}"</span>,
  <span class="hljs-attr">"subscriptions_url"</span>: <span class="hljs-string">"https://api.github.com/users/ahmedrizwan/subscriptions"</span>,
  <span class="hljs-attr">"organizations_url"</span>: <span class="hljs-string">"https://api.github.com/users/ahmedrizwan/orgs"</span>,
  <span class="hljs-attr">"repos_url"</span>: <span class="hljs-string">"https://api.github.com/users/ahmedrizwan/repos"</span>,
  <span class="hljs-attr">"events_url"</span>: <span class="hljs-string">"https://api.github.com/users/ahmedrizwan/events{/privacy}"</span>,
  <span class="hljs-attr">"received_events_url"</span>: <span class="hljs-string">"https://api.github.com/users/ahmedrizwan/received_events"</span>,
  <span class="hljs-attr">"type"</span>: <span class="hljs-string">"User"</span>,
  <span class="hljs-attr">"site_admin"</span>: <span class="hljs-literal">false</span>,
  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"ahmed"</span>,
  <span class="hljs-attr">"company"</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-attr">"blog"</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-attr">"location"</span>: <span class="hljs-string">"Rawalpindi, Pakistan"</span>,
  <span class="hljs-attr">"email"</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-attr">"hireable"</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-attr">"bio"</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-attr">"public_repos"</span>: <span class="hljs-number">9</span>,
  <span class="hljs-attr">"public_gists"</span>: <span class="hljs-number">0</span>,
  <span class="hljs-attr">"followers"</span>: <span class="hljs-number">5</span>,
  <span class="hljs-attr">"following"</span>: <span class="hljs-number">9</span>,
  <span class="hljs-attr">"created_at"</span>: <span class="hljs-string">"2013-05-06T18:32:59Z"</span>,
  <span class="hljs-attr">"updated_at"</span>: <span class="hljs-string">"2015-08-29T18:17:58Z"</span>
}</code></pre>
<p>Ok for this example, I just want to extract <em>id</em>, <em>name</em>, <em>avatar_url</em> and <em>public_repos</em> from the response. So my model class (which is also a realm class btw), would look something like</p>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/800/1*XkIxB1PtetctYpuPBMDM3Q.png"></p>
<p><em>*_*</em></p>
<blockquote>
<p>Note: If you want to extract everything from the JSON response, then I suggest visiting to this awesome <a href="http://www.jsonschema2pojo.org">website</a>, and generate a POJO. Then convert the Java code to Kotlin as described earlier.</p>
</blockquote>
<p>Ok, lots of things to cover here... Starting off from the <em>RealmClass</em> annotation... For Realm, this annotation is necessary for Realm’s code generation in Kotlin... <em>PrimaryKey</em> annotation is also a Realm annotation, representing the Primary Key field (duh!)... Rest of the annotations are for Gson...</p>
<p>Now the <strong>open</strong> keyword! In kotlin it’s the opposite of <strong>final</strong> in Java. By default, Kotlin classes are final — that means if you want a class to be inherrited — we explicitly have to declare it as <strong>open</strong>. Same is the case with properties. Like in our model, <em>name</em> is a property, with an actual getter and a setter (thanks to Kotlin). And in order for the getter/setter to be overridable (which Realm requires them to be), we put the keyword <strong>open</strong> along with the declaration of the property. Which makes sense (to me at least).</p>
<h4>Retrofit Interface</h4>
<p>Again the endpoint url is</p>
<p><code>https://api.github.com/users/[some_user]</code></p>
<p>So the interface would look something like :-</p>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/800/1*D8ABvZYNBRsw_Ffe5ilS0g.png"></p>
<p><em>Simplicity of Retrofit :’)</em></p>
<p>Notice how I’m returning Observable of a Github. This is possible because Retrofit allows Rx integration. And that’s super-super-cool!</p>
<h4>Retrofit Builder</h4>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/800/1*RAPCtfF_ztT6qB_wHoxLjw.png"></p>
<p><em>Yay... Now I can make API calls... ^</em>^_</p>
<p>Because of Realm we use a special Gson instance, which basically adds an exclusion strategy for skipping Realm generated fields. Otherwise Gson doesn’t work with the model.</p>
<p>Next we create an instance of Retrofit with RxJavaCallAdapter factory which allows Rx integration and we also add the Gson converter using the Gson instance we created before.</p>
<h4>Rx Magic</h4>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/800/1*_fSWqpcqhzNfoJNKc8PMig.png"></p>
<p><em>Lambdaaaaaaas! :’) Btw binding is my Databinding object!</em></p>
<p>Now all I do is get the observable, subscribe to it and get our Github object. Once we have the object, it’s easy to persist the user to Realm database.</p>
<h4>Caching</h4>
<p>Caching is also (sort of) possible, because we can first fetch data from Realm Database (if it has already been saved)... Like this...</p>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/800/1*_31bgwIcMTmcCTJHKv03UQ.png"></p>
<p><em>Dayum!</em></p>
<p>And... That’s it! Now if you run the app...</p>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/800/1*CLjgK7p_Cdro4oh0gu4_Qg.png"></p>
<p><em><em>slow clap</em></em></p>
<p>You can find the full code example <a href="https://github.com/ahmedrizwan/RxRealmRetroKotlin/tree/master">here</a>. Hope the article was somewhat useful!</p>
<p>Happy coding!</p>
]]></description><link>https://medium.com/@ahmedrizwan/kotlin-retrofit-rxandroid-realm-39d7be5dc9dc#.w7ufbebxh</link><guid isPermaLink="true">https://medium.com/@ahmedrizwan/kotlin-retrofit-rxandroid-realm-39d7be5dc9dc#.w7ufbebxh</guid><category><![CDATA[Retrofit]]></category><category><![CDATA[Realm]]></category><category><![CDATA[RxAndroid]]></category><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Ahmed Rizwan]]></dc:creator><pubDate>Tue, 15 Mar 2016 15:44:00 GMT</pubDate></item><item><title><![CDATA[Kotlin & Android: A Brass Tacks Experiment Wrap-Up]]></title><description><![CDATA[<p><img src="https://d262ilb51hltx0.cloudfront.net/max/1600/1*UN-S8ELMC2kpHf4tJKfbLQ.png"></p>
<p><em>Disclaimer: I am a Google employee, but the views expressed in this article are not those of my employer.</em></p>
<h3>Kotlin &#x26; Android: A Brass Tacks Experiment Wrap-Up</h3>
<p>It’s been fun exploring Kotlin® language features for use with Android development! If you’ve landed here without that context and want to explore this 7-part blog series from the beginning, you can <a href="https://medium.com/p/kotlin-android-a-brass-tacks-experiment-part-1-3e5028491bcc">jump back to the beginning</a>, but there’s no need for that to understand this article.</p>
<p>If you have been following along with the prior 6 parts, you know that, at this point in the experiment, we have a nice domain specific language for expressing the creation of an Android view hierarchy in Kotlin. We made use of the type-safe builder pattern, along with extension functions and properties, to provide ourselves with some handy tools to make this super easy.</p>
<p>A question you might have at this point in the journey is this: <em>Should I even try to use this technique to build views in my app?</em> Up until now, I’ve only ever talked about how it can be easy and convenient to do so, but I haven’t really compared it to anything other than the same task in the Java® programming language. On that point, I definitely find that using Kotlin’s type-safe builder pattern for building views far more agreeable than the equivalent practice in Java. However, specifying views in XML resources is the standard for Android apps, so let’s break down some categories for comparison between the classic XML layouts and the Kotlin type-safe builder approach.</p>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/800/1*LEibB6uJbdo3gZ4dNcydaQ.png"></p>
<p><strong>How well does the approach work with Activity configuration changes?</strong></p>
<p>With Android, a device may change configuration at any time. The most common type of configuration change is orientation. There are many other types, <a href="http://developer.android.com/guide/topics/manifest/activity-element.html">as documented here</a> (see android:configChanges within). Changes in orientation are especially important for Android views, because it is common practice to have a different layout for both landscape and portrait.</p>
<p>When dealing with XML layouts, it’s trivial to handle configuration changes that result in different UI. You simply define your layout twice — once for landscape under res/layout-land and once for portrait under res/layout-port. When you give the XML files the same name in these different spaces, that lets Android know to find and inflate the correct version of the layout for each circumstance. Generally speaking, you write no extra code to handle this change.</p>
<p>When dealing with layouts generated from code, you don’t get this configuration switching behavior for free. If you want to change layouts for different configurations, you have to write conditional logic to decide which views to create. And, if you do this a lot, it becomes cumbersome.</p>
<p>So, for handling a possible matrix of configuration settings with different UI, XML layouts are more convenient.</p>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/800/1*PrbCkbWf1z_dznNsRNpbXQ.png"></p>
<p><strong>How well does the approach work for complex layouts such as RelativeLayout?</strong></p>
<p>RelativeLayout is a tool that allows for a very flexible way of positioning views relative to other views. You can easily say that one view should be above, below, to the left, or to the right of another “anchor” view. This requires assigning IDs to the anchor views, while also calling out those IDs in the views to be positioned relative to its anchors. View IDs are also used to locate views within view hierarchies to make modifications to them in code.</p>
<p>In Android, it’s a best practice to let the compiler assign the integer values for view IDs. You shouldn’t just make up values of your own. This means that you have to use the Android tools to specify these IDs so they can be used later.</p>
<p>When dealing with XML layouts, it’s trivial to create a new ID. You simply call out a new value where it’s needed, usually in the view’s android:id property, like this:</p>
<pre><code class="hljs language-xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">TextView</span> <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/tv"</span> <span class="hljs-attr">...</span> /></span></code></pre>
<p>The +@id notation tells the Android toolchain to define a new ID called tv, or reuse an existing ID with the same name. Couldn’t be easier.</p>
<p>However, when dealing with layouts generated from code, it’s not possible to create a new ID in the middle of code. To create a new ID, you have to define a new ID as a resource in XML. Then you can reference it from the compiled R class that contains all the IDs used in the app. So, working with views programmatically involves dealing with another file, and Android will not automatically remove IDs for you when no longer referenced.</p>
<p>Considering all this, it’s easier to work with view IDs with XML layouts because of the tooling support for automatic ID management.</p>
<p><strong>How well does the approach work when doing calculations to assign to attributes of views?</strong></p>
<p>It’s not uncommon to want to calculate some value for an attribute of a view, such as its display text, or a background color, or its dimensions.</p>
<p>The Android XML layout language is purely declarative. You can’t do any computations in the strings used for assigning attributes. This means that attributes must be assigned in code later after the view has been inflated. This creates a disconnect between the definition in the layout file and its corresponding inflation code. Android programmers are not strangers to this practice!</p>
<p>However when building view programmatically, you can simply assign the result of a computation directly to the view property. You can also assign values to be equal to some other property on the view. How many times have you assigned the exact same value to marginLeft and marginBegin?</p>
<p>Given that you (of course) have all the flexibility of code when creating views programmatically, it’s definitely more convenient in this case to use programmatic view creation, especially with Kotlin type-safe builders.</p>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/800/1*Z38Ypb3iB2_Vw_OOHOXwOg.png"></p>
<p><strong>How easily can you experiment with tweaks to your layouts?</strong></p>
<p>Unless you’re really good at visualizing Android layout as you write them, you’ve probably used Android Studio to preview an XML layout without having to build and deploy to a device to see the result.</p>
<p>When you code layouts programmatically, you don’t have a quick preview method like this. When Android Studio 2.0 with Instant Run is fully released, this situation will improve greatly. But for now, the most convenient way to experiment with layout changes is usually through the Android Studio preview pane.</p>
<p><strong>What’s the performance like with each approach?</strong></p>
<p>This is a matter of benchmarking inflation of a view hierarchy against equivalent code that constructs the views directly. When I first started experimenting with this, I found that building a simple layout was up to twice as fast inflation! But as I started layering in more Kotlin features and doing more complicated things with views, the difference wasn’t so stark. On my Nexus 6P, I found that building takes roughly 75% of the time it takes to inflate. Presumably, this is because inflation has the overhead of processing the layout resource as it builds the views.</p>
<p>It should be noted that, in either case, it takes less than 1 millisecond to end up with a view hierarchy with 5 views total, so unless you’re making a whole lot of views, performance is not a huge problem to address.</p>
<p>If you want to perform the benchmarks yourself, the source code to a sample project can be found <a href="https://github.com/CodingDoug/kotlin-view-builder">in my GitHub</a>.</p>
<p><strong>What’s the size overhead of using Kotlin?</strong></p>
<p>There was a dangling question from part 1 about the size requirements of using Kotlin in Android. There is a runtime and standard library for Kotlin that you declare as a compile dependency. Any time you add a dependency to an Android app, you should definitely be considering its size, especially if you’re not able to multidex your app.</p>
<p>With Kotlin version 1.0.0, the runtime + stdlib jars weigh in at 210KB + 636K = <strong>846KB</strong>, which is fairly hefty for a library. Counting all the methods using <a href="https://github.com/mihaip/dex-method-counts">dex-method-counts</a> reveals a total of <strong>6584 methods</strong> under the kotlin package, not including the methods in the Java runtime it also references. This is at least a full 10% of your method count budget for a single dex! But, after applying ProGuard on my test project, that number drops to just <strong>42 methods</strong>. The final number will, of course, expand in relation to the other parts of Kotlin that the app makes use of. The bottom line is that use of ProGuard on apps that include Kotlin is crucial to keeping it under control for serious use.</p>
<p><strong>Summing it all up:</strong></p>
<p>Kotlin is a pleasure to use in general and can be directly applicable to Android development. For building views, it’s not a silver bullet, since there are many advantages to using XML layouts as is normally recommended. But there are definitely times when programmatic view building is preferable, and Kotlin can provide some handy shortcuts to getting that done with style.</p>
<p>You may also wonder what other hidden costs there are to using Kotlin. This is a valid question, and was recently addressed in <a href="https://www.reddit.com/r/androiddev/comments/47613n/can_we_talk_about_the_downsides_of_using_kotlin/">a discussion on Reddit</a>. I add my two cents to that discussion, so head over there if you want to see what some people think about that.</p>
<p>If you want to see my test project and compare XML layouts with views built by Kotlin, clone <a href="https://github.com/CodingDoug/kotlin-view-builder">my kotlin-view-builder repo</a> to easily try it out yourself.</p>
<p>I hope you enjoyed reading about my experiences with Kotlin for Android as much as I enjoyed learning about it myself!</p>
<p>I work extensively with Android, so be sure to follow me on <a href="https://medium.com/@CodingDoug">Medium</a> and <a href="https://twitter.com/CodingDoug">Twitter</a> to get my upcoming blogs.</p>
]]></description><link>https://medium.com/@CodingDoug/kotlin-android-a-brass-tacks-experiment-wrap-up-2b37e3ac8957#.nf83hy78g</link><guid isPermaLink="true">https://medium.com/@CodingDoug/kotlin-android-a-brass-tacks-experiment-wrap-up-2b37e3ac8957#.nf83hy78g</guid><category><![CDATA[Android]]></category><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Doug Stevenson]]></dc:creator><pubDate>Mon, 14 Mar 2016 20:57:00 GMT</pubDate></item><item><title><![CDATA[Kotlin Month Post 3: Safety]]></title><description><![CDATA[<h2><strong>Intro</strong></h2>
<p>In this third post for <a href="https://programmingideaswithjake.wordpress.com/kotlin/#kotlinmonth">Kotlin Month</a>, I’m going to go over some of the safety features that Kotlin comes with. Follow the link to see the previous posts.</p>
<h2><strong>Null Safety</strong></h2>
<p>This is one of the most touted features of Kotlin, from what I’ve seen. Personally, it has given me a little bit of grief, but some built-in property delegates, like <code>lazy</code> and <code>lateinit</code> are helpful workarounds.</p>
<p>Here’s the safety that Koltin provides: A variable cannot contain <code>null</code> unless its type specifies that it’s nullable. You can declare a type as nullable by placing a <code>?</code> at the end of the type’s name. For example, for a variable that can hold <code>null</code> or <code>String</code>, its type would be <code>String?</code>. That’s step one of the null safety.</p>
<p>The next step is that you cannot directly call methods or properties from a nullable variable. In order to safely dereference a nullable object, you must place a <code>?</code> before the <code>.</code>. This operator returns <code>null</code> if the object being dereferenced is <code>null</code>, or else returns the result of the method or property use. For example, if there’s a <code>String?</code> variable called <code>str</code>, and we want to find out if it’s empty, we would call it with <code>str?.isEmpty()</code>. The result is either <code>null</code>, <code>true</code>, or <code>false</code>. With the next operator, we can use that <code>null</code> to mean <code>true</code>.</p>
<p>The next operator, often called the elvis operator, since it kind of looks like it’d be a pompadoured emoticon, helps us turn <code>null</code> values into default values. It works a lot like the ternary operator (which Kotlin actually doesn’t have, since its <code>if</code>/<code>else</code> block is an expression, not a statement), except the left hand side is a combination of the left and middle of the ternary operator. It either evaluates to <code>null</code> or the desired type. If it <em>does</em> resolve as <code>null</code>, it uses the right side if the operator. So, our <code>String?</code> example above would become <code>str?.isEmpty() ?: true</code>, which returns whatever <code>isEmpty()</code> returns, or else <code>true</code> if <code>str</code> was <code>null</code>. By the way, the <code>?:</code> part was the operator.</p>
<p>The last piece of the puzzle is the <code>!!</code> operator. This is a way of telling the compiler one of two things. Either “I’d rather get a <code>NullPointerException</code> than have to deal with null safety”” or “”I know that the type says that it’s nullable, but I can <em>guarantee</em> that it won’t be <code>null</code>; at least not at this point.”</p>
<p>Now, because of Java interop, Kotlin can’t make any guarantees about the nullability of types coming from Java code. It goes the pragmatic route and lets the developer decide (and deal with the consequences, if need be) whether it can be <code>null</code> or not. Annotations can be used to tell the compiler, also. Check out their documentation on <a href="http://kotlinlang.org/docs/reference/java-interop.html#null-safety-and-platform-types">Java interop with null safety</a> for more information.</p>
<h2><strong>Smart Casting</strong></h2>
<p>Smart casting is nifty little feature that, while not coming up all that often in most cases, is really nice for cleaning up your code. Say you have code like this:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">if</span>(someVar instanceof SomeType) {
   SomeType anotherVar = (SomeType)someVar;
   ...
}</code></pre>
<p>This kind of casting is such a pain. Once you’ve determined that <code>someVar</code> is of type <code>SomeType</code>, you don’t get to just use it as if it is. No, first you have to create <em>another</em> variable (or, if you’re “lucky”, you can do it without the new variable for a single-line expression, but then you need <em>another</em> set of parentheses for the cast – <code>((SomeType)someVar)...</code>) as well as write out the cast.</p>
<p>In Kotlin, you write it like this:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">if</span>(someVar <span class="hljs-keyword">is</span> SomeType) {
   ...
}</code></pre>
<p>First off, the type check operartor is shorter as <code>is</code>. The cast operator is cleaner too. If we had needed to use it in this case (which we didn’t), it would have been <code>var anotherVar = someVar as SomeType</code>. It’s not shorter, but it’s cleaner.</p>
<p>The reason we didn’t need to cast it is because the compiler knows that, inside the block, <code>someVar</code> is definitely a <code>SomeType</code>. So, we didn’t even need to use another variable for that because it just pretends that <code>someVar</code>‘s type is <code>SomeType</code> instead of whatever it was declared as.</p>
<p>An interesting note about this is that it applies to nullability, too. Since <code>String?</code> isn’t considered to be the same thing as <code>String</code>, but rather a supertype, it can be smart cast from <code>String?</code> to <code>String</code>:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">if</span>(someStr != <span class="hljs-literal">null</span>) {
   ... <span class="hljs-keyword">as</span> <span class="hljs-keyword">if</span> someStr <span class="hljs-keyword">is</span> no longer a nullable type
}</code></pre>
<p>There is a limit to smart casting, though. If the variable in question could potentially be changed by another thread at any time, it will not do it. Therefore, smart casting can only be applied to <code>final</code> variables (<code>val</code>s) or local variables (those created within the function).</p>
<p>Check out <a href="http://kotlinlang.org/docs/reference/typecasts.html#smart-casts">Kotlin’s documentation on smart casts</a> if you want to learn more.</p>
<h2><strong>Generics</strong></h2>
<p>Straight-up, Kotlin has better generics than Java. ‘Nuff said.</p>
<p>I’m just kidding. But seriously, Kotlin’s generics are better; they can even allow you to do things that Java won’t compile. I can’t give you an example, but I spotted a StackOverflow example once where someone tried to turn their Kotlin code into Java code, but they couldn’t because the Java code doesn’t allow generics to be used in a certain way, but luckily the byte code is forgiving and allows Kotlin to do it.</p>
<p>Moving beyond that, Kotlin also uses declaration-site variance as a primary variance rather than Java’s use-site variance. It also follows the same syntax as C#’s variance (using <code>out</code> and <code>in</code> instead of <code>_ extends</code> or <code>_ super</code>), which is much easier to understand in most cases. Since I’m not good at explaining this stuff, I’d like to just point you to <a href="http://kotlinlang.org/docs/reference/generics.html">Kotlin’s documentation on it</a>.</p>
<h3><strong>Inline Functions and Reified Generics</strong></h3>
<p>Kotlin allows you to define inline functions (functions that are compiled in a way that, when called in code, it actually “copies” the code from inside the function into the place where it’s called), which can be really useful [and is only suggested to be used] when making functions that accept lambdas and method references that are called within, since <em>that</em> can be inlined too, without actually creating a function object. Another interesting feature of inline functions is the ability to have <em>reified generics</em> (generics without type erasure), since, in its inlined state, the compiler can actually <em>know</em> what the actual type is (assuming it wasn’t already a generic type to begin with). There’s actually quite the swathe of things that can be done with inline functions, so you should check them out in <a href="http://kotlinlang.org/docs/reference/inline-functions.html">Kotlin’s documentation on them</a>.</p>
<h2><strong>Outro</strong></h2>
<p>Thus ends my list of safety features in Kotlin. You should totally just go and fall in love with Kotlin now, as I have. Even if you won’t do it now, I still have next week’s post to sway you, so look forward to that.</p>
]]></description><link>https://programmingideaswithjake.wordpress.com/2016/03/13/kotlin-month-post-3-safety/</link><guid isPermaLink="true">https://programmingideaswithjake.wordpress.com/2016/03/13/kotlin-month-post-3-safety/</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Jacob Zimmerman]]></dc:creator><pubDate>Sun, 13 Mar 2016 22:53:00 GMT</pubDate></item><item><title><![CDATA[Feedback on the Josephus problem]]></title><description><![CDATA[<p>My last week <a href="https://blog.frankel.ch/solving-the-josephus-problem-in-kotlin">article</a> was about the solving the Josephus problem in Kotlin. For ease of comparison, here’s the version I wrote originally:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Soldier</span></span>(<span class="hljs-keyword">val</span> position: <span class="hljs-built_in">Int</span>) {
    <span class="hljs-keyword">var</span> state = State.Living
    lateinit <span class="hljs-keyword">var</span> next: Soldier
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">suicide</span><span class="hljs-params">()</span></span> {
        state = State.Dead
    }
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isDead</span><span class="hljs-params">()</span></span> = state == State.Dead
}

<span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">State</span> </span>{
    Living, Dead
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span></span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> size: <span class="hljs-built_in">Int</span>, <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> step: <span class="hljs-built_in">Int</span>) {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> first = Soldier(<span class="hljs-number">0</span>)

    init {
        <span class="hljs-keyword">var</span> person = first
        <span class="hljs-keyword">while</span> (person.position &#x3C; size - <span class="hljs-number">1</span>) {
            person = createNext(person)
        }
        <span class="hljs-keyword">val</span> last = person
        last.next = first
    }

    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createNext</span><span class="hljs-params">(soldier: <span class="hljs-type">Soldier</span>)</span></span>: Soldier {
        <span class="hljs-keyword">val</span> new = Soldier(soldier.position + <span class="hljs-number">1</span>)
        soldier.next = new
        <span class="hljs-keyword">return</span> new
    }

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">findSurvivor</span><span class="hljs-params">()</span></span>: Soldier {
        <span class="hljs-keyword">var</span> soldier: Soldier = first
        <span class="hljs-keyword">var</span> numberOfDead = <span class="hljs-number">0</span>
        <span class="hljs-keyword">while</span> (numberOfDead &#x3C; size - <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">var</span> count: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span>
            <span class="hljs-keyword">while</span> (count &#x3C; step) {
                soldier = nextLivingSoldier(soldier)
                count++
            }
            soldier.suicide()
            numberOfDead++
        }
        <span class="hljs-keyword">return</span> nextLivingSoldier(soldier)
    }

    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">nextLivingSoldier</span><span class="hljs-params">(soldier: <span class="hljs-type">Soldier</span>)</span></span>: Soldier {
        <span class="hljs-keyword">var</span> currentSoldier = soldier.next
        <span class="hljs-keyword">while</span> (currentSoldier.isDead()) {
            currentSoldier = currentSoldier.next
        }
        <span class="hljs-keyword">return</span> currentSoldier
    }
}</code></pre>
<p>The post ended with an open question: was the code the <em>right</em> way to do it? In particular:</p>
<ul>
<li>Is the code idiomatic Kotlin?</li>
<li>Lack of <code>for</code> means using <code>while</code> with <code>var</code>s</li>
<li>Too many mutability (<code>var</code>) for my own liking</li>
</ul>
<p>I’ve received great feedback from the community on many different channels, including Ilya Ryzhenkov from JetBrains, Cédric Beust, Peter Somerhoff and Gaëtan Zoritchak. Thanks guys!</p>
<p>I think the most interesting is this one, very slightly modified from the original <a href="https://gist.github.com/gzoritchak/1e2ec8d38fc39a4485ba">Gist</a> by Gaëtan:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Soldier</span></span>(<span class="hljs-keyword">val</span> position: <span class="hljs-built_in">Int</span>, <span class="hljs-keyword">var</span> state:State = State.Living) {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">suicide</span><span class="hljs-params">()</span></span> {
        state = State.Dead
    }
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isAlive</span><span class="hljs-params">()</span></span> = state == State.Living
}

<span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">State</span> </span>{
    Living, Dead
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span></span>(<span class="hljs-keyword">val</span> size: <span class="hljs-built_in">Int</span>, <span class="hljs-keyword">val</span> step: <span class="hljs-built_in">Int</span>) {

    <span class="hljs-keyword">val</span> soldiers = Array( size, {Soldier(it)}).toList()

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">findSurvivor</span><span class="hljs-params">()</span></span>: Soldier {
        <span class="hljs-keyword">var</span> soldier = soldiers.first()
        (<span class="hljs-number">2.</span>.size).forEach {
            (<span class="hljs-number">1.</span>.step).forEach {
                soldier = soldier.nextLivingSoldier()
            }
            soldier.suicide()
        }
        <span class="hljs-keyword">return</span> soldier.nextLivingSoldier()
    }

   tailrec <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> Soldier.<span class="hljs-title">nextLivingSoldier</span><span class="hljs-params">()</span></span>:Soldier =
            <span class="hljs-keyword">if</span> (next().isAlive())
                next()
            <span class="hljs-keyword">else</span>
                next().nextLivingSoldier()

   <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> Soldier.<span class="hljs-title">next</span><span class="hljs-params">()</span></span> = soldiers.<span class="hljs-keyword">get</span>(
           <span class="hljs-keyword">if</span> (position == size - <span class="hljs-number">1</span>)
               <span class="hljs-number">0</span>
           <span class="hljs-keyword">else</span>
               position + <span class="hljs-number">1</span>
   )
}</code></pre>
<p>I like this code a lot because it feels more Kotlin-esque. Improvements are many.</p>
<ul>
<li>The code is shorter without any loss of readability</li>
<li>
<p>It’s entirely functional, there’s only a single <code>var</code> involved:</p>
<ul>
<li>the 2 <code>while</code> loops with their associated <code>var</code> counter have been replaced by simple <code>forEach</code> on <code>Int</code> ranges.</li>
<li>Chaining <code>Soldier</code> instances is not handled in the <code>Soldier</code> class itself through the <code>next()</code> method but by the containing <code>Circle</code>. Thus, a simple backing array can store them and there’s no need for custom code with mutable variables.</li>
</ul>
</li>
<li>The <em>recursive</em> <code>nextLivingSoldier()</code> function has been “annotated” with <code>tailrec</code> in order for the compiler to run its optimization magic.</li>
<li>The <code>Soldier</code> class doesn’t know about its container <code>Circle</code>‘s <code>size</code>, so functions using it have been moved inside the <code>Circle</code> class as extension functions to the <code>Soldier</code> class. This is a great usage of Kotlin’s extension functions.</li>
</ul>
<p>This experience reinforced my belief that learning a language by just reading about it is not enough. To truly make it yours, steps should be those:</p>
<ol>
<li>obviously, learn the syntax of the language – and its API,</li>
<li>code a solution or an app with this language,</li>
<li>ask for feedback,</li>
<li>read, analyze and understand the feedback,</li>
<li>rinse and repeat.</li>
</ol>
]]></description><link>https://blog.frankel.ch/feedback-jospehus-problem</link><guid isPermaLink="true">https://blog.frankel.ch/feedback-jospehus-problem</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Nicolas Frankel]]></dc:creator><pubDate>Sun, 13 Mar 2016 19:14:00 GMT</pubDate></item><item><title><![CDATA[(RU) SDCast #41: в гостях Андрей Бреслав, руководитель проекта Kotlin в компании JetBrains]]></title><description><![CDATA[<p><img src="https://sdcast.ksdaemon.ru/wp-content/uploads/2014/06/sd-podcast-logo-200x200.png" alt="sd-podcast-logo"> Рад представить вам 41-й выпуск подкаста! Этот эпизод посвящен языку Kotlin, у меня в гостях Андрей Бреслав, руководитель проекта Kotlin в компании JetBrains.</p>
<p>В начале выпуска мы поговорили о том, зачем вообще нужен еще один язык, Андрей рассказал про историю и предпосылки появления Kotlin, как все начиналось и развивалось.</p>
<p>Обсудили так же общие теоретические аспекты разработки языков программирования: чем разработка языка отличается от разработки каких-либо других программных продуктов, какие компоненты являются основой для построения языка, на какие аспекты следует обращать особое внимание и как правильно заложить архитектуру.</p>
<p>Так же Андрей рассказал, почему в качестве платформы была выбрана JVM, рассказал некоторые технические подробности реализации проекта. Подробно рассказал про interop с Java, о том, как можно начать использовать Kotlin в уже существующем проекте на Java сейчас, и как они у себя, в компании JetBrains уже начали это делать.</p>
<p>Не обошли мы сторой и социальную составляющую проекта. Код языка Kotlin выложен в open source на github. Андрей рассказал про сообщество, которое сформировалось вокруг проекта, и как они с ним взаимодействуют, обсуждают запросы на новый функционал, баг-репорты и все прочее.</p>
<p>В завершение выпуска, Андрей поделился планами по развитию языка как в ближайшем будущем, так и в долгосрочной перспективе.</p>
<p>Ссылки на ресурсы по темам выпуска:</p>
<ul>
<li>
<p>Андрей в соц сетях:</p>
<ul>
<li><a href="https://twitter.com/abreslav">Twitter</a></li>
<li><a href="https://fb.com/abreslav">Facebook</a></li>
<li><a href="https://vk.com/abreslav">ВКонтакте</a></li>
<li><a href="https://www.linkedin.com/in/abreslav">LinkedIn</a></li>
</ul>
</li>
<li><a href="https://kotlinlang.org/">Основной сайт проекта kotlinlang.org</a></li>
<li><a href="https://github.com/JetBrains/kotlin">Репозиторий на github</a></li>
<li><a href="http://blog.jetbrains.com/kotlin/2016/02/kotlin-1-0-released-pragmatic-language-for-jvm-and-android/">Пост в блоге проекта о релизе 1.0</a></li>
<li>
<p>Несколько видео докладов про Kotlin Андрея Бреслава и Дмитрия Жемерова:</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=HWyd1gYMkl0">Что такое Kotlin? Введение</a></li>
<li><a href="https://www.youtube.com/watch?v=LWFx4QWrTyo">Kotlin: самое сложное — совместимость</a></li>
<li><a href="https://www.youtube.com/watch?v=VU_L2_XGQ9s">Kotlin для Android: коротко и ясно</a></li>
<li><a href="https://www.youtube.com/watch?v=YOmdOTlhZa8">Kotlin: сессия вопросов и ответов со встречи JUG.ru 04.03.2016</a></li>
</ul>
</li>
</ul>
]]></description><link>https://sdcast.ksdaemon.ru/2016/03/sdcast-41/</link><guid isPermaLink="true">https://sdcast.ksdaemon.ru/2016/03/sdcast-41/</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Podcast]]></category><dc:creator><![CDATA[Андрей Бреслав, Константин Буркалев]]></dc:creator><pubDate>Fri, 11 Mar 2016 21:54:00 GMT</pubDate><enclosure url="https://sdcast.ksdaemon.ru/podlove/file/159/s/download/SDCast-41.ogg" length="22683272" type="audio/ogg"/></item><item><title><![CDATA[Why I don't want to use Kotlin for Android Development yet]]></title><description><![CDATA[<p>Even though Kotlin is better than Java in many points it still has significant (in my opinion) drawbacks.</p>
<blockquote>
<p>Please treat it as personal opinion &#x26; comment if you have solutions for problems listed below.</p>
</blockquote>
<h6>1) Slow compilation</h6>
<p>Small project (~100 classes in total, mostly in Kotlin) takes ~1 minute to assemble. This is simply unacceptable. <a href="https://youtrack.jetbrains.com/issue/KT-6246">https://youtrack.jetbrains.com/issue/KT-6246</a></p>
<h6>2) Performance of Kotlin plugin for IDEA</h6>
<p>Syntax analysis and highlighting of Kotlin in IDEA (Android Studio) pretty often freezes development machine during typing, unacceptable.</p>
<h6>3) Problems with annotation processing</h6>
<p>Sometimes it gives random errors and you have to do <code>clean</code>. Almost every day I see complaints about that on different resources. I'm not alone.</p>
<h6>4) Mocking Kotlin classes with Mockito is painful</h6>
<p>Almost everything is <code>final</code> in Kotlin by default: classes, methods, etc. And I really like it because it forces immutability -> less bugs. But at the same time, it makes mocking via <code>Mockito</code> (which is kind of gold standard in JVM world) painful and goes contrary with language design.</p>
<p>Yes, PowerMock is possible solution, but it interferes with tools like Robolectric and generally it was always a good rule that you should not mock final classes and final method.</p>
<p>I understand that in Java we have that problem of everything non-final by design, but at the same time <strong>I don't want to change code just for testing.</strong></p>
<h6>5) No static analyzers for Kotlin yet</h6>
<p>Yes, <code>kotlinc</code> adds more safety to the code than <code>javac</code>, but if you want to achieve good performance of the compiler you don't want to turn it into static analyzer.</p>
<p>Static code analysis is good for CI, but probably you don't want to run it every time you click on <code>run</code> button in IDE during local development.</p>
<p>Java has: FindBugs, PMD, Checkstyle, Sonarqube, Error Prone, FB infer.</p>
<p>Kotlin has: <code>kotlinc</code>.</p>
<blockquote>
<p>Points above were objective, I hope. Points below are more subjective and personal.</p>
</blockquote>
<h6>6) <code>==</code> does <code>equals()</code> instead of reference comparison</h6>
<p>If Kotlin is "better" Java or "Java on steroids" then it should be <em>better</em>, but not <em>breaking</em>.</p>
<p>Imagine you're in the process of rewriting Java project to Kotlin, you will have Java and Kotlin code at the same time.</p>
<p>You'll have to read and write <em>same</em> code that works differently from language to language. This is one of the reasons why I don't like Groovy.</p>
<h6>7) In bad hands operators overloading may lead to bad results</h6>
<p>Statement 1: you will need to deal with old codebase written in Kotlin in future.
Statement 2: you can add operators overloading to <strong>existing</strong> java classes via extension functions.</p>
<p>Now imagine you see something like <code>val person3 = person1 + person2</code> in already written code you need to deal with.</p>
<p>Every project you'll work on may have its own meaning of operators for same classes 😿</p>
<p>Operators overloading is controversial, these links may help you decide (not all of them end with same conclusion):</p>
<ul>
<li><a href="http://cafe.elharo.com/programming/operator-overloading-considered-harmful/">Operator Overloading Considered Harmful</a></li>
<li><a href="http://james-iry.blogspot.ru/2009/03/operator-overloading-ad-absurdum.html">Operator Overloading Ad Absurdum</a></li>
<li><a href="http://blog.jooq.org/2014/02/10/why-everyone-hates-operator-overloading/">Why Everyone Hates Operator Overloading</a></li>
</ul>
<hr>
<p><a href="https://twitter.com/artem_zin">@artem_zin</a></p>
]]></description><link>http://artemzin.com/blog/why-i-dont-want-to-use-kotlin-for-android-development-yet/</link><guid isPermaLink="true">http://artemzin.com/blog/why-i-dont-want-to-use-kotlin-for-android-development-yet/</guid><category><![CDATA[Android]]></category><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Artem Zinnatullin]]></dc:creator><pubDate>Fri, 11 Mar 2016 19:58:00 GMT</pubDate></item><item><title><![CDATA[Getting Started with Kotlin and Anko on Android]]></title><description><![CDATA[<p>by <a href="https://twitter.com/donnfelker">Donn Felker</a></p>
<h3>Getting Started With Kotlin and Anko on Android</h3>
<p>I’m just going to say it like it is ...</p>
<blockquote>
<p>Android is stuck in Java 6 purgatory.</p>
</blockquote>
<p><img src="http://cl.ly/2q0e3B3l202Z/1__adb.png" alt="ADB Hell"></p>
<p>When I first started developing for Android, I was coming out of working very heavily with C# for a few years. I came over to find a lack of proper generics support (when compared to Java generics), no lambda expressions, and an awkward syntax for common things that I felt should just be in the language. 8 years later, I’m still stuck writing super-verbose Java 6. Java 8 has been out for a while now, and it would be great to use some of those features without having to resort to bytecode weaving! (That said, I am very thankful for <a href="https://github.com/orfjackal/retrolambda">retrolambda</a>.) Unfortunately, who knows if or when Java 8 support will ever arrive.</p>
<p>Thankfully, there seems to be a new hope for Android development: <a href="https://kotlinlang.org">Kotlin</a>.</p>
<p><img src="http://cl.ly/0q2n240R3I3N/kotlin-logo.png" alt="Kotlin Logo"></p>
<p>Kotlin is a new JVM-compatible language from JetBrains that you can use to write Android applications. If you haven’t been exposed to the language, I highly recommend that you watch <a href="https://realm.io/news/droidcon-michael-pardo-kotlin/">Michael Pardo’s talk on Kotlin</a> from <a href="http://droidcon.nyc">Droidcon NYC</a>. Furthermore, the layout view for a portion of the application will be created with <a href="https://github.com/Kotlin/anko">Anko</a>, a DSL (Domain-Specific Language) for Android which is written in Kotlin. You can get a basic understanding of Anko <a href="https://github.com/Kotlin/anko">here</a>.</p>
<p>Kotlin, as a language, is a breath of fresh air compared to Java 6. Once you get used to the syntax, you will notice that it is much more succinct than its Java 6 counterpart. Since Kotlin is JVM-compatible, it will compile down to JVM bytecode that is understood by Android.</p>
<p><em><strong>Important</strong>: This article will assume that you have a basic understanding of Kotlin and Anko.</em></p>
<h3>Using Kotlin in an Android project</h3>
<p>As with anything new, you’d probably like to try out Kotlin but you don’t want to commit an entire project to it just yet. With Kotlin and Android Studio, you can have both Java and Kotlin sitting side by side in your application. I recommend taking a screen, a feature, or a simple custom widget, and writing it in Kotlin to see how it feels. Integrating Kotlin into your codebase slowly allows you to give the language a test run and allows you to keep existing application code untouched.</p>
<p>Thankfully it’s quite easily to integrate Kotlin into an existing Android application with the free Kotlin plugin for Android Studio. To get started, you’ll need to install the plugin. Open Android Studio and select <code>Configure > Plugins</code>. If the screen below is not visible, close all your projects and <code>Welcome to Android Studio</code> window will present itself.</p>
<p><img src="http://f.cl.ly/items/0h2Q0f0I3g471m3j190s/Screen%20Shot%202016-03-01%20at%2010.45.09%20AM.png" alt="Configure Plugin"></p>
<p>Then select <code>Install JetBrains Plugin</code> as shown below.</p>
<p><img src="http://cl.ly/312E3M123n2L/3_1_16__10_46_AM.png" alt="Install Plugin"></p>
<p>Now search for <code>Kotlin</code> and install the <code>Kotlin</code> plugin as shown below. The main Kotlin plugin includes the Android extensions.</p>
<p><img src="http://cl.ly/2I1k3H0X2i0o/Untitled-1___100___Layer_1__RGB_8____.png"></p>
<p>You’re now ready to start building your first feature with Kotlin!</p>
<h3>The Application</h3>
<p>The application that I’m going to be working with is a simple to-do list application. The main screen has a list of to-dos that looks like this:</p>
<p><img src="http://cl.ly/2t15210V3r3l/3_1_16__11_05_AM.png" alt="Example Screenshot"></p>
<p>To add a to-do, users tap on the FAB (Floating Action Button). To edit a to-do, they tap on the to-do itself. This will load the add/edit screen. The add/edit screen is what I will write in Kotlin and Anko.</p>
<h3>What is Anko?</h3>
<p><a href="https://github.com/Kotlin/anko">Anko</a> is a DSL (Domain-Specific Language) for Android written in Kotlin. Traditionally, Android views are expressed as XML layouts. This XML is usually duplicated in various parts of your application and is not re-used (sometimes it is, with includes). At runtime, the XML is then transformed into the Java representation of the view which wastes CPU and battery. Anko allows you to write this view in Kotlin, in an Activity or Fragment (or even as an <a href="https://github.com/Kotlin/anko#ankocomponent">AnkoComponent</a>, an external Kotlin file that represents the view).</p>
<p>Here’s an example of a simple XML file that is transformed to Anko.</p>
<p><strong>XML</strong></p>
<pre><code class="hljs language-xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">LinearLayout</span>
    <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>
    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"match_parent"</span>
    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span>></span>

    <span class="hljs-tag">&#x3C;<span class="hljs-name">EditText</span>
        <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/todo_title"</span>
        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span>
        <span class="hljs-attr">android:layout_heigh</span>=<span class="hljs-string">"wrap_content"</span>
        <span class="hljs-attr">android:hint</span>=<span class="hljs-string">"@string/title_hint"</span> /></span>

    <span class="hljs-comment">&#x3C;!-- Cannot directly add an inline click listener as onClick delegates implementation to the activity --></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">Button</span>
        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span>
        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span>
        <span class="hljs-attr">android:text</span>=<span class="hljs-string">"@string/add_todo"</span> /></span>

<span class="hljs-tag">&#x3C;/<span class="hljs-name">LinearLayout</span>></span></code></pre>
<p><strong>The same view expressed in Anko</strong></p>
<pre><code class="hljs language-kotlin">verticalLayout {
    <span class="hljs-keyword">var</span> title = editText {
        id = R.id.todo_title
        hintResource = R.string.title_hint
    }
    button {
        textResource = R.string.add_todo
        onClick { view -> {
                <span class="hljs-comment">// do something here</span>
                title.text = <span class="hljs-string">"Foo"</span>
            }
        }
    }
}</code></pre>
<p>Notice the inline click listener in the layout definition above. Since this is Kotlin, you can also access other view members, such as <code>title</code> and use them in the click listener.</p>
<h3>Getting Started</h3>
<p>Using this <a href="https://github.com/donnfelker/KotlinMix/archive/fresh.zip">starter app</a> you can start with a blank slate. (Final code is available <a href="https://github.com/donnfelker/KotlinMix/">here</a>). This app has the following:</p>
<ul>
<li>An Activity (<code>MainActivity</code>) that acts as a simple controller of the application.</li>
<li>A <a href="https://github.com/thorbenprimke/realm-recyclerview">RecyclerView</a> to show the to-dos on the first screen (TodosFragment)</li>
<li>A Realm database to store the to-dos</li>
<li>A <code>Todo.java</code> Realm model</li>
<li>An adapter for the RecyclerView</li>
</ul>
<p>You will now build the add/edit screen using Kotlin and Anko.</p>
<h3>Set Up Your Application for Kotlin and Anko</h3>
<p>Now that you have the Kotlin extension installed, you’ll want to configure your application using the <code>Configure Kotlin in Project</code> action. In Android Studio, press <code>CMD+SHIFT+A</code> to open the action finder window. Type in <code>Kotlin</code> and select <code>Configure Kotlin in Project</code> action as shown below:</p>
<p><img src="http://cl.ly/2f023X2q1r2r/Screenshot_3_1_16__11_57_AM.png" alt="Actions"></p>
<p>After this runs, your <code>build.gradle</code> file will have been updated with <code>kotlin-android</code> applied at the top of the file, a Kotlin <code>sourceSet</code> added, and Kotlin added to your dependencies.</p>
<p>During this time you’ll also want to add Anko to your dependencies. Your <code>build.gradle</code> file should look similar to this:</p>
<pre><code class="hljs language-groovy">apply <span class="hljs-string">plugin:</span> <span class="hljs-string">'com.android.application'</span>
apply <span class="hljs-string">plugin:</span> <span class="hljs-string">'kotlin-android'</span>

android {
    compileSdkVersion <span class="hljs-number">23</span>
    buildToolsVersion <span class="hljs-string">"23.0.2"</span>

    defaultConfig {
        applicationId <span class="hljs-string">"com.donnfelker.kotlinmix"</span>
        minSdkVersion <span class="hljs-number">16</span>
        targetSdkVersion <span class="hljs-number">23</span>
        versionCode <span class="hljs-number">1</span>
        versionName <span class="hljs-string">"1.0"</span>
    }
    buildTypes {
        release {
            minifyEnabled <span class="hljs-literal">false</span>
        }
    }
    packagingOptions {
        exclude <span class="hljs-string">'META-INF/services/javax.annotation.processing.Processor'</span>
    }
    sourceSets {
        main.java.srcDirs += <span class="hljs-string">'src/main/kotlin'</span>
    }
}

dependencies {
    compile fileTree(<span class="hljs-string">dir:</span> <span class="hljs-string">'libs'</span>, <span class="hljs-string">include:</span> [<span class="hljs-string">'*.jar'</span>])
    testCompile <span class="hljs-string">'junit:junit:4.12'</span>

    <span class="hljs-comment">// Kotlin</span>
    compile <span class="hljs-string">"org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version"</span>

    <span class="hljs-comment">// Anko</span>
    compile <span class="hljs-string">'org.jetbrains.anko:anko-sdk15:0.8.2'</span> <span class="hljs-comment">// sdk19, sdk21, sdk23 are also available</span>
    compile <span class="hljs-string">'org.jetbrains.anko:anko-support-v4:0.8.2'</span> <span class="hljs-comment">// In case you need support-v4 bindings</span>
    compile <span class="hljs-string">'org.jetbrains.anko:anko-appcompat-v7:0.8.2'</span> <span class="hljs-comment">// For appcompat-v7 bindings</span>

    compile <span class="hljs-string">'com.android.support:appcompat-v7:23.1.1'</span>
    compile <span class="hljs-string">'com.android.support:design:23.1.1'</span>
    compile <span class="hljs-string">'io.realm:realm-android:0.87.1'</span>
    compile <span class="hljs-string">'com.github.thorbenprimke:realm-recyclerview:0.9.12'</span>
    compile <span class="hljs-string">'com.jakewharton:butterknife:7.0.1'</span>
    compile <span class="hljs-string">'com.android.support:support-v4:23.1.1'</span>
}
buildscript {
    ext.kotlin_version = <span class="hljs-string">'1.0.0'</span>
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath <span class="hljs-string">"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"</span>
    }
}
repositories {
    mavenCentral()
}</code></pre>
<p>You’re now ready to start creating the add/edit to-do screen.</p>
<h3>Adding a Fragment with Kotlin</h3>
<p>If the <code>src/main/kotlin/com.donnfelker.kotlinmix/</code> directory does not exist, create it. You’ll notice that the <code>kotlin</code> folder turns blue indicating that this is a source folder.</p>
<p>Right-click on the <code>/src/main/kotlin/com.donnfelker.kotlinmix/</code> folder, select <code>New > Kotlin File/Class</code>, and give it the name <code>EditFragment</code>. The new file is created and only contains a package declaration.</p>
<p>Copy the code below and past it into the <code>EditFragment</code> file.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">package</span> com.donnfelker.kotlinmix

<span class="hljs-keyword">import</span> android.os.Bundle
<span class="hljs-keyword">import</span> android.support.v4.app.Fragment
<span class="hljs-keyword">import</span> android.view.LayoutInflater
<span class="hljs-keyword">import</span> android.view.View
<span class="hljs-keyword">import</span> android.view.ViewGroup
<span class="hljs-keyword">import</span> android.widget.Button
<span class="hljs-keyword">import</span> android.widget.EditText
<span class="hljs-keyword">import</span> com.donnfelker.kotlinmix.models.Todo
<span class="hljs-keyword">import</span> io.realm.Realm
<span class="hljs-keyword">import</span> org.jetbrains.anko.*
<span class="hljs-keyword">import</span> org.jetbrains.anko.support.v4.UI
<span class="hljs-keyword">import</span> org.jetbrains.anko.support.v4.find
<span class="hljs-keyword">import</span> java.util.*

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EditFragment</span> : <span class="hljs-type">Fragment</span></span>() {

    <span class="hljs-keyword">val</span> TODO_ID_KEY: String = <span class="hljs-string">"todo_id_key"</span>

    <span class="hljs-keyword">val</span> realm: Realm = Realm.getDefaultInstance()

    <span class="hljs-keyword">var</span> todo: Todo? = <span class="hljs-literal">null</span>

    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> {
        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">newInstance</span><span class="hljs-params">(id: <span class="hljs-type">String</span>)</span></span>: EditFragment {
            <span class="hljs-keyword">var</span> args: Bundle = Bundle()
            args.putString(<span class="hljs-string">"todo_id_key"</span>, id)
            <span class="hljs-keyword">var</span> editFragment: EditFragment = newInstance()
            editFragment.arguments = args
            <span class="hljs-keyword">return</span> editFragment
        }

        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">newInstance</span><span class="hljs-params">()</span></span>: EditFragment {
            <span class="hljs-keyword">return</span> EditFragment()
        }
    }

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onActivityCreated</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> {
        <span class="hljs-keyword">super</span>.onActivityCreated(savedInstanceState)

        <span class="hljs-keyword">if</span>(arguments != <span class="hljs-literal">null</span> &#x26;&#x26; arguments.containsKey(TODO_ID_KEY)) {
            <span class="hljs-keyword">val</span> todoId = arguments.getString(TODO_ID_KEY)
            todo = realm.where(Todo::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>).<span class="hljs-title">equalTo</span></span>(<span class="hljs-string">"id"</span>, todoId).findFirst()
            <span class="hljs-keyword">val</span> todoTitle = find&#x3C;EditText>(R.id.todo_title)
            todoTitle.setText(todo?.title)
            <span class="hljs-keyword">val</span> todoDesc = find&#x3C;EditText>(R.id.todo_desc)
            todoDesc.setText(todo?.description)
            <span class="hljs-keyword">val</span> add = find&#x3C;Button>(R.id.todo_add)
            add.setText(R.string.save)
        }
    }

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">super</span>.onDestroy()
        realm.close()
    }

    <span class="hljs-comment">/**
     *  A private function to create a TODO item in the database (Realm).
     *
     *  <span class="hljs-doctag">@param</span> title the title edit text.
     *  <span class="hljs-doctag">@param</span> desc the description edit text.
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createTodoFrom</span><span class="hljs-params">(title: <span class="hljs-type">EditText</span>, desc: <span class="hljs-type">EditText</span>)</span></span> {
        realm.beginTransaction()

        <span class="hljs-comment">// Either update the edited object or create a new one.</span>
        <span class="hljs-keyword">var</span> t = todo?: realm.createObject(Todo::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>)</span>
        t.id = todo?.id?: UUID.randomUUID().toString()
        t.title = title.text.toString()
        t.description = desc.text.toString()
        realm.commitTransaction()

        <span class="hljs-comment">// Go back to previous activity</span>
        activity.supportFragmentManager.popBackStack();
    }

}</code></pre>
<p>The example above has a few methods: <code>newInstance</code>, <code>onActivityCreated</code>, <code>onDestroy</code>, and <code>createTodoFrom</code>. <code>createTodoFrom</code> accepts two <code>EditText</code> widgets as parameters, which are used to either create a new <code>Todo</code> or to update an existing one, all in a single line of code.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">var</span> t = todo?: realm.createObject(Todo::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>)</span></code></pre>
<p>This will check to see if the field-level <code>todo</code> value is null. If it is, then it will create a new <code>Todo</code> instance. If it is not null, it will use that local field instance. The field instance is instantiated in the <code>onActivityCreated</code> method near the top of the file.</p>
<p>In <code>onActivityCreated</code>, the arguments of the fragment are checked. If they’re not null, the id of the <code>Todo</code> is pulled from the intent extras and the <code>Todo</code> object is obtained from Realm. The <code>todo</code> field is now instantiated, indicating that the <code>Todo</code> object is being edited. The views are updated with the corresponding values at that point.</p>
<h3>Adding the View with Anko</h3>
<p>You’ve probably noticed that there is no view present in the Fragment. To add a view, copy and paste this code into the fragment:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreateView</span><span class="hljs-params">(inflater: <span class="hljs-type">LayoutInflater</span>?, container: <span class="hljs-type">ViewGroup</span>?, savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span>: View? {
    <span class="hljs-keyword">return</span> UI {
        verticalLayout {
            padding = dip(<span class="hljs-number">30</span>)
            <span class="hljs-keyword">var</span> title = editText {
                id = R.id.todo_title
                hintResource = R.string.title_hint
            }

            <span class="hljs-keyword">var</span> desc = editText {
                id = R.id.todo_desc
                hintResource = R.string.description_hint
            }
            button {
                id = R.id.todo_add
                textResource = R.string.add_todo
                onClick { view -> createTodoFrom(title, desc) }
            }
        }
    }.view
}</code></pre>
<p>This Anko code creates a LinearLayout with a vertical orientation (<code>verticalLayout</code>). Inside of the <code>verticalLayout</code> block, three Android widgets are created - two <code>editText</code> views and one <code>button</code> view. The view attributes are set in line. There is something interesting happening in the widget declaration of the button. The button has a click listener set in the view declaration. The method <code>createTodoFrom</code> is called with the <code>title</code> and <code>desc</code> variables that are declared prior to the button. Finally, the view is returned by calling the <code>view</code> property on the AnkoContext (<code>UI</code> class).</p>
<p>The <code>id</code>s are set with <code>R.id.&#x3C;id_name></code>. These <code>id</code>s had to be created manually in a file named <code>ids.xml</code> located in <code>app/src/main/res/values/ids.xml</code>. Create this file if it does not exist. The contents of this file are as follows:</p>
<pre><code class="hljs language-xml"><span class="php"><span class="hljs-meta">&#x3C;?</span>xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"utf-8"</span><span class="hljs-meta">?></span></span>
<span class="hljs-tag">&#x3C;<span class="hljs-name">resources</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"todo_title"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"id"</span> /></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"todo_desc"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"id"</span> /></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"todo_add"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"id"</span> /></span>
<span class="hljs-tag">&#x3C;/<span class="hljs-name">resources</span>></span></code></pre>
<p>This <code>ids.xml</code> file declares <code>id</code>s that can be used in an Android application for various view <code>id</code>s.</p>
<h3>Java and Kotlin Commingling</h3>
<p>At this point, the view can now be shown on the screen. The only thing left is to show the Fragment when a user taps on an item.</p>
<p>Open the <code>TodosFragment</code> and add the following code to the <code>onTodoClick</code> method:</p>
<pre><code class="hljs language-java">EditFragment editFragment = EditFragment.Companion.newInstance(task.getId());
        getActivity().getSupportFragmentManager()
                .beginTransaction()
                .replace(R.id.content_main, editFragment, editFragment.getClass().getSimpleName())
                .addToBackStack(editFragment.getClass().getSimpleName())
                .commit();</code></pre>
<p>The <code>EditFragment</code> is written in pure Kotlin, yet it can be called from Android code as a regular Java object very easily.</p>
<p>Notice the <code>EditFragment.Companion.newInstance</code> call? This is necessary because Kotlin does not have static methods. Therefore, a <a href="https://kotlinlang.org/docs/reference/classes.html#companion-objects">companion object</a> is necessary to accomplish a similar feat in Kotlin.</p>
<p>Finally, you’ll need to wire up the FAB to start the fragment. In the FAB’s click listener, in the <code>MainActivity</code>, you’ll need to add the following code:</p>
<pre><code class="hljs language-java">EditFragment editFragment = EditFragment.Companion.newInstance();
getSupportFragmentManager()
    .beginTransaction()
    .replace(R.id.content_main, editFragment, editFragment.getClass().getSimpleName())
    .addToBackStack(editFragment.getClass().getSimpleName())
    .commit();</code></pre>
<p>Build and install the application and tap the FAB. This starts the Kotlin part of the application. Add a to-do and tap <code>Add</code>. Back on the list of to-dos, tap a to-do so you can edit it. The button text in the Kotlin <code>EditFagment</code> will change to ‘save’. Update the to-do and tap save.</p>
<p><img src="https://dl.dropboxusercontent.com/u/888640/Realm/kotlin-mix-example.gif" alt="Example"></p>
<h3>Congratulations, you’ve now mixed Java and Kotlin together! 👏</h3>
<p>You’ve built a feature with Kotlin while the rest of your application remains functional with typical Java that is used in Android. You can continue on your path of Kotlin development or only bring it in where you find it useful.</p>
<p>You can also continue to use Anko as your view mechanism for Kotlin. If you prefer XML, you can still use XML layouts. For example, you can replace the above <code>onCreateView</code> method called with the following:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreateView</span><span class="hljs-params">(inflater: <span class="hljs-type">LayoutInflater</span>?, container: <span class="hljs-type">ViewGroup</span>?, savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span>: View? {
    <span class="hljs-keyword">return</span> inflater?.inflate(R.layout.your_layout, container, <span class="hljs-literal">false</span>)
}</code></pre>
<p>This gives you the flexibility to work with Kotlin with or without Anko.</p>
<p>Best of luck on your Kotlin adventures!</p>
<h3>Sample Code</h3>
<ul>
<li><a href="https://github.com/donnfelker/KotlinMix/archive/fresh.zip">Starter Project</a></li>
<li><a href="https://github.com/donnfelker/KotlinMix/">Finished Code For This Article</a></li>
</ul>
]]></description><link>https://realm.io/news/getting-started-with-kotlin-and-anko/</link><guid isPermaLink="true">https://realm.io/news/getting-started-with-kotlin-and-anko/</guid><category><![CDATA[Android]]></category><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Donn Felker]]></dc:creator><pubDate>Wed, 09 Mar 2016 15:44:00 GMT</pubDate></item><item><title><![CDATA[(RU) Дмитрий Полищук - Kotlin + Android: практический ликбез]]></title><description><![CDATA[<iframe width="960" height="480" src="https://www.youtube.com/embed/2oVpnArCdWI" frameborder="0" allowfullscreen></iframe>
]]></description><link>https://www.youtube.com/watch?v=2oVpnArCdWI</link><guid isPermaLink="true">https://www.youtube.com/watch?v=2oVpnArCdWI</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Android]]></category><dc:creator><![CDATA[Дмитрий Полищук]]></dc:creator><pubDate>Wed, 09 Mar 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[A DSL Workbench with Gradle and Kotlin]]></title><description><![CDATA[<p>Easy to use. This is one of a main tasks to solve then new tool is created. For the world of DSL this
mostly mean it should be easy to a end-user to use the tool and to be able to run the tool within
a continuous integration build easily.</p>
<p>I found an elegant way to fiddle a DSL tasks into Gradle to make it easy to use. Next I'll cover an example
of <a href="https://github.com/jonnyzzz/TeamCity2DSL">TeamCity2DSL</a> where I implemented this approach.</p>
<h2>Domain description</h2>
<p>I will not cover the domain where <a href="https://github.com/jonnyzzz/TeamCity2DSL">TeamCity2DSL</a> is
applied. This deserves a dedicated post(s) (link will be included here).
All we need to know about TeamCity2DSL here are</p>
<ul>
<li>it provides a way to describe build settings with <a href="https://kotlinlang.org/">Kotlin</a> DSL</li>
<li>the DSL is executed to generate XML settings that TeamCity understands</li>
<li>it also generates DSL from existing XML settings from TeamCity</li>
</ul>
<p>Here goes tricks one need to handle to use the TeamCity2DSL</p>
<ul>
<li>download TeamCity2DSL classes</li>
<li>have Kotlin sources with DSL complied</li>
<li>allow an IDE to be used to author/edit DSL code</li>
</ul>
<p>This is vital to provide as easy as possible way to run those tasks. This is where our Gradle plugin is used.</p>
<h2>TeamCity2DSL Gradle Plugin</h2>
<p>The plugin does the following set of tricks</p>
<ul>
<li>it setups project repositories and dependencies</li>
<li>setups dependency on Kotlin runtime and compiler</li>
<li>declares <code>dsl2xml</code> and <code>xml2dsl</code> tasks</li>
<li>adds DSL generation output folder as Kotlin sources</li>
<li>introduces a dependency on compilation from <code>dsl2xml</code> task</li>
</ul>
<h2>A Gradle Plugin Usage Example</h2>
<p>This is <code>build.gradle</code> script that is only required to have both TeamCity2DSL tasks (<code>dsl2xml</code> and <code>xml2dsl</code>) supported</p>
<pre><code class="hljs language-groovy">buildscript {
  repositories {
    jcenter()
    mavenCentral()
    maven { url <span class="hljs-string">"http://dl.bintray.com/jonnyzzz/maven"</span> }
  }

  dependencies {
    classpath <span class="hljs-string">'org.jonnyzzz.teamcity.dsl:gradle-plugin:&#x3C;PLUGIN VERSION>'</span>
  }
}

apply <span class="hljs-string">plugin:</span> <span class="hljs-string">'org.jonnyzzz.teamcity.dsl'</span></code></pre>
<p><em>NOTE</em>. Replace <code>&#x3C;PLUGIN VERSION></code> with the latest version
from the <a href="https://bintray.com/jonnyzzz/maven/teamcity2dsl/view">maven repository</a>
<em>NOTE2</em>. We also assume
<a href="https://confluence.jetbrains.com/display/TCD10/Storing+Project+Settings+in+Version+Control">TeamCity project settings XML files</a>
are located in a <code>.teamcity</code> folder.</p>
<h2>IDE Usages</h2>
<p>The project opens in IntelliJ IDEA. It detects all dependencies, Kotlin, source roots, library sources, etc.
No specific requirements here. It <em>Just Works</em>. And again an easy-to-use pattern is implemented.</p>
<h1>Implementation Details</h1>
<p>I use <a href="https://kotlinlang.org/">Kotlin</a> in <a href="https://github.com/jonnyzzz/TeamCity2DSL">TeamCity2DSL</a>.
The Gradle plugin is implemented with Kotlin as well.</p>
<p>The first trick is the plugin itself declares a dependency on
<a href="https://kotlinlang.org/docs/reference/using-gradle.html">Kotlin Gradle plugin</a>. The version of Kotlin
is selected from plugin dependency. This allows to avoid
explicit configuration for Kotlin.</p>
<pre><code class="hljs language-groovy">project.apply { config ->
  config.plugin(<span class="hljs-string">"java"</span>)
  config.plugin(<span class="hljs-string">"kotlin"</span>)
}</code></pre>
<p>The plugin includes DSL dependencies to itself into <code>compile</code> configuration. Those jars are predefined and
we make Gradle download them from Maven repository.</p>
<pre><code class="hljs language-groovy">val dsl2xml = project.tasks.create(<span class="hljs-string">"dsl2xml"</span>, <span class="hljs-string">Dsl2Xml:</span>:<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>)
<span class="hljs-title">dsl2xml</span>.<span class="hljs-title">dependsOn</span>(<span class="hljs-title">project</span>.<span class="hljs-title">tasks</span>.<span class="hljs-title">getByName</span>("<span class="hljs-title">classes</span>"))</span></code></pre>
<p>Next, we include all <code>buildScript</code> block repositories into code repositories. This helps to avoid
duplicates in repositories declaration.</p>
<pre><code class="hljs language-groovy">project.buildscript.repositories.forEach { project.repositories.add(it) }</code></pre>
<p>To add extra source directory we use the following code (that depends on Gradle's Java plugin)</p>
<pre><code class="hljs language-groovy">println(<span class="hljs-string">"Adding DSL path to Kotlin source set: ${settings.dslPath}"</span>)
val sourceSets = project.convention.getPlugin(<span class="hljs-string">JavaPluginConvention:</span>:<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>).<span class="hljs-title">sourceSets</span>

<span class="hljs-title">println</span>("<span class="hljs-title">Source</span> <span class="hljs-title">sets</span>: ${</span>sourceSets.names}<span class="hljs-string">")
sourceSets.getByName("</span>main<span class="hljs-string">").java.srcDir( settings.dslPath!!.path )</span></code></pre>
<p>We know Kotlin plugin checks Java output path for kotlin sources too. So we depend here only on Java plugin,
not on a private API of the Kotlin plugin.</p>
<p>The task implementation uses a custom classloader (with <code>null</code> parent) to avoid bothering Gradle's tasks
execution classpath. This is too complicated, from the other hand, to synchronize dependencies
of TeamCity2DSL and Gradle. In the future we may consider running an external processes for better stability.</p>
<h1>Finally</h1>
<p>We created a Gradle plugin that helps to use a Kotlin DSL.</p>
<p>Everything that is related to the setup and execution of tasks is now packed as a Gradle Plugin
leading to easy-to-use and easy-to-adopt solution.</p>
<p>This pattern could be re-used for other applications.</p>
<p>Feel free to try <a href="https://github.com/jonnyzzz/TeamCity2DSL">TeamCity2DSL</a> for TeamCity project settings domain.</p>
]]></description><link>http://jonnyzzz.com/blog/2016/03/08/gradle-for-dsl/</link><guid isPermaLink="true">http://jonnyzzz.com/blog/2016/03/08/gradle-for-dsl/</guid><category><![CDATA[Gradle]]></category><category><![CDATA[DSL]]></category><category><![CDATA[Teamcity2DSL]]></category><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Eugene Petrenko]]></dc:creator><pubDate>Tue, 08 Mar 2016 21:02:00 GMT</pubDate></item><item><title><![CDATA[Kotlin & Android: A Brass Tacks Experiment, Part 6]]></title><description><![CDATA[<p><img src="https://d262ilb51hltx0.cloudfront.net/max/1600/1*UN-S8ELMC2kpHf4tJKfbLQ.png"></p>
<p><em>Disclaimer: I am a Google employee, but the views expressed in this article are not those of my employer.</em></p>
<h3>Kotlin &#x26; Android: A Brass Tacks Experiment, Part 6</h3>
<p>Alright! We’re nearing the end of this series about experimenting with Kotlin to make view creation easier during Android app development. (Please <a href="https://medium.com/p/kotlin-android-a-brass-tacks-experiment-part-1-3e5028491bcc">jump back to the beginning</a> if you landed here prematurely.) So far we’ve learned a bunch of features of the Kotlin® language that help implement the type-safe builder pattern, including:</p>
<ul>
<li>Lambda with receiver &#x26; reified types (<a href="https://medium.com/p/kotlin-android-a-brass-tacks-experiment-part-2-c67661cfdf5f">part 2</a>)</li>
<li>Extension functions (<a href="https://medium.com/p/kotlin-android-a-brass-tacks-experiment-part-4-4b7b501fa457">part 4</a>)</li>
<li>Extension properties (<a href="https://medium.com/p/kotlin-android-a-brass-tacks-experiment-part-5-bd79eb9c85d4">part 5</a>)</li>
</ul>
<p>These have all been instrumental in creating a “domain specific language” for expressing the programmatic creation of view hierarchies in a declarative fashion. For example, using all these techniques combined, we can write this to create two TextViews stacked on top of each other with some padding:</p>
<pre><code class="hljs language-kotlin">v&#x3C;LinearLayout> {
    layoutParams = LayoutParams(MATCH_PARENT, WRAP_CONTENT)
    orientation = VERTICAL
    padLeft = dp_i(<span class="hljs-number">16</span>f)

    v&#x3C;TextView> {
        layoutParams = LayoutParams(WRAP_CONTENT, WRAP_CONTENT)
        text = <span class="hljs-string">"Hello"</span>
    }
    v&#x3C;TextView> {
        layoutParams = LayoutParams(WRAP_CONTENT, WRAP_CONTENT)
        text = <span class="hljs-string">"World"</span>
    }
}</code></pre>
<p>This is pretty good on its own, and it definitely beats writing out all these view creations and associations traditionally. Now, to wrap up the coding part of this experiment, let’s do a couple more things to tighten up the syntax <em>even more!</em></p>
<p><strong>How do we assign values to specialized layout parameter properties?</strong></p>
<p>It’s not immediately evident from the code above, but there is a problem if you want to assign some attributes of the layout parameters specific to LinearLayout. Up until now we have only specified the height and width of a view using the <a href="http://developer.android.com/reference/android/widget/LinearLayout.LayoutParams.html">LinearLayout.LayoutParams</a> class constructor, and assigned that new object to the layoutParams synthetic property of a view. But what if we also wanted to assign values to the “gravity” property of the layout parameters? It might make sense to try it like this:</p>
<pre><code class="hljs language-kotlin">layoutParams = LinearLayout.LayoutParams(WRAP_CONTENT, WRAP_CONTENT)
layoutParams.gravity = Gravity.CENTER  <span class="hljs-comment">// oops, compiler says no</span></code></pre>
<p>But the compiler won’t allow that because the layoutParams property of View is of type ViewGroup.LayoutParams, the superclass of all other LayoutParams. In order to use layoutParams as a LinearLayout.LayoutParams, it will need to be downcast.</p>
<p>Instead of casting and assigning to another value as you would in the Java® language, we can use a Kotlin stdlib function called “<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/with.html">with</a>” to make it easier to deal with layoutParams. The “with” function takes an object parameter along with lambda with receiver and executes that lambda against the given object. This description may not sound interesting, but it allows a syntax like this:</p>
<pre><code class="hljs language-kotlin">v&#x3C;TextView> {
    with(layoutParams <span class="hljs-keyword">as</span> LinearLayout.LayoutParams) {
        width = WRAP_CONTENT
        height = WRAP_CONTENT
        gravity = CENTER
    }
    text = <span class="hljs-string">"Hello"</span>
}</code></pre>
<p>Notice how we’re able to simultaneously cast layoutParams to LinearLayout.LayoutParams, then use that as the receiver inside the lambda for abbreviated access to its properties.</p>
<p>Another subtle thing to be aware of here is that an Android view container will automatically create and assign a correctly typed layout parameter object to layoutParams when a child view is added to it. In our case, adding a TextView child to a LinearLayout will <em>automatically</em> create and assign a LinearLayout.LayoutParams to the TextView’s layoutParams property. This means we don’t actually need to create a new LayoutParams object — we can just access the one that’s already provided by the parent LinearLayout. Please remember that this only happens when adding a child view to a parent ViewGroup. The outermost ViewGroup will not have layout parameters assigned automatically because it’s not yet attached to its own parent!</p>
<p>All that said, this is not exactly the <em>most</em> desirable syntax for layout parameters, but it’s the most straightforward way I could find to specify specialized layout parameters inside the lambdas we have for creating views.</p>
<p><strong>And now, for my last trick, I’ll make the “v” functions disappear!</strong></p>
<p>The “v” functions we’ve been using so far are pretty convenient, but what if we want to further shortcut their syntax? It would be even more convenient to take the layout from above and pattern it like this:</p>
<pre><code class="hljs language-kotlin">linearLayout {
    textView {
        <span class="hljs-comment">// properties...</span>
    }
    textView {
        <span class="hljs-comment">// properties...</span>
    }
}</code></pre>
<p>This looks even more natural, and makes for easy reading. It also looks very similar to the Android Gradle configuration language. The trick to getting a syntax like this is to effectively create a sort of alias for each type of view we want to use. So, to create a structure like above, we need a function called “linearLayout” that works like “v<LinearLayout>” and a function called “textView” that works like “v<TextView>”. Kotlin makes this pretty easy to set up:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> ViewGroup.<span class="hljs-title">linearLayout</span><span class="hljs-params">(init: <span class="hljs-type">LinearLayout</span>.()</span></span> -> <span class="hljs-built_in">Unit</span>) = v(init)
<span class="hljs-function"><span class="hljs-keyword">fun</span> Context.<span class="hljs-title">linearLayout</span><span class="hljs-params">(init: <span class="hljs-type">LinearLayout</span>.()</span></span> -> <span class="hljs-built_in">Unit</span>) = v(init)

<span class="hljs-function"><span class="hljs-keyword">fun</span> ViewGroup.<span class="hljs-title">textView</span><span class="hljs-params">(init: <span class="hljs-type">TextView</span>.()</span></span> -> <span class="hljs-built_in">Unit</span>) = v(init)
<span class="hljs-function"><span class="hljs-keyword">fun</span> Context.<span class="hljs-title">textView</span><span class="hljs-params">(init: <span class="hljs-type">TextView</span>.()</span></span> -> <span class="hljs-built_in">Unit</span>) = v(init)</code></pre>
<p>Here, I defined two functions for each type of view in order to account for the different v functions that could be invoked, depending on the starting point of a Context or a ViewGroup parent. The Kotlin language feature that makes these declarations possible is called <em>single expression function</em>. This is a special syntax for functions that allows you to:</p>
<ol>
<li>Omit the usual curly braces for the function body.</li>
<li>Infer the return type based on the return type of the expression.</li>
<li>Omit the return keyword.</li>
</ol>
<p>Now, let’s use these convenience functions to recreate the view hierarchy from the beginning of this article:</p>
<pre><code class="hljs language-kotlin">linearLayout {
    layoutParams = LayoutParams(MATCH_PARENT, WRAP_CONTENT)
    orientation = VERTICAL
    padLeft = dp_i(<span class="hljs-number">16</span>f)

    textView {
        layoutParams = LayoutParams(WRAP_CONTENT, WRAP_CONTENT)
        text = <span class="hljs-string">"Hello"</span>
    }
    textView {
        layoutParams = LayoutParams(WRAP_CONTENT, WRAP_CONTENT)
        text = <span class="hljs-string">"World"</span>
    }
}</code></pre>
<p>Wow, we’ve come a long way since our humble beginnings in part 2! (As long as you’re willing to define alias functions for each type of view you want to build.)</p>
<p><strong>But the novelty of this technique is not all that novel after all!</strong></p>
<p>Some readers of this series have pointed out that this method using the type-safe builder pattern for building view hierarchies is really close to that of a project called <a href="https://github.com/Kotlin/anko">Anko</a>. I actually set out on this series without having any knowledge of it, and it wasn’t until I was finished with the first two parts of this series that one of my colleagues pointed this out to me. Anko provides a more comprehensive solution for building views than what I’ve been experimenting with here. Even after seeing it, I was still pretty interested in going through the process of discovering Kotlin language features and how they could be applied to Android development. If you’ve been following this series, I hope you’ve also enjoyed discovering these things!</p>
<p><strong>So, are we really any better off with this technique?</strong></p>
<p>You might be wondering now if it’s better in general to create your Android views programmatically like this in Kotlin than the traditional XML layout resources. Up till now, it certainly seems like a big win to use Kotlin in this way. So, for the next part in this series, I’ll compare the two techniques with each other to see how they compare to each other. Also, I’ll provide a sample project that you can use to easily compare equivalent implementations.</p>
<p>Don’t forget that you can follow me <a href="https://medium.com/@CodingDoug">here on Medium</a> to get <a href="https://medium.com/p/kotlin-android-a-brass-tacks-experiment-wrap-up-2b37e3ac8957">the next part to this series</a> (in addition to future blogs and series!). And for even faster updates, <a href="https://twitter.com/CodingDoug">follow me on Twitter</a>!</p>
]]></description><link>https://medium.com/@CodingDoug/kotlin-android-a-brass-tacks-experiment-part-6-49fea0ed3a7#.53axmkcxt</link><guid isPermaLink="true">https://medium.com/@CodingDoug/kotlin-android-a-brass-tacks-experiment-part-6-49fea0ed3a7#.53axmkcxt</guid><category><![CDATA[Android]]></category><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Doug Stevenson]]></dc:creator><pubDate>Tue, 08 Mar 2016 20:57:00 GMT</pubDate></item><item><title><![CDATA[Solving the Josephus problem in Kotlin]]></title><description><![CDATA[<p>I recently stumbled upon a <a href="http://www.danvk.org/josephus.html">post</a> telling about the <a href="https://en.wikipedia.org/wiki/Josephus_problem">Josephus problem</a> and trying to solve it in different scripting languages. For the sake of brevity, here’s the problem (taken from the referenced post):</p>
<blockquote>
<p>Flavius Josephus was a roman historian of Jewish origin. During the Jewish-Roman wars of the first century AD, he was in a cave with fellow soldiers, 40 men in all, surrounded by enemy Roman troops. They decided to commit suicide by standing in a ring and counting off each third man. Each man so designated was to commit suicide...Josephus, not wanting to die, managed to place himself in the position of the last survivor.</p>
</blockquote>
<blockquote>
<p>In the general version of the problem, there are n soldiers numbered from 1 to n and each k-th soldier will be eliminated. The count starts from the first soldier. What is the number of the last survivor?</p>
</blockquote>
<p>It seemed like a good challenge to test my building Kotlin skills. Here’s the solution I’ve come up with. First, the test class, using TestNG and a data provider – it’s the perfect use-case:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JosephusTest</span> </span>{

    <span class="hljs-meta">@DataProvider</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">data</span><span class="hljs-params">()</span></span>: Array&#x3C;Array&#x3C;<span class="hljs-built_in">Int</span>>> {
        <span class="hljs-keyword">return</span> arrayOf(
                arrayOf(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>),
                arrayOf(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>),
                arrayOf(<span class="hljs-number">10</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>),
                arrayOf(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>),
                arrayOf(<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)
        )
    }

    <span class="hljs-meta">@Test(dataProvider = <span class="hljs-meta-string">"data"</span>)</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">circle_of_size_and_step_should_survive_position</span><span class="hljs-params">(size: <span class="hljs-type">Int</span>, step: <span class="hljs-type">Int</span>, expectedPosition: <span class="hljs-type">Int</span>)</span></span> {
        <span class="hljs-keyword">val</span> circle = Circle(size, step)
        <span class="hljs-keyword">val</span> survivor = circle.findSurvivor()
        assertEquals(survivor.position, expectedPosition)
    }
}</code></pre>
<p>Now, the code:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Soldier</span></span>(<span class="hljs-keyword">val</span> position: <span class="hljs-built_in">Int</span>) {
    <span class="hljs-keyword">var</span> state = State.Living
    lateinit <span class="hljs-keyword">var</span> next: Soldier
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">suicide</span><span class="hljs-params">()</span></span> {
        state = State.Dead
    }
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isDead</span><span class="hljs-params">()</span></span> = state == State.Dead
}

<span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">State</span> </span>{
    Living, Dead
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span></span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> size: <span class="hljs-built_in">Int</span>, <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> step: <span class="hljs-built_in">Int</span>) {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> first = Soldier(<span class="hljs-number">0</span>)

    init {
        <span class="hljs-keyword">var</span> person = first
        <span class="hljs-keyword">while</span> (person.position &#x3C; size - <span class="hljs-number">1</span>) {
            person = createNext(person)
        }
        <span class="hljs-keyword">val</span> last = person
        last.next = first
    }

    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createNext</span><span class="hljs-params">(soldier: <span class="hljs-type">Soldier</span>)</span></span>: Soldier {
        <span class="hljs-keyword">val</span> new = Soldier(soldier.position + <span class="hljs-number">1</span>)
        soldier.next = new
        <span class="hljs-keyword">return</span> new
    }

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">findSurvivor</span><span class="hljs-params">()</span></span>: Soldier {
        <span class="hljs-keyword">var</span> soldier: Soldier = first
        <span class="hljs-keyword">var</span> numberOfDead = <span class="hljs-number">0</span>
        <span class="hljs-keyword">while</span> (numberOfDead &#x3C; size - <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">var</span> count: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span>
            <span class="hljs-keyword">while</span> (count &#x3C; step) {
                soldier = nextLivingSoldier(soldier)
                count++
            }
            soldier.suicide()
            numberOfDead++
        }
        <span class="hljs-keyword">return</span> nextLivingSoldier(soldier)
    }

    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">nextLivingSoldier</span><span class="hljs-params">(soldier: <span class="hljs-type">Soldier</span>)</span></span>: Soldier {
        <span class="hljs-keyword">var</span> currentSoldier = soldier.next
        <span class="hljs-keyword">while</span> (currentSoldier.isDead()) {
            currentSoldier = currentSoldier.next
        }
        <span class="hljs-keyword">return</span> currentSoldier
    }
}</code></pre>
<p>This code works fine and the tests are successful.</p>
<p>However, while trying to code the solution, I realized that there were no data-structure implementing circular linked lists neither in Java nor in Kotlin. I had thus to implement my own circular data-structure, but without implementing common collection features.</p>
<p>Now, my problem with the above code is that while the <code>Soldier</code> class looks fine by me, the <code>Circle</code> class doesn’t. There are too many vars in <code>Circle</code> and it feels too much like imperative programming. The lack of <code>for(;;)</code> in Kotlin forces me to use a <code>while</code> with an outside variable – twice: <code>count</code> and <code>numberOfDead</code>.</p>
<p>I’ve been thinking that I could improve the situation by changing the data-structure. I just don’t know how... Now, Kotlin and FP gurus, do you have any proposal?</p>
]]></description><link>https://blog.frankel.ch/solving-the-josephus-problem-in-kotlin</link><guid isPermaLink="true">https://blog.frankel.ch/solving-the-josephus-problem-in-kotlin</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Nicolas Franke]]></dc:creator><pubDate>Sun, 06 Mar 2016 16:00:00 GMT</pubDate></item><item><title><![CDATA[Kotlin Month Post 2: Inheritance and Defaults]]></title><description><![CDATA[<h2>Intro</h2>
<p>Continuing on with <a href="https://programmingideaswithjake.wordpress.com/kotlin/#kotlinmonth">Kotlin Month</a>, this week, I’ll be discussing topics in Kotlin that have to do with inheritance and default values.</p>
<h2>Composition Over Inheritance</h2>
<p>Kotlin has put in a feature and a couple defaults that help developers keep the principle of Composition Over Inheritance at the forefront of their mind. The first of these is a feature that lets you composition almost as easily as inheritance when it comes to defining wrapper classes.</p>
<h2>First-Class Delegation</h2>
<p>Kotlin provides first-class access to delegation with very little help from you, the developer. All that needs to be done is:</p>
<ol>
<li>The new class inherits from an interface</li>
<li>The new class provides a primary constructor that defines a property that inherits from the same interface</li>
<li>After declaring the inheritance of the interface, include “by &#x3C;name of property>”</li>
</ol>
<p>For example:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">A</span> </span>{
   <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Unit</span>
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> </span>(<span class="hljs-keyword">val</span> a: A) : A <span class="hljs-keyword">by</span> a</code></pre>
<p>In this example, we have interface <code>A</code>, which has a <code>doSomething()</code> method to be implemented. Class <code>B</code> is our delegator class. It inherits from <code>A</code>, includes a primary constructor with a property called <code>a</code> that inherits from <code>A</code> (<code>(val a: A)</code>), and says to delegate to <code>a</code> with <code>A by a</code>.</p>
<p>Now <code>B</code> doesn’t need to explicitly implement any of the methods from <code>A</code> because they’re implicitly provided via delegation, just like it would with normal inheritance if <code>B</code> was inheriting from a fully implemented class. In this case, instead of just pointing to its parent class implementation, it gets a default implementation as if <code>B</code> had been defined like this:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> </span>(<span class="hljs-keyword">val</span> a: A) A {
   <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span> {
      a.doSomething()
   }
}</code></pre>
<p>The delegation can be done for multiple interfaces at a time, too.</p>
<p>I created a <a href="https://programmingideaswithjake.wordpress.com/2015/05/23/python-decorator-for-simplifying-delegate-pattern/">class decorator in Python</a> that did something like this a while back, since I liked this idea so much.</p>
<p>Kotlin practically needed something like this in the language to go along with a certain set of defaults...</p>
<h2>Final By Default</h2>
<p>Classes and public methods are <code>final</code> by default in Kotlin, meaning they can not be inherited from or overridden, respectively. In order to make those options available, classes and methods must be marked as <code>open</code>.</p>
<p>This goes along with item 17 in Effective Java, namely “Design and document for inheritance or else prohibit it”, just as this entire item lines up with item 16 in Effective Java, “Favor Composition Over Inheritance”.</p>
<p>These two pieces work together quite nicely and will hopefully mean that code written in Kotlin will be of better quality because of it.</p>
<p>Many people are against the decision of final by default, but they largely seem to not realize that C# has had the same thing all along (without first-class delegation, I might add), and I haven’t heard any complaints from their side. I would venture to guess that most of the people that argue this point also don’t have a mindset of preferring composition. Obviously, there are some cases where this may backfire (especially if a library doesn’t provide an interface for a certain class you want to extend), but this should hopefully prevent more problems than it makes.</p>
<h2>Visibility Modifier Defaults</h2>
<p>What is the most commonly typed word in all of Java? I would venture to guess that it’s <code>public</code>, with <code>return</code> and <code>import</code> in a close second place. For the most part, that <code>public</code> keyword is clutter; most things are public, and it should probably be the default. Kotlin decided to do just that, making the code cleaner.</p>
<p>Now, this does go against the general advice for encapsulation for making members of a class as private as possible, but even when this advice is followed pretty well, <code>public</code> is still the most common visibility modifier. So, thankfully, <code>public</code> is the default in Kotlin.</p>
<h2>Sealed Classes</h2>
<p>Sealed Classes are a more interesting than useful feature, in my opinion. They provide a way to lock in a hierarchy so that the only subclasses of the sealed class are those defined within its borders. This is really handy for the split-type monads (such as Either and Maybe/Optional) and, judging by the example used in the documents, expression trees.</p>
<p>Again, Kotlin has an additional feature that plays well with this feature, and that’s the when expression, which is a reimagined <code>switch</code>. The <code>when</code> expression is made aware by the compiler to know whether all of the subclasses are presented so that it doesn’t force you to needlessly provide a default <code>else</code> clause.</p>
<p>Again, I find this feature more interesting than useful, especially since I worked out a (slightly more painful) way to largely recreate the same thing in Java (with an additional idea or two running through my head). If you’re curious how I do it, leave a comment letting me know, and I’ll do a post about it.</p>
<h1>Extension Methods</h1>
<p>Extension methods are methods that you can “add onto a class” after the fact. I use quotes because they’re not actually added to the class (at least not in Kotlin); rather, they are a static methods that can be used as if they’re methods on an instance, allowing you to import those methods to be used only in certain instances and to discover them with autocompletion. But mostly it’s a syntax that makes static methods look less stupid.</p>
<p>Why are these not more of a thing in the programming world? All those <code>String</code> and <code>Date</code> utility classes would be so much easier to use if they could be used as extensions to the actual class. Other than C#, I don’t know of any other languages that do this (understandably, dynamic languages don’t actually need anything special for this feature, since you can literally add any method to a class any time you want). If you know of any, I’d appreciate it if you listed them in the comments.</p>
<p>Another awesome thing about extension methods is how Kotlin combines them with lambdas to make extension lambdas, which make certain things like <a href="https://kotlinlang.org/docs/reference/type-safe-builders.html">their</a> <a href="https://programmingideaswithjake.wordpress.com/2016/01/16/mimicking-kotlin-builders-in-java-and-python/">type-safe</a> <a href="https://programmingideaswithjake.wordpress.com/2016/01/23/kotlin-like-builders-in-java-and-python-continued-additional-parameters/">builders</a> so much cleaner.</p>
<h2>Outro</h2>
<p>That’s the end of <em>this</em> article. Tune in next week for the third post of <a href="https://programmingideaswithjake.wordpress.com/kotlin/#kotlinmonth">Kotlin Month!</a> That one will go over the safety features that Kotlin has, such as null safety and improved generics.</p>
]]></description><link>https://programmingideaswithjake.wordpress.com/2016/03/05/kotlin-month-post-2-inheritance-and-defaults/</link><guid isPermaLink="true">https://programmingideaswithjake.wordpress.com/2016/03/05/kotlin-month-post-2-inheritance-and-defaults/</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Jacob Zimmerman]]></dc:creator><pubDate>Sat, 05 Mar 2016 06:00:00 GMT</pubDate></item><item><title><![CDATA[Building a Kotlin project 2/2]]></title><description><![CDATA[<h6><em>Part 2</em></h6>
<p>In the previous <a href="http://www.cirorizzo.net/building-a-kotlin-project/">post</a> we started a new project from scratch, and adjusted the <code>build.gradle</code> for the Kitten App purpose.</p>
<p>The next steps are going to be the programming of the elements of the app.</p>
<h4>Data Model</h4>
<p>One of the main features of the app is to retrieve data through Internet via the <code>http://thecatapi.com/</code></p>
<blockquote>
<p><em>The complete API call will be i.e. <code>http://thecatapi.com/api/images/get?format=xml&#x26;results_per_page=10</code></em></p>
</blockquote>
<p>The API sends back an <code>XML</code> file like this one</p>
<p><img src="http://cirorizzo.net/content/images/2016/03/xxmlAPI.png.pagespeed.ic.CABTBWB1Ch.png" alt="XML-API"></p>
<p>It needs to deserialize in order to get the <code>url</code> property containing the location of the Kitten image.</p>
<p>Kotlin has a very useful class called <code>data class</code> that is perfect for the purpose.</p>
<p>Let's starting to create a new class file in the <code>model.cats</code> package using right click on it and <code>New->Kotlin File/Class</code> and call it <code>Cats</code> and choose <code>Class</code> as kind.</p>
<p>In order to structure the class as the <code>XML</code> file received the <code>Cats.kt</code> will be as the following</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cats</span></span>(<span class="hljs-keyword">var</span> <span class="hljs-keyword">data</span>: Data? = <span class="hljs-literal">null</span>)

<span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Data</span></span>(<span class="hljs-keyword">var</span> images: ArrayList&#x3C;Image>? = <span class="hljs-literal">null</span>)

<span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Image</span></span>(<span class="hljs-keyword">var</span> url: String? = <span class="hljs-string">""</span>, <span class="hljs-keyword">var</span> id: String? = <span class="hljs-string">""</span>, <span class="hljs-keyword">var</span> source_url: String? = <span class="hljs-string">""</span>)</code></pre>
<p>So far very simple...
The same class in Java is much longer!</p>
<p>The Kotlin Data Class has several benefits, some of them are that the compiler generates <code>getter()</code>, <code>setter()</code> and <code>toString()</code> methods, and many more like <code>equals()</code> <code>hashCode()</code> and <code>copy()</code>. So it's the perfect class to use to deserialize data</p>
<h4>API Call</h4>
<p>There are many ways to retrieve data through the network, and different libraries to handle it. One of these libraries is the <a href="http://square.github.io/retrofit/">Retrofit2</a> library from Square.
This is a very powerful <code>HTTPClient</code> and easy to set up.</p>
<p>Let's start with the <code>interface</code> and create it under the <code>network</code> package.
Call it <code>CatAPI</code> as shown</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CatAPI</span> </span>{
    <span class="hljs-meta">@GET(<span class="hljs-meta-string">"/api/images/get?format=xml&#x26;results_per_page="</span> + BuildConfig.MAX_IMAGES_PER_REQUEST)</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getCatImageURLs</span><span class="hljs-params">()</span></span>: Observable&#x3C;Cats>
}</code></pre>
<p>The <code>interface</code> will manage the <code>Get</code> request to the API Endpoint <code>/api/images/get?format=xml&#x26;results_per_page=</code>.
In this case the param <code>results_per_page</code> retrieve its numerical value from the constant defined in the <code>build.gradle</code> called <code>MAX_IMAGES_PER_REQUEST</code> that will have different values depending on the <code>buildTypes</code> used.</p>
<pre><code class="hljs language-kotlin">buildTypes {
    debug {
        buildConfigField(<span class="hljs-string">"int"</span>, <span class="hljs-string">"MAX_IMAGES_PER_REQUEST"</span>, <span class="hljs-string">"10"</span>)
        ...</code></pre>
<blockquote>
<p>This method is very useful to have different value of constants in case we're using <code>debug</code> type or <code>release</code> one i.e. <em>especially in case you need to access to the debug API instead of the production one</em></p>
</blockquote>
<p>About the <code>interface CatAPI</code> is very interesting the function called to manage the callback from the API <code>fun getCatImageURLs(): Observable&#x3C;Cats></code></p>
<p>So the next step is its implementation.
Let's create a new class under the same package (<code>network</code>) and call it <code>CatAPINetwork</code> as this</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CatAPINetwork</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getExec</span><span class="hljs-params">()</span></span>: Observable&#x3C;Cats> {
        <span class="hljs-keyword">val</span> retrofit = Retrofit.Builder()
            .baseUrl(<span class="hljs-string">"http://thecatapi.com"</span>)
            .addConverterFactory(SimpleXmlConverterFactory.create())
            .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
            .build()

        <span class="hljs-keyword">val</span> catAPI: CatAPI = retrofit.create(CatAPI::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>)</span>

        <span class="hljs-keyword">return</span> catAPI.getCatImageURLs().
            subscribeOn(Schedulers.io()).
            observeOn(AndroidSchedulers.mainThread())
    }
}</code></pre>
<p>The <code>fun getExec(): Observable&#x3C;Cats></code> is implicitly <code>public</code> so that means available to be called by outside this class.</p>
<p>The line <code>.addConverterFactory(SimpleXmlConverterFactory.create())</code> indicates to use the <code>XML</code> converter to deserialize the result form the API call.</p>
<p>Then the <code>.addCallAdapterFactory(RxJavaCallAdapterFactory.create())</code> is the call adapter to use on the API Callback</p>
<p>The <code>return</code> lines referring to the <code>RxJava</code> <code>Observable</code></p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">return</span> catAPI.getCatImageURLs().
            subscribeOn(Schedulers.io()).
            observeOn(AndroidSchedulers.mainThread())</code></pre>
<h4>Presenter</h4>
<p>The <code>Presenter</code> modules are in charge of managing the logic of the app and to bind data between the <code>View</code> and the <code>Model</code>.</p>
<p>In our case it will implement the method called by the <code>View</code> to retrieve the API data and send them to the <code>Adapter</code> in charge to show up.</p>
<p>In order to communicate with the <code>View</code> we're starting to create its <code>interface</code> called <code>MasterPresenter</code> under the package <code>presenter</code> as the followed</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MasterPresenter</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">connect</span><span class="hljs-params">(imagesAdapter: <span class="hljs-type">ImagesAdapter</span>)</span></span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getMasterRequest</span><span class="hljs-params">()</span></span>
}</code></pre>
<p>The first function <code>fun connect(imagesAdapter: ImagesAdapter)</code> will be used to connect the <code>Adapter interface</code> to show data, and the <code>fun getMasterRequest()</code> will be the one to start the API request.</p>
<p>Let's the implementations in a new class under the same <code>presenter</code> package and call it <code>MasterPresenterImpl</code></p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MasterPresenterImpl</span> : <span class="hljs-type">MasterPresenter {</span></span>
    lateinit <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> imagesAdapter: ImagesAdapter

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">connect</span><span class="hljs-params">(imagesAdapter: <span class="hljs-type">ImagesAdapter</span>)</span></span> {
        <span class="hljs-keyword">this</span>.imagesAdapter = imagesAdapter
    }

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getMasterRequest</span><span class="hljs-params">()</span></span> {
        imagesAdapter.setObservable(getObservableMasterRequest(CatAPINetwork()))
    }

    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getObservableMasterRequest</span><span class="hljs-params">(catAPINetwork: <span class="hljs-type">CatAPINetwork</span>)</span></span>: Observable&#x3C;Cats> {
        <span class="hljs-keyword">return</span> catAPINetwork.getExec()
    }
}</code></pre>
<p>Interesting line at <code>lateinit private var imagesAdapter: ImagesAdapter</code> where Kotlin give us the chance to declare a Non-Nullable mutable object without initialization thanks to <code>lateinit</code> keyword. So it will be initialize at the first time it will be used at runtime; in our case on calling the <code>fun connect(imagesAdapter: ImagesAdapter)</code>.</p>
<p>The function <code>fun getMasterRequest()</code> is in charge of starting the API call, just set the <code>Observable</code> in order to be subscribed by the <code>Adapter</code> (i.e. <code>imagesAdapter</code>) after starts the <code>catAPINetwork.getExec()</code> that executes the API call</p>
<h4>View section</h4>
<p>In the <code>view</code> package are collected the classes to manage the UI.
Basically are the <code>View</code> and the <code>Adapter</code> ones; in our case <code>MainActivity</code> and <code>ImagesAdapter</code>.</p>
<h6>Layouts</h6>
<p>Before starting with their implementation, let's go through the <code>Layout</code> designing.</p>
<p><img src="http://cirorizzo.net/content/images/2016/03/xkittenApp-1.png.pagespeed.ic.ulo4yWl6Cg.png" alt="Kitten App"> To design it we need basically of two elements the <mark>main container</mark> and the <mark>item container</mark>.</p>
<p>The <mark>main container</mark> is the element containing the list of the item and we're going to place it in the <code>activity_main.xml</code> contained in the <code>res->layout</code> folder of the project; this one has been automatically created during the initial phase of <a href="http://www.cirorizzo.net/building-a-kotlin-project/">Project Creation</a>.</p>
<p>For our app we need to inject in a <code>RecyclerView</code> component (a very powerful and optimized component for listing views).</p>
<p>The <code>activity_main.xml</code> will be like shown</p>
<pre><code class="hljs language-xml"><span class="php"><span class="hljs-meta">&#x3C;?</span>xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"utf-8"</span><span class="hljs-meta">?></span></span>
<span class="hljs-tag">&#x3C;<span class="hljs-name">RelativeLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>
    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">"http://schemas.android.com/tools"</span>
    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"wrap_content"</span>
    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span>
    <span class="hljs-attr">tools:context</span>=<span class="hljs-string">".view.MainActivity"</span>
    <span class="hljs-attr">android:gravity</span>=<span class="hljs-string">"center"</span>></span>

    <span class="hljs-tag">&#x3C;<span class="hljs-name">android.support.v7.widget.RecyclerView</span>
        <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/containerRecyclerView"</span>
        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"wrap_content"</span>
        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span>
        <span class="hljs-attr">android:scrollbars</span>=<span class="hljs-string">"vertical"</span>
        <span class="hljs-attr">android:layout_centerInParent</span>=<span class="hljs-string">"true"</span> /></span>
<span class="hljs-tag">&#x3C;/<span class="hljs-name">RelativeLayout</span>></span></code></pre>
<p>The component <code>containerRecyclerView</code> represents the <mark>main container</mark> of the list of item</p>
<p>The <code>row_card_view.xml</code> is the <mark>item container</mark> of our list and basically it appears like this</p>
<pre><code class="hljs language-xml"><span class="php"><span class="hljs-meta">&#x3C;?</span>xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"utf-8"</span><span class="hljs-meta">?></span></span>
<span class="hljs-tag">&#x3C;<span class="hljs-name">android.support.v7.widget.CardView</span>
    <span class="hljs-attr">xmlns:card_view</span>=<span class="hljs-string">"http://schemas.android.com/apk/res-auto"</span>
    <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>
    <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/card_view"</span>
    <span class="hljs-attr">android:layout_gravity</span>=<span class="hljs-string">"center"</span>
    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"wrap_content"</span>
    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span>
    <span class="hljs-attr">card_view:cardCornerRadius</span>=<span class="hljs-string">"4dp"</span>
    <span class="hljs-attr">android:layout_margin</span>=<span class="hljs-string">"16dp"</span>
    <span class="hljs-attr">android:background</span>=<span class="hljs-string">"@android:color/transparent"</span>
    <span class="hljs-attr">android:layout_centerInParent</span>=<span class="hljs-string">"true"</span>
    <span class="hljs-attr">android:elevation</span>=<span class="hljs-string">"4dp"</span>></span>

    <span class="hljs-tag">&#x3C;<span class="hljs-name">RelativeLayout</span>
        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"wrap_content"</span>
        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span>
        <span class="hljs-attr">android:layout_centerInParent</span>=<span class="hljs-string">"true"</span>
        <span class="hljs-attr">android:gravity</span>=<span class="hljs-string">"center"</span>
        <span class="hljs-attr">android:foregroundGravity</span>=<span class="hljs-string">"center"</span>></span>

        <span class="hljs-tag">&#x3C;<span class="hljs-name">ImageView</span>
            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"wrap_content"</span>
            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span>
            <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/imgVw_cat"</span>
            <span class="hljs-attr">android:padding</span>=<span class="hljs-string">"4dp"</span>
            <span class="hljs-attr">android:layout_centerInParent</span>=<span class="hljs-string">"true"</span>
            <span class="hljs-attr">android:scaleType</span>=<span class="hljs-string">"fitCenter"</span>
            <span class="hljs-attr">android:contentDescription</span>=<span class="hljs-string">"@string/cat_image"</span> /></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">RelativeLayout</span>></span>
<span class="hljs-tag">&#x3C;/<span class="hljs-name">android.support.v7.widget.CardView</span>></span></code></pre>
<p>As you can see the item container is the <code>card_view</code> that basically is composed by a <code>RelativeLayout</code> containing an <code>ImageView</code> (<code>imgVw_cat</code>)</p>
<h6>Adapter</h6>
<p>Now we've got basic elements of the <code>Layout</code>, so let's move on implementing the <code>MainActivity</code> and the <code>Adapter</code>.</p>
<p>Starting on <code>Adapter</code> the first thing to create is its <code>interface</code> in order to be invoked by the previous <code>MasterPresenterImpl</code> so let's create a new file in the <code>view</code> package and called it <code>ImagesAdapter</code> and write it down like this</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ImagesAdapter</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setObservable</span><span class="hljs-params">(observableCats: <span class="hljs-type">Observable</span>&#x3C;<span class="hljs-type">Cats</span>>)</span></span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">unsubscribe</span><span class="hljs-params">()</span></span>
}</code></pre>
<p>The function <code>setObservable(observableCats: Observable&#x3C;Cats>)</code> is called by <code>MasterPresenterImpl</code> to set the <code>Observable</code> and give the <code>Adapter</code> to subscribe to it.</p>
<p>The <code>unsubscribe()</code> function will be invoked by the <code>MainActivity</code> to unsubscribe the <code>Adapter</code> from the <code>Observable</code> when the activity is destroyed.</p>
<p>Now let's implement them in a new class under the same package called <code>ImagesAdapterImpl</code> that appears like that</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ImagesAdapterImpl</span> : <span class="hljs-type">RecyclerView.Adapter</span>&#x3C;<span class="hljs-type">ImagesAdapterImpl.ImagesURLsDataHolder</span>></span>(), ImagesAdapter {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> TAG = ImagesAdapterImpl::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>.<span class="hljs-title">simpleName</span></span>

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> cats: Cats? = <span class="hljs-literal">null</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> subscriber: Subscriber&#x3C;Cats> <span class="hljs-keyword">by</span> lazy { getSubscribe() }

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreateViewHolder</span><span class="hljs-params">(parent: <span class="hljs-type">ViewGroup</span>, viewType: <span class="hljs-type">Int</span>)</span></span>: ImagesURLsDataHolder {
        <span class="hljs-keyword">return</span> ImagesURLsDataHolder(
                LayoutInflater.from(parent.context).inflate(R.layout.row_card_view, parent, <span class="hljs-literal">false</span>))
    }

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getItemCount</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span> {
        <span class="hljs-keyword">return</span> cats?.<span class="hljs-keyword">data</span>?.images?.size ?: <span class="hljs-number">0</span>
    }

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onBindViewHolder</span><span class="hljs-params">(holder: <span class="hljs-type">ImagesURLsDataHolder</span>, position: <span class="hljs-type">Int</span>)</span></span> {
        holder.bindImages(cats?.<span class="hljs-keyword">data</span>?.images?.<span class="hljs-keyword">get</span>(position)?.url ?: <span class="hljs-string">""</span>)
    }

    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setData</span><span class="hljs-params">(cats: <span class="hljs-type">Cats</span>?)</span></span> {
        <span class="hljs-keyword">this</span>.cats = cats
    }

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setObservable</span><span class="hljs-params">(observableCats: <span class="hljs-type">Observable</span>&#x3C;<span class="hljs-type">Cats</span>>)</span></span> {
        observableCats.subscribe(subscriber)
    }

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">unsubscribe</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">if</span> (!subscriber.isUnsubscribed) {
            subscriber.unsubscribe()
        }
    }

    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getSubscribe</span><span class="hljs-params">()</span></span>: Subscriber&#x3C;Cats> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">object</span> : Subscriber&#x3C;Cats>() {
            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">()</span></span> {
                Log.d(TAG, <span class="hljs-string">"onCompleted"</span>)
                notifyDataSetChanged()
            }

            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onNext</span><span class="hljs-params">(cats: <span class="hljs-type">Cats</span>)</span></span> {
                Log.d(TAG, <span class="hljs-string">"onNextNew"</span>)
                setData(cats)
            }

            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onError</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span> {
                <span class="hljs-comment">//TODO : Handle error here</span>
                Log.d(TAG, <span class="hljs-string">""</span> + e.message)
            }
        }
    }

    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ImagesURLsDataHolder</span></span>(view: View) : RecyclerView.ViewHolder(view) {

        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bindImages</span><span class="hljs-params">(imgURL: <span class="hljs-type">String</span>)</span></span> {
            Glide.with(itemView.context).
                    load(imgURL).
                    placeholder(R.mipmap.document_image_cancel).
                    diskCacheStrategy(DiskCacheStrategy.ALL).
                    centerCrop().
                    into(itemView.imgVw_cat)
        }
    }
}</code></pre>
<p>This is the class inflate the <code>row_card_view.xml</code>, basically the <mark>item container</mark> as you can see at function <code>onCreateViewHolder</code></p>
<p>The function <code>getSubscribe()</code> provide to subscribe the <code>Adapter</code> to the <code>Observable</code> used at line <code>private val subscriber: Subscriber&#x3C;Cats> by lazy { getSubscribe() }</code> where you can notice the <code>lazy</code> initialization, this is a way to declare an unmutable object (i.e. <code>subscriber</code>) and it'll be created through the function enclosed in the braces (i.e. <code>getSubscribe()</code>) at the first invocation at runtime.</p>
<blockquote>
<p><em>The Subscriber and Observable concepts comes from <a href="https://github.com/ReactiveX/RxJava">RxJava</a>; We can dig deeper in some next posts</em></p>
</blockquote>
<p>At the end, a very interesting piece of code is the inner class called <code>ImagesURLsDataHolder</code> used to fill up the <code>imgVw_cat</code> using the <code>Glide</code> library, that helps to retrieve the image from the passed <code>URL</code> extracted by the API call. This part is wrapped in the function <code>bindImages(imgURL: String)</code> and invoked by the method <code>onBindViewHolder</code> in the same file.</p>
<h6>Activity</h6>
<p>Last but not least the the <code>Activity</code> (i.e. <code>MainActivity</code>)</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span></span>() {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> imagesAdapterImpl: ImagesAdapterImpl <span class="hljs-keyword">by</span> lazy { ImagesAdapterImpl() }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> masterPresenterImpl: MasterPresenterImpl
            <span class="hljs-keyword">by</span> lazy {
                MasterPresenterImpl()
            }

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> {
        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        initRecyclerView()
        connectingToMasterPresenter()
        getURLs()
    }

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span></span> {
        imagesAdapterImpl.unsubscribe()
        <span class="hljs-keyword">super</span>.onDestroy()
    }

    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">initRecyclerView</span><span class="hljs-params">()</span></span> {
        containerRecyclerView.layoutManager = GridLayoutManager(<span class="hljs-keyword">this</span>, <span class="hljs-number">1</span>)
        containerRecyclerView.adapter = imagesAdapterImpl
    }

    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">connectingToMasterPresenter</span><span class="hljs-params">()</span></span> {
        masterPresenterImpl.connect(imagesAdapterImpl)
    }

    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getURLs</span><span class="hljs-params">()</span></span> {
        masterPresenterImpl.getMasterRequest()
    }
}</code></pre>
<p>Notice the functions</p>
<ul>
<li><code>initRecyclerView()</code></li>
<li><code>connectingToMasterPresenter()</code></li>
<li><code>getURLs()</code></li>
</ul>
<p>Respectively used to</p>
<ul>
<li>initialize the <mark>main container</mark> (i.e. <code>RecyclerView</code>)</li>
<li>connecting the <code>MainActivity</code> to the <code>MasterPresenterImpl</code> and pass to it the <code>interface</code> of the <code>ImagesAdapterImpl</code> (aka <code>Adapter</code>)</li>
<li><code>getURLs()</code> starts the API request to retrieve the <code>XML</code> data, and so executing the followed tasks (deserialize data, retrieving images through <code>Adapter</code>).</li>
</ul>
<p>The Kitten App is now ready to run.
In any case you can find the entire project on my Github Repository of the <a href="https://github.com/cirorizzo/KShows">KShow</a> project.
The same project has been written in Java as well <a href="https://github.com/cirorizzo/JShows">JShows</a> so you can comparing them</p>
<h6><em>Translations</em></h6>
<p>This post is also available in Chinese on <a href="https://goo.gl/3YpGoR">gold.xitu.io</a>
A special thanks for the translation to the <strong>gold.xitu.io</strong> Team</p>
]]></description><link>http://cirorizzo.net/2016/03/04/building-a-kotlin-project-2/</link><guid isPermaLink="true">http://cirorizzo.net/2016/03/04/building-a-kotlin-project-2/</guid><category><![CDATA[Android]]></category><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Ciro Rizzo]]></dc:creator><pubDate>Fri, 04 Mar 2016 21:22:00 GMT</pubDate></item><item><title><![CDATA[Building a Kotlin project 1/2]]></title><description><![CDATA[<h3>Part 1</h3>
<p>The best way to learn a new language is to use it in a real use case.
That's way this new series of posts are focused on building a proper Android project using Kotlin.</p>
<h2>Scenario</h2>
<p>To cover as many scenarios as possible the project will require:</p>
<ul>
<li>Accessing to the network</li>
<li>Retrieving data through out a REST API call</li>
<li>Deserialize data</li>
<li>Showing Images in a list</li>
</ul>
<p>For this purpose why not have an app showing kittens? ;)
Using the <a href="http://thecatapi.com/">http://thecatapi.com/</a> API we can retrieve several funny cat images</p>
<p><img src="http://cirorizzo.net/content/images/2016/03/xkittenApp.png.pagespeed.ic.ulo4yWl6Cg.png" alt="Example"></p>
<h2>Dependencies</h2>
<p>It looks like a very good chance to try out some very cool libraries like</p>
<ul>
<li><a href="http://square.github.io/retrofit/">Retrofit2</a> for the network access, REST API calls and deserializing data</li>
<li><a href="https://github.com/bumptech/glide">Glide</a> for showing images</li>
<li><a href="https://github.com/ReactiveX/RxJava">RxJava</a> to bind data</li>
<li><a href="http://developer.android.com/training/material/lists-cards.html">RecyclerView CardView</a> as UI</li>
<li>Everything wrapped in a <a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93presenter">MVP</a> pattern</li>
</ul>
<h2>Set Up the Project</h2>
<p>Using <a href="http://developer.android.com/sdk/index.html">Android Studio</a> is extremely simple create a new project from scratch</p>
<h3>Start a new Android Project</h3>
<p><img src="http://cirorizzo.net/content/images/2016/03/xAndroidStudio_NewProject.png.pagespeed.ic.7fDR0qSTJd.png" alt="Start a new Android Project"></p>
<h3>Create a new project</h3>
<p><img src="http://cirorizzo.net/content/images/2016/03/xAndroidStudio_NewProject_Create_NEW-1.png.pagespeed.ic.rtJ-FIVYiG.png" alt="Create a new project"></p>
<h3>Select Target Android Device</h3>
<p><img src="http://cirorizzo.net/content/images/2016/03/xAndroidStudio_NewProject_Target.png.pagespeed.ic.bXlb6fWH62.png" alt="Select Target Android Device"></p>
<h3>Add an activity</h3>
<p><img src="http://cirorizzo.net/content/images/2016/03/xAndroidStudio_NewProject_Empty.png.pagespeed.ic.VYxIdhZ3Xk.png" alt="Add an activity"></p>
<h3>Customize the Activity</h3>
<p><img src="http://cirorizzo.net/content/images/2016/03/xAndroidStudio_NewProject_Activity.png.pagespeed.ic.3g2X5Gs9Bn.png" alt="Customize the Activity"></p>
<p>Press on Finish, the new project from the chosen template will be created.</p>
<p><img src="http://cirorizzo.net/content/images/2016/03/xAndroidStudio_Basic_Template.png.pagespeed.ic.3iX8nv51PP.png" alt="Done"></p>
<p>This is the starting point of our Kitten App!
However the code is still in Java, later we’re going to see how to convert it.</p>
<h2>Defining Gradle Build Tool</h2>
<p>The next step is to adjust the Build Tool and defining which libraries we're going to use for the project.</p>
<blockquote>
<p>Before starting with this phase, have a look at what you need for an Android Kotlin project on this <a href="http://www.cirorizzo.net/kotlin-code/">post</a></p>
</blockquote>
<p>Open the Module App <code>build.gradle</code> (highlighted with a red rectangle in the picture)</p>
<p><img src="http://cirorizzo.net/content/images/2016/03/xAndroidStudio_Basic_Gradle_High.png.pagespeed.ic.0SHrJn4YZc.png" alt="Gradle"></p>
<p>It's a very good practice collecting all the libraries' version and Android properties in separate scripts and accessing to them through the <code>ext</code> property object provided by Gradle.</p>
<p>The easiest way is to add at the beginning of the <code>build.gradle</code> file the following snippet</p>
<pre><code class="hljs language-groovy">buildscript {
  ext.compileSdkVersion_ver = <span class="hljs-number">23</span>
  ext.buildToolsVersion_ver = <span class="hljs-string">'23.0.2'</span>

  ext.minSdkVersion_ver = <span class="hljs-number">21</span>
  ext.targetSdkVersion_ver = <span class="hljs-number">23</span>
  ext.versionCode_ver = <span class="hljs-number">1</span>
  ext.versionName_ver = <span class="hljs-string">'1.0'</span>

  ext.support_ver = <span class="hljs-string">'23.1.1'</span>

  ext.kotlin_ver = <span class="hljs-string">'1.0.0'</span>
  ext.anko_ver = <span class="hljs-string">'0.8.2'</span>

  ext.glide_ver = <span class="hljs-string">'3.7.0'</span>
  ext.retrofit_ver = <span class="hljs-string">'2.0.0-beta4'</span>
  ext.rxjava_ver = <span class="hljs-string">'1.1.1'</span>
  ext.rxandroid_ver = <span class="hljs-string">'1.1.0'</span>

  ext.junit_ver = <span class="hljs-string">'4.12'</span>

  repositories {
      mavenCentral()
  }

  dependencies {
      classpath <span class="hljs-string">"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_ver"</span>
  }
}</code></pre>
<p>Then adding the Kotlin plugins as shown</p>
<pre><code class="hljs language-groovy">apply <span class="hljs-string">plugin:</span> <span class="hljs-string">'com.android.application'</span>
apply <span class="hljs-string">plugin:</span> <span class="hljs-string">'kotlin-android'</span>
apply <span class="hljs-string">plugin:</span> <span class="hljs-string">'kotlin-android-extensions'</span></code></pre>
<p>Before adding the dependencies for the libraries we're going to use in the project starting to change all the version numbers of the script with the <code>ext</code> properties added early at the beginning of the file</p>
<pre><code class="hljs language-groovy">android {
  compileSdkVersion <span class="hljs-string">"$compileSdkVersion_ver"</span>.toInteger()
  buildToolsVersion <span class="hljs-string">"$buildToolsVersion_ver"</span>

  defaultConfig {
    applicationId <span class="hljs-string">"com.github.cirorizzo.kshows"</span>
    minSdkVersion <span class="hljs-string">"$minSdkVersion_ver"</span>.toInteger()
    targetSdkVersion <span class="hljs-string">"$targetSdkVersion_ver"</span>.toInteger()
    versionCode <span class="hljs-string">"$versionCode_ver"</span>.toInteger()
    versionName <span class="hljs-string">"$versionName_ver"</span>
}
...</code></pre>
<p>One more change to the <code>builTypes</code> section</p>
<pre><code class="hljs language-groovy">buildTypes {
    debug {
        buildConfigField(<span class="hljs-string">"int"</span>, <span class="hljs-string">"MAX_IMAGES_PER_REQUEST"</span>, <span class="hljs-string">"10"</span>)
        debuggable <span class="hljs-literal">true</span>
        minifyEnabled <span class="hljs-literal">false</span>
        proguardFiles getDefaultProguardFile(<span class="hljs-string">'proguard-android.txt'</span>), <span class="hljs-string">'proguard-rules.pro'</span>
    }

    release {
        buildConfigField(<span class="hljs-string">"int"</span>, <span class="hljs-string">"MAX_IMAGES_PER_REQUEST"</span>, <span class="hljs-string">"500"</span>)
        debuggable <span class="hljs-literal">false</span>
        minifyEnabled <span class="hljs-literal">true</span>
        shrinkResources <span class="hljs-literal">true</span>
        proguardFiles getDefaultProguardFile(<span class="hljs-string">'proguard-android.txt'</span>), <span class="hljs-string">'proguard-rules.pro'</span>
    }
}
sourceSets {
    main.java.srcDirs += <span class="hljs-string">'src/main/kotlin'</span>
}</code></pre>
<p>Next step is to declare the Libraries used in the project</p>
<pre><code class="hljs language-groovy">dependencies {
  compile fileTree(<span class="hljs-string">dir:</span> <span class="hljs-string">'libs'</span>, <span class="hljs-string">include:</span> [<span class="hljs-string">'*.jar'</span>])
  testCompile <span class="hljs-string">"junit:junit:$junit_ver"</span>

  compile <span class="hljs-string">"com.android.support:appcompat-v7:$support_ver"</span>
  compile <span class="hljs-string">"com.android.support:cardview-v7:$support_ver"</span>
  compile <span class="hljs-string">"com.android.support:recyclerview-v7:$support_ver"</span>
  compile <span class="hljs-string">"com.github.bumptech.glide:glide:$glide_ver"</span>

  compile <span class="hljs-string">"com.squareup.retrofit2:retrofit:$retrofit_ver"</span>
  compile (<span class="hljs-string">"com.squareup.retrofit2:converter-simplexml:$retrofit_ver"</span>) {
    exclude <span class="hljs-string">module:</span> <span class="hljs-string">'xpp3'</span>
    exclude <span class="hljs-string">group:</span> <span class="hljs-string">'stax'</span>
}

  compile <span class="hljs-string">"io.reactivex:rxjava:$rxjava_ver"</span>
  compile <span class="hljs-string">"io.reactivex:rxandroid:$rxandroid_ver"</span>
  compile <span class="hljs-string">"com.squareup.retrofit2:adapter-rxjava:$retrofit_ver"</span>

  compile <span class="hljs-string">"org.jetbrains.kotlin:kotlin-stdlib:$kotlin_ver"</span>
  compile <span class="hljs-string">"org.jetbrains.anko:anko-common:$anko_ver"</span>
}</code></pre>
<p>Finally the <code>build.gradle</code> is ready to work with the project.</p>
<p>Just one more thing is to add the <code>uses-permission</code> to access to Internet, so add the following line to the <code>AndroidManifest.xml</code></p>
<pre><code class="hljs language-xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.permission.INTERNET"</span> /></span></code></pre>
<p>And now we are ready to go to the next step</p>
<h2>Designing Project Structure</h2>
<p>Another good practice is to structure the project having different packages and folders for different group of Classes composing our project so we can structure our project as shown below.</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARIAAAB1CAMAAAC1b55HAAAABGdBTUEAALGPC/xhBQAAAm1QTFRFPT9BPUBBPUBCPkBBPkFDQEJDQEJEQENFQkRFQkRGQkVHQ0ZHQ0ZIREdJRUhJRkhKRklLR0pLSEpMSEtNSUxNSUxOSk1OS05PS05QTE5QTVBRTlBSTlFTTl1mT1JTT11nUFJUUVJUUVRVUVRWUlRWUlVXU1VXU1ZXVFZYVFdZVVdZVVhZV1laV1lbV1pbWFpcWVtcWVtdWlxeWl1eW11eW11fW3ODXF5gXF9gXV9gXV9hX2BiX2FiX2FjYGJjYGJkYWNkYmRlYmRmY2VmY2VnZGZnZGZoZWdoZWdpZmhpZmhqZ2lqZ2lraGpraWtsaWttamxta21ta21ua21vbG5vbW9xbnBxb3FycHFycHJzcXN0cnR1c3R2c3V2c5y3dHV2dJ23dJ24dXd4dnh5d3l6eHl6eXp7emtUenx9eqfEe3x9e31+fH5/fX5/fX+Afn+Af4GCgIGCgYODgYOEgoOEg4WGhIWGhYaHhoeIh4iJiImKiYqLiouLiouMi4yNjI2NjI2OjY2OjY6Pjo+Pjo+QjpCQj5CRkJGSkZKSkZKTkpOTkpOUk5SUk5SVlJWVlJWWlZaWlpaXlpeXlpeYl5iYmJmZmJmamZqampubmpucm5ycnJ2dnJ2enZ2enZ6enp6fnp+gn6CgoKChoKGhoKGioaKioqKjoqOjo6Ojo6SkpKSkpKSlpKWlpaWlpaampqanpqenp6enp6ioqKipqampqaqqqqqrq6urrKysrKytra2tra6urq6vr6+vr7CwsLCxsbGxsrKzs7OztLS0tLS1tbW1tra2tra3t7e3uJZouLi4uLi5urq6urq7u7u7y01+uQAAB/NJREFUeNrtnftDU2Ucxr8sLnIZzKGZYWqGXUArb4kXRFspRuIyFcEsnFZeUiyVMs2sjCysKEDxklg6l5cojwR2ajEnYiHtb+q9nss2tiOM6c7e54dzOOf77gt7xjm8+/CcHQAhISGh+Gkr0XPCiGBLhCehljDhPV9sSaKn/4tMdSmiJdmjksiSMmbJAp0lwV/X1wBsueA9YIFPXwawXUijGybVSeJIG0S0BB84lQ/bfM/A+mMA6w+zDZPqUWLJxOiWIJ2ogfw7o8FdyjbMqs+RI59AdEsqGpp8yIW2msl/WfiGSZV1Xe7Oim7JU/8UwHHkwpozdbuVDbOqTt4B0S1Z7M0o7HwTwNrfM1XZMKtSW1MNzEvSz/rddb5igKaLoG4k71TtRCVa5ALkKWN0G8mn+p0+m5jT6zRzlVWYICQkJCQUJ/1L9LYwItiSoXmyacrgW8PuN/x2w7SEyeCDJId2pd8ZcU/4fWFrkQbGTuHg45AsyU2D05XRLUHDwMi+e2hJOPiotYF+Pb7J37MOxrf6pQqAlhcafbvsbd4NdMTE9huHjlZAS8mOfu+1VGlFQ089wNkigLZZIK1u9h9hNIL2aCmBloq2BqUX/rqlxHYNy8pWvMhcWHQ8E5b85N+PNmhzWv52PmR0OCDlXCYtxk5h4COy4ZHa2kdUS1KunCrMHWu5eMC2/HYxSF3lswJnS5f708mItv3WuTeq0M+ec7naDpJcPa1/CvhmAnQtAqlj6cLuKjKM9sBPUepaZld7LUOPcaTY7fZjJyxsxYvUkgneIrD8Pi/tIWDNWfn9PVB6Zx/M+IEVY6cw8BHZULt1a61qSVFgHloWB9A3PlUP0hqAW89DVmAcHpDdPx7g9Fr8XD34wHEBXHYqlqDX+t0vSSPag1hSrelVzY8Hl0zebuIVL5LxK6+uQqvOvfj/BrQ5KzuuwN76q7DLxYoxVCh8pJZsVC1Z+l8GXt7E75SPkmfQOx1GUUsW4r0aS1DRrVqCtl7tII1oD2KJQ9+LLObefhqXyYoXyXh3N/5lLJb+LOXNWTm73/arvXd0x0RWjKFC4SOyYdLG1yeplkwLTEfLZwPodWzeF2SJfcAOKZepJU7VkjmQ/je1ZNeHpBHtwS3R9sKLsT3k8KIrXiTjV3g+I+xrc18ma87L7Zt/hO83SbwYS4XAx5DTa6p0xJaany67LJNvLtZa8kY5wM9fOxq8xJLGOsWScxtyDt5Bluyx5F14CfA42oNbou2FFmnnPsLfjK14EXeXHPnydkgrhDF9Vtacl3f4t4HLv5sXRxQ+hv4Rfvxan28bzPiju+8d0FrScRCgsPnki54VeG9Zj4dbsrLXV4UPnIOS/xv0AuJxtAezRNsLLRYGfF6vt4CteBE/Cg2Y2ltplbs6XYrfrDw7UIROO7OBFeM+VbOTPy/5qWEfYBt4kqzTVR45isw1cixpueow2oNrkF6DFPMsEcp599k/Iw/s3ykdEe+CtJpQXl0iXBASEhISEvDxnsPHmun3ARYcAbU/NmT4iN4Tx5eBxUmyfNg6MpZgFpmglsjdb0V5d6zljQwMFrTfOORBlhScudmYpVhCASONRRIWGWsuGC9LZPm3BRHho4Y3cjB47IPsMn8VQKsrt3U1t4QBRhqLxCwy5lwwfpbI8muR4KOGNzLyl9E3jhw4ObeemLD9Y24JA4xAY5EYvMWcC8bNks5XIMSSjVpLFGzCyN88Pz2XLOo/f/58A7eEAUYWi8SWxJwLxsmS6+89EHwu0cNHjSWM/E0ZyAY4sxamDYzRnF4pYOSxSMwiY88F42LJdw9CtNOragknf15X+tq+Kki9Wp8JVjJAAYw8FtlYNxJcMA66NMfAvETDGxn5W9ffV49+S6Dwir+zmQxQACOPRZb1eOLBBeM5ex1sXkLJX2YO27TpDgwCGFksErPIPNNepCAkJCQkJCQUv3mJAI2hU7W798QkuHEYoDFEJsGNQwCNgxJE01hiBDQuIfFCShUxQWxSIobauCKLJJrAEgOgkWYXKVXEBFGNGOrjijiSaA5LooJGEi/kVNFTCUrEUB9XpJFEU1hiBDS6nZwqIkuUiKE+rkgjiSawxBhodDs5VcQEkUcM9XFFFklMeEsMgka3k1NFnGbkEcOguCKOJCa8DINGt5NTRZxm5BHDoLgijiSaePYabl5CqWK67urqiHFFISEhISEhIaHhz0sEaAydqiWtJ7EEjSbRMBKNoTpdaQ5LjIDGcnpZNMGJLMRIw4psg5JIEmLke/DQhLXEAGhkl0UTnEhxIwsr8kQjIZHkgmq+Bw9NYEuigkZ2WTTGiRw3krCikmikV1F7KtU91Yl84BgDjfiyaLzmuJGEFbWJRjexRJ9xTFRLjIFGfFk0XnPcSMKK2kQjtsQZlHFMUEuMgEZ2WTR+ngw30rCiJtGILWms02YcE1XGQONX9LJo8jwpbmRhRTXRiC3BCFKzx3SzVx171V4WzXAjCyvqEo0EQdoywfwy10seE83PFx4ICQkJCY3UvESAxtCpmgCNkWavyTVhuwvQGOnzFc1lSXTQyO4U01LCuKL6kYlmtSQqaGR3ikEHDqWISp4RzGtJFNDI7hQjORhFVD8y0byWRAON9E4xkoNRRPUjE81qSXTQSO4UgyzhFFH9yERzWmIANJI7xSBLOEXkeUZzyhBoJHeKwadXRhGVPGOSzV7D/wM0KSiikJCQkJCQQf0P6Bh9nhVvE5IAAAAASUVORK5CYII=" alt="Structure"></p>
<blockquote>
<p>Right Click on the Root Package <code>com.github.cirorizzo.kshows</code> and then <code>New -> Package</code></p>
</blockquote>
<h2>Coding</h2>
<p>The next <a href="http://www.cirorizzo.net/2016/03/04/building-a-kotlin-project-2/">post</a> is on how to code the elements of the Kitten app</p>
<h2>Translations</h2>
<p>This post is also available in Chinese on <a href="https://goo.gl/tBIMn7">gold.xitu.io</a>
A special thanks for the translation to the gold.xitu.io Team</p>
]]></description><link>http://cirorizzo.net/2016/03/04/building-a-kotlin-project/</link><guid isPermaLink="true">http://cirorizzo.net/2016/03/04/building-a-kotlin-project/</guid><category><![CDATA[Android]]></category><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Ciro Rizzo]]></dc:creator><pubDate>Fri, 04 Mar 2016 21:19:00 GMT</pubDate></item><item><title><![CDATA[(RU) Видео со встречи JUG.ru с разработчиками Kotlin]]></title><description><![CDATA[<h2>Часть 1. Введение</h2>
<p>Андрей Бреслав расскажет про то, что такое Kotlin, как у него сейчас дела и т.д.
<a href="https://www.youtube.com/watch?v=HWyd1gYMkl0">Андрей Бреслав — Что такое Kotlin Введение</a></p>
<h2>Часть 2. К релизу и далее</h2>
<p>Начиная с версии 1.0, Kotlin предоставляет гарантии обратной совместимости с существующим кодом. Дмитрий Жемеров расскажет о том, что в точности они обещают на будущее, о том, как это обещание повлияло на дизайн языка, и о том, под какие направления будущего развития уже есть заготовки в версии 1.0.
<a href="https://www.youtube.com/watch?v=m5T0M7SnCC0">Дмитрий Жемеров, JetBrains — Kotlin - к релизу и далее</a></p>
<h2>Часть 3. Самое сложное — совместимость</h2>
<p><a href="https://www.youtube.com/watch?v=LWFx4QWrTyo">Андрей Бреслав — Kotlin - самое сложное — совместимость</a>
Андрей Бреслав расскажет о том, как они боролись за прозрачную совместимость: чтобы Kotlin и Java могли дружно обитать в одном проекте. Для этого пришлось придумать немало оригинальных решений и пойти на многие компромиссы на всех уровнях: от системы типов до плагинов к билд-системам.</p>
<h2>Часть 4. Сессия вопросов и ответов</h2>
<p><a href="https://www.youtube.com/watch?v=YOmdOTlhZa8">Андрей Бреслав и Дмитрий Жемеров — Kotlin - сессия вопросов и ответов</a>
Андрей, Дмитрий и другие разработчики Kotlin с удовольствием ответят на ваши вопросы.</p>
]]></description><link>https://github.com/KotlinBy/awesome-kotlin/blob/master/app/rss/articles/%5BRU%5D%20%D0%92%D0%B8%D0%B4%D0%B5%D0%BE%20%D1%81%D0%BE%20%D0%B2%D1%81%D1%82%D1%80%D0%B5%D1%87%D0%B8%20JUG.ru%20%D1%81%20%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%87%D0%B8%D0%BA%D0%B0%D0%BC%D0%B8%20Kotlin.md</link><guid isPermaLink="true">https://github.com/KotlinBy/awesome-kotlin/blob/master/app/rss/articles/%5BRU%5D%20%D0%92%D0%B8%D0%B4%D0%B5%D0%BE%20%D1%81%D0%BE%20%D0%B2%D1%81%D1%82%D1%80%D0%B5%D1%87%D0%B8%20JUG.ru%20%D1%81%20%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%87%D0%B8%D0%BA%D0%B0%D0%BC%D0%B8%20Kotlin.md</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Video]]></category><dc:creator><![CDATA[JetBrains]]></dc:creator><pubDate>Fri, 04 Mar 2016 17:12:00 GMT</pubDate></item><item><title><![CDATA[Kotlin: a new JVM language you should try]]></title><description><![CDATA[<h2>Kotlin 1.0 is here</h2>
<p><a href="https://www.jetbrains.com/">JetBrains</a> (the people behind IntelliJ IDEA) have <a href="http://blog.jetbrains.com/kotlin/2016/02/kotlin-1-0-released-pragmatic-language-for-jvm-and-android/">recently announced</a> the first RC for version 1.0 of <a href="https://kotlinlang.org/">Kotlin</a>, a new programming language for the JVM. I say ‘new’, but Kotlin has been in the making for a few years now, and has been used by JetBrains to develop several of their products, including Intellij IDEA. The company <a href="https://github.com/JetBrains/kotlin">open-sourced</a> Kotlin in 2011, and have worked with the community since then to make the language what it is today.</p>
<p><img src="https://opencredo.com/wp-content/uploads/2016/02/kronshtadt.jpg" alt="Kotlin"></p>
<h2>What is Kotlin and why you should care</h2>
<p>There is no shortage of <a href="https://en.wikipedia.org/wiki/List_of_JVM_languages">JVM languages</a> to choose from these days. Kotlin (named after <a href="https://en.wikipedia.org/wiki/Kotlin_Island">Kotlin island</a>, near St. Petersburg, pictured above) positions itself as a pragmatic and easy-to-use alternative to Java, with which it is highly interoperable, to the point where you can mix Kotlin and Java code in the single codebase. The emphasis on interoperability lowers the adoption barrier, which can make Kotlin rather appealing to any Java developer who wished Java was more expressive and less verbose. Kotlin compiles to Java 6-compatible bytecode so you can use the powerful features it offers on older JVM versions (or Android where it has become quite popular already).</p>
<h2>Hello World! with Kotlin</h2>
<p>Let’s see some code and compare it with Java and Scala (from which Kotlin has borrowed quite a few language constructs) to get a first impression about the language and highlight a few differences compared to the alternatives.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">// Kotlin</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&#x3C;<span class="hljs-type">String</span>>)</span></span> {
    println(<span class="hljs-string">"Hello, World!"</span>)
}</code></pre>
<pre><code class="hljs language-scala"><span class="hljs-comment">// Scala</span>
<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">App</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]) {
    println(<span class="hljs-string">"Hello, world!"</span>)
  }
}</code></pre>
<pre><code class="hljs language-java"><span class="hljs-comment">// Java</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        System.out.println(<span class="hljs-string">"Hello, World!"</span>);
    }
}</code></pre>
<p>You can observe almost immediately how compact Kotlin’s version is (even compared to Scala). Kotlin benefits from top-level (or package-level) functions that are not members of a class or object, which is perfect for the <code>main</code> function. Since package declaration is omitted the function belongs to the default package.</p>
<p>There are a few language features shown above that make Kotlin programs somewhat similar to Scala ones:</p>
<ul>
<li>Type declarations are defined after function argument names, variable names or function/method names</li>
<li>the <code>Unit</code> return type (equivalent to Java void) is optional</li>
<li><code>Array</code> is a regular generic type</li>
<li>The <code>println()</code> function, and other print functions, are available implicitly</li>
<li>semicolons are optional :)</li>
</ul>
<h2>Type system</h2>
<p>Kotlin’s type system is close enough to Java’s to provide a good level of interoperability, although it still empowers developers to produce elegant code in a productive way; for instance, type inference removes the need to declare variable types everywhere. A lot of features in Kotlin have been influenced by the <a href="http://www.oracle.com/technetwork/java/effectivejava-136174.html">Effective Java</a> series, and try to tackle some of the not-so-great elements that Java has inherited from its early days. Kotlin makes it easier to follow best practice, and prevents some of the more questionable practices completely.</p>
<p>The key features of Kotlin’s type system (compared to Java) are:</p>
<ul>
<li>every class inherits from type <code>Any</code>, which defines only 3 functions (<code>equals()</code>, <code>hashCode()</code> and <code>toString()</code>), compared to quite a few more in Java’s <code>Object</code></li>
<li>all <a href="https://kotlinlang.org/docs/reference/basic-types.html">data types</a> are represented by classes, including numbers (<code>Int</code>, <code>Long</code>, <code>Double</code>, etc.), characters (<code>Char</code>) and booleans (<code>Boolean</code>)</li>
<li>a class’s primary <a href="https://kotlinlang.org/docs/reference/classes.html#constructors">constructor</a> can be defined as part of the class declaration</li>
</ul>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span></span>(<span class="hljs-keyword">val</span> bar: String, <span class="hljs-keyword">val</span> baz: <span class="hljs-built_in">Int</span>)</code></pre>
<ul>
<li>the <code>new</code> keyword is missing</li>
</ul>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> foo = Foo(<span class="hljs-string">"bar"</span>, <span class="hljs-number">42</span>)</code></pre>
<ul>
<li>there are no static methods and any static code needs to be defined in a <a href="https://kotlinlang.org/docs/reference/object-declarations.html#companion-objects">class companion object</a></li>
<li>classes and functions are final by default and have to be declared <code>open</code> to be overridable</li>
<li>any type can be enhanced by using <a href="https://kotlinlang.org/docs/reference/extensions.html">extension functions</a> to define additional functions/methods (no more <code>xUtils</code> classes)</li>
<li><a href="https://kotlinlang.org/docs/reference/generics.html">generics</a> have been revamped to make working with variance much easier</li>
<li><a href="https://kotlinlang.org/docs/reference/object-declarations.html">objects</a> can be used to implement the singleton pattern or to avoid the need for anonymous inner classes</li>
<li><a href="https://kotlinlang.org/docs/reference/data-classes.html">data classes</a> make it trivial to create Java Bean-style data containers</li>
</ul>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>(<span class="hljs-keyword">val</span> firstName: String, <span class="hljs-keyword">val</span> lastName: String)</code></pre>
<h2>Functional programming</h2>
<p>Kotlin is not a functional language but provides decent support for FP elements where they make sense in the OO world. It lifts functions to first-class-citizen status and makes using them very easy (the same sadly can’t be said about Java, even in version 8). Kotlin supports <a href="https://kotlinlang.org/docs/reference/lambdas.html#higher-order-functions">higher-order functions</a> which means that functions can be passed in as arguments to other functions or returned from functions.</p>
<pre><code class="hljs language-kotln"><span class="hljs-comment">// List.map() is an example of a higher-order function</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span>  List.<span class="hljs-title">map</span><span class="hljs-params">(transform: (<span class="hljs-type">T</span>)</span></span> -> R): List {
  <span class="hljs-keyword">val</span> result = arrayListOf()
  <span class="hljs-keyword">for</span> (item <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>)
    result.add(transform(item))
  <span class="hljs-keyword">return</span> result
}</code></pre>
<p>Additionally, <a href="https://kotlinlang.org/docs/reference/lambdas.html#lambda-expression-syntax">lambda expressions</a> and <a href="https://kotlinlang.org/docs/reference/lambdas.html#anonymous-functions">anonymous functions</a> can be used when function expressions or references are expected.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> doubled = ints.map { it -> it * <span class="hljs-number">2</span> }</code></pre>
<p>Some other nice features around working with <a href="https://kotlinlang.org/docs/reference/functions.html#functions">functions</a> in Kotlin include:</p>
<ul>
<li>default argument values</li>
</ul>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">read</span><span class="hljs-params">(b: <span class="hljs-type">Array</span>, off: <span class="hljs-type">Int</span> = <span class="hljs-number">0</span>, len: <span class="hljs-type">Int</span> = b.size()</span></span>) {...}</code></pre>
<ul>
<li>named arguments</li>
</ul>
<pre><code class="hljs language-kotlin">read(bytes, len = <span class="hljs-number">100</span>)</code></pre>
<ul>
<li>infix notation</li>
</ul>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> plusOne = value + <span class="hljs-number">1</span> <span class="hljs-comment">// plus operator is a function call using infix notation</span></code></pre>
<ul>
<li>Unit return is optional</li>
</ul>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printMe</span><span class="hljs-params">(message: <span class="hljs-type">String</span>)</span></span>: <span class="hljs-built_in">Unit</span> { println(message) }</code></pre>
<ul>
<li>single-expression functions</li>
</ul>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printMe</span><span class="hljs-params">(message: <span class="hljs-type">String</span>)</span></span>: <span class="hljs-built_in">Unit</span> = println(message)</code></pre>
<ul>
<li>tail-recursive functions</li>
</ul>
<pre><code class="hljs language-kotlin">tailrec <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">findFixPoint</span><span class="hljs-params">(x: <span class="hljs-type">Double</span> = <span class="hljs-number">1.0</span>)</span></span>: <span class="hljs-built_in">Double</span> = <span class="hljs-keyword">if</span> (x == Math.cos(x)) x <span class="hljs-keyword">else</span> findFixPoint(Math.cos(x))</code></pre>
<h2>Null safety</h2>
<p>Handling null references has been quite a chore in Java from the very beginning. In recent versions of the language a few utility classes have been added to make it somewhat more manageable (<code>Objects</code> in Java 7 and Optional in Java 8 come to mind), but the language itself doesn’t provide much-needed native support. Kotlin is different as it adopts and further enhances Groovy’s approach to <a href="https://kotlinlang.org/docs/reference/null-safety.html">null-safety</a> and makes working with object references less of a hassle.</p>
<p>By default, the compiler will prevent assigning null value to an object reference and you have to explicitly declare a variable as nullable.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">var</span> a: String = <span class="hljs-string">"abc"</span>
a = <span class="hljs-literal">null</span> <span class="hljs-comment">// compilation error</span>

<span class="hljs-keyword">var</span> b: String? = <span class="hljs-string">"abc"</span> <span class="hljs-comment">// '?' declares variable as nullable</span>
b = <span class="hljs-literal">null</span> <span class="hljs-comment">// ok</span></code></pre>
<p>With that initial safety feature in place you can then safely follow nullable object references without worrying about <code>NullPointerException</code> (or employing an excessive degree of null-checking). Additionally, the so-called Elvis operator (surely you can see Elvis’ hair do in <code>?:</code>) provides a syntactic sugar for defining a default value if a null reference has been encountered.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> departmentHead = employee?.department?.head?.name ?: <span class="hljs-string">"n/a"</span></code></pre>
<p>On top of that, Kotlin offers safe-casting support, where instead of throwing ClassCastException the expression returns a null value.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> aInt: <span class="hljs-built_in">Int</span>? = a <span class="hljs-keyword">as</span>? <span class="hljs-built_in">Int</span></code></pre>
<h2>Collections</h2>
<p>Unlike Scala, Kotlin doesn’t provide its own collection framework built from ground up. The rationale behind that choice is Java interoperability. Collections are the bread and butter of software engineering and the team behind Kotlin decided they didn’t want to make it difficult to use Java collections from Kotlin, or to make developers to learn new collection types. <a href="https://kotlinlang.org/docs/reference/collections.html">Collections in Kotlin</a> reflect those in Java with one difference – Kotlin distinguishes between immutable and mutable collections, favouring immutability (although mutable Java collections are being used behind the scenes).</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> numbers: MutableList = mutableListOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
<span class="hljs-keyword">val</span> readOnlyView: List = numbers
println(numbers)        <span class="hljs-comment">// prints "[1, 2, 3]"</span>
numbers.add(<span class="hljs-number">4</span>)
println(readOnlyView)   <span class="hljs-comment">// prints "[1, 2, 3, 4]"</span>
readOnlyView.clear()    <span class="hljs-comment">// -> does not compile</span>

<span class="hljs-keyword">val</span> strings = hashSetOf(<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>, <span class="hljs-string">"c"</span>)
assert(strings.size == <span class="hljs-number">3</span>)</code></pre>
<p>Additionally, the <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/index.html">collection API in Kotlin</a> offers a range of easy-to-use extension functions around collection types.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> items = listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)
items.first() == <span class="hljs-number">1</span>
items.last() == <span class="hljs-number">4</span>
items.filter { it % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> }   <span class="hljs-comment">// returns [2, 4]</span>
items.filter { it % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> } take <span class="hljs-number">1</span> forEach { println(it) } <span class="hljs-comment">// prints out 2</span>
items.fold(<span class="hljs-number">0</span>) { total, current -> total + current } <span class="hljs-comment">// returns 10</span></code></pre>
<p>Creating and using maps is quite convenient too.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> readWriteMap = hashMapOf(<span class="hljs-string">"foo"</span> to <span class="hljs-number">1</span>, <span class="hljs-string">"bar"</span> to <span class="hljs-number">2</span>)
println(readWriteMap[<span class="hljs-string">"foo"</span>])
<span class="hljs-keyword">val</span> readOnlyView: Map = HashMap(readWriteMap)
<span class="hljs-keyword">val</span> doubled = readOnlyView.mapValues { entry -> entry.value * <span class="hljs-number">2</span> }
<span class="hljs-keyword">for</span> ((key, value) <span class="hljs-keyword">in</span> doubled) println(<span class="hljs-string">"<span class="hljs-subst">$key</span> -> <span class="hljs-subst">$value</span>"</span>)</code></pre>
<h2>Control flow</h2>
<p>Kotlin offers some improved <a href="https://kotlinlang.org/docs/reference/control-flow.html">control flow constructs</a>, certainly compared with Java. So for instance, the <code>if ... else</code> block is an expression (returns a value).</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> max = <span class="hljs-keyword">if</span> (a > b) a <span class="hljs-keyword">else</span> b</code></pre>
<p>The <code>switch</code> operator (as found in C and Java) has been replaced by <code>when</code> expression form, similar to pattern-matching in Scala, that also makes a convenient replacement for <code>if ... else</code> chains.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">when</span> {
  x.isOdd() -> print(<span class="hljs-string">"x is odd"</span>)
  x.isEven() -> print(<span class="hljs-string">"x is even"</span>)
  <span class="hljs-keyword">else</span> -> print(<span class="hljs-string">"x is funny"</span>)
}</code></pre>
<p>The <code>when</code> expression supports <a href="https://kotlinlang.org/docs/reference/typecasts.html#smart-casts">smart-casts</a> too, when combined with matching on the type of the when argument.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> hasPrefix = <span class="hljs-keyword">when</span>(x) {
  <span class="hljs-keyword">is</span> String -> x.startsWith(<span class="hljs-string">"prefix"</span>) <span class="hljs-comment">// x is automatically casted to String</span>
  <span class="hljs-keyword">else</span> -> <span class="hljs-literal">false</span>
}</code></pre>
<p>A <code>for</code> loop can iterate over any type that provides an iterator implementing <code>next()</code> and <code>hasNext()</code>.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">for</span> (item <span class="hljs-keyword">in</span> collection)
  print(item)

<span class="hljs-keyword">for</span> ((index, value) <span class="hljs-keyword">in</span> array.withIndex()) {
    println(<span class="hljs-string">"the element at <span class="hljs-subst">$index</span> is <span class="hljs-subst">$value</span>"</span>)
}</code></pre>
<h2>Other features</h2>
<p>I think we’ve covered quite a lot already, but there are still a few more features worth highlighting to round up the language overview:</p>
<ul>
<li><a href="https://kotlinlang.org/docs/reference/basic-types.html#string-templates">string templates</a> (known in Scala as string interpolation) make it easy to format string messages easily by resolving variables and expressions</li>
</ul>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> s = <span class="hljs-string">"abc"</span>
<span class="hljs-keyword">val</span> str = <span class="hljs-string">"<span class="hljs-subst">$s</span>.length is <span class="hljs-subst">${s.length}</span>"</span> <span class="hljs-comment">// evaluates to "abc.length is 3"</span></code></pre>
<ul>
<li><a href="https://kotlinlang.org/docs/reference/multi-declarations.html">destructuring</a> allows convenient extraction of data class or collection elements</li>
</ul>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> person = Person(<span class="hljs-string">"Rafal"</span>, <span class="hljs-number">22</span>) <span class="hljs-comment">// I wish I was 22 again!</span>
<span class="hljs-keyword">val</span> (name, age) = person

<span class="hljs-keyword">for</span> ((key, value) <span class="hljs-keyword">in</span> map) {
   <span class="hljs-comment">// Map.Entry can be destructured too</span>
}</code></pre>
<ul>
<li><a href="https://kotlinlang.org/docs/reference/typecasts.html">type checks</a> support smart-casting</li>
</ul>
<pre><code class="hljs language-koltin"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">x</span> is String) {
   <span class="hljs-keyword">print</span>(<span class="hljs-keyword">x</span>.length) <span class="hljs-comment">// x is automatically cast to String</span>
}</code></pre>
<ul>
<li><a href="https://kotlinlang.org/docs/reference/equality.html#structural-equality">structural equality</a> can be checked simply with the <code>==</code> operator (no need to use <code>equals()</code>)</li>
<li><a href="https://kotlinlang.org/docs/reference/equality.html#referential-equality">referential equality</a> can be checked with the <code>===</code> operator</li>
<li>creating <a href="https://kotlinlang.org/docs/reference/ranges.html">ranges</a> is supported natively</li>
</ul>
<pre><code class="hljs language-koltin">for (<span class="hljs-name">i</span> in <span class="hljs-number">1</span>..<span class="hljs-number">10</span> step <span class="hljs-number">2</span>) println(<span class="hljs-name">i</span>)</code></pre>
<ul>
<li>predefined <a href="https://kotlinlang.org/docs/reference/operator-overloading.html">operators can be overloaded</a> (so no crazy operators allowed but still quite powerful)</li>
<li>all <a href="https://kotlinlang.org/docs/reference/exceptions.html">exceptions</a> are unchecked (no more forced exception handling)</li>
<li><code>try</code> is an expression</li>
</ul>
<pre><code class="hljs language-koltin"><span class="hljs-keyword">val</span> a: <span class="hljs-built_in">Int</span>? = <span class="hljs-keyword">try</span> { parseInt(input) } <span class="hljs-keyword">catch</span> (e: NumberFormatException) { <span class="hljs-literal">null</span> }</code></pre>
<ul>
<li><a href="https://kotlinlang.org/docs/reference/type-safe-builders.html">type-safe builders</a> help creating rich DSLs</li>
</ul>
<pre><code class="hljs language-koltin"><span class="hljs-class">html </span>{
  <span class="hljs-class">head </span>{
     <span class="hljs-class">title </span>{+<span class="hljs-string">"HTML built with Kotlin"</span>}
  }
  <span class="hljs-comment">// ...</span>
}</code></pre>
<p>By now I’m sure you are overloaded with all this Kotlin knowledge, so I will stop here. I hope I was able to showcase the entire host of very powerful capabilities that Kotlin offers. By all means explore <a href="https://kotlinlang.org/docs/reference/">the language reference</a> to find out more about various language features.</p>
<h2>Java interoperability</h2>
<p>One of the design goals behind Kotlin has always been to stay close enough to Java to lower the barrier to adoption. Obviously, on the other hand the need to stay interoperable limits the the scope to introduce many new features into the language. I think Kotlin has managed to achieve quite a lot without breaking its ties to the Java world.</p>
<p>Most of the <a href="https://kotlinlang.org/docs/reference/java-interop.html">interoperability</a> aspects revolve around mapping concepts or types between both languages.</p>
<p>For instance, since Java doesn’t offer null safety support similar to Kotlin, Java types are treated in a special way and called <a href="https://kotlinlang.org/docs/reference/java-interop.html#null-safety-and-platform-types">platform types</a>. Null checks are relaxed for such types with the risk of <code>NullPointerExceptions</code> being thrown at runtime.</p>
<pre><code>val list = ArrayList() // non-null (constructor result)
list.add("Item")
val size = list.size() // non-null (primitive int)
val item = list[0] // platform type inferred (ordinary Java object)

item.substring(1) // allowed, may throw an exception if item == null

val nullable: String? = item // allowed, always works
val notNull: String = item // allowed, may fail at runtime
</code></pre>
<p>Similarly, Java generics are handled in a special way when types are imported to Kotlin and using Java arrays of primitives requires a workaround where specialised classes are used to represent them in Kotlin.</p>
<p>When it comes to <a href="https://kotlinlang.org/docs/reference/java-to-kotlin-interop.html">Kotlin classes being called from Java</a>, much of the work required to make them interoperable happens on the Kotlin side. Developers can use an range of annotations to instruct the compiler to produce code that will be usable from Java.</p>
<h2>Tooling</h2>
<p>One of the interesting aspects about Kotlin is that the language has been created by the company behind a popular IDE product. As one might expect IDE support (well, for Intellij IDEA at least) for Kotlin has been very much a part of working on the language itself. The result is a comprehensive <a href="https://kotlinlang.org/docs/tutorials/getting-started.html">Kotlin support in Intellij IDEA</a> on a par with that for Java. JetBrains also maintains an <a href="https://kotlinlang.org/docs/tutorials/getting-started-eclipse.html">Eclipse plugin for Kotlin</a> so this open-source IDE should also provide a good level of support.</p>
<p>Kotlin creators have resisted the need to redefine much of the external tooling around the language. So for instance Kotlin projects can be built using Maven, Gradle or even Ant so except for the compiler plugin not much else is changing for those coming from the Java background.</p>
<h2>Kotlin ecosystem</h2>
<p>There is a growing community around the language so perhaps not surprisingly one can already find a good selection of open-source libraries and frameworks written in Kotlin. If you want to stick with your favourite Java framework, you don’t have to make a full transition to Kotlin as you can use your existing framework in Kotlin without too much hassle and even mix Java and Kotlin code in a single codebase.</p>
<p>The official Kotlin website lists several <a href="https://kotlinlang.org/docs/resources.html">tools, libraries and frameworks</a>, covering MVC/Web, HTTP client, dependency injection and text editor support among over things. Also, the <a href="https://kotlin.link">Awesome Kotlin</a> GitHub website offers a great selection of resources to explore.</p>
<h2>Summary</h2>
<p>I believe Kotlin deserves at least a try, especially if you are coming from the Java background. The language brings a lot of good features from Scala and Groovy closer to Java, so you can benefit from the best of both worlds: the vastness of the Java ecosystem with expressiveness and productivity enhanced by constructs and features coming from other languages. If you do want to give Kotlin a go, why don’t you <a href="http://try.kotlinlang.org/">try it online</a> first or just create a Kotlin project in your favourite IDE and start experimenting with it.</p>
<p>Throughout this post I was covering Kotlin from the perspective of somebody coming from Java as I believe this is a primary expansion area for the new language. It’s worth knowing that Kotlin is also targeting Android development (also Java but still on version 6) as well as (still experimental) JavaScript runtime as an alternative to the JVM. With such a wide range of applications and some great features I reckon Kotlin stands a good chance of attracting quite a few new users.</p>
]]></description><link>https://opencredo.com/kotlin/</link><guid isPermaLink="true">https://opencredo.com/kotlin/</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Rafal Gancarz]]></dc:creator><pubDate>Thu, 03 Mar 2016 09:55:00 GMT</pubDate></item><item><title><![CDATA[(RU) Kotlin для начинающих]]></title><description><![CDATA[<p>Уже не мало нашумел Kotlin в мире программирования, не мало профессиональных инженеров уже обратил на него внимание, но также есть и те кому он не симпатизирует.</p>
<p><img src="https://habrastorage.org/files/a52/453/729/a52453729bd64cb3b5ca8a4892e45cc1.png" alt="Kotlin"></p>
<p>В данном топике я бы хотел обратить внимание тех начинающих программистов которые возможно только делают свой выбор языка программирования, которому бы хотели посвятить свою жизнь так сказать.</p>
<p>Я сам Java Developer и для меня наступил тот период я когда хотелось посмотреть на другие языки, взять какие-то практики для себя с них.</p>
<p>И однажды примерно в 2013 году я услышал что та прекрасная компания делающая такие крутые продукты как <strong>Intellij IDEA</strong>, <strong>Youtrack</strong> а именно <a href="https://www.jetbrains.com/">JetBrains</a>, анонсировала о новом языке <a href="https://kotlinlang.org/">Kotlin</a>, который на то время был в активной стадии разработки.</p>
<p>И в этом году а именно 15 февраля 2016 года был выпушен релиз <strong>Kotlin 1.0</strong>. С этого момента я начал уже более активней его изучать и пытаться применять в небольших свои проектах.</p>
<h2>Kotlin для начинающих</h2>
<p>И этим постом я бы хотел поделится серией видео в которой я начал делится всем тем что я изучил за это время касаемо Kotlin.</p>
<p><strong>Урок 0. Введение и знакомство</strong>
<a href="https://www.youtube.com/watch?v=L9k_NdTaMeI">https://www.youtube.com/watch?v=L9k_NdTaMeI</a></p>
<p><strong>Урок 1. String Templates</strong>
<a href="https://www.youtube.com/watch?v=frw1DpNm_ms">https://www.youtube.com/watch?v=frw1DpNm_ms</a></p>
<p>Пока планирую выкладывать два видео в неделю, весь список будет <a href="https://goo.gl/yegW0d">тут</a>.
Спасибо за ваше внимание, и надеюсь, данная информация кому-то будет полезно!</p>
]]></description><link>https://habrahabr.ru/post/278277/</link><guid isPermaLink="true">https://habrahabr.ru/post/278277/</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[@Devcolibri]]></dc:creator><pubDate>Wed, 02 Mar 2016 15:18:00 GMT</pubDate></item><item><title><![CDATA[Kotlin & Android: A Brass Tacks Experiment, Part 5]]></title><description><![CDATA[<p><img src="https://cdn-images-1.medium.com/max/800/1*UN-S8ELMC2kpHf4tJKfbLQ.png" alt="Header Picture"></p>
<p><em>Disclaimer: I am a Google employee, but the views expressed in this article are not those of my employer.</em></p>
<h2>Kotlin &#x26; Android: A Brass Tacks Experiment, Part 5</h2>
<p>Well, we’ve made it to part 5 in an ongoing weekly blog about my experiences using the Kotlin® language to do useful things for Android development. If you’ve landed here randomly or unexpectedly, perhaps you’d like to jump to one of the prior parts first and catch up to where we are now?</p>
<p><a href="https://medium.com/p/kotlin-android-a-brass-tacks-experiment-part-1-3e5028491bcc">Part 1</a> (setup) | <a href="https://medium.com/p/kotlin-android-a-brass-tacks-experiment-part-2-c67661cfdf5f">Part 2</a> (code starts here) | <a href="https://medium.com/p/kotlin-android-a-brass-tacks-experiment-part-3-84e65d567a37">Part 3</a> | <a href="https://medium.com/p/kotlin-android-a-brass-tacks-experiment-part-4-4b7b501fa457">Part 4</a></p>
<p>At this point, we have a pretty good way of expressing the creation of an Android view hierarchy with fewer keystrokes than the equivalent XML resource, and <em>far</em> fewer than the equivalent written purely in the Java® language. Its syntax is declarative, the nesting of views is obvious, and we know how to use Kotlin <em>extension functions</em> to add convenient utility functions as needed.</p>
<p>But we left things last time with an awkward situation while trying to set a view’s left padding. Here’s what it looks like currently to set padding. Note that we have to call setPadding() with its four arguments instead of assigning to a <em>synthetic property</em> that’s derived from JavaBeans-style getters and setters:</p>
<pre><code class="hljs language-kotlin">v&#x3C;TextView> {
    layoutParams = LayoutParams(WRAP_CONTENT, WRAP_CONTENT)
    setPadding(dp_i(<span class="hljs-number">16</span>), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)  <span class="hljs-comment">// bleh - it's not consistent</span>
    text = <span class="hljs-string">"Hello"</span>
}</code></pre>
<p>To be consistent in this view builder code, we would rather specify the left padding directly by assignment instead of calling a method with four parameters. At first blush, you might consider using another extension function to attach an extension method called “setLeftPadding(int)” to the View class. You could do this, but then you wouldn’t actually be able to refer to it as “leftPadding = dp_i(16)” in the <em>lambda with receiver</em>. It turns out that member functions that look like JavaBeans-style accessors that are <em>defined in Kotlin</em> don’t get automatically converted into synthetic properties like member methods <em>defined in Java classes</em>. Bummer... but not really!</p>
<p>Instead, Kotlin also allows you to define <em>extension properties</em>, which allow a syntax that looks just like the synthetic properties for Java class methods that we’ve been using so far. An extension property is grafted onto an existing class just like a Kotlin extension method so you can access them on instances of that class, assuming the extension property is imported into your code.</p>
<p>So what we can do is define extension properties to set padding values in a way that’s consistent with the other synthetic properties of view. I’ll just show a single property here for left padding; the others follow suit:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">var</span> View.padLeft: <span class="hljs-built_in">Int</span>
    <span class="hljs-comment">// Specify the setter behavior; value is the assigned Int</span>
    <span class="hljs-keyword">set</span>(value) {
        <span class="hljs-comment">// Use View.setPadding to set left padding value,</span>
        <span class="hljs-comment">// uses Kotlin synthetic properties for the others</span>
        setPadding(value, paddingTop, paddingRight, paddingBottom)
    }
    <span class="hljs-comment">// Specify the getter behavior</span>
    <span class="hljs-keyword">get</span>() {
        <span class="hljs-keyword">return</span> paddingLeft
    }</code></pre>
<p>Using this “padLeft” extension property, our earlier TextView creation can now be written like this:</p>
<pre><code class="hljs language-kotlin">v&#x3C;TextView> {
    layoutParams = LayoutParams(WRAP_CONTENT, WRAP_CONTENT)
    padLeft = dp_i(<span class="hljs-number">16</span>)  <span class="hljs-comment">// ahhh - much better!</span>
    text = <span class="hljs-string">"Hello"</span>
}</code></pre>
<p>Consistency in assignment for all the properties. Excellent!</p>
<p>There’s a few things to note about the padLeft extension property:</p>
<ul>
<li>It uses a syntax similar to the “class dot function” notation for extension functions, but now it’s “class dot property”.</li>
<li>The property type is given after the colon.</li>
<li>It’s declared using “var”, which is Kotlin’s way of saying a variable or property is <em>mutable</em>. This means we can assign values directly to it. (On the other hand, “val” properties are <em>immutable</em> and can only be read.)</li>
<li>An extension property that’s mutable requires us to provide both a getter and setter implementation. (Likewise, an immutable property requires only a getter).</li>
</ul>
<p>The implementation of the padLeft <em>setter</em> is defined in terms the existing setPadding() method of View. It takes the value provided from the right hand side of the assignment expression and uses that as the first parameter to setPadding(), along with the values of synthetic properties for the other existing padding values of the TextView. Below the setter, the implementation of the padLeft <em>getter</em> is simply defined using the View’s existing “paddingLeft” synthetic property.</p>
<p>Side note: I find it somewhat ironic that Android’s View class provides JavaBeans-style <em>getters</em> for each directional padding metric but <em>not setters</em>. Oh well, we fixed it with extension properties!</p>
<p>If you ever need more from a class API that you don’t control, just add what you want with Kotlin’s extension functions and properties. 😃</p>
<h2>Any other Kotlin tricks to share?</h2>
<p>There a couple more simple tricks that can be used to tighten up the syntax even more. One trick allows you to get rid of all references to “v” in your view builder expressions, and another will make it easier to specify complicated layout parameters. So check in next time to see how these work!</p>
<p>As usual, you can follow me <a href="https://medium.com/@CodingDoug">here on Medium</a> and also <a href="https://twitter.com/CodingDoug">on Twitter as CodingDoug</a> to get notified of the next part to this series. I hope you’ve found it useful for learning Kotlin language features as well as learning some new things about Android views.</p>
]]></description><link>https://medium.com/@CodingDoug/kotlin-android-a-brass-tacks-experiment-part-5-bd79eb9c85d4#.tyblv8pv8</link><guid isPermaLink="true">https://medium.com/@CodingDoug/kotlin-android-a-brass-tacks-experiment-part-5-bd79eb9c85d4#.tyblv8pv8</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Android]]></category><dc:creator><![CDATA[Doug Stevenson]]></dc:creator><pubDate>Tue, 01 Mar 2016 22:14:00 GMT</pubDate></item><item><title><![CDATA[Developing on Android sucks a lot less with Kotlin]]></title><description><![CDATA[<p><img src="https://wiredcraft.com/images/posts/Android-app-development-Kotlin.jpg" alt="Kotlin"></p>
<p>While Android development has improved tremendously in the past few years, many think that it still sucks when compared to iOS. A lot of folks are working hard to make it better, maybe even enjoyable. And <a href="https://kotlinlang.org/">Kotlin</a>, a new programming language, seems to be headed in that direction. Having been brought onboard by Starbucks in China to work on their mobile apps, we've been experimenting with Kotlin as a viable option to improving the UX of the Android app and making it overall more maintainable.</p>
<h2>What is Kotlin?</h2>
<p><a href="https://kotlinlang.org/">Kotlin</a> is a new language from the guys at JetBrain, the team behind Intellij, Android Studio, and some of the best IDE in the industry. Essentially, Kotlin is an evolution of the Java syntax. Its source code can be compiled to JVM bytecode and it has 100% interoperability with Java. JetBrain even recently added the ability to compile Kotlin code to JavaScript, potentially broadening its reach.</p>
<h2>Who should use Kotlin?</h2>
<p>So, who is Kotlin for? Newbies or experts?</p>
<p>I would argue both.</p>
<p>Newbies can enjoy a cleaner and more concise syntax and avoid a lot of beginner's mistakes people usually run into with Java. Experts will also most likely enjoy the cleaner syntax, and most likely find themselves more productive for it.</p>
<h2>What makes Kotlin different?</h2>
<p>If you hate Java, Kotlin may be your solution. In many ways, it "fixes" Java, especially for Android. While the next major release of Java (8) looks pretty promising and brings a lot of modern language features (e.g. lambda and functional programming), there's no official schedule yet for when it will be made available for the Android platform. Kotlin is available right now.</p>
<p>Let's have a what it brings:</p>
<h3>1. Cleaner syntax</h3>
<p>Here's a "Hello world" in Kotlin:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&#x3C;<span class="hljs-type">String</span>>)</span></span> {
  println(<span class="hljs-string">"Hello, World!"</span>)
}</code></pre>
<p>Compared to Java:</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
  <span class="hljs-comment">//Prints "Hello, World" to the terminal window.System.out.println("Hello, World");</span>
  }
}</code></pre>
<p>I think you'll agree that Kotlin is much cleaner and way more concise.</p>
<h3>2. Null safety</h3>
<p>How many times did you run into a <code>Null Pointer Exception</code> while developing or testing? Kotlin takes all <code>null</code> value checks from runtime to compile time. By doing so, it ensures null safety for any code that passes compilation.</p>
<p>For example, the Java code below can be compiled, but will throw a <code>Null Pointer Exception</code> at runtime.</p>
<pre><code class="hljs language-java">String a  = <span class="hljs-keyword">null</span>;
System.out.println(a.length());</code></pre>
<p>With Kotlin, variables are not nullable by default. For example, this piece of Kotlin code won't compile:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> a:String = <span class="hljs-literal">null</span></code></pre>
<p>But if you really want to allow some variable to have null value, you can add a question mark:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> a: String? = <span class="hljs-literal">null</span>
println(a?.length())</code></pre>
<p>In the example above, the first <code>?</code> is used to make the variable <code>a</code> nullable, the second <code>?</code> is just to check if the value of <code>a</code> is null.</p>
<h3>3. Functional programming</h3>
<p>One of the most important changes in Java 8 is lambda. While we're waiting for this to come to the Android platform, Kotlin can already add a lot of high-order functional programming features on top of Java 6.</p>
<p>By "high-order," I mean a function that can take another function as a parameter or return a function. For example, many programming languages have the <code>filter</code> function, which can take a Collection-like data structure and a function to filter the elements in the Collection that doesn't meet certain criteria. Then return a subset of the original Collection.</p>
<p>This is how you might implement a <code>filter</code> function in Kotlin:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&#x3C;T></span> <span class="hljs-title">filter</span><span class="hljs-params">(items: <span class="hljs-type">Collection</span>&#x3C;<span class="hljs-type">T</span>>, f: (<span class="hljs-type">T</span>)</span></span> -> <span class="hljs-built_in">Boolean</span>): List&#x3C;T> {
  <span class="hljs-keyword">val</span> newItems = arrayListOf&#x3C;T>()
  <span class="hljs-keyword">for</span> (item <span class="hljs-keyword">in</span> items) <span class="hljs-keyword">if</span> (f(item)) newItems.add(item)
  <span class="hljs-keyword">return</span> newItems
}</code></pre>
<p>Then you can use it on a Collection data structure:</p>
<pre><code class="hljs language-kotlin">filter(numbers, { value ->
  value >= <span class="hljs-number">5</span>
})</code></pre>
<p>Pretty clean implementation right? Wait, it can be even cleaner by using the special <code>it</code> keyword that represents each item inside the collection:</p>
<pre><code class="hljs language-kotlin">filter(numbers) { it >= <span class="hljs-number">5</span> }</code></pre>
<h2>Minimum overhead</h2>
<p>Beyond adding features, the Kotlin language is actually pretty small. For the latest version to this day (<code>1.0.0-beta-4584</code>), runtime and standard library are a few kilobytes in size. It won't add much weight to your project.</p>
<p>The features we mentioned previously are just a few things that Kotlin brings to the table. For more, I suggest checking out the <a href="https://kotlinlang.org/docs/reference/">official reference page</a>.</p>
<h2>Using Kotlin on Android Studio</h2>
<p>The author of Kotlin is also the author of some of the most popular IDE out there. There are official plugins for Eclipse, IntelliJ IDEA, and standalone command line compiler as well. Since we're focusing on Android, here are a few tips for Android Studio:</p>
<ol>
<li>Download and install Intellij IDEA/Android Studio plugin. You can install it through the IDE preference panel or download if from JetBrain site.</li>
</ol>
<p><img src="https://wiredcraft.com/images/posts/Kotlin-android-app-development-2.png" alt="android-studio-Kotlin-development"></p>
<ol start="2">
<li>Once you have the plugin installed, you can start using it. If you're trying to convert an existing Java project, simply click <code>Code → Convert Java File to Kotlin File</code> in the menu bar. Kotlin will convert the source Java code to Kotlin code. Alternatively, if you're starting a project from scratch, you can create a new Java project and then convert all <code>.java</code> files into <code>.kt</code> files. Not the best, but hopefully Google and JetBrain will learn to play nice with each other in the future.</li>
</ol>
<p><img src="https://wiredcraft.com/images/posts/Kotlin-android-app-development-3.png" alt="android-studio-Kotlin-development"></p>
<p>That's it!</p>
<h2>Conclusion</h2>
<p>Kotlin probably isn't as hot in the Android community as Swift is for the iOS world, but the number of libraries is growing. Being interoperable with Java 6 and backed up by JetBrain should put you at ease with investing in it; it will be around for a long time.</p>
<p>Kotlin fixed a lot of the issues we had with developing for Android. There's still room for improvement, but I encourage all of you out there who shared the frustrations of building Android apps to give it a try on your next project.</p>
<p>And finally, if you're looking for a rock-solid team of nerds and creatives in NYC, Berlin, or Shanghai to work on your next Android or iOS project, <a href="http://twitter.com/wiredcraft">reach out on Twitter</a> or shoot us an email either <a href="https://wiredcraft.typeform.com/to/GG4GQz">on our site</a> or at <a href="mailto:info@wiredcraft.com">info@wiredcraft.com</a>.</p>
]]></description><link>https://wiredcraft.com/blog/android-apps-development-kotlin/</link><guid isPermaLink="true">https://wiredcraft.com/blog/android-apps-development-kotlin/</guid><category><![CDATA[Android]]></category><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Kuno Qing]]></dc:creator><pubDate>Tue, 01 Mar 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[The Journey of a Spring Boot application from Java 8 to Kotlin, part 3: Data Classes]]></title><description><![CDATA[<p>Welcome to the third installment of our Java 8 -> Kotlin conversion for a Spring Boot application. <a href="/post/spring-boot-configuration-in-kotlin/">Last time</a> we saw how converting a configuration class to Kotlin helped clean up some of the boilerplate code required in Java.</p>
<p>In this third installment, we are going to continue our theme of "write less code with Kotlin" and look at how <a href="https://kotlinlang.org/docs/reference/data-classes.html">Kotlin data classes</a> help us clean up our POJOs data classes.</p>
<p>Our <a href="https://github.com/mikegehard/user-management-evolution-kotlin/blob/83883fee6dac3cb06e10bd6a510403cbe3e1ef62/components/email/src/main/java/com/example/email/EmailMessage.java">starting point</a> is a plain old Java object (POJO) to hold some data to be sent via RabbitMQ:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">package</span> com.example.email;

<span class="hljs-keyword">import</span> java.io.Serializable;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmailMessage</span> <span class="hljs-title">implements</span> <span class="hljs-title">Serializable</span> </span>{

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String toAddress;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String subject;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String body;

    <span class="hljs-keyword">public</span> EmailMessage(String toAddress, String subject, String body) {
        <span class="hljs-keyword">this</span>.toAddress = toAddress;
        <span class="hljs-keyword">this</span>.subject = subject;
        <span class="hljs-keyword">this</span>.body = body;
    }

    <span class="hljs-keyword">public</span> String getToAddress() {
        <span class="hljs-keyword">return</span> toAddress;
    }

    <span class="hljs-keyword">public</span> String getSubject() {
        <span class="hljs-keyword">return</span> subject;
    }

    <span class="hljs-keyword">public</span> String getBody() {
        <span class="hljs-keyword">return</span> body;
    }
}</code></pre>
<p>Here is the <a href="https://github.com/mikegehard/user-management-evolution-kotlin/blob/f137c5ec25a2a575c30113a3260f55af6d0285ed/components/email/src/main/kotlin/com/example/email/EmailMessage.kt">same class</a> implemented as a <a href="https://kotlinlang.org/docs/reference/data-classes.html">Kotlin data class</a>:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">package</span> com.example.email

<span class="hljs-keyword">import</span> java.io.Serializable

<span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmailMessage</span></span>(<span class="hljs-keyword">val</span> toAddress: String, <span class="hljs-keyword">val</span> subject: String, <span class="hljs-keyword">val</span> body: String) : Serializable</code></pre>
<p>Not only is this code much shorter than it's Java counterpart, it also has more functionality. As a Kotlin data class, this tiny amount of code gets:</p>
<ul>
<li>generated implementations for a <code>equals()/hashCode()</code> pair</li>
<li>a default <code>toString()</code> method</li>
<li>a <code>copy()</code> method that allows for easy altering of individual attributes of the object</li>
<li>the ability to <a href="https://kotlinlang.org/docs/reference/data-classes.html#data-classes-and-destructuring-declarations">destructure</a> the object in an assignment statement.</li>
</ul>
<p>Other places this feature will come in handy is with <a href="https://spring.io/blog/2016/02/15/developing-spring-boot-applications-with-kotlin#jackson-kotlin-module">JSON deserialization</a> and <a href="https://spring.io/blog/2016/02/15/developing-spring-boot-applications-with-kotlin#jackson-kotlin-module">Spring Data JPA classes</a>.</p>
<p>As someone evaluating a switch from Java to Kotlin, these data classes are a major reasons for adopting Kotlin in your Spring Boot application. They help you write, and thus maintain, less code and the less code we have to maintain the better in my mind.</p>
]]></description><link>http://engineering.pivotal.io/post/spring-boot-kotlin-data-classes/</link><guid isPermaLink="true">http://engineering.pivotal.io/post/spring-boot-kotlin-data-classes/</guid><category><![CDATA[Spring Boot]]></category><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Mike Gehard]]></dc:creator><pubDate>Mon, 29 Feb 2016 17:53:00 GMT</pubDate></item><item><title><![CDATA[Как себе выстрелить в ногу в Kotlin]]></title><description><![CDATA[<blockquote>
<p>Пост-наброс</p>
</blockquote>
<h2>Как себе выстрелить в ногу в Kotlin</h2>
<p>Совсем недавно вышел <a href="http://blog.jetbrains.com/kotlin/2016/02/kotlin-1-0-released-pragmatic-language-for-jvm-and-android/">релиз</a> Kotlin, а его команда разработчиков предлагала <a href="https://habrahabr.ru/company/JetBrains/blog/277573/">задавать вопросы</a> про язык. Он сейчас на слуху и, возможно, многим хочется его попробовать.</p>
<p>Пару недель назад тимлид сделал для компании презентацию о том, что в Котлине хорошо. Одним из самых интересных вопросов был «А как в Котлине выстрелить себе в ногу?» Так получилось, что ответил на этот вопрос я.</p>
<p>Disclaimer:
Не стоит воспринимать эту статью как «Kotlin — отстой». Хотя я отношусь скорее к категории тех, кому и со Scala хорошо, я считаю, что язык неплохой.
Все пункты спорные, но раз в год и палка стреляет. Когда-то вы себе прострелите заодно и башку, а когда-то у вас получится выстрелить только в полночь полнолуния, если вы предварительно совершите черный ритуал создания плохого кода.</p>
<p>Наша команда недавно закончила большой проект на Scala, сейчас делаем проект помельче на Kotlin, поэтому в спойлерах будет сравнение со Scala. Я буду считать, что Nullable в Kotlin — это эквивалент Option, хотя это совсем не так, но, скорее всего, большинство из тех, кто работал с Option, будут вместо него использовать Nullable.</p>
<h4>1. Пост-инкремент и преинкремент как выражения</h4>
<p>Цитирую вопрошавшего: «Фу, это ж баян, скучно». Столько копий сломано, миллион вопросов на собеседованиях C++... Если есть привычка, то можно было его оставить инструкцией (statement'ом). Справедливости ради, другие операторы, вроде +=, являются инструкциями.
<a href="https://habrahabr.ru/company/JetBrains/blog/277573/#comment_8784811">Цитирую</a> одного из разработчиков, <a href="https://habrahabr.ru/users/abreslav/">abreslav</a>:</p>
<blockquote>
<p>Смотрели на юзкейсы, увидели, что поломается, решили оставить.</p>
<p>Замечу, что у нас тут не С++, и на собеседовании про инкремент спросить особо нечего. Разве что разницу между префиксным и постфиксным.</p>
</blockquote>
<p>На нет и суда нет. Разумеется, в здравом уме никто так делать не будет, но случайно — может быть.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">var</span> i = <span class="hljs-number">5</span>
i = i++ + i++
println(i)</code></pre>
<blockquote>
<p><strong>Никакого undefined behaviour, результат, очевидно, 12</strong></p>
<p>11</p>
</blockquote>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">var</span> a = <span class="hljs-number">5</span>
a = ++a + ++a
println(a)</code></pre>
<blockquote>
<p><strong>Тут все проще, конечно, 14</strong></p>
<p>13</p>
</blockquote>
<blockquote>
<p><strong>Больше примеров</strong></p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">var</span> b = <span class="hljs-number">5</span>
b = ++b + b++
println(b)</code></pre>
<blockquote>
<p><strong>Банальная логика говорит, что ответ должен быть между 11 и 13</strong></p>
<p>да, 12</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">var</span> c = <span class="hljs-number">5</span>
c = c++ + ++c
println(c)</code></pre>
</blockquote>
<blockquote>
<p><strong>От перестановки мест слагаемых сумма не меняется</strong></p>
<p>разумеется, 12</p>
</blockquote>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">var</span> d = <span class="hljs-number">5</span>
d = d + d++ + ++d + ++d
println(d)

<span class="hljs-keyword">var</span> e = <span class="hljs-number">5</span>
e = ++e + ++e + e++ + e
println(e)</code></pre>
<blockquote>
<p><strong>От перестановки мест слагаемых сумма не меняется!</strong></p>
<p>Разумеется:
25
28</p>
</blockquote>
</blockquote>
<blockquote>
<p><strong>Чё там в Scala?</strong></p>
<p>Ничего интересного, в Scala инкрементов нет. Компилятор скажет, что нет метода ++ для Int. Но если очень захотеть, его, конечно, можно определить.</p>
</blockquote>
<h4>2. Одобренный способ</h4>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> foo: <span class="hljs-built_in">Int</span>? = <span class="hljs-literal">null</span>
<span class="hljs-keyword">val</span> bar = foo!! + <span class="hljs-number">5</span></code></pre>
<blockquote>
<p><strong>Что хотели, то и получили</strong></p>
<p>Exception in thread «main» kotlin.KotlinNullPointerException</p>
</blockquote>
<p>В документации говорится, что так делать стоит только если вы очень хотите получить NullPointerException. Это хороший метод выстрелить себе в ногу: !! режет глаз и при первом взгляде на код все понятно. Разумеется, использование !! предполагается тогда, когда до этого вы проверили значение на null и smart cast по какой-нибудь причине не сработал. Или когда вы почему-то уверены, что там не может быть null.</p>
<blockquote>
<p><strong>Чё там в Scala?</strong></p>
<pre><code class="hljs language-scala"><span class="hljs-keyword">val</span> foo: <span class="hljs-type">Option</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">None</span>
<span class="hljs-keyword">val</span> bar = foo.get + <span class="hljs-number">5</span></code></pre>
<blockquote>
<p><strong>Что хотели, то и получили</strong></p>
<p>Exception in thread «main» java.util.NoSuchElementException: None.get</p>
</blockquote>
</blockquote>
<h4>3. Переопределение invoke()</h4>
<p>Начнем с простого: что делает этот кусок кода и какой тип у a?</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>(){...}
<span class="hljs-keyword">val</span> a = A()</code></pre>
<blockquote>
<p><strong>На глупый вопрос - глупый ответ</strong></p>
<p>Правильно, создает новый объект типа A, вызывая конструктор по умолчанию.</p>
</blockquote>
<p>А здесь что будет?</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> В <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span></span>(){...}
<span class="hljs-keyword">val</span> b = B()</code></pre>
<blockquote>
<p><strong>Ну, наверно, ошибка компиляции будет...</strong></p>
<p>А вот и нет!</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span></span>(){
    <span class="hljs-keyword">var</span> param = <span class="hljs-number">6</span>

    <span class="hljs-keyword">constructor</span>(a: <span class="hljs-built_in">Int</span>): <span class="hljs-keyword">this</span>(){
        param = a
    }

    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span>{
        <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invoke</span><span class="hljs-params">()</span></span> = B(<span class="hljs-number">7</span>)
    }
}</code></pre>
<p>Для класса может быть определена фабрика. А если бы она была в классе A, то там все равно вызывался бы конструктор.</p>
</blockquote>
<p>Теперь вы ко всему готовы:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> С <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span></span>(){...}
<span class="hljs-keyword">val</span> c = C()</code></pre>
<blockquote>
<p><strong>Тут создается объект класса С через фабрику, определенную в объекте-компаньоне класса С.</strong></p>
<p>Конечно же нет!</p>
<pre><code class="hljs language-kotlin">    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span></span>(){
        ...
        <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span>{
            <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invoke</span><span class="hljs-params">()</span></span> = A(<span class="hljs-number">9</span>)
        }
    }</code></pre>
<p>У переменной c будет тип A. Заметьте, что A и С не связаны родственными узами.</p>
</blockquote>
<p><strong>Полный код</strong></p>
<blockquote>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>(){
    <span class="hljs-keyword">var</span> param = <span class="hljs-number">5</span>

    <span class="hljs-keyword">constructor</span>(a: <span class="hljs-built_in">Int</span>): <span class="hljs-keyword">this</span>(){
        param = a
    }

    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span>{
        <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invoke</span><span class="hljs-params">()</span></span>= A(<span class="hljs-number">10</span>)
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span></span>(){
    <span class="hljs-keyword">var</span> param = <span class="hljs-number">6</span>

    <span class="hljs-keyword">constructor</span>(a: <span class="hljs-built_in">Int</span>): <span class="hljs-keyword">this</span>(){
        param = a
    }

    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span>{
        <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invoke</span><span class="hljs-params">()</span></span> = B(<span class="hljs-number">7</span>)
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span></span>(){
    <span class="hljs-keyword">var</span> param = <span class="hljs-number">8</span>

    <span class="hljs-keyword">constructor</span>(a: <span class="hljs-built_in">Int</span>): <span class="hljs-keyword">this</span>(){
        param = a
    }

    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span>{
        <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invoke</span><span class="hljs-params">()</span></span> = A(<span class="hljs-number">9</span>)
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span></span>(){
    <span class="hljs-keyword">var</span> param = <span class="hljs-number">10</span>

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span>(a: <span class="hljs-built_in">Int</span>): <span class="hljs-keyword">this</span>(){
        param = a
    }

    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span>{
        <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invoke</span><span class="hljs-params">(a: <span class="hljs-type">Int</span> = <span class="hljs-number">25</span>)</span></span> = D(a)
    }
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&#x3C;<span class="hljs-type">String</span>>)</span></span> {
    <span class="hljs-keyword">val</span> a = A()
    <span class="hljs-keyword">val</span> b = B()
    <span class="hljs-keyword">val</span> c = C()
    <span class="hljs-keyword">val</span> d = D()
    println(<span class="hljs-string">"<span class="hljs-subst">${a.javaClass}</span>, <span class="hljs-subst">${a.param}</span>"</span>)
    println(<span class="hljs-string">"<span class="hljs-subst">${b.javaClass}</span>, <span class="hljs-subst">${b.param}</span>"</span>)
    println(<span class="hljs-string">"<span class="hljs-subst">${c.javaClass}</span>, <span class="hljs-subst">${c.param}</span>"</span>)
    println(<span class="hljs-string">"<span class="hljs-subst">${d.javaClass}</span>, <span class="hljs-subst">${d.param}</span>"</span>)
}</code></pre>
<p>Результат выполнения:</p>
<p>class A, 5
class B, 7
class A, 9
class D, 10</p>
</blockquote>
<p>К сожалению, придумать короткий пример, где у вас реально все поломается, я не смог. Но пофантазировать немного можно. Если вы вернете левый класс, как в примере с классом C, то скорее всего, компилятор вас остановит. Но если вы никуда не передаете объект, то можно сымитировать утиную типизацию, как в примере. Ничего криминального, но человек, читающий код, может сойти с ума и застрелиться, если у него не будет исходника класса.</p>
<p>Если у вас есть наследование и функции для работы с базовым классом (Animal), а invoke() от одного наследника (Dog) вернет вам другого наследника (Duck), то тогда при проверке типов (Animal as Dog) вы можете накрякать себе беду.</p>
<blockquote>
<p><strong>Чё там в Scala?</strong></p>
<p>В Scala проще — есть new, который всегда вызывает конструктор. Если не будет new, то всегда вызывается метод apply у компаньона (который тоже может вернуть левый тип). Разумеется, если что-то вам не доступно из-за private, то компилятор ругнется. Все то же самое, только очевиднее.</p>
</blockquote>
<h4>4. lateinit</h4>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SlowPoke</span></span>(){
    lateinit <span class="hljs-keyword">var</span> value: String

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>{
        <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span>){ <span class="hljs-comment">//компилятор здесь говорит, что проверка не нужна (и правильно делает)</span>
            println(<span class="hljs-string">"null"</span>)
            <span class="hljs-keyword">return</span>
        }
        <span class="hljs-keyword">if</span> (value == <span class="hljs-string">"ololo"</span>)
            println(<span class="hljs-string">"ololo!"</span>)
        <span class="hljs-keyword">else</span>
            println(<span class="hljs-string">"alala!"</span>)
    }
}
SlowPoke().test()</code></pre>
<blockquote>
<p><strong>Результат предсказуем</strong></p>
<p>Exception in thread «main» kotlin.UninitializedPropertyAccessException: lateinit property value has not been initialized</p>
</blockquote>
<blockquote>
<p><strong>А как правильно?</strong></p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SlowBro</span></span>(){
    <span class="hljs-keyword">val</span> value: String? = <span class="hljs-literal">null</span>

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>{
        <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span>) {
            println(<span class="hljs-string">"null"</span>)
            <span class="hljs-keyword">return</span>
        }
        <span class="hljs-keyword">if</span> (value == <span class="hljs-string">"ololo"</span>)
            println(<span class="hljs-string">"ololo!"</span>)
        <span class="hljs-keyword">else</span>
            println(<span class="hljs-string">"alala!"</span>)
    }
}
SlowBro().test()</code></pre>
<p><strong>Результат</strong></p>
<p>null</p>
</blockquote>
<p>Я бы сказал, что это тоже одобренный способ, но при чтении кода это неочевидно, в отличие от !!. В документации немного завуалированно говорится, что, мол, проверять не надо, если что, мы кинем тебе Exception. По идее, этот модификатор используется тогда, когда вы точно уверены, что поле будет инициализированно кем-то другим. То есть никогда. По моему опыту, все поля, которые были lateinit, рано или поздно стали Nullable. Неплохо это поле вписалось в контроллер JavaFX приложения, где Gui грузится из FXML, но даже это «железобетонное» решение было свергнуто после того, как появился альтернативный вариант без пары кнопок. Один раз так получилось, что в SceneBuilder изменил fx:id, а в коде забыл. В первые дни кодинга на Kotlin немного взбесило, что нельзя сделать lateinit Int. Я могу придумать, почему так сделали, но сомневаюсь, что совсем нет способа обойти эти причины (читай: сделать костыль).</p>
<blockquote>
<p><strong>Чё там в Scala?</strong></p>
<p>А там аналога lateinit как такового и нет. По крайней мере, я не обнаружил.</p>
</blockquote>
<h4>5. Конструктор</h4>
<blockquote>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IAmInHurry</span></span>(){
    <span class="hljs-keyword">val</span> param = initSecondParam()
    <span class="hljs-comment">/*tons of code*/</span>
    <span class="hljs-keyword">val</span> twentySecondParam = <span class="hljs-number">10</span>
    <span class="hljs-comment">/*tons of code*/</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">initSecondParam</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span>{
        println(<span class="hljs-string">"Initializing by default with <span class="hljs-subst">$twentySecondParam</span>"</span>)
        <span class="hljs-keyword">return</span> twentySecondParam
    }

}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IAmInHurryWithStrings</span></span>(){
    <span class="hljs-keyword">val</span> param = initSecondParam()
    <span class="hljs-comment">/*tons of code*/</span>
    <span class="hljs-keyword">val</span> twentySecondParam = <span class="hljs-string">"Default value of param"</span>
    <span class="hljs-comment">/*tons of code*/</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">initSecondParam</span><span class="hljs-params">()</span></span>: String{
        println(<span class="hljs-string">"Initializing by default with <span class="hljs-subst">$twentySecondParam</span>"</span>)
        <span class="hljs-keyword">return</span> twentySecondParam
    }
}
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&#x3C;<span class="hljs-type">String</span>>)</span></span>{
    IAmInHurry()
    IAmInHurryWithStrings()
}</code></pre>
</blockquote>
<blockquote>
<p><strong>Результат</strong></p>
<p>Initializing by default with 0
Initializing by default with null</p>
</blockquote>
<p>Все просто — к полю идет обращение до того, как оно было инициализировано. Видимо, тут стоит немного доработать компилятор. По идее, если вы пишете код хорошо, такая проблема у вас не должна возникнуть, но всякое бывает, не с потолка же я взял этот пример (коллега себе так выстрелил в ногу, случайно через цепочку методов в редко срабатывающем коде вызвал поле, которое было не инициализировано).</p>
<blockquote>
<p><strong>Чё там в Scala?</strong></p>
<p>Все то же самое.</p>
<p>object Initializer extends App{
class IAmInHurry(){
val param = initSecondParam()
/<em>tons of code</em>/
val twentySecondParam = 10
/<em>tons of code</em>/
def initSecondParam(): Int = {
println(s"Initializing by default with $twentySecondParam")
twentySecondParam
}</p>
<p>  }</p>
<p>  class IAmInHurryWithStrings(){
val param = initSecondParam()
/<em>tons of code</em>/
val twentySecondParam = "Default value of param"
/<em>tons of code</em>/
def initSecondParam(): String = {
println(s"Initializing by default with $twentySecondParam")
twentySecondParam
}</p>
<p>  }</p>
<p>  override def main(args: Array[String]){
new IAmInHurry()
new IAmInHurryWithStrings()
}
}</p>
<p><strong>Результат</strong></p>
<p>Initializing by default with 0
Initializing by default with null</p>
</blockquote>
<h4>6. Взаимодействие с Java</h4>
<p>Для выстрела тут простор достаточно большой. Очевидное решение — считать все, что пришло из Java, Nullable. Но тут есть долгая и поучительная <a href="http://blog.jetbrains.com/kotlin/2015/04/upcoming-change-more-null-safety-for-java/">история</a>. Как я понял, она связана в основном с шаблонами, наследованием, и цепочкой Java-Kotlin-Java. И при таких сценариях приходилось делать много костылей, чтобы заработало. Поэтому решили от идеи «все Nullable» отказаться.
Но вроде как один из основных сценариев — свой код пишем на Kotlin, библиотели берем Java (как видится мне, простому крестьянину-кодеру). И при таком раскладе, лучше безопасность в большей части кода и явные костыли в небольшой части кода, которые видно, чем «красиво и удобно» + внезапные грабли в рантайме (или яма с кольями, как повезет). Но у разработчиков другое <a href="https://habrahabr.ru/company/JetBrains/blog/277573/#comment_8784731">мнение</a>:</p>
<blockquote>
<p>Одна из основных причин была в том, что писать на таком языке было неудобно, а читать его — неприятно. Повсюду вопросительные и восклицательные знаки, которые не очень-то помогают из-за того, что расставляются в основном, чтобы удовлетворить компилятор, а не чтобы корректно обработать случаи, когда выражение вычисляется в null. Особенно больно в случае дженериков: например, Map&#x3C;String?, String?>?..</p>
</blockquote>
<p>Сделаем небольшой класс на Java:</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaCopy</span> </span>{
    <span class="hljs-keyword">private</span> String a = <span class="hljs-keyword">null</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">JavaCopy</span><span class="hljs-params">()</span></span>{};

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">JavaCopy</span><span class="hljs-params">(String s)</span></span>{
        a = s;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">get</span><span class="hljs-params">()</span></span>{
        <span class="hljs-keyword">return</span> a;
    }
}</code></pre>
<p>И попробуем его вызвать из Kotlin:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printString</span><span class="hljs-params">(s: <span class="hljs-type">String</span>)</span></span> {
    println(s)
}

<span class="hljs-keyword">val</span> j1 = JavaCopy()
<span class="hljs-keyword">val</span> j1Got = j1.<span class="hljs-keyword">get</span>()
printString(j1Got)</code></pre>
<blockquote>
<p><strong>Результат</strong></p>
<p>Exception in thread «main» java.lang.IllegalStateException: j1Got must not be null</p>
</blockquote>
<p>Тип у j1 — String! и исключение мы получим только тогда, когда вызовем printString. Ок, давайте явно зададим тип:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> j2 = JavaCopy(<span class="hljs-string">"Test"</span>)
<span class="hljs-keyword">val</span> j3 = JavaCopy(<span class="hljs-literal">null</span>)

<span class="hljs-keyword">val</span> j2Got: String = j2.<span class="hljs-keyword">get</span>()
<span class="hljs-keyword">val</span> j3Got: String = j3.<span class="hljs-keyword">get</span>()

printString(j2Got)
printString(j3Got)</code></pre>
<blockquote>
<p><strong>Результат</strong></p>
<p>Exception in thread «main» java.lang.IllegalStateException: j3.get() must not be null</p>
</blockquote>
<p>Все логично. Когда мы явно указываем, что нам нужен NotNullable, тогда и ловим исключение. Казалось бы, указывай у всех переменных Nullable, и все будет хорошо. Но если делать так:</p>
<pre><code class="hljs language-kotlin">printString(j2.<span class="hljs-keyword">get</span>())</code></pre>
<p>то ошибку вы можете обнаружить нескоро.</p>
<blockquote>
<p><strong>Чё там в Scala?</strong></p>
<p>Никаких гарантий, NPE словить можно элементарно. Решение — оборачивать все в Option, у которого, напомню, есть хорошее свойство, что Option(null) = None. С другой стороны, тут нет иллюзий, что java interop безопасен.</p>
</blockquote>
<h4>7. infix нотация и лямбды</h4>
<p>Сделаем цепочку из методов и вызовем ее:</p>
<pre><code class="hljs language-kotlin">    <span class="hljs-function"><span class="hljs-keyword">fun</span><span class="hljs-type">&#x3C;R></span> <span class="hljs-title">first</span><span class="hljs-params">(func: ()</span></span> -> R): R{
        println(<span class="hljs-string">"calling first"</span>)
        <span class="hljs-keyword">return</span> func()
    }

    <span class="hljs-keyword">infix</span> <span class="hljs-function"><span class="hljs-keyword">fun</span><span class="hljs-type">&#x3C;R, T></span> R.<span class="hljs-title">second</span><span class="hljs-params">(func: (<span class="hljs-type">R</span>)</span></span> -> T): T{
        println(<span class="hljs-string">"calling second"</span>)
        <span class="hljs-keyword">return</span> func(<span class="hljs-keyword">this</span>)
    }

    first {
        println(<span class="hljs-string">"calling first body"</span>)
    }
    second {
        println(<span class="hljs-string">"calling second body"</span>)
    }</code></pre>
<p><strong>Результат</strong></p>
<pre><code class="hljs language-kotlin">calling first
calling first body
Oops!
calling second body</code></pre>
<p>Подождите-ка... тут какая-то подстава! И правда, «забыл» один метод вставить:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span><span class="hljs-type">&#x3C;T></span> <span class="hljs-title">second</span><span class="hljs-params">(func: ()</span></span> -> T): T{
    println(<span class="hljs-string">"Oops!"</span>)
    <span class="hljs-keyword">return</span> func()
}</code></pre>
<p>И чтобы заработало «как надо», нужно было написать так:</p>
<pre><code class="hljs language-kotlin">first {
    println(<span class="hljs-string">"calling first body"</span>)
} second {
    println(<span class="hljs-string">"calling second body"</span>)
}</code></pre>
<blockquote>
<p><strong>Результат</strong></p>
<p>calling first
calling first body
calling second
calling second body</p>
</blockquote>
<p>Всего один перенос строки, который легко при переформатировании удалить/добавить переключает поведение. Основано на реальных событиях: была цепочка методов «сделай в background» и «потом сделай в ui треде». И был метод «сделай в ui» с таким же именем.</p>
<blockquote>
<p><strong>Чё там в Scala?</strong></p>
<p>Синтаксис немного отличается, поэтому так просто тут себе не выстрелишь:</p>
<pre><code class="hljs language-scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Infix</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">App</span></span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">first</span></span>[<span class="hljs-type">R</span>](func: () => <span class="hljs-type">R</span>): <span class="hljs-type">R</span> = {
    println(<span class="hljs-string">"calling first"</span>)
    func()
  }

  <span class="hljs-keyword">implicit</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Second</span>[<span class="hljs-type">R</span>](<span class="hljs-params">val value: <span class="hljs-type">R</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">AnyVal</span></span>{
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">second</span></span>[<span class="hljs-type">T</span>](func: (<span class="hljs-type">R</span>) => <span class="hljs-type">T</span>): <span class="hljs-type">T</span> = {
      println(<span class="hljs-string">"calling second"</span>)
      func(value)
    }
  }

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">second</span></span>[<span class="hljs-type">T</span>](func: () => <span class="hljs-type">T</span>): <span class="hljs-type">T</span> = {
    println(<span class="hljs-string">"Oops!"</span>)
    func()
  }

  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]) {
    first { () =>
      println(<span class="hljs-string">"calling first body"</span>)
    } second { () => <span class="hljs-comment">//&#x3C;--------type mismach</span>
      println(<span class="hljs-string">"calling second body"</span>)
    }
  }
}</code></pre>
<p>Зато, пытаясь подогнать скаловский код хотя бы для неочевидности засчет implicit/underscore, я взорвал все вокруг.</p>
<blockquote>
<p><strong>Осторожно! Кровь, кишки и расчлененка...</strong></p>
<pre><code>object Infix2 extends App{
  def first(func: (Unit) => Unit): Unit = {
    println("calling first")
    func()
  }

  implicit class Second(val value: Unit) extends AnyVal{
    def second(func: (Unit) => Unit): Unit = {
      println("calling second")
      func(value)
    }
  }

  def second(func: (Unit) => Unit): Unit = {
    println("Oops!")
    func()
  }

  override def main(args: Array[String]) {
    first { _ =>
      println("calling first body")
    } second { _ =>
      println("calling second body")
    }
  }
}
</code></pre>
<p>И результат:</p>
<pre><code class="hljs language-scala"><span class="hljs-type">Exception</span> in thread <span class="hljs-string">"main"</span> java.lang.<span class="hljs-type">VerifyError</span>: <span class="hljs-type">Operand</span> stack underflow
<span class="hljs-type">Exception</span> <span class="hljs-type">Details</span>:
  <span class="hljs-type">Location</span>:
    <span class="hljs-type">Infix2</span>$<span class="hljs-type">Second</span>$.equals$extension(<span class="hljs-type">Lscala</span>/runtime/<span class="hljs-type">BoxedUnit</span>;<span class="hljs-type">Ljava</span>/lang/<span class="hljs-type">Object</span>;)<span class="hljs-type">Z</span> @<span class="hljs-number">40</span>: pop
  <span class="hljs-type">Reason</span>:
    <span class="hljs-type">Attempt</span> to pop empty stack.
  <span class="hljs-type">Current</span> <span class="hljs-type">Frame</span>:
    bci: @<span class="hljs-number">40</span>
    flags: { }
    locals: { <span class="hljs-symbol">'Infix2</span>$<span class="hljs-type">Second</span>/pre>, <span class="hljs-symbol">'scala</span>/runtime/<span class="hljs-type">BoxedUnit</span>', <span class="hljs-symbol">'java</span>/lang/<span class="hljs-type">Object</span>', <span class="hljs-symbol">'java</span>/lang/<span class="hljs-type">Object</span>', integer }
    stack: { }
  <span class="hljs-type">Bytecode</span>:
    <span class="hljs-number">0000000</span>: <span class="hljs-number">2</span>c4e <span class="hljs-number">2</span>dc1 <span class="hljs-number">0033</span> <span class="hljs-number">9900</span> <span class="hljs-number">0904</span> <span class="hljs-number">3604</span> a700 <span class="hljs-number">0603</span>
    <span class="hljs-number">0000010</span>: <span class="hljs-number">3604</span> <span class="hljs-number">1504</span> <span class="hljs-number">9900</span> <span class="hljs-number">4</span>d2c c700 <span class="hljs-number">0901</span> <span class="hljs-number">5701</span> a700
    <span class="hljs-number">0000020</span>: <span class="hljs-number">102</span>c c000 <span class="hljs-number">33</span>b6 <span class="hljs-number">0036</span> <span class="hljs-number">57</span>bb <span class="hljs-number">0038</span> <span class="hljs-number">59</span>bf <span class="hljs-number">3</span>a05
    <span class="hljs-number">0000030</span>: b200 <span class="hljs-number">1</span>f57 b200 <span class="hljs-number">1</span>fb2 <span class="hljs-number">001</span>f <span class="hljs-number">57</span>b2 <span class="hljs-number">001</span>f <span class="hljs-number">3</span>a06
    <span class="hljs-number">0000040</span>: <span class="hljs-number">59</span>c7 <span class="hljs-number">000</span>c <span class="hljs-number">5719</span> <span class="hljs-number">06</span>c6 <span class="hljs-number">000</span>e a700 <span class="hljs-number">0</span>f19 <span class="hljs-number">06</span>b6
    <span class="hljs-number">0000050</span>: <span class="hljs-number">003</span>c <span class="hljs-number">9900</span> <span class="hljs-number">0704</span> a700 <span class="hljs-number">0403</span> <span class="hljs-number">9900</span> <span class="hljs-number">0704</span> a700
    <span class="hljs-number">0000060</span>: <span class="hljs-number">0403</span> ac
  <span class="hljs-type">Stackmap</span> <span class="hljs-type">Table</span>:
    append_frame(@<span class="hljs-number">15</span>,<span class="hljs-type">Object</span>[#<span class="hljs-number">4</span>])
    append_frame(@<span class="hljs-number">18</span>,<span class="hljs-type">Integer</span>)
    same_frame(@<span class="hljs-number">33</span>)
    same_locals_1_stack_item_frame(@<span class="hljs-number">46</span>,<span class="hljs-type">Null</span>)
    full_frame(@<span class="hljs-number">77</span>,{<span class="hljs-type">Object</span>[#<span class="hljs-number">2</span>],<span class="hljs-type">Object</span>[#<span class="hljs-number">27</span>],<span class="hljs-type">Object</span>[#<span class="hljs-number">4</span>],<span class="hljs-type">Object</span>[#<span class="hljs-number">4</span>],<span class="hljs-type">Integer</span>,<span class="hljs-type">Null</span>,<span class="hljs-type">Object</span>[#<span class="hljs-number">27</span>]},{<span class="hljs-type">Object</span>[#<span class="hljs-number">27</span>]})
    same_frame(@<span class="hljs-number">85</span>)
    same_frame(@<span class="hljs-number">89</span>)
    same_locals_1_stack_item_frame(@<span class="hljs-number">90</span>,<span class="hljs-type">Integer</span>)
    chop_frame(@<span class="hljs-number">97</span>,<span class="hljs-number">2</span>)
    same_locals_1_stack_item_frame(@<span class="hljs-number">98</span>,<span class="hljs-type">Integer</span>)

    at <span class="hljs-type">Infix2</span>$.main(<span class="hljs-type">Infix</span>.scala)</code></pre>
</blockquote>
</blockquote>
<h4>8. Перегрузка методов и it</h4>
<p>Это, скорее, метод подгадить другим. Представьте, что вы пишите библиотеку, и в ней есть функция</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">applier</span><span class="hljs-params">(x: <span class="hljs-type">String</span>, func: (<span class="hljs-type">String</span>)</span></span> -> <span class="hljs-built_in">Unit</span>){
    func(x)
}</code></pre>
<p>Разумеется, народ ее использует довольно прозрачным способом:</p>
<pre><code class="hljs language-kotlin">applier (<span class="hljs-string">"arg"</span>) {
    println(it)
}
applier (<span class="hljs-string">"no arg"</span>) {
    println(<span class="hljs-string">"ololo"</span>)
}</code></pre>
<p>Код компилируется, работает, все довольны. А потом вы добавляете метод</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">applier</span><span class="hljs-params">(x: <span class="hljs-type">String</span>, func: ()</span></span> -> <span class="hljs-built_in">Unit</span>){
    println(<span class="hljs-string">"not applying <span class="hljs-subst">$x</span>"</span>)
    func()
}</code></pre>
<p>И чтобы компилятор не ругался, пользователям придется везде отказаться от it (читай: переписать кучу кода):</p>
<pre><code class="hljs language-kotlin">applier (<span class="hljs-string">"arg"</span>) { it -> <span class="hljs-comment">//FIXED</span>
    println(it)
}
applier (<span class="hljs-string">"no arg"</span>) { -> <span class="hljs-comment">//yes, explicit!</span>
    println(<span class="hljs-string">"ololo"</span>)
}</code></pre>
<p>Хотя, теоретически, компилятор мог бы и угадать, что если есть it, то это лямбда с 1 входным аргументом. Думаю, что с развитием языка и компилятор поумнеет, и этот пункт — временный.</p>
<blockquote>
<p><strong>Чё там в Scala?</strong></p>
<p>Без аргументов придется явно указать, что это лямбда. А при добавлении нового метода поведение не изменится.</p>
<pre><code class="hljs language-scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Its</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">App</span></span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">applier</span></span>(x: <span class="hljs-type">String</span>, func: (<span class="hljs-type">String</span>) => <span class="hljs-type">Unit</span>){
    func(x)
  }

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">applier</span></span>(x: <span class="hljs-type">String</span>, func: () => <span class="hljs-type">Unit</span>){
    println(<span class="hljs-string">"not applying $x"</span>)
    func()
  }

  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]) {
    applier(<span class="hljs-string">"arg"</span>, println(_))
    applier(<span class="hljs-string">"no arg"</span>, _ => println(<span class="hljs-string">"ololo"</span>))
  }
}</code></pre>
</blockquote>
<h4>9. Почему не стоит думать о Nullable как об Option</h4>
<p>Пусть у нас есть обертка для кэша:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cache</span>&#x3C;<span class="hljs-type">T</span>></span>(){
    <span class="hljs-keyword">val</span> elements: MutableMap&#x3C;String, T> = HashMap()

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">put</span><span class="hljs-params">(key: <span class="hljs-type">String</span>, elem: <span class="hljs-type">T</span>)</span></span> = elements.put(key, elem)

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">get</span><span class="hljs-params">(key: <span class="hljs-type">String</span>)</span></span> = elements[key]
}</code></pre>
<p>И простой сценарий использования:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> cache = Cache&#x3C;String>()
cache.put(<span class="hljs-string">"foo"</span>, <span class="hljs-string">"bar"</span>)

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getter</span><span class="hljs-params">(key: <span class="hljs-type">String</span>)</span></span> {
    cache.<span class="hljs-keyword">get</span>(key)?.let {
        println(<span class="hljs-string">"Got <span class="hljs-subst">$key</span> from cache: <span class="hljs-subst">$it</span>"</span>)
    } ?: println(<span class="hljs-string">"<span class="hljs-subst">$key</span> is not in cache!"</span>)
}

getter(<span class="hljs-string">"foo"</span>)
getter(<span class="hljs-string">"baz"</span>)</code></pre>
<blockquote>
<p><strong>Результат довольно предсказуем</strong></p>
<p>Got foo from cache: bar
baz is not in cache!</p>
</blockquote>
<p>Но если мы вдруг захотим к кэше хранить Nullable...</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> cache = Cache&#x3C;String?>()
cache.put(<span class="hljs-string">"foo"</span>, <span class="hljs-string">"bar"</span>)

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getter</span><span class="hljs-params">(key: <span class="hljs-type">String</span>)</span></span> {
    cache.<span class="hljs-keyword">get</span>(key)?.let {
        println(<span class="hljs-string">"Got <span class="hljs-subst">$key</span> from cache: <span class="hljs-subst">$it</span>"</span>)
    } ?: println(<span class="hljs-string">"<span class="hljs-subst">$key</span> is not in cache!"</span>)
}

getter(<span class="hljs-string">"foo"</span>)
getter(<span class="hljs-string">"baz"</span>)

cache.put(<span class="hljs-string">"IAmNull"</span>, <span class="hljs-literal">null</span>)
getter(<span class="hljs-string">"IAmNull"</span>)</code></pre>
<blockquote>
<p><strong>То получится не очень хорошо</strong></p>
<p>Got foo from cache: bar
baz is not in cache!
IAmNull is not in cache!</p>
</blockquote>
<p>Зачем хранить null? Например, чтобы показать, что результат не вычислим. Конечно, тут было бы правильнее использовать Option или Either, но, к сожалению, ни того, ни другого в стандартной библиотеке нет (но есть, например, в <a href="https://github.com/MarioAriasC/funKTionale/wiki">funKTionale</a>). Более того, как раз при реализации Either, я наступил на грабли этого пункта и предыдущего. Решить эту проблему с «двойным Nullable» можно, например, возвратом Pair или специального data class.</p>
<blockquote>
<p><strong>Чё там в Scala?</strong></p>
<p>Никто не запретит сделать Option от Option. Надеюсь, понятно, что так все будет хорошо. Да и с null тоже:</p>
<pre><code class="hljs language-scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">doubleNull</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">App</span></span>{
  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cache</span>[<span class="hljs-type">T</span>]</span>{
    <span class="hljs-keyword">val</span> elements =  mutable.<span class="hljs-type">Map</span>.empty[<span class="hljs-type">String</span>, <span class="hljs-type">T</span>]

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">put</span></span>(key: <span class="hljs-type">String</span>, elem: <span class="hljs-type">T</span>) = elements.put(key, elem)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span></span>(key: <span class="hljs-type">String</span>) = elements.get(key)
  }

  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]) {
    <span class="hljs-keyword">val</span> cache = <span class="hljs-keyword">new</span> <span class="hljs-type">Cache</span>[<span class="hljs-type">String</span>]()
    cache.put(<span class="hljs-string">"foo"</span>, <span class="hljs-string">"bar"</span>)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getter</span></span>(key: <span class="hljs-type">String</span>) {
      cache.get(key) <span class="hljs-keyword">match</span> {
        <span class="hljs-keyword">case</span> <span class="hljs-type">Some</span>(value) => println(<span class="hljs-string">s"Got <span class="hljs-subst">$key</span> from cache: <span class="hljs-subst">$value</span>"</span>)
        <span class="hljs-keyword">case</span> <span class="hljs-type">None</span> => println(<span class="hljs-string">s"<span class="hljs-subst">$key</span> is not in cache!"</span>)
      }
    }

    getter(<span class="hljs-string">"foo"</span>)
    getter(<span class="hljs-string">"baz"</span>)

    cache.put(<span class="hljs-string">"IAmNull"</span>, <span class="hljs-literal">null</span>)
    getter(<span class="hljs-string">"IAmNull"</span>)
  }</code></pre>
<blockquote>
<p><strong>Все хорошо</strong></p>
<p>Got foo from cache: bar
baz is not in cache!
Got IAmNull from cache: null</p>
</blockquote>
</blockquote>
<h4>10. Объявление методов</h4>
<p>Бонус для тех, кто раньше писал на Scala. Спонсор данного пункта — <a href="https://habrahabr.ru/users/lgorsl/">lgorSL</a>.
<a href="https://habrahabr.ru/post/277479/#comment_8779645">Цитирую:</a></p>
<blockquote>
<p>...
Или, например, синтаксис объявления метода:
В scala: def methodName(...) = {...}
В kotlin возможны два варианта — как в scala (со знаком =) и как в java (без него), но эти два способа объявления неэквивалентны друг другу и работают немного по-разному, я однажды кучу времени потратил на поиск такой «особенности» в коде.
...</p>
</blockquote>
<blockquote>
<p>Я подразумевал следующее:</p>
<p>fun test(){ println(«it works») }
fun test2() = println(«it works too»)
fun test3() = {println(«surprise!»)}</p>
<p>Чтобы вывести «surprise», придётся написать test3()(). Вариант вызова test3() тоже нормально компилируется, только сработает не так, как ожидалось — добавление «лишних» скобочек кардинально меняет логику программы.</p>
<p>Из-за этих граблей переход со скалы на котлин оказался немного болезненным — иногда «по привычке» в объявлении какого-нибудь метода пишу знак равенства, а потом приходится искать ошибки.</p>
</blockquote>
<h4>Заключение</h4>
<p>На этом список наверняка не исчерпывается, поэтому делитесь в комментариях, как вы шли дорогой приключений, но потом что-то пошло не так...
У языка много положительных черт, о которых вы можете прочитать на <a href="http://kotlinlang.org/">официальном сайте</a>, в <a href="https://habrahabr.ru/post/277479/">статьях</a> <a href="https://habrahabr.ru/post/268463/">на</a> <a href="https://habrahabr.ru/post/274997/">хабре</a> и еще много где. Но лично я не согласен с некоторыми архитектурными решениями (классы final by default, java interop) и иногда чувствуется, что языку нехватает единообразия, консистентности. Кроме примера с lateinit Int приведу еще два. Внутри блоков let используем it, внутри with — this, а внутри run, <a href="http://beust.com/weblog/2015/10/30/exploring-the-kotlin-standard-library/">который является комбинацией let и this</a> что надо использовать? А у класса String! можно вызвать методы isBlank(), isNotBlank(), isNullOrBlank(), а «дополняющего» метода вроде isNotNullOrBlank нет:( После Scala нехватает некоторых вещей — Option, Either, matching, каррирования. Но в целом язык оставляет приятное впечатление, надеюсь, что он продолжит достойно развиваться.</p>
<p>P.S. Хабровская подсветка Kotlin хромает, надеюсь, что администрация <a href="https://habrahabr.ru/users/habrahabr/">habrahabr</a> это когда-нибудь поправит...</p>
<h4>UPD: Выстрелы от комментаторов (буду обновлять)</h4>
<p><a href="https://habrahabr.ru/post/278169/#comment_8786835">Неочевидный приоритет оператора elvis</a>. Автор — <a href="https://habrahabr.ru/users/senia/">senia</a>.</p>
]]></description><link>https://habrahabr.ru/post/278169/</link><guid isPermaLink="true">https://habrahabr.ru/post/278169/</guid><category><![CDATA[Puzzlers]]></category><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[@ov7a]]></dc:creator><pubDate>Mon, 29 Feb 2016 06:24:00 GMT</pubDate></item><item><title><![CDATA[Kotlin and Ceylon]]></title><description><![CDATA[<p>I recently got a chance to dive into two interesting JVM languages, Kotlin (1.0) and Ceylon (1.2.1). They’re both attempts at being better Javas. My thoughts and observations in no particular order:</p>
<ul>
<li>Kotlin has many commercial users already and it’s the JVM language besides Java and Scala that people talk about at the conferences I attend.</li>
<li>Kotlin is <em>very</em> solid. Except for an obscure type inference bug, I haven’t encountered much in the way of bugs at all. I unfortunately hit quite a few Ceylon bugs in both the compiler and the SDK.</li>
<li>Ceylon has JBoss modules as part of the language. I think it’s exactly the right idea. The fact that Kotlin doesn’t have a language level module system is disappointing. If they’re waiting for Jigsaw, they’ll end up with something inferior.</li>
<li>Both languages have typesafe null. This is the single most important improvement over Java.</li>
<li>Kotlin supports Android very well, which I think explains the popularity of this young language. Who wants to code in pre-Java 8? It helps that Android Studio is based on IntelliJ IDEA. Ceylon does not support Android at all.</li>
<li>Kotlin feels a lot like TypeScript, which I use for the web clients. Helps me switch back and forth. I <em>could</em> use Kotlin in the browser, but I don’t see the point. With both Google and Microsoft backing it, TypeScript is the future of the web (I think both the Kotlin and Ceylon teams should put a bullet in the head of their Javascript backends. It’s a colossal waste of time.)</li>
<li>Ceylon has the best Eclipse support. Kotlin has the best IntelliJ support.</li>
<li>Kotlin has a fast compiler and programs start quickly under the JVM. Ceylon programs takes some time to both compile and launch. While running, they seem to perform equally well.</li>
<li>Kotlin has a quirky object literal syntax (think JSON-ish structures). Ceylon got this one right.</li>
<li>Kotlin has unchecked exceptions, and that’s it. Good. I still don’t know how I’m supposed to deal with errors consistently in Ceylon.</li>
<li>Ceylon has a very nice Tour to get you started. Kotlin, not so much.</li>
<li>Ceylon has reified generics. Ok, so why doesn’t Kotlin have reified generics again? I find no reasonable excuses for this omission.</li>
<li>Kotlin manages to be both terse and readable. It has the right amount of annotations to make intentions clear. Ceylon is basically just as verbose as Java, except when “programming in the small” where list comprehensions and stuff like that shines. The syntax for Ceylon generics is an acquired taste.</li>
<li>Using union types is like driving around in a brand new Ferrari with your mother-in-law in the passenger seat. Mixed emotions. Flow typing and union types are very powerful ideas, but they trick you into not paying attention to proper type abstractions. Result? Unmaintainable and unrefactorable code.</li>
<li>Ceylon lacks overloading because union types and default arg values are supposed to remove the need for them. At times, I still ended up with “overloads” having arbitrary naming schemes.</li>
<li>Both languages have multiple return values, using tuples and destructuring respectively. Useful when contained, but don’t expose this in public signatures if you want readable, maintainable and interop friendly code.</li>
<li>The number one priority of any JVM language? Frictionless interop with Java and the SDK of course. Kotlin gets Java interop exactly right. Ceylon’s Java interop is surprisingly quirky.</li>
</ul>
<p>I ended up liking Kotlin a lot and I’m already using it in a real Android-client, AWS-backend project. Ceylon has a lot of good ideas, but I never felt at home. You should try both languages though.</p>
<p>I’m currently learning Clojure. It will be interesting to see if I can get the chance to finally do a lisp project.</p>
]]></description><link>https://medium.com/@elviraw/kotlin-and-ceylon-3ee011125b7d#.lzdgs065k</link><guid isPermaLink="true">https://medium.com/@elviraw/kotlin-and-ceylon-3ee011125b7d#.lzdgs065k</guid><category><![CDATA[Ceylon]]></category><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Elvira]]></dc:creator><pubDate>Sun, 28 Feb 2016 21:06:00 GMT</pubDate></item><item><title><![CDATA[Kotlin Month Post 1: Assorted Features]]></title><description><![CDATA[<p>To open up Kotlin Month, we’ll look at a small assortment of Kotlin’s features that aren’t big enough to merit their own post and don’t fit into a grouping for the upcoming posts, starting with operator overloading.</p>
<h2>Operator Overloading</h2>
<p>Because of the mess it made in C++, Java decided to not include <a href="https://kotlinlang.org/docs/reference/operator-overloading.html">operator overloading</a>, and it has unfortunately stuck to that decision, presumably because people haven’t made a big enough stink about it. This makes sense if a majority of Java programmers haven’t had much/any experience with a language that does, which I think may be the case at this point.</p>
<p>My opinion is that it isn’t specifically operator overloading that was the problem in C++; the problem was the free reign to invent whatever operators you wanted. This is still technically possible in Kotlin (see the next feature), but it’s still harder to abuse in its case. And obviously, operators can still be abused and used in ways they’re not meant to be, but that applies for just about anything in programming.</p>
<p>Anyway, I really enjoy the increased readability and conciseness of properly used operators over functions, so it’s nice to have.</p>
<h2>Infix “Operator” Methods</h2>
<p>Using the <a href="https://kotlinlang.org/docs/reference/functions.html#infix-notation">infix notation</a> for functions allows Kotlin to allow extending the list of available “operators” without falling into the same deep pit that C++ did by limiting them to legal method names. By doing so, they kept coders from using symbols that had no inherent meaning, making it much more likely that people will be able to decipher the meaning of the operator, assuming it’s named well.</p>
<p>One pointer I would give to those considering infixing one of their functions is that you shouldn’t use them in the case where they’re meant to be chained in a fluent interface. It can become very difficult to distinguish between objects and operators, since they’re all just a bunch of identifiers. A potential exception to this rule is an internal DSL that is meant to be used in a configuration-like file.</p>
<p>For the most part, I don’t think this feature will be used a whole lot, but I can definitely see enough use cases to make it a valuable part of Kotlin.</p>
<h2>Streaming</h2>
<p>Of all the features of all the languages out there, being able to filter, map, and reduce over a collection declaratively is probably my all-time favorite. Kotlin does not disappoint, to this end. Being required to compile to Java 6, they didn’t automatically have access to the new Stream API, so they made their own essentially, called <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/-sequence/index.html">Sequence</a>. It is largely the same idea, but doesn’t support doing the work in parallel. Luckily, it makes up for it by having an even larger set of methods to use. Not only that, but the collections themselves (and even Iterators) have the same set (or at least similar set) of methods as a Sequence, making it so you don’t have to make the Stream or Sequence instance to do a simple filter or map. Unfortunately, doing the calls from a collection or iterator is eager and creates (usually) a List right away. That’s what Sequence is for: to make it lazy.</p>
<p>I really like that they 1) made Iterators be iterable (meaning you can put Iterators directly into a for loop, just like in Python; the iterator() method simply returns “this”) and 2) the streaming methods can be called from iterators, too, so you don’t need an eagerly created collection to start with.</p>
<p>Also, <a href="https://kotlinlang.org/docs/reference/ranges.html">Ranges</a> allow for the quick creation of numbers to iterate over as well as checking if a value is within it.</p>
<p>And Strings are iterable!</p>
<h2>Data Classes</h2>
<p><a href="https://kotlinlang.org/docs/reference/data-classes.html">Data classes</a> are a quick, easy way to make bean-like classes in Kotlin. By annotating a class with “data”, it will use all the properties defined in the primary constructor to define toString(), hashCode(), equals(), and the <a href="https://kotlinlang.org/docs/reference/multi-declarations.html">component functions</a>. It also creates a <a href="https://kotlinlang.org/docs/reference/data-classes.html#copying">copy() method</a> that is pretty awesome.</p>
<p>In an older article, I tried to recreate this for Python, then someone commented that it pretty much already existed as named tuples :P</p>
<h2>Outro</h2>
<p>I could on and on, as everything that Kotlin does differently from Java is generally pretty good, but then I’d be digging a bit too deep into the minutia of it all and bore you. If you want to learn more about it, check out <a href="https://programmingideaswithjake.wordpress.com/kotlin/">my other Kotlin articles</a> or look at <a href="https://kotlinlang.org/docs/reference/">Kotlin’s awesome reference page</a>.</p>
<p>Next week, I’ll be shouting my praises of Kotlin’s decisions about inheritance, its special cases, and defaults.</p>
]]></description><link>https://programmingideaswithjake.wordpress.com/2016/02/27/kotlin-month-post-1-assorted-features/</link><guid isPermaLink="true">https://programmingideaswithjake.wordpress.com/2016/02/27/kotlin-month-post-1-assorted-features/</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Jacob Zimmerman]]></dc:creator><pubDate>Sat, 27 Feb 2016 06:00:00 GMT</pubDate></item><item><title><![CDATA[Kotlin - 2 Years On]]></title><description><![CDATA[<p>I <a href="https://yobriefca.se/blog/2012/07/14/kotlin-heres-what-i-think-for-now/">first played</a> with Kotlin back in 2012, I've written some Android apps with and without it and generally played around with it. Since the <a href="http://blog.jetbrains.com/kotlin/2016/02/kotlin-1-0-released-pragmatic-language-for-jvm-and-android/">release of Kotlin 1.0</a> a few days ago I've decided to jump back into it and see if my original views still hold up.</p>
<blockquote>
<p>Herein lies opinion of the personal kind. Proceed with an open mind.</p>
</blockquote>
<p>Scala is my day job, not only Scala but <strong>legacy/old</strong> Scala. Not only that but <strong>a lot</strong> of legacy/old Scala. Worse still not only a lot of legacy/old Scala but a lot of <strong>other peoples</strong> legacy/old Scala. Thanks to the feature rich and impressively flexible nature of Scala this means there is a lot of sharp edges, unpredictability and a fresh arduous learning curve for each functional area. It can seem like a language designed by <a href="https://en.wikipedia.org/wiki/At%C3%AB">Atë</a> at times.</p>
<p>Java is no better of course, it just resides at the other end of a spectrum, with its anaemic yet rigid feature set and almost pointless type system it's no wonder you see so many over-engineered and baklava-class layered solutions. Yeah Java 8 has improved the language a fair bit but the sacrifices made for backwards compatibility has meant those changes don't often go far enough.</p>
<p>Both Scala and Java require a lot of work to simplify so there has to be a middle ground and I (still) think that middle ground is Kotlin.</p>
<p>Think of Kotlin as C# for the JVM, Scala the Good Parts, Java++ or simply a decent general purpose language that won't require the blood of your first born. It's created by Jetbrains, it's about 5ish years old and just gone version 1.0. It is used extensively on Jetbrains products, being hailed as "Swift for Android" and works seamlessly within a mixed code base. It offers features similar to C# Extension methods, Scala implicits, Scala case classes, multiple inheritance and solid collection functionality like LINQ. It doesn't just ape Scala and C# features but introduces relatively original concepts like <a href="http://kotlinlang.org/docs/reference/delegated-properties.html">delegated properties</a>, <a href="https://kotlinlang.org/docs/reference/delegation.html#class-delegation">class delegation</a> and <a href="https://kotlinlang.org/docs/reference/typecasts.html">typecasting</a>.</p>
<p>I'd also proffer that it has an easier transition from Java to Kotlin than it is for Scala though I have no evidence for this other than my own experience of all 3 languages (including leading mixed skill teams in Scala and Java).</p>
<p>You could ask "but why not one of the other many languages available on the JVM?" and that would be fair. Many JVM languages haven't seen a great deal of traction or remain relatively niche but I think Kotlin is much better placed. It's more "general purpose" than a lot of the alt languages which means it will map better to current practises. It's closer to Java and/or Scala than other languages, it strikes the right balance around the type system with features like type inference and enhanced generics and it doesn't hurt that Jetbrains; a major player in the JVM world; is heavily invested in Kotlins future.</p>
<p>In the two years since I started playing with Kotlin it has aged well. It resisted adding a plethora of features for the sake of it and instead created a core syntax and feature set that allows developers enough wiggle room for being creative without turning them into Wizards of Arcane DSLs. This is a sweet spot for me when it comes to building and supporting a service over many years as it avoids the unnecessary pain that comes from the extreme ends of spectrum that Java and Scala tend to reside. Of course this doesn't mean it's perfect, nothing is. You're still adding another language to a project and taking on the associated baggage that comes with it like tooling differences and additional upskilling. Its not suddenly going to make your organisation move the JVM if they aren't already there. It's also not going to fix all your problems - bad architecture will remain bad architecture and bad patterns will remain bad patterns. However, with that said, <strong>I believe Kotlin will reduce enough of the friction of general software development and maintenance on the JVM to make it worth the investment</strong>.</p>
]]></description><link>https://yobriefca.se/blog/2016/02/24/kotlin-2-years-on/</link><guid isPermaLink="true">https://yobriefca.se/blog/2016/02/24/kotlin-2-years-on/</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[James Hughes]]></dc:creator><pubDate>Wed, 24 Feb 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[The Journey of a Spring Boot application from Java 8 to Kotlin, part 2: Configuration Classes]]></title><description><![CDATA[<p>In the <a href="/post/spring-boot-application-with-kotlin/">first post</a> of this series, we looked at the conversion of a Spring Boot application class from Java 8 to Kotlin. The nice thing about these migrations is that they can be done incrementally since Kotlin plays very nicely with legacy Java. In fact, it was one of the design considerations for the language.</p>
<p>In this second post, we will look at the conversion of a configuration class into Kotlin.</p>
<p>Here is an example of a Spring Boot configuration class as written in Java 8:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">package</span> com.example.billing;

<span class="hljs-keyword">import</span> com.example.billing.reocurringPayments.Service;
<span class="hljs-keyword">import</span> com.example.payments.RecurlyGateway;
<span class="hljs-keyword">import</span> org.springframework.context.<span class="hljs-keyword">annotation</span>.Bean;
<span class="hljs-keyword">import</span> org.springframework.context.<span class="hljs-keyword">annotation</span>.Configuration;

<span class="hljs-meta">@Configuration</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Configuration</span> </span>{
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> com.example.payments.Gateway paymentGateway() {
        <span class="hljs-keyword">return</span> new RecurlyGateway();
    }

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> Service serviceThatMayFail() {
        <span class="hljs-keyword">return</span> new Service();
    }
}</code></pre>
<p>Here is that same configuration class written in Kotlin:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">package</span> com.example.billing

<span class="hljs-keyword">import</span> com.example.billing.reocurringPayments.Service
<span class="hljs-keyword">import</span> com.example.payments.RecurlyGateway
<span class="hljs-keyword">import</span> org.springframework.context.<span class="hljs-keyword">annotation</span>.Bean
<span class="hljs-keyword">import</span> org.springframework.context.<span class="hljs-keyword">annotation</span>.Configuration

<span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Configuration</span> </span>{
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">paymentGateway</span><span class="hljs-params">()</span></span> = RecurlyGateway()

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">serviceThatMayFail</span><span class="hljs-params">()</span></span> = Service()
}</code></pre>
<p>There aren't a bunch of huge differences but here are some of the smaller differences that stand out to me:</p>
<ul>
<li>The Configuration class must be declared open. This is because Spring Boot subclasses your configuration class but Kotlin makes them final by default. See <a href="https://kotlinlang.org/docs/reference/classes.html#inheritance">here</a> for details.</li>
<li>The @Bean functions must be declared open for the same reason as above.</li>
<li>There are no return types on the functions because Kotlin will infer the types. This type inference is one of
my favorite features of Kotlin.</li>
<li>Kotlin has implicit returns (and no braces) for <a href="https://kotlinlang.org/docs/reference/functions.html#single-expression-functions">single-expression functions</a>. When you only have one expression in a function body, Kotlin will automatically assume that you want to return that value so there is no need for an explicit <code>return</code> or braces. For bodies with multiple expressions, the <code>return</code> is still mandatory because the compiler may not be able to guess what the return type is for the function.</li>
<li>No <code>new</code> keyword when initializing an object. This coupled with the type inference, implicit returns and single statement/no braces makes for a nice compact configuration class.</li>
</ul>
<p>Spring configuration classes are a mixed bag for me in Kotlin. The actual code difference is only 4 lines of code (18 vs 14) but the visual noise is significantly reduced in Kotlin. Having to declare both the class and all of the methods as open seems a bit clunky for me but I'm willing to overlook it due to the type inference, lack of return for single expression functions and the other improvements that these classes gain from Kotlin.</p>
<p>Thanks for reading. In our next installment, we will take a look at Spring controllers in Kotlin.</p>
]]></description><link>http://engineering.pivotal.io/post/spring-boot-configuration-in-kotlin/</link><guid isPermaLink="true">http://engineering.pivotal.io/post/spring-boot-configuration-in-kotlin/</guid><category><![CDATA[Spring Boot]]></category><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Mike Gehard]]></dc:creator><pubDate>Tue, 23 Feb 2016 14:29:00 GMT</pubDate></item><item><title><![CDATA[An Introduction to Kotlin]]></title><description><![CDATA[<p><a href="https://kotlinlang.org/">Kotlin</a> is a relatively new language that keeps the good parts of Java while eliminating boilerplate and encouraging better Object Oriented programming style while still allowing a Functional paradigm. Best of all, it’s 100% Java-compatible which allows you to mix it with Java, Groovy, or any other Java-bytecode language. Kotlin is similar in many ways to Groovy by handling a lot of the more mundane aspects of coding in Java but unlike Groovy, which took a Dynamic Typing approach, Kotlin doubled-down on Static typing to help eliminate many of the common annoyances in Java.</p>
<h2>Kotlin Features</h2>
<p>While Kotlin’s entire feature list is far too expansive to discuss in this post I would like to point out some of my favorites coming from a Java background. If you want to dive straight into some Kotlin code there is an <a href="https://github.com/mike-plummer/KotlinCalendar">example program out on GitHub</a> that demonstrates most of the features discussed below.</p>
<h3>Null Safety and Immutability</h3>
<p>By default all variables are enforced as non-nullable by the compiler unless explicitly defined otherwise. By enforcing nullability constraints the compiler can automatically guard you from potential NullPointerExceptions and will, in fact, generate an error if you attempt to write unsafe code.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> myNonNullVariable: ComplexObject = ComplexObject()  <span class="hljs-comment">// Declare non-nullable variable</span>
myNonNullVariable = <span class="hljs-literal">null</span>                              <span class="hljs-comment">// Compilation error, cannot assign null to this variable</span>

<span class="hljs-keyword">val</span> myNullableVariable: ComplexObject?                <span class="hljs-comment">// Declare a variable as nullable</span>
println myNullableVariable.getFieldA()                <span class="hljs-comment">// Compilation error since variable could be null here</span>
println myNullableVariable?.getFieldA()               <span class="hljs-comment">// Use a safe call to guard against NullPointerException</span>
                                                      <span class="hljs-comment">// If variable is null then safe call will return 'null'</span></code></pre>
<p>This null-checking extends throughout Kotlin syntax, even into cast operations:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> variable: Any = <span class="hljs-string">"A string value"</span>
<span class="hljs-keyword">val</span> stringVariable = variable <span class="hljs-keyword">as</span> String                        <span class="hljs-comment">// Unsafe cast that will succeed - note lack of nullability on types</span>

<span class="hljs-keyword">val</span> nullVariable: Any? = <span class="hljs-literal">null</span>
<span class="hljs-keyword">val</span> nullableStringVariable: String? = nullVariable <span class="hljs-keyword">as</span> String?  <span class="hljs-comment">// Unsafe cast that will succeed - note that both sides must specify nullability</span>
<span class="hljs-keyword">val</span> nullableStringVariable2: String? = nullVariable <span class="hljs-keyword">as</span>? String  <span class="hljs-comment">// The line above can also be done using the 'safe cast' operator</span>
<span class="hljs-keyword">val</span> invalidCast = stringVariable <span class="hljs-keyword">as</span> List                       <span class="hljs-comment">// Guaranteed to throw a ClassCastException</span></code></pre>
<p>Kotlin also provides multiple mechanisms for declaring variables. When using the keyword ‘val’ a variable is implicitly treated as immutable meaning the compiler will only define a getter and will generate an error if an attempt is made to reassign. Declaring using ‘var’ means the variable is mutable thus a getter and setter will be generated.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ComplexObject</span> </span>{
    <span class="hljs-keyword">val</span> fieldA: String = <span class="hljs-string">"Value 1"</span>   <span class="hljs-comment">// Non-nullable immutable String (just a getter will be generated)</span>
    <span class="hljs-keyword">var</span> fieldB: String = <span class="hljs-string">"Value 2"</span>   <span class="hljs-comment">// Non-nullable but mutable (will have getter and setter generated)</span>
    <span class="hljs-keyword">var</span> fieldC: String?              <span class="hljs-comment">// Nullable, will require null checks or safe call operator ( ?. )</span>
    <span class="hljs-keyword">val</span> fieldD = <span class="hljs-string">"Value 4"</span>           <span class="hljs-comment">// Type will be inferred if omitted but value is initialized</span>
}</code></pre>
<h3>Boilerplate Reduction</h3>
<p>Much like Groovy, Kotlin handles auto-generating much of the common logic in your programs. As previously discussed Getter and Setter methods are auto-generated but can be overridden with custom logic if desired. In addition, marking a class with the keyword ‘data’ will treat it as a Data Transfer Object and will auto-generate ‘equals’, ‘hashCode’, ‘copy’, and ‘toString’ methods.</p>
<h3>Flexibility</h3>
<p>Classes can overload any standard operator which can aid code brevity and readability. In cases where appropriate operators don’t exist an ‘infix’ function can be declared which enables it to be used without dot notation or parentheses, making it look and behave much like a custom operator.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">// Use infix to declare an "operator" function to allow somewhat cleaner code</span>
<span class="hljs-comment">// This also happens to be an extension function (see below)</span>
<span class="hljs-comment">// In this case, perform a subtraction and return the absolute value of the result</span>
<span class="hljs-keyword">infix</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Long</span>.<span class="hljs-title">absSubtract</span><span class="hljs-params">(input: <span class="hljs-type">Long</span>)</span></span>: <span class="hljs-built_in">Long</span> {
    <span class="hljs-keyword">return</span> Math.abs(<span class="hljs-keyword">this</span> - input)
}

println(<span class="hljs-number">1</span>L absSubtract <span class="hljs-number">5</span>L)  <span class="hljs-comment">// prints positive 4</span></code></pre>
<p>Extension functions can be added to any class at runtime which enables you to add behaviors to classes you use without forcing you to subclass them.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">// Anywhere this function is imported all Duration objects will gain this function</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> Duration.<span class="hljs-title">prettyPrint</span><span class="hljs-params">()</span></span>: String {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"<span class="hljs-subst">${toHours()}</span>:<span class="hljs-subst">${toMinutes() % <span class="hljs-number">60</span>}</span>:<span class="hljs-subst">${get(ChronoUnit.SECONDS) % <span class="hljs-number">60</span>}</span>"</span>
}

Duration.ZERO.prettyPrint()  <span class="hljs-comment">// Outputs '0:0:0'</span></code></pre>
<p>Finally, Kotlin has excellent support for delegating functions and properties to member variables or extended classes. This is an alternative to gaining behaviors through extension and is a really simple way to implement several popular design patterns with minimal code.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">WakeUpProvider</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">wakeUp</span><span class="hljs-params">()</span></span>
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AlarmClock</span></span>() : WakeUpProvider {
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">wakeUp</span><span class="hljs-params">()</span></span> {
        println(<span class="hljs-string">"Alarm Clock woke you up!"</span>)
    }
}

<span class="hljs-comment">// Make WakeUpSystem delegate to 'provider' any 'WakeUpProvider' interface functions</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WakeUpSystem</span></span>(provider: WakeUpProvider) : WakeUpProvider <span class="hljs-keyword">by</span> provider

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>)</span></span> {
    <span class="hljs-keyword">val</span> provider = AlarmClock()
    WakeUpSystem(provider).wakeUp() <span class="hljs-comment">// Prints 'Alarm Clock woke you up!'</span>
}</code></pre>
<h3>The Kotlin Object</h3>
<p>Object is a special type in Kotlin that is very different from Java’s Object base type. Object is a versatile construct that can be used much like ad-hoc objects in JavaScript, easily build a Singleton, or add static-like capabilities to your Kotlin classes.</p>
<h4>Ad-hoc Objects</h4>
<p>Object can be used to generate on-the-fly structures without going through the work of defining a class. When used as part of an expression like this the Object is evaluated as the line is executed which contrasts with other uses of Object that are initialized the first time they are referenced.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">var</span> adhoc = <span class="hljs-keyword">object</span> {
    <span class="hljs-keyword">val</span> first = <span class="hljs-string">"firstValue"</span>
    <span class="hljs-keyword">val</span> second = <span class="hljs-string">"secondValue"</span>
}

println(<span class="hljs-string">"<span class="hljs-subst">${adhoc.first}</span>, <span class="hljs-subst">${adhoc.second}</span>"</span>)    <span class="hljs-comment">// Prints "firstValue, secondValue"</span></code></pre>
<h4>Singleton</h4>
<p>If you need a Singleton you can simply write an Object declaration (contrasted with the Object expression used above) that will behave much like a class with static fields and methods in Java.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">object</span> MySingleton {
    <span class="hljs-keyword">val</span> aSingletonValue = <span class="hljs-string">"ValueA"</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">aSingletonFunction</span><span class="hljs-params">()</span></span> {
        println(<span class="hljs-string">"Yay for Kotlin Objects!"</span>)
    }
}
...
println(MySingleton.aSingletonValue)       <span class="hljs-comment">// Prints "ValueA"</span>
println(MySingleton.aSingletonFunction())  <span class="hljs-comment">// Prints "Yay for Kotlin Objects!"</span></code></pre>
<h4>Companion</h4>
<p>Objects can be used as Companions in Kotlin classes to add static-like properties and functions to the class. The Companion will be constructed only once and shared amongst all instances of the containing class.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassWithCompanion</span> </span>{
    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> {
        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">PrintAMessage</span><span class="hljs-params">()</span></span> {
            println(<span class="hljs-string">"I'm a function in the Companion!"</span>)
        }
    }
}
ClassWithCompanion.PrintAMessage()    <span class="hljs-comment">// Note the 'static' access. Prints "I'm a function in the Companion!"</span></code></pre>
<h3>Java Goodness</h3>
<p>Coming from a Java background? Good news! All the familiar Java concepts and libraries are still available. Interfaces, abstract/inner classes, the Java standard library, generics, enums, etc all are present and for the most part behave in exactly the same way. On top of the basics all the latest features in Java such as Lambdas and Streams are available in Kotlin.</p>
<p>A notable exception is the lack of ‘static’ variables and methods. Often ‘static’ was misused and ended up breaking many precepts of Object Oriented design. In Kotlin this has been supplanted by Object, Companions, and package-level declarations to encourage proper encapsulation and separation of concerns while still providing the same features.</p>
<p>For a more complete comparison of how Kotlin compares with Java I recommend <a href="https://kotlinlang.org/docs/reference/comparison-to-java.html">this article</a>.</p>
<h4>Fixes for Common Annoyances</h4>
<p>Java’s been around long enough for everyone to find a few features they dislike. Kotlin attempts to fix a number of the most common complaints.</p>
<h5>Automatic Casting</h5>
<p>How many times have you written code like this in Java?</p>
<pre><code class="hljs language-java">Object unknownObjectType = ...
<span class="hljs-keyword">if</span> (unknownObjectType <span class="hljs-keyword">instanceof</span> String) {
    String castString = (String) unknownObjectType;    <span class="hljs-comment">// Have to cast in order to treat it like a String</span>
    castString.indexOf(<span class="hljs-string">"abc"</span>);
}</code></pre>
<p>Never fear, you will never have to write that in Kotlin! The Kotlin Compiler is smart enough to track the state of a variable as it executes which means it ‘knows’ everything various conditionals and other constructs tell it.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> unknownObjectType: Any = ...
<span class="hljs-keyword">if</span> (unknownObjectType <span class="hljs-keyword">is</span> String) {
    unknownObjectType.indexOf(<span class="hljs-string">"abc"</span>)    <span class="hljs-comment">// Compiler knows it's a String here so it is auto-cast</span>
}</code></pre>
<h5>Destructuring</h5>
<p>Another common annoyance is that occasionally you need to call a function that returns an object but then have to immediately pull only a subset of fields out of that object. Kotlin supports ‘destructuring’ similar to ECMAScript 2015, and supports destructuring in loop expressions.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> complexObjectCollection: Collection
<span class="hljs-keyword">for</span> ( (fieldA, fieldB) <span class="hljs-keyword">in</span> complexObjectCollection) {
    <span class="hljs-comment">// Variables fieldA and fieldB are accessible here and will be equal to fields</span>
    <span class="hljs-comment">// named 'fieldA' and 'fieldB' from each item in the collection</span>
}</code></pre>
<h5>Generics</h5>
<p>In the Java world generics are certainly a boon, but certain design decisions and limitations leave them with a number of significant gotchas. Most of these are related to the wildcard generic (?) which has been eliminated in Kotlin. Kotlin makes use of new keywords ‘in’ and ‘out’ to help further define generic bounds similar to the PECS (Producer-extend, Consumer-super) concept in Java without the same shortcomings.</p>
<h5>Equality</h5>
<p>Tired of having to remember when it’s safe to use == and doing null-checks before calling ‘.equals(..)’? Kotlin uses == as ‘structural equality’ and === as ‘referential equality’. Put another way, == is the same as calling ‘.equals(..)’ while guarding against null in Java whereas === maps to Java’s ==.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> stringA: String = <span class="hljs-string">"New York"</span>
<span class="hljs-keyword">val</span> stringB: String = <span class="hljs-string">"New "</span> + <span class="hljs-string">"York"</span>
<span class="hljs-keyword">val</span> stringC: String = stringA
println(stringA == stringB)     <span class="hljs-comment">// True, contents are equal</span>
println(stringA === stringB)    <span class="hljs-comment">// False, not the exact same object</span>
println(stringA === stringC)    <span class="hljs-comment">// True, both reference the same object</span></code></pre>
<h5>Inlining</h5>
<p>Finally, for anyone with C or C++ experience I’m sure you’re well-aware that Java doesn’t allow you to request a method be <a href="https://en.wikipedia.org/wiki/Inline_expansion">inlined</a>. Kotlin allows you to mark any function with the ‘inline’ keyword which makes the compiler insert that function’s code anywhere the function is called. At runtime this means fewer function calls at the expense of increasing the size of your compiled artifact. This isn’t necessary for most programs but can be a useful performance tweak especially when calling many lightweight functions in a large loop.</p>
<h3>Exception Handling</h3>
<p>Many people have mixed feelings on this but Kotlin does not have the concept of Checked Exceptions. If a method you’re calling potentially throws an exception you are not required to catch it. This reduces the number of try-catch blocks in your code, especially in situations where you know a normally-checked exception truly can’t be thrown. Other than this, exceptions basically work the same as in Java.</p>
<h2>Environment</h2>
<p>There are a number of options for developing in Kotlin. Excellent IDE support is integrated into IntelliJ IDEA and a plugin is available for Eclipse. Outside of an IDE environment you can compile and run Kotlin using Gradle, Maven, Ant, or standalone command line tools.</p>
<p>Information and downloads for these are available at <a href="https://kotlinlang.org/">kotlinlang.org</a>.</p>
<h2>Testing</h2>
<p>A new 100% Kotlin-based testing framework, Spek, is also under development. For those who have worked with Spock or Mocha it will be very familiar – tests are broken down into a series of nested “given-on-it” clauses to help semantically structure your tests and encourage targeted, readable tests.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DurationExtensionSpecs</span>: <span class="hljs-type">Spek</span></span>() {
    init {
        given(<span class="hljs-string">"A zero duration"</span>) {
            <span class="hljs-keyword">var</span> duration = Duration.ZERO
            on(<span class="hljs-string">"adding time values using method chaining"</span>) {
                duration = duration.plusHours(<span class="hljs-number">2</span>).plusMinutes(<span class="hljs-number">5</span>).plusSeconds(<span class="hljs-number">12</span>)
                it(<span class="hljs-string">"should reflect the expected value"</span>) {
                    shouldEqual(duration.toHours(), <span class="hljs-number">2</span>)
                    shouldEqual(duration.toMinutes() % <span class="hljs-number">60</span>, <span class="hljs-number">5</span>)
                    shouldEqual(duration.<span class="hljs-keyword">get</span>(ChronoUnit.SECONDS) % <span class="hljs-number">60</span>, <span class="hljs-number">12</span>)
                }
            }
        }
    }
}</code></pre>
<p>Thankfully the ever-popular Hamcrest library has been ported over to Kotlin as <a href="https://github.com/npryce/hamkrest">HamKrest</a> which allows you to write very powerful tests the same way you would in JUnit.</p>
<h2>Example</h2>
<p>I’ve coded up a simple example of using Kotlin in a standalone program <a href="https://github.com/mike-plummer/KotlinCalendar">out on GitHub</a>. This program demonstrates much of what I’ve discussed here, including many of Kotlin’s core features and Spek tests.</p>
<h2>Conclusion</h2>
<p>I hope I’ve shown you a few reasons to get excited about Kotlin and want to use it in your next project. Especially now that version 1.0 has dropped it’s never been a better time. Popular frameworks like Spring Boot are <a href="https://spring.io/blog/2016/02/15/developing-spring-boot-applications-with-kotlin">adding support</a> which makes it downright easy to gain the power and expressiveness of Kotlin. If you have any questions leave a comment below. If you would like to see more detail on specific Kotlin features leave that below too; if there’s enough interest I will explore them in future posts. In the meantime, take a look at the <a href="https://github.com/mike-plummer/KotlinCalendar">example code</a> and <a href="https://kotlinlang.org/docs/">Kotlin docs</a>. Happy coding!</p>
]]></description><link>https://objectpartners.com/2016/02/23/an-introduction-to-kotlin/</link><guid isPermaLink="true">https://objectpartners.com/2016/02/23/an-introduction-to-kotlin/</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Mike Plummer]]></dc:creator><pubDate>Tue, 23 Feb 2016 12:00:00 GMT</pubDate></item><item><title><![CDATA[Kotlin 1.0 is finally released!]]></title><description><![CDATA[<p>Last week, there was a wonderful announcement: (see title of post)! No more milestones, betas, or release candidates required! Obviously, release candidates for later versions will be coming out, but now you don’t have to worry about them if you don’t want to.</p>
<p>If you’re like me and were waiting until release before trying to convince company management to consider Kotlin as a development option, now is the time to speak out!</p>
<p>In celebration of Kotlin’s proper release, I will be doing a short series of articles describing some of my favorite things about the language. Starting this weekend with a quick overview of smaller features that I don’t have a ton to say about. I’m calling it Kotlin Month, and I only slightly regret that the first one will be in one month while the others are in the next month :P</p>
<p>Also, you may notice that there’s now a page at the top pertaining to Kotlin articles. This won’t be much more useful than selecting the Kotlin tag from the tag cloud to the right, but it will at least stay there, even if Kotlin posts dwindle far enough to remove the tag from the cloud.</p>
]]></description><link>https://programmingideaswithjake.wordpress.com/2016/02/22/kotlin-1-0-is-finally-released/</link><guid isPermaLink="true">https://programmingideaswithjake.wordpress.com/2016/02/22/kotlin-1-0-is-finally-released/</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Jacob Zimmerman]]></dc:creator><pubDate>Tue, 23 Feb 2016 02:09:00 GMT</pubDate></item><item><title><![CDATA[More Kotlin Features to Love]]></title><description><![CDATA[<p>Constants are important
One of the things that I’ve come to appreciate more and more as a programmer are constants. Before I would have yawned and said big deal why? Now I’d say they are so important as they prevent so many needless bugs. If we are guaranteed that something is not null then we can focus simply on getting our work done instead having to null check the world.</p>
<p>that is gnarly
In Java we used the final keyword to create a constant. Unfortunately the gnarly requirement for using the final keyword is that you must either declare the value inline or set it in the constructor. I’ve run into a fair number of cases where I want something to be final, but don’t know it yet, worse is when it belongs in a class but will not be available until after that class has been constructed and had one of it’s methods executed. Fortunately Kotlin allows us to have constants declared that aren’t required to be set during the constructor. We can use the lazy keyword:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> myConstant : String <span class="hljs-keyword">by</span> Lazy{
     calculateConstant();
}</code></pre>
<p>This allows us to have a constant that is instantiated the first time myConstant is used. This is perfect for two reasons:</p>
<ol>
<li>We don’t need to do this calculation in the constructor(which is bad anyways as it violates SOLID principles by having logic in the constructor other than variable assignment)</li>
<li>The result of the Lazy calculation is cached, and will not be run in subsequent requests(good for expensive calculations)</li>
</ol>
<h2>Sort of Ternary Operator</h2>
<p>While Kotlin doesn’t have a true Ternary Operator it does have an operator that comes close that I had not noticed before:</p>
<pre><code class="hljs language-kotlin">println(listOfStrings?.size ?: <span class="hljs-string">"empty"</span>) <span class="hljs-comment">// will first check if the strings is not null and print the size, or empty if it is null</span></code></pre>
<h2>Kotlin is concise</h2>
<p>The common theme I keep coming back to with Kotlin is that the language allows use to concisely write code. For example in Java if we wanted to execute a block of code if a null check was passed we’d do this:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">object</span> != <span class="hljs-literal">null</span>) {
     <span class="hljs-comment">// do some action with object</span>
}</code></pre>
<p>but in Kotlin we can be more concise and do the following:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">object</span>?.let {
    <span class="hljs-comment">// if object is not null execute what is in the curly braces</span>
}</code></pre>
<p>It’s a much simpler syntax for doing the same thing</p>
<p><img src="http://i.giphy.com/UnQ68p0AVulkQ.gif" alt="Kotlin is concise"></p>
]]></description><link>http://blog.jimbaca.com/2016/02/22/more-kotlin-features-to-love/</link><guid isPermaLink="true">http://blog.jimbaca.com/2016/02/22/more-kotlin-features-to-love/</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Jim Baca]]></dc:creator><pubDate>Mon, 22 Feb 2016 15:44:00 GMT</pubDate></item><item><title><![CDATA[A Very Peculiar, but Possibly Cunning Kotlin Language Feature.]]></title><description><![CDATA[<p>This has caught me by surprise. After studying the <a href="https://kotlinlang.org/">Kotlin language</a> to learn about how to best leverage this interesting new language for <a href="http://www.jooq.org/">jOOQ</a>, I stumbled upon this puzzler. What do you think the following program will print?</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>)</span></span> {
    (<span class="hljs-number">1.</span><span class="hljs-number">.5</span>).forEach {
        <span class="hljs-keyword">if</span> (it == <span class="hljs-number">3</span>)
            <span class="hljs-keyword">return</span>
        print(it)
    }

    print(<span class="hljs-string">"done"</span>)
}</code></pre>
<p>Well... You might have guessed wrong. The above will print:</p>
<pre><code>12
</code></pre>
<p>It will NOT print what most people might expect:</p>
<pre><code>1245done
</code></pre>
<p><strong>Note to those of you who are not surprised</strong>:</p>
<p>The above is peculiar for someone used to working with Java 8, where the following code will indeed print 1245done:</p>
<pre><code class="hljs language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
    IntStream.rangeClosed(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>).forEach(it -> {
        <span class="hljs-keyword">if</span> (it == <span class="hljs-number">3</span>)
            <span class="hljs-keyword">return</span>;

        System.out.print(it);
    });

    System.out.print(<span class="hljs-string">"done"</span>);
}</code></pre>
<p>The syntactical reason is explained in this section of the Kotlin manual:
<a href="https://kotlinlang.org/docs/reference/returns.html">https://kotlinlang.org/docs/reference/returns.html</a></p>
<p>In lambdas / closures, the return statement will not (necessarily) return from the lambda / closure, but from the immediate enclosing scope of the lambda / closure. The rationale has been kindly given to me by Dmitry Jemerov from JetBrains in two tweets:</p>
<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr"><a href="https://twitter.com/lukaseder">@lukaseder</a> <a href="https://twitter.com/kotlin">@kotlin</a> reason is very simple: we want to have lambdas that work exactly like built-in language features (e.g. synchronised)</p>&mdash; Dmitry Jemerov (@intelliyole) <a href="https://twitter.com/intelliyole/status/701729566453321728">February 22, 2016</a></blockquote>
<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr"><a href="https://twitter.com/lukaseder">@lukaseder</a> therefore ‘return’ in a lambda passed to ‘synchronised’ function must do the same as a ‘return’ in a Java ‘synchronised’ block</p>&mdash; Dmitry Jemerov (@intelliyole) <a href="https://twitter.com/intelliyole/status/701729699198799874">February 22, 2016</a></blockquote>
<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
<p>Cunningly, the Kotlin language has removed language-based support for Java constructs like try-with-resources, or the synchronized statement. That’s very reasonable, because these language constructs don’t necessarily belong in the language (<a href="http://blog.jooq.org/2016/01/12/if-java-were-designed-today-the-synchronizable-interface/">as we’ve previously claimed in another blog post</a>), but could be moved to libraries instead. For example:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">// try-with-resources is emulated using an</span>
<span class="hljs-comment">// extension function "use"</span>
OutputStreamWriter(r.getOutputStream()).use {
    it.write(<span class="hljs-string">'a'</span>)
}</code></pre>
<p>(criticism here)</p>
<p>Or:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">// Synchronized is a function!</span>
<span class="hljs-keyword">val</span> x = synchronized (lock, { computation() })</code></pre>
<p>See also:
<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/synchronized.html">https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/synchronized.html</a></p>
<p>After all, even in Java, the language feature only works because the language depends on library types, like Iterable (foreach), AutoCloseable (try-with-resources), or JVM features (monitor on each reference for synchronized)</p>
<h2>So, what’s the deal with return?</h2>
<p>Along the lines of the above rationale, when language designers want to avoid language constructs for things that can be implemented with libraries, but still want you to feel like these were language constructs, then the only reasonable meaning of return inside of such a “construct-ish” lambda / closure is to return from the outer scope. So, when you write something like:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args : <span class="hljs-type">Array</span>)</span></span> {
    <span class="hljs-keyword">val</span> lock = Object()
    <span class="hljs-keyword">val</span> x = synchronized(lock, {
        <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> == <span class="hljs-number">1</span>)
            <span class="hljs-keyword">return</span>

        <span class="hljs-string">"1"</span>
    })

    print(x)
}</code></pre>
<p>The real intention is for this to be the equivalent of the following Java code:</p>
<pre><code class="hljs language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
    Object lock = <span class="hljs-keyword">new</span> Object();
    String x;

    <span class="hljs-keyword">synchronized</span> (lock) {
        <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> == <span class="hljs-number">1</span>)
            <span class="hljs-keyword">return</span>;

        x = <span class="hljs-string">"1"</span>;
    }

    System.out.println(x);
}</code></pre>
<p>In the Java case, obviously, the return statement exits the main() method, because there is no other reasonable stack frame to return from. Unlike in Kotlin, where one might argue the lambda / closure would produce its own stack frame.</p>
<p>But it really doesn’t. The reason for this is the inline modifier on the synchronized function:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&#x3C;R></span> <span class="hljs-title">synchronized</span><span class="hljs-params">(lock: <span class="hljs-type">Any</span>, block: ()</span></span> -> R): R {
    monitorEnter(lock)
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">return</span> block()
    }
    <span class="hljs-keyword">finally</span> {
        monitorExit(lock)
    }
}</code></pre>
<p>See also:
<a href="https://kotlinlang.org/docs/reference/inline-functions.html">https://kotlinlang.org/docs/reference/inline-functions.html</a></p>
<p>Which means that the block closure passed as an argument isn’t really a pure lambda expression, but just syntactic sugar embedded in the call-site’s scope.</p>
<p>Weird. Cunning. Clever. But a bit unexpected.</p>
<p>Is this a good idea? Or will the language designers regret this, later on? Are all lambdas / closures potentially “language construct-ish”, where such a return statement is expected to leave the outer scope? Or are there clear cases where this inline behaviour just makes total sense?</p>
<p>We’ll see. In any case, it is very interesting for a language to have chosen this path.</p>
]]></description><link>http://blog.jooq.org/2016/02/22/a-very-peculiar-but-possibly-cunning-kotlin-language-feature/</link><guid isPermaLink="true">http://blog.jooq.org/2016/02/22/a-very-peculiar-but-possibly-cunning-kotlin-language-feature/</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Puzzlers]]></category><dc:creator><![CDATA[Lukas Eder]]></dc:creator><pubDate>Mon, 22 Feb 2016 15:33:00 GMT</pubDate></item><item><title><![CDATA[Kotlin: Easily storing a list in SharedPreferences with Custom Accessors]]></title><description><![CDATA[<p>SharedPreferences is at its core a simple tool with a deceptively verbose interface that weighs heavily on developer productivity. Kotlin on its own will not necessarily make Java-interfacing code pretty and concise, but you can apply a few particular concepts to create an elegant, downright easy-to-use solution to a common use-case:</p>
<p><strong>Storing a list of strings that will persist across app sessions.</strong></p>
<p>You can write code as if you have a regular old stored List<String> property, with the additional benefit that it is always in sync with SharedPreferences (*):</p>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">// Adding to a list</span>
<span class="hljs-keyword">if</span> (syncingSongIds.indexOf(song.id) == <span class="hljs-number">-1</span>) {
    syncingSongIds += song.id
}

<span class="hljs-comment">// Iterate through a list and do something with each element</span>
syncingSongIds.forEach { id ->
    stopSyncing(id)
}

<span class="hljs-comment">// Best of all: subtracting from a list</span>
<span class="hljs-keyword">val</span> intent = Intent(DONE_SYNCING)
intent.putExtra(<span class="hljs-string">"song"</span>, song)
sendBroadcast(intent) <span class="hljs-comment">// send a broadcast that we're done syncing</span>

syncingSongIds -= song.id <span class="hljs-comment">// and remove the song id from the persisted list of syncing songs</span></code></pre>
<p>If you’re interested, read on.</p>
<p>I’m assuming you’re doing this all inside an object or class with access to a <code>context</code> property.</p>
<p>First of all, let’s set up easy access to the SharedPreferences file we’ll be reading/writing:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> sharedPreferences: SharedPreferences <span class="hljs-keyword">by</span> lazy {
    <span class="hljs-comment">// Replace with your code for accessing shared preferences</span>
    <span class="hljs-comment">// e.g. context.getSharedPreferences(SHARED_PREFERENCES_FILENAME, Context.MODE_PRIVATE)</span>
}</code></pre>
<p>For the uninitiated, the beauty of lazy properties (<code>by lazy</code>) is that they are initialized when you first access the property (i.e. when you first type <code>sharedPreferences</code>, it will call <code>context.getSharedPreferences(...)</code>) and stored from then on, so in this case, you will only ever call <code>context.getSharedPreferences(...)</code> once in the lifetime of your object.</p>
<p><em>Skip this paragraph if you already know what a property without a backing field is</em>. In Java, instance variables are conventionally stored properties. In Kotlin, we get the option to provide completely custom accessors for a property without having any storage for the property. That means we can have a property called <code>count: Float</code> on a class <code>Counter</code> where the property is never actually <strong>stored</strong> on the Counter class. It’s very useful in instances where you want to have a property that wraps data stored somewhere else (database, server) without having to copy that data into the class containing the property. So the count property on Counter might actually be stored in (i.e., “backed by”) a file on disk: every time you increment the counter, it writes directly to the file on disk, and every time you retrieve the counter’s value, it reads directly from the file on disk. <em>While this particular example out of context is not a great idea as it incurs tons of I/O overhead, I feel it effectively illustrates the concept of a non-stored property</em>.</p>
<p>We are going to create a property that reads directly from, and writes directly to, SharedPreferences, using Kotlin’s syntax for custom accessors:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">var</span> syncingSongIds: List
    <span class="hljs-keyword">get</span>() {
        <span class="hljs-keyword">val</span> raw = sharedPreferences.getString(<span class="hljs-string">"syncing_song_ids"</span>, <span class="hljs-literal">null</span>) ?: <span class="hljs-keyword">return</span> emptyList()
        <span class="hljs-keyword">return</span> raw.split(<span class="hljs-string">","</span>)
    }
    <span class="hljs-keyword">set</span>(value) {
        sharedPreferences.edit().putString(<span class="hljs-string">"syncing_song_idslue.joinToString("</span>,<span class="hljs-string">")).apply()
    }</span></code></pre>
<p>That’s actually all you need to do for really simple strings that are guaranteed not to have commas in them.</p>
<p><strong>NB: This will only work for very simple strings. If you want to extend this functionality to be more powerful and accept any string or object type</strong>, try using Google GSON or another JSON serialization library (JSONObject from the Android SDK is perfectly workable, if quirky) and replacing <code>raw.split(",")</code> and <code>value.joinToString(",")</code> with a JSON -> Object, and Object -> JSON conversion respectively.</p>
<p><strong>NB: Because we call <code>apply()</code> in the setter rather than <code>commit</code>, this code is relatively safe to call on the main thread but it does NOT have immediate consistency</strong>. That is, if you call <code>syncingSongIds += "asdf"; print(syncingSongIds)</code> it may not include “asdf” in the printout. <strong>To fix this, change <code>apply()</code> to <code>commit()</code>, but beware of incurring additional overhead</strong> as the setter now has to write to disk synchronously every time it is called. It is your decision as to whether or not to call the setter on the main thread; I think it is relatively safe when done sparingly, but I would certainly keep an eye on that particular setter and make sure it doesn’t adversely impact performance in your app noticeably.</p>
<p>* I’m not making any synchronicity guarantees–maybe as a part two, but ultimately if your code is not thread-safe, you should still modify and test these code snippets to fit your synchronicity needs.</p>
]]></description><link>http://blog.dennislysenko.com/2016/01/22/kotlin-easily-storing-a-list-in-sharedpreferences-with-custom-accessors/</link><guid isPermaLink="true">http://blog.dennislysenko.com/2016/01/22/kotlin-easily-storing-a-list-in-sharedpreferences-with-custom-accessors/</guid><category><![CDATA[Android]]></category><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Dennis Lysenko]]></dc:creator><pubDate>Mon, 22 Feb 2016 12:36:00 GMT</pubDate></item><item><title><![CDATA[Kotlin — Love at first line]]></title><description><![CDATA[<h2>Kotlin — Love at first line</h2>
<p>Kotlin 1.0 has been <a href="https://blog.jetbrains.com/kotlin/2016/02/kotlin-1-0-released-pragmatic-language-for-jvm-and-android/">released</a>
a few days ago and it’s time to check out its awesome features.</p>
<p>For those of you who might have been living under a rock and don’t know what Kotlin is — Kotlin is a new JVM programming language that tries to “fill in the gaps” that Java has. It’s 100% interoperable with Java — meaning that you can have a mixed project that contains Kotlin &#x26; Java classes. The classes are compiled to Java bytecode, and that bytecode is “runnable” on Java6+, which makes it runnable on Android.</p>
<p>The language is awesome, and combined with the <a href="https://github.com/Kotlin/anko">Anko</a> library it’s even <a href="http://www.urbandictionary.com/define.php?term=Awesome-er">awesome-er*</a>. I won’t be explaining the syntax of the language (for that you have the official <a href="https://kotlinlang.org/">page</a>). I’m just going to try and expose a few of it’s awesome features.</p>
<h3><a href="https://kotlinlang.org/docs/reference/functions.html#single-expression-functions">Single-Expression functions</a></h3>
<p>If we have a function that boils down to a single expression, we can use the single-expression function syntax:</p>
<pre><code>override fun equals(other: Any?) = other is Task &#x26;&#x26; other.id == id
</code></pre>
<h3><a href="https://kotlinlang.org/docs/reference/extensions.html">Extensions</a></h3>
<p>Extensions allow us to extend any existing class by adding functions and properties without the need to inherit from that class.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> ViewGroup.<span class="hljs-title">inflate</span><span class="hljs-params">(
    <span class="hljs-meta">@LayoutRes</span> layoutRes: <span class="hljs-type">Int</span>,
    attachToRoot: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">false</span>)</span></span> =

    LayoutInflater
        .from(context)
        .inflate(layoutRes, <span class="hljs-keyword">this</span>, attachToRoot)</code></pre>
<p>The extension function above adds the <strong>.inflate(...)</strong> method to the ViewGroup class, so instead of doing this every time:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> view = LayoutInflater
    .from(parent)
    .inflate(R.layout.todo_list_item, parent, <span class="hljs-literal">false</span>)</code></pre>
<p>now we can just do this:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> view = parent.inflate(R.layout.todo_list_item)</code></pre>
<p>or:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> view = parent.inflate(R.layout.todo_list_item,
    attachToRoot = <span class="hljs-literal">true</span>)</code></pre>
<p>I guess you already noticed that Kotlin also supports <a href="https://kotlinlang.org/docs/reference/functions.html#default-arguments">default arguments</a>.</p>
<h3><a href="https://kotlinlang.org/docs/reference/lambdas.html#lambda-expressions-and-anonymous-functions">Lambda</a></h3>
<p>Intentionally left blank.</p>
<h3><a href="https://kotlinlang.org/docs/reference/null-safety.html">Optionals / Null safety</a></h3>
<p>Forget about NullPointerExceptions. Kotlin has 2 types of variables, nullable and non-nullable. If we declare our variable as non-nullable — the compiler won’t let us assign a null value to it. Only nullable variables can be null.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">var</span> nonNullable: String = <span class="hljs-string">"This is a title"</span> <span class="hljs-comment">// Non-nullable variable</span>
<span class="hljs-keyword">var</span> nullable: String? = <span class="hljs-literal">null</span> <span class="hljs-comment">// Nullable variable</span></code></pre>
<p>In case of the <em>nonNullable</em> variable, we can safely call methods on it, without any null checks, because it <em>cannot have a null value</em>.</p>
<p>In case of the <em>nullable</em> variable, we can safely call methods with the help of the <em>safe-trasversal operator (?.)</em>, and forget about null checks:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> length = nullable?.length</code></pre>
<p>The code above won’t fail, even if the <em>nullable</em> variable has a null value. In that case, the value of the <em>length</em> variable will be <em>null</em>.</p>
<h3><a href="https://kotlinlang.org/docs/reference/null-safety.html#elvis-operator">Elvis operator</a></h3>
<p>The result of a <strong>safe call (?.)</strong> is always a nullable variable. So in cases where we are calling a method on a null variable — the result will be null.</p>
<p>That can be inconvenient sometimes. For example, in the code sample above, we want our <strong>length</strong> variable to be a non-null variable because it’s logical for it to have a value of 0 in case of a null string.</p>
<p>In cases like that, we can use the <strong>elvis operator ( ?: )</strong>.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> length = nullable?.length ?: <span class="hljs-number">0</span></code></pre>
<p>The elvis operator will use the left side value if it’s not null. In case the left side value is null, it will use the right non-nullable value.</p>
<p>You can even use it to make your sanity checks more readable.</p>
<pre><code class="hljs language-kotlin">    ...
}</code></pre>
<p>With help of the elvis operator, the same method in Kotlin will look like this:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">myMethod</span><span class="hljs-params">(str: <span class="hljs-type">String</span>?)</span></span> {
    <span class="hljs-comment">// Sanity check</span>
    str ?: <span class="hljs-keyword">return</span>

    ...
}</code></pre>
<p>The great part of using this is that the compiler will <strong>smart cast</strong> our <strong>str</strong> variable to a non-nullable variable after the “<em>str ?: return</em>” line.</p>
<h3><a href="https://kotlinlang.org/docs/reference/properties.html#properties-and-fields">Optional getters/setters</a></h3>
<p>Unlike in Java, where we are used to define all of our class properties <strong><em>private</em></strong> and write getters and setters, in Kotlin we write getters and setters only if we want to have some custom behaviour.</p>
<p>The simplest definition looks like this:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task</span> </span>{
   <span class="hljs-keyword">var</span> completed = <span class="hljs-literal">false</span>
}</code></pre>
<p>And we can access the property:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> task = Task()
<span class="hljs-keyword">if</span> (task.completed) ...</code></pre>
<p>If we wan’t to expose just the getter and allow setting the value only from within the class:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">var</span> completed = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span></code></pre>
<p>And if we want to have completely custom behaviour:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">var</span> completedInt = <span class="hljs-number">0</span>
<span class="hljs-keyword">var</span> completed: <span class="hljs-built_in">Boolean</span>
    <span class="hljs-keyword">get</span>() = completedInt == <span class="hljs-number">1</span>
    <span class="hljs-keyword">set</span>(value) { completedInt = <span class="hljs-keyword">if</span> (value) <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span> }</code></pre>
<h3><a href="https://kotlinlang.org/docs/reference/delegated-properties.html#lazy">Lazy properties</a></h3>
<p>Kotlin allows us to declare lazy properties — properties that are initialized when we first access them.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> recyclerView <span class="hljs-keyword">by</span> lazy {
    find&#x3C;RecyclerView>(R.id.task_list_new)
}</code></pre>
<p>When we first access the <strong>recyclerView</strong> property, the lambda expression is evaluated and the returned value from the lamdba is saved and returned in that and every subsequent call.</p>
<h3><a href="https://kotlinlang.org/docs/reference/delegated-properties.html#observable">Observable properties</a></h3>
<p>In Kotlin we can observe properties. The syntax for declaring such properties is the following:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">var</span> tasks <span class="hljs-keyword">by</span> Delegates.observable(mutableListOf&#x3C;Task>()) {
    prop, old, new ->
        notifyDataSetChanged()
        dataChangedListener?.invoke()
}</code></pre>
<p>This means that we are going to be notified every time the value of our property changes (the provided lambda will be called).</p>
<h2><a href="https://github.com/Kotlin/anko">Anko extensions</a></h2>
<p>Anko is a great library and has a lot of great extensions. I will list a couple.</p>
<h3>find<T>(id: Int)</h3>
<p>It replaces the findViewById(int id) method. This extension function returns the view already cast to the given type T, so there is no need to cast it.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> recyclerView = find&#x3C;RecyclerView>(R.id.task_list_new)</code></pre>
<h3><a href="https://github.com/Kotlin/anko/blob/master/doc/SQLITE.md#anko-heart-sqlite">SQLite</a></h3>
<p>Anko has great support for SQLite databases. For a complete overview, check their <a href="https://github.com/Kotlin/anko/blob/master/doc/SQLITE.md#anko-heart-sqlite">guide</a>. I will just show you one example:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">allTasks</span><span class="hljs-params">()</span></span> = use {
    select(table)
        .orderBy(completed)
        .orderBy(priority, SqlOrderDirection.DESC)
        .exec {
            parseList(parser)
        }
}</code></pre>
<p>The <strong>use {...}</strong> function opens the database for us, and closes it after the given lambda executes. So we don’t have to worry about closing it anymore and can forget about all those <strong>try {...} catch(...) {...} finally {...}</strong> blocks. Inside the lambda that we pass to the <strong>use</strong> function, <strong>this</strong> references our database. That is the power of Kotlin’s <strong>type-safe builders</strong>. Read more about them <a href="http://blog.jetbrains.com/kotlin/2011/10/dsls-in-kotlin-part-1-whats-in-the-toolbox-builders/">here</a> and <a href="https://kotlinlang.org/docs/reference/type-safe-builders.html">here</a>.</p>
<p>The <strong>select(...)...exec {}</strong> call chain, selects data from the database. And the <strong>parseList(parser)</strong> call parses the rows of data and returns a list of objects, that our <strong>parser</strong> returns. The definition of our <strong>parser</strong> is:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> parser = rowParser {
    id: <span class="hljs-built_in">Int</span>, name: String, priority: <span class="hljs-built_in">Int</span>, completed: <span class="hljs-built_in">Int</span> ->
    Task(id, name, priority, completed)
}</code></pre>
]]></description><link>https://medium.com/@dime.kotevski/kotlin-love-at-first-line-7127befe240f#.p5hp6dxlh</link><guid isPermaLink="true">https://medium.com/@dime.kotevski/kotlin-love-at-first-line-7127befe240f#.p5hp6dxlh</guid><category><![CDATA[Anko]]></category><category><![CDATA[Android]]></category><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Dimitar Kotevski]]></dc:creator><pubDate>Sun, 21 Feb 2016 12:13:00 GMT</pubDate></item><item><title><![CDATA[(RU) Радио-Т 484]]></title><description><![CDATA[<ul>
<li><a href="http://thenextweb.com/dd/2016/02/15/kotlin-the-pragmatic-language-for-android-and-jvm-has-reached-its-1-0-release/">Kotlin дорос до версии 1.0</a> - 00:02:45.</li>
<li><a href="https://dzone.com/articles/kotlin-10-is-now-available">В чем его прагматизм</a> - 00:12:57.</li>
<li>Версия 3 iTerm2 - 00:42:04.</li>
<li>Странная история борьбы Apple - 00:52:37.</li>
<li>GitHub добавил поддержку шаблонов - 01:10:35.</li>
<li>Go 1.6 - 01:15:12.</li>
<li>Страшный баг угрожает нашим серверам - 01:21:21.</li>
<li>Архитектура Stack Overflow на 2016 - 01:26:33.</li>
<li>Custom Machine Types - конфигурации по вкусу - 01:31:15.</li>
<li>Темы наших слушателей</li>
</ul>
]]></description><link>https://radio-t.com/p/2016/02/20/podcast-484/</link><guid isPermaLink="true">https://radio-t.com/p/2016/02/20/podcast-484/</guid><category><![CDATA[Podcast]]></category><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Umputun, Bobuk, Gray, Ksenks]]></dc:creator><pubDate>Sat, 20 Feb 2016 15:44:00 GMT</pubDate><enclosure url="http://cdn.radio-t.com/rt_podcast484.mp3" length="72259834" type="audio/mpeg"/></item><item><title><![CDATA[(RU) DevZen Podcast: Kotlin и Vulkan 1.0 — Episode 0080.]]></title><description><![CDATA[<p>Темы выпуска: Сравнение разных конфигурации сети в Kubernetes, Kotlin наконец вышел в версии 1.0, Vulkan тоже вышел в 1.0, критическая уязвимость в glibc, ZFS в Ubuntu 16.04, снова Rust, и про Монады. И, конечно, ответы на вопросы слушателей.</p>
<p>Шоу нотес:</p>
<ul>
<li>Вакансия C++ &#x26; Scala Software Engineer</li>
<li>Comparison of Networking Solutions for Kubernetes — Comparison of Networking Solutions for Kubernetes 2 documentation</li>
<li><a href="http://blog.jetbrains.com/kotlin/2016/02/kotlin-1-0-released-pragmatic-language-for-jvm-and-android/">Kotlin 1.0 Released: Pragmatic Language for JVM and Android | Kotlin Blog</a></li>
<li>Go 1.6 is released — The Go Blog</li>
<li>Does FreeBSD support OpenGL 3.3?</li>
<li>Unable to build Assimp on FreeBSD 10.2 · Issue #795 · assimp/assimp · GitHub</li>
<li>Vulkan — Industry Forged</li>
<li>Vulkan in 30 minutes</li>
<li>OpenNews: Опубликован графический стандарт Vulkan 1.0</li>
<li>Khronos Products</li>
<li>Vulkan 1.0 Released: What You Need To Know About This Cross-Platform, High-Performance Graphics API — Phoronix</li>
<li>PVS-Studio покопался в ядре FreeBSD</li>
<li>Критическая уязвимость библиотеки glibc позволяет осуществлять удаленное выполнение кода / Блог компании Positive Technologies / Хабрахабр</li>
<li>FreeBSD and CVE-2015-7547</li>
<li>OpenNews: В Ubuntu 16.04 будет добавлена поддержка ZFS и Vulkan</li>
<li>From the Canyon Edge: ZFS is <em>the</em> FS for Containers in Ubuntu 16.04!</li>
<li>There is No Now — ACM Queue</li>
<li>select * from depesz; » Blog Archive » Waiting for 9.6 – Remove GROUP BY columns that are functionally dependent on other columns.</li>
<li>Hint Bits — PostgreSQL wiki</li>
<li>Speeding up things with hint bits — Cybertec — The PostgreSQL Database Company</li>
<li>Introduction to Windows shellcode development – Part 3 – Security Café</li>
<li>The latest high-end Ubuntu phone will be available globally | ZDNet</li>
<li>CharybdeFS: a new fault-injecting filesystem for software testing</li>
<li>Red Book, 5th ed. Ch. 6: Weak Isolation and Distribution</li>
<li>PostgreSQL: Documentation: 9.5: Transaction Isolation</li>
<li>[Libevent-users] Comparison of libevent and libuv</li>
<li>Kazuho’s Weblog: The reasons I stopped using libuv for H2O</li>
<li>Using non-blocking and asynchronous I/O (CK10 problem) in Linux and Windows (with epool, iocp, libevent/libev/libuv/boost.asio and librt/libaio) | Rui’s Blog</li>
<li>Запах монад по утрам — Прогулки по воде</li>
<li>Темы и вопросы слушателей для 0080 « DevZen Podcast</li>
</ul>
]]></description><link>http://devzen.ru/episode-0080/</link><guid isPermaLink="true">http://devzen.ru/episode-0080/</guid><category><![CDATA[Podcast]]></category><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[DevZen Podcast]]></dc:creator><pubDate>Sat, 20 Feb 2016 11:34:00 GMT</pubDate><enclosure url="http://devzen.ru/download/2016/devzen-0080-2016-02-19-3280e712a2cc1485.mp3" length="55240704" type="audio/mpeg"/></item><item><title><![CDATA[The Kobalt diaries: testing]]></title><description><![CDATA[<p>Kobalt automatically detects how to run your tests based on the test dependencies that you declared:</p>
<pre><code class="hljs language-kotlin">dependenciesTest {
    compile(<span class="hljs-string">"org.testng:testng:6.9.9"</span>)
}</code></pre>
<p>By default, Kobalt supports TestNG, JUnit and Spek. You can also configure how your tests run with the test{} directive:</p>
<pre><code class="hljs language-Kotlin">test {
    args(<span class="hljs-string">"-excludegroups"</span>, <span class="hljs-string">"broken"</span>, <span class="hljs-string">"src/test/resources/testng.xml"</span>)
}</code></pre>
<p>The full list of configuration parameters can be found in the <a href="https://github.com/cbeust/kobalt/blob/master/modules/kobalt-plugin-api/src/main/kotlin/com/beust/kobalt/TestDirective.kt#L6">TestConfig</a> class.</p>
<p>Additionally, you can define multiple test configurations, each with a different name. Each configuration will create an additional task named "test" followed by the name of that configuration. For example:</p>
<pre><code class="hljs language-Kotlin">test {
    args(<span class="hljs-string">"-excludegroups"</span>, <span class="hljs-string">"broken"</span>, <span class="hljs-string">"src/test/resources/testng.xml"</span>)
}

test {
    name = <span class="hljs-string">"All"</span>
    args(<span class="hljs-string">"src/test/resources/testng.xml"</span>)
}</code></pre>
<p>The first configuration has no name, so it will be launched with the task "test", while the second one can be run with the task "testAll".</p>
<p>The full series of articles on Kobalt can be found <a href="http://beust.com/weblog/category/kobalt/">here</a>.</p>
]]></description><link>http://beust.com/weblog/2016/02/20/the-kobalt-diaries-testing/</link><guid isPermaLink="true">http://beust.com/weblog/2016/02/20/the-kobalt-diaries-testing/</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Kobalt]]></category><dc:creator><![CDATA[Cédric Beust]]></dc:creator><pubDate>Sat, 20 Feb 2016 10:35:00 GMT</pubDate></item><item><title><![CDATA[(RU) Немного о Kotlin.]]></title><description><![CDATA[<p><img src="https://habrastorage.org/getpro/habr/post_images/b30/fc2/317/b30fc231752f0d1d270b4c80538a28dc.jpg" alt="Kotlin"></p>
<p>На днях JetBrains после пятилетней работы выпустила первый релиз языка Kotlin. Давайте посмотрим, что же это за язык, попробуем разобраться зачем и для кого он, какие имеет функциональные особенности. Скорее всего в статью затесались и личные впечатления от языка, но я старался, чтобы они не влияли на изложение полезной информации. Если вы еще ничего или почти ничего не знаете о Kotlin, то я завидую вам, ибо по моему ощущению почитать про инструмент, который ты долго ждал, сродни распаковке новогоднего подарка. Впрочем судите сами.</p>
<h2>Что такое Котлин</h2>
<p>Котлин — это небольшой остров в Финском заливе недалеко от Санкт-Петербурга. Видимо, тем самым создатели дают отсылку к тому, что новый язык, как остров Котлин — младший русский брат далекого острова <a href="https://ru.wikipedia.org/wiki/%D0%AF%D0%B2%D0%B0">Ява</a>.</p>
<h2>Для кого этот язык</h2>
<p>Действительно, новый язык компилируется в JVM байт-код (есть еще и компиляция в JavaScript, но так как релиз компилятора именно в JVM, эту тему придется опять отложить). А это значит, что он может заинтересовать всех, кто имеет дело с Java-машиной и в целом с языками со сборщиком мусора (а с выходом релиза компиляции в JavaScript покрытие и возможности будут еще шире).</p>
<h2>Простой и совместимый</h2>
<p>Две главных особенности котлина, на мой взгляд, это его простота и полная совместимость с Java. Котлин создавался компанией, которая делает очень много продуктов на Java и которая хорошо разбирается в современных инструментах разработки. Запрос на новый язык витает в воздухе давно, но сделать такой язык, который бы позволил взять (огромную) готовую кодовую базу Java, обычных Java-разработчиков, дать им новый инструмент и бесшовно (но более эффективно) продолжать разработку — такого инструмента до появления котлина не существовало. Создатели нового языка, на мой взгляд, очень хорошо почувствовали потребности бизнеса и разработчиков: бизнесу дали возможность увеличить эффективность разработчиков, а разработчикам дать современный инструмент для разработки. И когда я говорю о «современном инструменте», я, конечно, имею ввиду не только компилятор, но и поддержку в IDE, без которой лично моя деятельность разработчика мне видится совсем немыслимой.
В итоге: простота позволяет использовать язык почти любому Java-разработчику, который готов потратить полчаса на то, чтобы посмотреть туториал или спецификацию языка, обратная совместимость же позволяет использовать язык в уже существующем проекте.</p>
<h2>Production-ready</h2>
<p>Конечно, в первую очередь, запрос на этот язык был у самой JetBrains, отсюда и некоторое понимание, каким он должен быть. Более того, JetBrains же внутри компании его и тестировала: к моменту выхода этого релиза у компании уже есть как минимум один <a href="https://blog.jetbrains.com/dotnet/2016/01/13/project-rider-a-csharp-ide/">крупный продукт сделанный чисто на котлине</a> (да, я понимаю, что платформа по прежнему написана на Java). Отсюда можно предположить, что заявления о готовности языка к продакшену не голословны. А из своего же опыта использования котлина с 2012 года могу сказать, что из тех проблем, с которыми я сталкивался в дорелизные времена, до релиза ни одна не дожила. Есть еще небольшие проблемы с плагином для IDEA, но сам компилятор работает как часы.</p>
<h2>Совместим с Java 1.6</h2>
<p>Это очень важный момент, ведь именно эта версия Java используется во всех современных версиях Android, и, не смотря на <a href="http://venturebeat.com/2015/12/29/google-confirms-next-android-version-wont-use-oracles-proprietary-java-apis/">запланированный переход на OpenJDK</a>, восьмая версия попадет в руки разработчикам под мобильные устройства не так скоро как хотелось бы. Конечно, есть всякие ретролямбды и другие ухищрения, но котлин — это не только лямбды для андроид, но и современный язык, позволяющий сделать разработку под андроид <a href="https://kotlinlang.org/docs/tutorials/android-plugin.html">проще</a> и приятней без особых затрат. А увеличение размера apk совсем не значительно по нынешним временам: 823KB (для версии 1.0.0)</p>
<h2>Особенности</h2>
<p>Полный список возможностей, конечно, лучше искать в <a href="https://kotlinlang.org/docs/reference/">документации</a>, я же постараюсь отразить наиболее важные на мой взгляд моменты в общих словах:</p>
<h2>Null safety</h2>
<p>Почему-то исторически так сложилось, что <a href="https://kotlinlang.org/docs/reference/null-safety.html">эта</a> особенность котлина вспоминается первой. И хотя она безусловно важна, на мой взгляд не является важнейшей. Здесь язык позволяет, определяя переменные, поля, константы и тд, указать, может ли в них храниться ссылка на null. Поднимает на новый уровень идею аннотаций вроде @Nullable и NotNull, позволяет умно приводить к не-nullable типу после проверки её на null. Надо отметить, что бывают случаи, когда эта особенность расходится с моим закостенелым разработкой на Java представлением о том как должны быть сделаны некоторые вещи, но после некоторого раздумья хорошее решение всегда находится.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">/* вопросом помечаем, что может прийти null */</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">someFunction</span><span class="hljs-params">(someNullableParam:<span class="hljs-type">SomeType</span>?)</span></span> {
    <span class="hljs-keyword">if</span>(someNullableParam != <span class="hljs-literal">null</span>) {
         <span class="hljs-comment">// smart cast. Компилятор видит, что передаваемое</span>
         <span class="hljs-comment">// значение не null и разрешает его передать в функцию</span>
        anotherFunction(someNullableParam)
    }
}

<span class="hljs-comment">/* здесь же уже null не пройдет, в попытке передать
 * null или nullable значение компилятор выдаст ошибку */</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">anotherFunction</span><span class="hljs-params">(someParam:<span class="hljs-type">SomeType</span>)</span></span> {
    <span class="hljs-comment">// делаем что-то без опаски, что переданное значение null</span>
}</code></pre>
<h2>Выведение типов</h2>
<p>Да, котлин почти везде где возможно, умеет вывести тип, однако тип всё же придется определить для публичных методов и свойств, что очень разумно (мне подсказывают, что это неправда — с какой-то версии это убрали):</p>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">// Kotlin в курсе, что здесь List&#x3C;Char></span>
<span class="hljs-keyword">val</span> result = sequenceOf(<span class="hljs-number">10</span>).map { it.toString() }.flatMap { it.toCharArray().asSequence() }.toList()</code></pre>
<h2>Extension methods</h2>
<p><a href="https://kotlinlang.org/docs/reference/extensions.html">Возможность</a>, которой мне остро не хватает в Java для увеличения гибкости языка и решений. Заключается в возможности определить метод для типа отдельно от его (типа) объявления. Такая функция, конечно, не будет виртуальной и никак не меняет класса, которому мы добавляем метод, однако позволяет добавить как утилитарную функциональность для уже существующего кода, так и разгрузить интерфейс от этих же утилитарных методов.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Vector2</span> </span>{
    <span class="hljs-keyword">val</span> x:<span class="hljs-built_in">Float</span> <span class="hljs-comment">// это не поле, а ридонли свойство (property)</span>
    <span class="hljs-keyword">val</span> y:<span class="hljs-built_in">Float</span> <span class="hljs-comment">// в Java были бы методы getX() и getY()</span>
}

<span class="hljs-comment">/* Extension property. Без поля в классе, просто getLength() */</span>
<span class="hljs-keyword">val</span> Vector2.length:<span class="hljs-built_in">Float</span>
    <span class="hljs-keyword">get</span>() = (x * x + y  * y).sqrt() <span class="hljs-comment">// притворимся, что такая extension-функция для Float уже существует</span>

<span class="hljs-comment">/* переопределяем оператор + */</span>
<span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> Vector2.<span class="hljs-title">plus</span><span class="hljs-params">(other:<span class="hljs-type">Vector2</span>)</span></span>:Vector2 = createVector(x+<span class="hljs-keyword">this</span>.x, y+<span class="hljs-keyword">this</span>.y) <span class="hljs-comment">// какой-то способ создать новый вектор</span>

<span class="hljs-comment">/* без тела, после знака = пишем одно выражение */</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> Vector2.<span class="hljs-title">dot</span><span class="hljs-params">(x: <span class="hljs-type">Float</span>, y: <span class="hljs-type">Float</span>)</span></span>: <span class="hljs-built_in">Float</span> = x * <span class="hljs-keyword">this</span>.x + y * <span class="hljs-keyword">this</span>.y

<span class="hljs-comment">/* Помечая функцию с одним параметром как infix,
 * мы позволяем вызывать её через пробел: v1 dot v2 */</span>
<span class="hljs-keyword">infix</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> Vector2.<span class="hljs-title">dot</span><span class="hljs-params">(vec2: <span class="hljs-type">Vector2</span>)</span></span>: <span class="hljs-built_in">Float</span> = dot(vec2.x, vec2.y)

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">usage</span><span class="hljs-params">(vec1:<span class="hljs-type">Vector2</span>, vec2:<span class="hljs-type">Vector2</span>)</span></span> {
    <span class="hljs-keyword">val</span> dotProduct = vec1 dot vec2
    <span class="hljs-keyword">val</span> sum = vec1 + vec2 <span class="hljs-comment">// на выходе новый вектор</span>
    <span class="hljs-keyword">val</span> length = sum.length <span class="hljs-comment">// обращаемся просто как к свойству</span>

}</code></pre>
<h2>Лямбды</h2>
<p>Конечно, как любой современный язык с претензией на возможности функцинального программирования, у котлина функция — это сущность первого класса, если переводить дословно. Т.е. функции можно не только объявлять прямо в пакете (из джавы они видны всё равно в классах — по имени файла), но и передавать в качестве параметров, возвращать из других функций и тд. И сейчас, конечно, никого этим не удивишь, но например в сравнении с Java, где синтаксически функций как таковых нет (а только функциональные интерфейсы), в котлине полноценный синтаксис для объявления функции:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">/* передаем в одну функцию другую -- принимает в параметр Int
 * и Int же возвращает. Возвращаем её же, только с фиксированным
 * значением в качестве параметра */</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">passTen</span><span class="hljs-params">(func: (<span class="hljs-type">Int</span>)</span></span>-><span class="hljs-built_in">Int</span> ): ()-><span class="hljs-built_in">Int</span> {
    <span class="hljs-keyword">return</span> { func(<span class="hljs-number">10</span>) }
}</code></pre>
<h2>Extension-лямбды</h2>
<p>Наряду с extension-методами, это еще одна моя любимая фича. Позволяет определить лямбду, которая будет еще и extension-методом. Звучит не очень, да. Посмотрим на примере:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">World</span></span>(<span class="hljs-keyword">val</span> name:String = <span class="hljs-string">"world"</span>)

<span class="hljs-keyword">val</span> printName:World.()-><span class="hljs-built_in">Unit</span> = {
     <span class="hljs-comment">// интерполяцией в синтаксисе языка сейчас уже</span>
     <span class="hljs-comment">// никого не привлечь на темную сторону</span>
    println(<span class="hljs-string">"Hello <span class="hljs-subst">$name</span>"</span>)
}

<span class="hljs-keyword">val</span> world = World()

 <span class="hljs-comment">// вызываем нашу функцию как будто это метод нашего класса!</span>
world.printName()</code></pre>
<p>Эта возможность особенно интересно смотрится в <a href="https://kotlinlang.org/docs/reference/type-safe-builders.html">билдерах</a>, посмотреть на которые я предлагаю вам самостоятельно — на случай, если вам интересно, как получаются вот такие конструкции:</p>
<pre><code class="hljs language-kotlin">html {
    head {
      title {+<span class="hljs-string">"XML encoding with Kotlin"</span>}
    }
    body {
      h1 {+<span class="hljs-string">"XML encoding with Kotlin"</span>}
      a(href = <span class="hljs-string">"http://kotlinlang.org"</span>) {+<span class="hljs-string">"Kotlin"</span>}
    }
}</code></pre>
<h2>Inline-фукнции</h2>
<p>Помечая функцию как inline мы просим компилятор поместить её по месту использования. Чаще всего такими вещами занимается рантайм, но есть кейзы, когда мы точно знаем, что фукнция это просто шорткат для какого-то действия — особенно эффективно это работает с передаваемыми лямбдами:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">/* передаваемой лямбдой block сейчас уже никого не удивишь.
 * Главно, что лишних затрат на вызов этой функции не будет вообще,
 * иногда мне кажется, что это что-то вроде макросов */</span>
<span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">lock</span><span class="hljs-params">(lock:<span class="hljs-type">Lock</span>, block:()</span></span>-><span class="hljs-built_in">Unit</span>) {
    lock.lock()
    <span class="hljs-keyword">try</span> {
        block()
    } <span class="hljs-keyword">finally</span> {
        lock.unlock()
    }
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">usage</span><span class="hljs-params">()</span></span> {
    lock(Lock()) {
        <span class="hljs-comment">// делаем что-то внутри блокировки</span>
    }
}</code></pre>
<p>Конечно, на такие функции накладывается серия ограничений, подробнее см. <a href="https://kotlinlang.org/docs/reference/inline-functions.html">документацию</a>.</p>
<h2>Делегирование</h2>
<p>В котлине есть два типа делегирования. <a href="https://kotlinlang.org/docs/reference/delegation.html">Первый</a>, который позволяет делегировать все методы реализуемого интерфейса к какому-то инстансу этого типа:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Connection</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">connect</span><span class="hljs-params">()</span></span>
}

<span class="hljs-comment">/* здесь мы видим стандартный для котлина синтаксис определения
 * класса вместе с параметрами конструктора и свойствами --
 * в данном случае connection будет и в конструкторе и в поле.
 * Есть возможность определить и множественный конструктор
 * см https://kotlinlang.org/docs/reference/classes.html#constructors
 * И, наконец, мы видим что класс реализует интерфейс Connection, все методы
 * которого делегируются к переданному в конструктор экземпляру Connection-а.
 * При желании их конечно можно переопределить в теле класса */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectionWrapper</span></span>(<span class="hljs-keyword">val</span> connection:Connection) : Connection <span class="hljs-keyword">by</span> connection</code></pre>
<p>У этого синтаксиса есть ряд ограничений. Например, инстанс для делегирования должен быть известен до вызова конструктора.</p>
<p>Второй тип делегирования — это <a href="https://kotlinlang.org/docs/reference/delegated-properties.html">delegated properties</a>. Позволяет определить объект с методами get (и set для var), к которым будет осуществляться делегирование доступа при обращении к свойству объекта.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>{
    <span class="hljs-comment">/* это делегат из стандартной библиотеки,
       позволяет отложить инициализацию поля
       до первого обращения к нему */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> someProeprty <span class="hljs-keyword">by</span> lazy { HavyType() }
}</code></pre>
<h2>Generics</h2>
<p>Создатели котлина несколько <a href="https://kotlinlang.org/docs/reference/generics.html">улучшили</a> Java-дженерики. Из-за совместимости с джавой не всё получилось как хотелось бы, но им удалось исправить много неприятных моментов, которые не учли их предшественники при работе над Java 5.</p>
<h2>Деструктуризация</h2>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> (first, second) = someFunc()</code></pre>
<p>Чтобы такой код заработал, возвращаемое значение из someFunc() должно быть типа, у которого есть (можно extension) методы component1(), component2():</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">component1</span><span class="hljs-params">()</span></span>:String = <span class="hljs-string">"test"</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">component2</span><span class="hljs-params">()</span></span>:<span class="hljs-built_in">Int</span> = <span class="hljs-number">10</span>
}
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">someFunc</span><span class="hljs-params">()</span></span>:Foo = Foo()

<span class="hljs-comment">// или так, to -- в это такой infix extension-метод определенный</span>
<span class="hljs-comment">// для Any, который создает экземпляр класса Pair, метод hashMapOf</span>
<span class="hljs-comment">// в свою очередь принимает vararg параметр таких пар</span>
<span class="hljs-keyword">val</span> map = hashMapOf(<span class="hljs-number">1</span> to <span class="hljs-string">"test"</span>)
<span class="hljs-keyword">for</span> ((id, name) <span class="hljs-keyword">in</span> map) {
    <span class="hljs-comment">//  такой синтаксис возможен, потому что для Map-а определен метод iterator()</span>
    <span class="hljs-comment">// возвращающий набор Map.Entry, а для него в свою очередь определены два</span>
    <span class="hljs-comment">// extension-метода component1() и component2()</span>
}</code></pre>
<h2>Data-классы</h2>
<p>Сахар компилятора для создания бинов:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bean</span></span>(<span class="hljs-keyword">val</span> a:String, <span class="hljs-keyword">val</span> b:<span class="hljs-built_in">Int</span>)</code></pre>
<p>Создает бин с полями + автогенерирует equals+hashCode+toString()+componentN из раздела выше, что позволяет писать такой код:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">someFunc</span><span class="hljs-params">()</span></span>:Bean = Bean(<span class="hljs-string">"test"</span>, <span class="hljs-number">10</span>)
<span class="hljs-keyword">val</span> (a, b) = someFunc()</code></pre>
<p>Полезная вещь, но о нюансах см. пункт «О грустном».</p>
<h2>Стандартная библиотека</h2>
<p>Конечно, нельзя не упомянуть и <a href="https://kotlinlang.org/api/latest/jvm/stdlib/index.html">стандартную библиотеку</a>. Так как котлин нацелен в первую очередь на работу вместе с Java, то и целиком своей стандартной библиотеки у него нет. Большая часть стандартной библиотеки Kotlin нацелена на улучшение и исправление библиотеки старшего брата — Java. Однако, это тема для другой большой статьи.</p>
<h2>О грустном</h2>
<p>Вы могли подумать, что это идеальный продукт, но нет, есть и неприятные моменты:</p>
<h2>IDE</h2>
<p>Над плагином еще работать и работать, периодически выдает эксепшены, плохо умеет в toString() в дебаге, а так же любит промахиваться по ссылке на исходник, иногда (видимо из за особенностей инлайна) путает где поставлен брэкпоинт и тому подобные проблемы. Это всё конечно со временем наверняка поправят, но сейчас мы имеем именно это.</p>
<h2>Data-классы</h2>
<p>Надо признать, что идея была хорошая, но в данный момент есть масса <a href="https://kotlinlang.org/docs/reference/data-classes.html">ограничений</a>, наложенных на этот тип классов, что позволяет их использовать в сильно более ограниченном числе кейзов, нежели хотелось бы. Создатели языка обещают поработать над решением этой проблемы, но пока так.</p>
<h2>Некоторая неряшливость</h2>
<p>Конечно, неряшливость в первую очередь в головах, но краткость синтаксиса иногда играет злую шутку, и местами код выглядит неважно. Возможно, наличие стайл-гайда несколько эту проблему исправило бы, но пока иногда приходится постараться, чтобы не только хорошо работало, но и красиво выглядело. Особенно на мой субъективный взгляд страшно выглядят get, set для свойств.</p>
<h2>В заключение</h2>
<p>Одной статьёй невозможно охватить все особенности и аспекты языка, но я и не пытался. Моей задачей было познакомить с языком, может быть обратить на него внимание. Тот, кто заинтересовался, сможет найти больше в <a href="https://kotlinlang.org/docs/reference/">документации</a>, посмотреть <a href="https://github.com/JetBrains/kotlin">исходники</a>, <a href="http://try.kotlinlang.org/">попробовать</a>, <a href="https://habrahabr.ru/company/JetBrains/blog/277573/">задать вопрос</a>. Сложно предсказать популярность этого языка, но уже сейчас видно, что такого продукта многие ждали, проекты на котлине появляются как грибы, а после релиза частота их появления увеличится еще. По моему впечатлению, языка хорошо сбалансирован и продуман — во время написания кода, складывается ощущение, что всё на своем месте. Если вы используете jvm или любой другой язык со сборкой мусора, есть смысл обратить внимание на котлин. Лично для меня, котлин — это тот инструмент, которого я долго ждал и теперь не представляю, как мог бы обходиться без него.</p>
]]></description><link>https://habrahabr.ru/post/277479/</link><guid isPermaLink="true">https://habrahabr.ru/post/277479/</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Review]]></category><dc:creator><![CDATA[@fogone]]></dc:creator><pubDate>Sat, 20 Feb 2016 08:25:00 GMT</pubDate></item><item><title><![CDATA[Using Mockito for unit testing with Kotlin (1/x)]]></title><description><![CDATA[<p>Dependencies:</p>
<pre><code class="hljs language-gradle"><span class="hljs-comment">// Android stuff...</span>
<span class="hljs-keyword">dependencies</span> {
    <span class="hljs-comment">//...</span>
    <span class="hljs-keyword">compile</span> <span class="hljs-string">"org.jetbrains.kotlin:kotlin-stdlib:1.0.0"</span>

    testCompile <span class="hljs-string">'junit:junit:4.12'</span>
    testCompile <span class="hljs-string">'org.mockito:mockito-core:2.0.42-beta'</span>
    testCompile(<span class="hljs-string">'com.squareup.assertj:assertj-android:1.1.1'</span>) {
        <span class="hljs-keyword">exclude</span> <span class="hljs-keyword">group</span>: <span class="hljs-string">'com.android.support'</span>, module: <span class="hljs-string">'support-annotations'</span>
    }
}</code></pre>
<h2>Little Notes</h2>
<ul>
<li>All the functions AND PROPERTIES should be open, by default functions and properties are final and mockito cant mock them.</li>
<li><strong>DONT USE</strong> spy functions make tests fail bc of some weird crash (<em>if someone had use them right comment!!</em>).</li>
</ul>
<h2>Example</h2>
<p>We will show:</p>
<ol>
<li><code>Settings</code>: manage settings storage, where to store them and which ones.</li>
<li><code>SettingsView</code>: ...</li>
<li><code>SettingsPresenter</code>: manage the bussiness logic for the settings.</li>
</ol>
<p>You may have a class <code>Settings</code>:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Settings</span></span>(context: Context) {
    <span class="hljs-keyword">val</span> localCache = LocalCache(context)

    <span class="hljs-keyword">open</span> <span class="hljs-keyword">var</span> playJustWithHeadphones: <span class="hljs-built_in">Boolean</span>
        <span class="hljs-keyword">get</span>() = localCache.<span class="hljs-keyword">get</span>(<span class="hljs-string">"headphones"</span>, <span class="hljs-literal">false</span>)
        <span class="hljs-keyword">set</span>(value) = localCache.put(<span class="hljs-string">"headphones"</span>, value)
}</code></pre>
<p>Then a presenter that use those settings:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SettingsPresenter</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> mSettings: Settings? = <span class="hljs-literal">null</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> mView: SettingsView? = <span class="hljs-literal">null</span>

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(view: <span class="hljs-type">SettingsView</span>, settings: <span class="hljs-type">Settings</span>)</span></span> {
        mView = view
        mSettings = settings

        view.setHeadphonesToggleCheck(settings.playJustWithHeadphones)
    }
}</code></pre>
<p>Check that mocked Settings class <strong>is open</strong> and mocked var property <strong>is open</strong></p>
<p>Then the tests passing:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SettingsPresenterTests</span> </span>{
    <span class="hljs-meta">@Mock</span> lateinit <span class="hljs-keyword">var</span> mockedView: SettingsView
    <span class="hljs-meta">@Mock</span> lateinit <span class="hljs-keyword">var</span> mockedSettings: Settings
    lateinit <span class="hljs-keyword">var</span> presenter: SettingsPresenter

    <span class="hljs-meta">@Before</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span></span> {
        MockitoAnnotations.initMocks(<span class="hljs-keyword">this</span>)
        presenter = SettingsPresenter()
    }

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test_onCreate_updateGui</span><span class="hljs-params">()</span></span> {
        Mockito.`<span class="hljs-keyword">when</span>`(mockedSettings.playJustWithHeadphones).thenReturn(<span class="hljs-literal">true</span>)
        presenter.onCreate(mockedView, mockedSettings)

        Mockito.verify(mockedView).setHeadphonesToggleCheck(<span class="hljs-literal">true</span>)
    }
}</code></pre>
<h2>Notes</h2>
<ul>
<li>Using <code>lateinit</code> to let the variables be initialized on <code>@Before</code> and avoid using <code>?</code> or <code>!!</code> all over the tests.</li>
<li><code>SettingsView</code> and <code>Settings</code> are mocked using <code>MockitoAnnotations</code></li>
</ul>
]]></description><link>http://makingiants.com/blog/using-mockito-for-unit-tests-with-kotlin-1x/</link><guid isPermaLink="true">http://makingiants.com/blog/using-mockito-for-unit-tests-with-kotlin-1x/</guid><category><![CDATA[Android]]></category><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[MAKINGIANTS]]></dc:creator><pubDate>Sat, 20 Feb 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[Weekend resources for new Kotlin programmers]]></title><description><![CDATA[<p><a href="https://www.jetbrains.com/"><img src="http://www.globalnerdy.com/wordpress/wp-content/uploads/2016/02/jetbrains.png" alt="jetbrains"></a>Over the years, <a href="https://www.jetbrains.com/">JetBrains</a> have released a number of nice development tools. Many of you from the .NET world live and die by <a href="https://www.jetbrains.com/resharper/">ReSharper,</a> the add-on that supercharges Visual Studio and takes a lot of drudgery and donkey-work out of .NET development. If you’re a Java developer tired of the nightmare of self-flagellation that is Eclipse, you probably use <a href="https://www.jetbrains.com/idea/">IntelliJ IDEA,</a> which is a far nice environment to work in. And if you’re building Android apps, you probably are still giving thanks for <a href="http://developer.android.com/tools/studio/index.html">Android Studio,</a> which was built on IntelliJ.</p>
<p><a href="http://kotlinlang.org/"><img src="http://www.globalnerdy.com/wordpress/wp-content/uploads/2016/02/kotlin.jpg" alt="kotlin"></a><strong>Six years ago, JetBrains embarked on a project to build a new programming language named <a href="https://kotlinlang.org/">Kotlin</a></strong> after an island near St. Petersburg, Russia, where one of their development teams is based. <strong><a href="http://blog.jetbrains.com/kotlin/2016/02/kotlin-1-0-released-pragmatic-language-for-jvm-and-android/">On February 15, 2016, JetBrains announced the 1.0 release of Kotlin,</a></strong> which in their own words, “works everywhere where Java works”:</p>
<ul>
<li>IntelliJ IDEA, Android Studio and Eclipse</li>
<li>Maven, Gradle and Ant</li>
<li><a href="https://spring.io/blog/2016/02/15/developing-spring-boot-applications-with-kotlin">Spring Boot</a> (Kotlin support released today!)</li>
<li>GitHub, Slack and even Minecraft <img src="http://i2.wp.com/blog.jetbrains.com/kotlin/wp-includes/images/smilies/simple-smile.png?w=640" alt=":)"></li>
</ul>
<p>You can <a href="http://try.kotlinlang.org/">try out Kotlin online</a> or on your own development environment:</p>
<ul>
<li><strong>IntelliJ IDEA</strong> (<a href="https://www.jetbrains.com/idea/download/">Ultimate or Community</a>): just create a Kotlin project or a Kotlin file in a Java project</li>
<li><strong>Android Studio</strong>: install the plugin through <em>Plugin Manager</em></li>
<li><strong>Eclipse</strong>: install the plugin through <a href="https://marketplace.eclipse.org/content/kotlin-plugin-eclipse">Marketplace</a></li>
</ul>
<p>...then download <a href="https://kotlinlang.org/docs/kotlin-docs.pdf">its documentation</a> from the official site, after which you should check out these perfect-for-weekend-enjoyment resources...</p>
<h3>First, a little reading material</h3>
<p><img src="http://www.globalnerdy.com/wordpress/wp-content/uploads/2016/02/why-kotlin-is-my-next-programming-language.jpg" alt="why kotlin is my next programming language"></p>
<p>Start with <a href="https://medium.com/@octskyward">Mike Hearn’s</a> essay on Medium, <em>Why Kotlin is my next programming language</em>. It lays out a pretty complete list of reasons why you’d want to take up development with Kotlin. If you’re convinced by the end of the essay, continue with the videos below...</p>
<h3>The <em>Fragmented</em> podcast on Kotlin</h3>
<p><a href="http://fragmentedpodcast.com/2015/10/"><img src="http://www.globalnerdy.com/wordpress/wp-content/uploads/2016/02/fragmented.png" alt="fragmented"></a>If you’re going for a walk, run, bike ride, or to the gym, and you’d like to find out more about Kotlin, <a href="http://fragmentedpodcast.com/2015/10/">check out the October 2015 edition of the Android-centric <em>Fragmented</em> podcast in which hosts Donn Felker and Kaushik Gopal talk about Kotlin with Hadi Hariri, JetBrain’s developer advocacy lead.</a> This one’s pretty in depth and runs 1 hour and 25 minutes.</p>
<h3>Fun with Kotlin</h3>
<p><a href="https://www.linkedin.com/in/ederb">Eder Bastos,</a> and Android developer at <a href="http://www.raizlabs.com/">Raizlabs</a>, takes under 8 minutes to provide a nice tour of the Kotlin programming language and why you should consider it for your next Android project. This was published January 14, 2016:</p>
<iframe src="https://www.youtube.com/embed/ZlQhmkp_jyk?rel=0" allowfullscreen="allowfullscreen" height="540" frameborder="0" width="960"></iframe>
<h3>Kotlin: New Hope in a Java 6 Wasteland</h3>
<p><a href="https://github.com/pardom">Michael Pardo</a> gave a Kotlin talk at <a href="http://droidcon.nyc/2015/">Droidcon NYC 2015</a> on August 27, 2015:</p>
<iframe src="https://www.youtube.com/embed/0BiPmgk3nyw?rel=0" allowfullscreen="allowfullscreen" height="540" frameborder="0" width="960"></iframe>
<h3>Kotlin: The Swift of Android</h3>
<p>Here’s <a href="https://github.com/svtk">Svetlana Isakova</a> of <a href="https://www.jetbrains.com/">JetBrains</a> (creator of Kotlin, Android Studio, ReSharper and a whole lot of IDEs) at <a href="http://de.droidcon.com/">DroidCon Berlin</a> on June 4, 2015:</p>
<iframe src="https://www.youtube.com/embed/-BvN0X5tqjw?rel=0" allowfullscreen="allowfullscreen" height="540" frameborder="0" width="960"></iframe>
<h3>Android Development with Kotlin</h3>
<p>Presented by <a href="http://jakewharton.com/">Jake Wharton</a> at the <a href="http://www.meetup.com/androidkw/">AndroidKW Meetup</a> in Waterloo, Canada, December 3, 2015:</p>
<iframe src="https://www.youtube.com/embed/A2LukgT2mKc?rel=0" allowfullscreen="allowfullscreen" height="540" frameborder="0" width="960"></iframe>
<p>You may also want to take a look at these other Android/Kotlin presentations by Jake Wharton:</p>
<ul>
<li><a href="http://jakewharton.com/presentation/2015-11-07-gdg-devfest/">Advancing Android Development with Kotlin</a> GDG DevFest (Dublin, Ireland, November 7, 2015)</li>
<li><a href="http://jakewharton.com/presentation/2015-11-06-oredev/">Advancing Android Development with the Kotlin Language</a> Øredev (Malmö, Sweden, November 6, 2015)</li>
</ul>
<h3>Functional Programming with Kotlin</h3>
<p>Here’s a talk by Mike Hearn (the same Mike Hearn who wrote <em>Why Kotlin is my next programminglanguage</em>) where he shows Kotlin in action, with an emphasis on functional programming. This one was posted November 5, 2015, and he’s demonstrating using a pre-1.0-beta version:</p>
<iframe src="https://www.youtube.com/embed/AhA-Q7MOre0?rel=0" allowfullscreen="allowfullscreen" height="540" frameborder="0" width="960"></iframe>
]]></description><link>http://www.globalnerdy.com/2016/02/20/weekend-resources-for-new-kotlin-programmers/</link><guid isPermaLink="true">http://www.globalnerdy.com/2016/02/20/weekend-resources-for-new-kotlin-programmers/</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Joey deVilla]]></dc:creator><pubDate>Sat, 20 Feb 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[(RU) Kotlin 1.0. Задай вопрос команде.]]></title><description><![CDATA[<h2>Kotlin 1.0. Задай вопрос команде</h2>
<p>На этой неделе случилось важное для нас событие — <a href="http://blog.jetbrains.com/kotlin/2016/02/kotlin-1-0-released-pragmatic-language-for-jvm-and-android/">вышла первая версия</a> языка программирования <a href="http://kotlinlang.org/">Kotlin</a>! Так как почти вся разработка Kotlin велась в Питерском офисе компании JetBrains, многие хабровчане уже знают, что такое Kotlin и пробовали его на практике, поэтому этот пост больше для комментариев: задавайте любые вопросы и команда Kotlin ответит. Мы онлайн!</p>
<p><img src="https://habrastorage.org/getpro/habr/post_images/2f8/f4e/685/2f8f4e6857445ecef579ae6e96e80c60.png" alt="Kotlin"></p>
<p>Для тех, кто слышит о Kotlin впервые, а так же для затравки разговора, несколько фактов о Kotlin:</p>
<ul>
<li>Kotlin — это “прагматичный” язык для JVM и Android, который мы в JetBrains написали, для того чтобы нам было на чем программировать ;)
<em>Kotlin имеет ту же облаcть применимости, что и Javа, и совместим со всеми современными технологиями и инструментами:
</em> <a href="http://kotlinlang.org/docs/tutorials/getting-started.html">IntelliJ IDEA</a>, <a href="http://kotlinlang.org/docs/tutorials/kotlin-android.html">Android Studio</a>, <a href="http://kotlinlang.org/docs/tutorials/getting-started-eclipse.html">Eclipse</a>
<em> <a href="http://kotlinlang.org/docs/reference/using-maven.html">Maven</a>, <a href="http://kotlinlang.org/docs/reference/using-gradle.html">Gradle</a>, <a href="http://kotlinlang.org/docs/reference/using-ant.html">Ant</a>
</em> <a href="https://spring.io/blog/2016/02/15/developing-spring-boot-applications-with-kotlin">Spring Boot</a></li>
<li>Kotlin полностью <a href="http://kotlinlang.org/docs/reference/java-interop.html">совместим с Java</a>. В смешанных проектах код на Kotlin может легко вызывать код на Java и наоборот. Соответственно, все существующие Java-библиотеки доступны из Kotlin.</li>
<li>В Kotlin нелегко получить Null Pointer Exception, потому что система типов исключает это.</li>
<li>Kotlin позволяет <a href="http://kotlinlang.org/docs/reference/extensions.html">создавать функции-расширения</a> для существующих классов. Поэтому стандартная библиотека не определяет свои классы коллекций, но предоставляет кучу удобных функций для работы с JDK коллекциями</li>
<li>Начиная с версии 1.0 мы гарантируем бинарную совместимость. Так что теперь можно ;)</li>
<li>Нас много! За январь Kotlin использовало больше 11 тысяч человек, из них 5 тысяч за последнюю неделю. Почти 2 тысячи человек общаются в нашем Slack-канале и помогают друг другу. Сейчас в команде Kotlin больше двадцати человек. В JetBrains написано около 500К строчек кода на Kotlin, более чем в десяти проектах, а в открытых репозиториях на GitHub (исключая наши) число строчек растет экспоненциально, и на момент релиза их уже больше двух миллионов: <img src="https://habrastorage.org/getpro/habr/post_images/75e/087/333/75e087333d725b9f69ec3d009abf17fe.gif" alt="Kotlin GitHub"></li>
<li>Мы планируем вскоре зарелизить поддержку JavaScript и Java 8</li>
<li>У нас есть своя онлайн-песочница: <a href="http://try.kotl.in/">http://try.kotl.in</a> В ней есть серия задачек <a href="http://try.kotl.in/koans">Kotlin Koans</a>, которые помогают освоиться с языком буквально за несколько часов. Действительно за несколько часов! Также у нас отличная документация на <a href="http://kotlinlang.org/docs/reference/">официальном сайте</a>.</li>
<li>Мы открыты! Kotlin <a href="https://github.com/JetBrains/kotlin">разрабатывается на GitHub</a>, под лицензией Apache 2.0. Но самое главное, мы всегда внимательно прислушиваемся ко всему входящему фидбеку, так что теперь слово вам:</li>
</ul>
]]></description><link>https://habrahabr.ru/company/JetBrains/blog/277573/</link><guid isPermaLink="true">https://habrahabr.ru/company/JetBrains/blog/277573/</guid><category><![CDATA[JetBrains]]></category><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Роман Белов]]></dc:creator><pubDate>Fri, 19 Feb 2016 16:30:00 GMT</pubDate></item><item><title><![CDATA[Kotlin & Android: A Brass Tacks Experiment, Part 3.]]></title><description><![CDATA[<p><img src="https://d262ilb51hltx0.cloudfront.net/max/800/1*UN-S8ELMC2kpHf4tJKfbLQ.png">
<em>Disclaimer: I am a Google employee, but the views expressed in this article are not those of my employer.</em></p>
<h3>Kotlin &#x26; Android: A Brass Tacks Experiment, Part 3</h3>
<p>This is post 3 in a series about my experiment using Kotlin in a uniquely Android way. If you haven’t read <a href="https://medium.com/p/kotlin-android-a-brass-tacks-experiment-part-1-3e5028491bcc">part 1 (setup)</a> and <a href="https://medium.com/p/kotlin-android-a-brass-tacks-experiment-part-2-c67661cfdf5f">part 2</a> yet, read up to catch up!</p>
<p>We left things last time with a fairly useful function called “v” using the type-safe builder pattern in Kotlin®. It can be used to build instances of arbitrary types of Android views.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">import</span> android.content.Context
<span class="hljs-keyword">import</span> java.lang.reflect.Constructor

<span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&#x3C;<span class="hljs-keyword">reified</span> TV : View></span></span>
        v(context: Context, init: TV.() -> <span class="hljs-built_in">Unit</span>) : TV {
    <span class="hljs-keyword">val</span> constr = TV::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>.<span class="hljs-title">getConstructor</span></span>(Context::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>)</span>
    <span class="hljs-keyword">val</span> view = constr.newInstance(context)
    view.init()
    <span class="hljs-keyword">return</span> view
}</code></pre>
<p>We can import this definition into some Kotlin code and call it to create and initialize a new view of any type:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">import</span> android.view.ViewGroup.LayoutParams
<span class="hljs-keyword">import</span> android.view.ViewGroup.LayoutParams.WRAP_CONTENT
<span class="hljs-keyword">import</span> android.widget.TextView

<span class="hljs-keyword">val</span> view = v&#x3C;TextView>(context) {
    layoutParams = LayoutParams(WRAP_CONTENT, WRAP_CONTENT)
    text = <span class="hljs-string">"Hello"</span>
}</code></pre>
<h4>But is this practical?</h4>
<p>What if we want to create a simple layout with two TextViews stacked on top of each other? Here’s a simple view hierarchy expressed in XML:</p>
<pre><code class="hljs language-xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">LinearLayout</span>
    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"wrap_content"</span>
    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span>
    <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">"vertical"</span> ></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">TextView</span>
        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"wrap_content"</span>
        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span>
        <span class="hljs-attr">android:text</span>=<span class="hljs-string">"Hello"</span> /></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">TextView</span>
        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"wrap_content"</span>
        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span>
        <span class="hljs-attr">android:text</span>=<span class="hljs-string">"World"</span> /></span>
<span class="hljs-tag">&#x3C;/<span class="hljs-name">LinearLayout</span>></span></code></pre>
<p>Our poor v function can’t build all that at once. But it could with some help! We just need an additional function that has smarts for creating views that get added to a parent ViewGroup (such as LinearLayout here, or RelativeLayout). So let’s make a new v function overload to buddy up with our existing v function:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&#x3C;<span class="hljs-keyword">reified</span> TV : View></span> <span class="hljs-title">v</span><span class="hljs-params">(parent: <span class="hljs-type">ViewGroup</span>, init: <span class="hljs-type">TV</span>.()</span></span> -> <span class="hljs-built_in">Unit</span>) : TV {
    <span class="hljs-keyword">val</span> constr = TV::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>.<span class="hljs-title">getConstructor</span></span>(Context::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>)</span>
    <span class="hljs-keyword">val</span> view = constr.newInstance(parent.context)
    parent.addView(view)
    view.init()
    <span class="hljs-keyword">return</span> view
}</code></pre>
<p>This function is <em>almost exactly</em> like the original v except for one thing. Its first parameter is of type ViewGroup instead of Context. This new v function needs to know about a <em>parent</em> ViewGroup is so it can add its own newly created view to that parent before initializing and returning it. That’s the first argument to this function. It will then get a hold of the Context needed to initialize the view from the parent argument instead of being passed the Context directly.</p>
<p>Let’s see how this new v function can work together with our old v to build the same view hierarchy as the above XML:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">import</span> android.content.Context
<span class="hljs-keyword">import</span> android.widget.LinearLayout
<span class="hljs-keyword">import</span> android.widget.LinearLayout.VERTICAL
<span class="hljs-keyword">import</span> android.widget.LinearLayout.LayoutParams
<span class="hljs-keyword">import</span> android.widget.LinearLayout.LayoutParams.WRAP_CONTENT
<span class="hljs-keyword">import</span> android.widget.TextView

<span class="hljs-keyword">val</span> view = v&#x3C;LinearLayout>(context) {
    layoutParams = LayoutParams(WRAP_CONTENT, WRAP_CONTENT)
    orientation = VERTICAL

    <span class="hljs-comment">// adds a new TextView as the first child to the LinearLayout ("this")</span>
    v&#x3C;TextView>(<span class="hljs-keyword">this</span>) {
        layoutParams = LayoutParams(WRAP_CONTENT, WRAP_CONTENT)
        text = <span class="hljs-string">"Hello"</span>
    }

    <span class="hljs-comment">// adds a another new TextView to the LinearLayout</span>
    v&#x3C;TextView>(<span class="hljs-keyword">this</span>) {
        layoutParams = LayoutParams(WRAP_CONTENT, WRAP_CONTENT)
        text = <span class="hljs-string">"World"</span>
    }
}</code></pre>
<p>I love the way these functions nest naturally just like the XML!</p>
<p>If you recall from <a href="https://medium.com/p/kotlin-android-a-brass-tacks-experiment-part-2-c67661cfdf5f">part 2</a> of this series, a Kotlin <em>lambda with receiver</em> makes the receiver object available as “this” in the lambda body. In the specific case above, the LinearLayout typed receiver in the <em>outer</em> v lambda (made available via the “this” keyword) is passed as the first parameter of both calls to the new <em>inner</em> v function. Because LinearLayout is a type of ViewGroup, Kotlin knows that we intend to use our new v function overload instead of our original v that takes a Context.</p>
<p>With these two buddy v functions we can now <em>programmatically</em> and <em>succinctly</em> create nested views as deeply as we want with any type of ViewGroup parent and View child. We’re starting to get a sort uniquely expressive language (some might say “<a href="https://en.wikipedia.org/wiki/Domain-specific_language">domain specific language</a>”) for creating Android views that’s close to the usual XML representation. It turns out that this is also faster than inflating XML, as we’ll discover in a future post in this series.</p>
<h4>Room for Improvement</h4>
<p>There’s still some awkwardness with this scheme when you want to specify a dimension of some view in density independent pixels. For example, in XML, you might simply say “48dp” as a value to describe width or height, but to say this programmatically in Kotlin using the API provided by Android, you’d have to write something gnarly like this:</p>
<pre><code class="hljs language-kotlin">TypedValue.applyDimension(
    TypedValue.COMPLEX_UNIT_DIP,
    <span class="hljs-number">48</span>,
    context.resources.displayMetrics)</code></pre>
<p>Super yuck! Stay tuned for <a href="https://medium.com/@CodingDoug/kotlin-android-a-brass-tacks-experiment-part-4-4b7b501fa457">next week’s post</a> where we’ll make use of another Kotlin language feature to address this problem and further tighten up expressions for view creation using our dynamic duo of v functions. Be sure to follow me here on Medium as <a href="https://medium.com/@CodingDoug">@CodingDoug</a> or on <a href="https://twitter.com/CodingDoug">Twitter as the same</a> to stay on top of this series!</p>
]]></description><link>https://medium.com/@CodingDoug/kotlin-android-a-brass-tacks-experiment-part-3-84e65d567a37#.lgtyczp3h</link><guid isPermaLink="true">https://medium.com/@CodingDoug/kotlin-android-a-brass-tacks-experiment-part-3-84e65d567a37#.lgtyczp3h</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Android]]></category><dc:creator><![CDATA[Doug Stevenson]]></dc:creator><pubDate>Tue, 16 Feb 2016 19:39:00 GMT</pubDate></item><item><title><![CDATA[Kotlin 1.0: The good, the bad and the evident.]]></title><description><![CDATA[<p>Kotlin 1.0 is a programming language made by JetBrains, the creator of the popular IntelliJ IDEA development environment. This programming language for the JVM and Android focuses on safety, interoperability, clarity and tooling support and combines OO and functional features.</p>
<p>After a long wait, Kotlin 1.0 is finally here! According to the <a href="http://blog.jetbrains.com/kotlin/2016/02/kotlin-1-0-released-pragmatic-language-for-jvm-and-android/">official announcement</a>, ” Kotlin works everywhere where Java works: server-side applications, mobile applications (Android), desktop applications. It works with all major tools and services such as IntelliJ IDEA, Android Studio and Eclipse, Maven, Gradle and Ant, Spring Boot, GitHub, Slack and even Minecraft.”</p>
<p>Interoperability and seamless support for mixed Java+ Kotlin projects has been a focal point in the making of this project. Adoption is easier, which leads to less boilerplate code and more type-safety. Plus, the new programming language has a huge standard library which makes daily tasks not only easy, but also smooth while maintaining the byte code footprint low. Kotlin has been dubbed a ‘pragmatic’ programming language because in its creation developers focused on use cases to transform it into a good tool. Utility was the idea behind Kotlin 1.0, as emphasized by Andrey Breslav, the lead language designer of Kotlin: ” the less our users have to re-learn, re-invent, re-do from scratch, the more they can re-use, the better.”</p>
<p>Breslav explained that Kotlin 1.0 is mature enough and ready for production because the team has been using it in real-life projects on a broad scale over the past couple of years and pointed out that a handful of other companies have been using this new programming language in production “for some time now.”  The lead language designer of Kotlin revealed that the reason why it took so long for them to produce 1.0 was that they paid extra attention to validating their design decision in practice.</p>
<p>The team has kept Kotlin’s development very open since 2012 and has continuously talked to the community, collecting and addressing lots of feedback. Breslav announced that they are planning to establish a centralized venue for design proposals and discussions in order to make the process even more organized and visible. The team’s goals in the near future are to offer constant performance improvements for the Kotlin toolchain, JavaScript support and support generating Java 8 byte code.</p>
<h2>The good about Kotlin</h2>
<p>Mike Hearn, a former bitcoin core developer who recently made waves when he declared that the bitcoin project had “failed”, wrote in a post on <a href="https://medium.com/@octskyward/why-kotlin-is-my-next-programming-language-c25c001e26e3#.w9lbw7fso">Medium</a> last July that Kotlin is the programming language he will probably use for the next five to 10 years. He opined that Kotlin is “of greatest interest to people who work with Java today, although it could appeal to all programmers who use a garbage collected runtime, including people who currently use Scala, Go, Python, Ruby and JavaScript.”</p>
<p>According to Hearn, this programming language “comes from industry, not academia and solves problems faced by working programmers today.” It is open source, approachable and can be learned in a few hours by reading the language reference. “The syntax is lean and intuitive. Kotlin looks a lot like Scala, but is simpler,” he added. It allows developers to continue to use their productivity enhancing tools and adopting it is low risk because “it can be trialled in a small part of your code base by one or two enthusiastic team members without disrupting the rest of your project.”</p>
<h2>The bad: pre-1.0</h2>
<p>As Breslav remarked in the official announcement, the team took their time before they released Kotlin 1.0 because they paid extra attention to validating their design decision on practice. Therefore, all the problems pointed out by Hearn in his review of Kotlin should not exist anymore now that Kotlin 1.0 has been released. The former bitcoin core developer pointed out that Kotlin’s biggest problems were its immaturity (because it was a pre 1.0 language) and that sometimes the requirements of Java interop resulted in unintuitive limitations.</p>
<p>Hearn also criticized the size of the community, which was smaller at that time. However, according to Breslav, over 11.000 people were using Kotlin last month and almost 5.000 earlier this month. Plus, there is a growing list of companies using Kotlin, including Expedia and Prezi.</p>
<p>Language docs and tutorials can be found on the <a href="https://kotlinlang.org/">official website</a>.</p>
]]></description><link>https://jaxenter.com/kotlin-1-0-the-good-the-bad-and-the-evidence-124041.html</link><guid isPermaLink="true">https://jaxenter.com/kotlin-1-0-the-good-the-bad-and-the-evidence-124041.html</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Review]]></category><dc:creator><![CDATA[Gabriela Motroc]]></dc:creator><pubDate>Tue, 16 Feb 2016 17:11:00 GMT</pubDate></item><item><title><![CDATA[(RU) Релиз Kotlin 1.0, языка программирования для JVM и Android.]]></title><description><![CDATA[<p>Компания Jetbrains, развивающая интегрированную среду разработки IntelliJ IDEA, <a href="http://blog.jetbrains.com/kotlin/2016/02/kotlin-1-0-released-pragmatic-language-for-jvm-and-android/">представила</a> первый значительный релиз объектно-ориентированного языка программирования <a href="https://kotlinlang.org/">Kotlin 1.0</a>, позволяющего создавать приложения, скомпилированные для последующего выполнения внутри стандартной виртуальной машины Java (JVM) или Android. Дополнительно поддерживается преобразование программ в JavaScript-представление для запуска внутри браузера, но данная функциональность пока отнесена к экспериментальным возможностям.</p>
<p>Выпуск 1.0 позиционируется как первый выпуск, готовый для промышленного применения. Все дальнейшие обновления будут выпускаться с учётом сохранения обратной совместимости. Исходные тексты <a href="http://github.com/jetbrains/kotlin">открыты</a> под лицензией Apache 2.0. Плагины с поддержкой Kotlin подготовлены для интегрированных сред разработки IntelliJ IDEA, Eclipse и Android Studio. Из систем сборки поддерживаются Maven, Gradle и Ant.</p>
<p>Язык развивается в санкт-петербургском центре разработки компании JetBrains c целью создания максимально совместимого с Java языка программирования, одновременно лишённого ограничений и недостатков Java, от которых Java не может избавиться из-за необходимости обеспечения обратной совместимости. При этом проекты на Kotlin полностью совместимы с компонентами на языке Java - из программ Kotlin можно вызывать Java-классы и наоборот, из Java вызывать компоненты, написанные на Kotlin. Кроме возможности использования штатных Java-бибилиотек для Kotlin подготовлена большая библиотека классов, оптимизированная для генерации байткода минимального размера.</p>
<p>Из отличительных черт языка Kotlin можно выделить ориентацию на обеспечение более высокой безопасности за счет реализации статических проверок для выявления таких проблем как разыменование NULL-указателей. Среди других особенностей, имеющих отношение к безопасности, отмечается отсутствие raw-типов, полное сохранение информации о типах в процессе выполнения и реализация массивов в виде <a href="http://confluence.jetbrains.net/display/Kotlin/Basic+types#Basictypes-Arrays">инварианта</a>. Из расширенных языковых возможностей отмечается поддержка <a href="http://ru.wikipedia.org/wiki/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F_%D0%B2%D1%8B%D1%81%D1%88%D0%B5%D0%B3%D0%BE_%D0%BF%D0%BE%D1%80%D1%8F%D0%B4%D0%BA%D0%B0">функций высшего порядка</a>, <a href="http://ru.wikipedia.org/wiki/%D0%92%D1%8B%D0%B2%D0%BE%D0%B4_%D1%82%D0%B8%D0%BF%D0%BE%D0%B2">вывода типов</a> значений на основании выражения, использование уточняющих "<a href="http://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D1%81%D1%8C_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)">примесей</a>" (mixin) и <a href="http://ru.wikipedia.org/wiki/%D0%94%D0%B5%D0%BB%D0%B5%D0%B3%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)">делегирования</a>.</p>
]]></description><link>http://www.opennet.ru/opennews/art.shtml?num=43882</link><guid isPermaLink="true">http://www.opennet.ru/opennews/art.shtml?num=43882</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[JVM]]></category><dc:creator><![CDATA[Open Source]]></dc:creator><pubDate>Tue, 16 Feb 2016 11:21:00 GMT</pubDate></item><item><title><![CDATA[JVM Newcomer Kotlin 1.0 is GA]]></title><description><![CDATA[<p>After a long and winding road to development, pragmatic JVM and Android newcomer <a href="http://blog.jetbrains.com/kotlin/2016/02/kotlin-1-0-released-pragmatic-language-for-jvm-and-android/">Kotlin</a> 1.0 is officially GA. The open source progeny of Java IDE supremo JetBrains (it was developed on <a href="https://github.com/JetBrains/kotlin">GitHub</a> under the Apache 2.0 Open-Source license), Kotlin has been cooking since 2010, and as you’d expect, runs seamlessly on the company’s signature Java IDE, <a href="https://www.voxxed.com/blog/2015/09/partying-with-intellij-idea-dart-java-websocket-and-glassfish/">IntelliJ</a> IDEA.</p>
<p>A key characteristic of Kotlin is its end user focus, and a steadfast effort has been made in its development to ensure features lists are sharp and concise. It’s also lightweight and fully interoperable with the Java language, making it a natural fit for mobile development.</p>
<p>Although originally intended to be a contemporary answer to the legacy issues Java brought in its wake, Kotlin could prove an excellent choice for Android developers in 2016 looking for a JVM alternative that reaches beyond the capabilities for version 6 of the platform. And thanks to the kotlin-android-extensions plugin in for the Kotlin compiler, developers can access views in a type-safe fashion without the need for extra user code or runtime libraries.</p>
<p>Moreover, as Antonio Leiva <a href="https://www.voxxed.com/blog/2016/01/kotlin-android-developers/">notes</a>, Kotlin’s library is small enough to let developers work without proguard during development. Then there’s the not-inconsequential fact that Android Studio (the official Android IDE) was constructed on top of IntelliJ.</p>
<p>Aside from its aptitude for Android development, lead language designer <a href="http://blog.jetbrains.com/kotlin/author/andrey-breslav/">Andrey Breslav</a> highlights that, because Kotlin can run wherever Java runs – be that server-side applications, mobile applications (Android), or desktop applications, it plays nicely with most of the leading Java ecosystem tools, including things like Maven, Gradle and Ant, GitHub, Slack, and, as of today, officially supports <a href="https://spring.io/blog/2016/02/15/developing-spring-boot-applications-with-kotlin">Spring Boot</a>. And, because you can use libraries interchangeably between Java and Kotlin, you can keep bytecode footprints nice and small.</p>
<p>Breslav comments that, even before its official release, a number of companies have judged Kotlin fit for production, and JetBrains themselves have been utilising the language, along with its compiler and tooling projects, on extensive “real-life” projects for the past two years. In terms of adoption, over 11,000 people used Kotlin last month, and there are already two books – <a href="https://www.manning.com/books/kotlin-in-action">Kotlin in Action</a> and <a href="https://leanpub.com/kotlin-for-android-developers">Kotlin for Android Developers</a> – to get developers going with the language.</p>
<p>Going forward, JetBrains will look to make Kotlin development more transparent by establishing a centralized venue for design proposals and discussions. You can expect standardization efforts to happen in the near future too. Aside from bug fixes, plans for the roadmap ahead include formalised support for JavaScript (at the moment this is strictly experimental), performance improvements to the Kotlin toolchain, and support for generating Java 8 bytecode with things like optimized lambdas.</p>
<p>For a taste of what Kotlin has to offer, its creators recommend giving this online mini-IDE <a href="https://try.kotlinlang.org/">try.kotl.in</a> a whirl and having a go at <a href="http://try.kotlinlang.org/koans">Koans</a> — a set of introductory problems to guide you through the basics of the language.</p>
<p>To learn more about Kotlin and how it compares to fellow Java-botherer Ceylon, as well as Java itself, we suggest checking out this Devoxx UK 2015 session by Russel Winder:</p>
<p><a href="https://www.youtube.com/watch?v=Q_Z_8HXt68k">https://www.youtube.com/watch?v=Q_Z_8HXt68k</a></p>
]]></description><link>https://www.voxxed.com/blog/2016/02/kotlin/</link><guid isPermaLink="true">https://www.voxxed.com/blog/2016/02/kotlin/</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[JVM,]]></category><dc:creator><![CDATA[Lucy Carey]]></dc:creator><pubDate>Mon, 15 Feb 2016 17:50:00 GMT</pubDate></item><item><title><![CDATA[Developing Spring Boot applications with Kotlin.]]></title><description><![CDATA[<p>Just in time for <a href="http://blog.jetbrains.com/kotlin/2016/02/kotlin-1-0-released-pragmatic-language-for-jvm-and-android/">Kotlin 1.0 release</a>, we are adding support for Kotlin language to <a href="https://start.spring.io/#!language=kotlin">https://start.spring.io</a> in order to make it easier to start new Spring Boot projects with this language.</p>
<p>This blog post is also an opportunity for me to explain why I find this language interesting, to show you a sample project in detail and to give you some tips.</p>
<h2>What is Kotlin?</h2>
<p><a href="https://kotlinlang.org/">Kotlin</a> is a language created by <a href="https://www.jetbrains.com/">JetBrains</a>. It runs on top of the JVM (but not only), it is an object oriented language that includes many ideas from functional programming. I won’t go too much in details about all Kotlin features (<a href="https://kotlinlang.org/docs/kotlin-docs.pdf">PDF</a>, <a href="https://kotlinlang.org/docs/reference/">HTML</a>), but I would like to highlight the ones I find the most interesting:</p>
<ul>
<li>Kotlin is a statically typed language, but thanks to its <a href="https://kotlinlang.org/docs/reference/basic-types.html">clever type inference</a>, it allows you to write code as short and expressive as dynamic language with performances close to pure Java projects</li>
<li><a href="https://kotlinlang.org/docs/reference/properties.html#declaring-properties">Properties support</a></li>
<li>Relatively lightweight standard library compared to other languages</li>
<li>Easy to learn: a Java developer can quickly understand most of the language (this <a href="https://kotlinlang.org/docs/reference/comparison-to-java.html">quick comparison to Java</a> is worth to read)</li>
<li><a href="https://kotlinlang.org/docs/reference/java-interop.html">Java interop</a> is a first class concern and great</li>
<li>Perfect for Android development</li>
<li>Built-in immutability and <a href="https://kotlinlang.org/docs/reference/null-safety.html">null safety</a> support</li>
<li>Code is easy to read, efficient to write</li>
<li>Allows to <a href="https://kotlinlang.org/docs/reference/extensions.html">extend existing libraries</a> without having to inherit from the class or use any type of design pattern such as Decorator</li>
<li>No semicolon required ;-)</li>
</ul>
<p>You will find a lot of useful links to improve your Kotlin knowledge in this <a href="http://blog.jetbrains.com/kotlin/2016/01/kotlin-digest-2015/">Kotlin digest 2015</a> blog post. Also have a look to these simple <a href="http://try.kotlinlang.org/koans">Kotlin exercices</a> to have a quick overview of the language.</p>
<h2>A sample Spring Boot + Kotlin project</h2>
<p>Kotlin has been designed to play well with the Java ecosystem, and it seems to me that it shares the same pragmatic, innovative and opinionated mindset as Spring Boot, so they play well together. You can have a look at this simple <a href="https://github.com/sdeleuze/spring-boot-kotlin-demo">Spring Boot + Spring Data JPA Kotlin project</a> to see more concretely what it looks like.</p>
<p>Kotlin allows to write (and read) your domain model easily thanks to <a href="https://kotlinlang.org/docs/reference/data-classes.html">data classes</a>. The compiler automatically derives the following members from all properties declared in the primary constructor:</p>
<ul>
<li><code>equals()</code> / <code>hashCode()</code> pair</li>
<li><code>toString()</code> of the form “Customer(firstName=Foo, lastName=Bar, id=42)”</li>
<li><code>componentN()</code> functions corresponding to the properties in their order or declaration</li>
<li><code>copy()</code> function</li>
</ul>
<p>You can see that Kotlin allows you to specify parameter default values, and types are declared after the name of the variable/parameter:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@Entity</span>
<span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Customer</span></span>(
	<span class="hljs-keyword">var</span> firstName: String = <span class="hljs-string">""</span>,
	<span class="hljs-keyword">var</span> lastName: String = <span class="hljs-string">""</span>,
	<span class="hljs-meta">@Id</span> <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.AUTO)</span>
	<span class="hljs-keyword">var</span> id: <span class="hljs-built_in">Long</span> = <span class="hljs-number">0</span>
)</code></pre>
<p>The Spring MVC REST controller you can see below is using constructor level injection, and default visibility in Kotlin is <code>public</code> so no need to specify it. When a function returns a single expression, the curly braces can be omitted and the body is specified after a <code>=</code> symbol. It is even better since the return type can be inferred by the compiler.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@RestController</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomerController</span> <span class="hljs-meta">@Autowired</span> <span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword">val</span> repository:CustomerRepository) {

	<span class="hljs-meta">@RequestMapping(<span class="hljs-meta-string">"/"</span>)</span>
	<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">findAll</span><span class="hljs-params">()</span></span> = repository.findAll()


	<span class="hljs-meta">@RequestMapping(<span class="hljs-meta-string">"/{name}"</span>)</span>
	<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">findByLastName</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> name:<span class="hljs-type">String</span>)</span></span>
		= repository.findByLastName(name)
}</code></pre>
<p>The Spring Data repository is self explanatory:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CustomerRepository</span> : <span class="hljs-type">CrudRepository</span>&#x3C;<span class="hljs-type">Customer, Long</span>> </span>{
	<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">findByLastName</span><span class="hljs-params">(name: <span class="hljs-type">String</span>)</span></span>: List&#x3C;Customer>
}</code></pre>
<p>Since Kotlin supports top-level functions, you can declare your application as simple as:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>{

	<span class="hljs-meta">@Bean</span>
	<span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">init</span><span class="hljs-params">(repository: <span class="hljs-type">CustomerRepository</span>)</span></span> = CommandLineRunner {
		repository.save(Customer(<span class="hljs-string">"Jack"</span>, <span class="hljs-string">"Bauer"</span>))
		repository.save(Customer(<span class="hljs-string">"Chloe"</span>, <span class="hljs-string">"O'Brian"</span>))
		repository.save(Customer(<span class="hljs-string">"Kim"</span>, <span class="hljs-string">"Bauer"</span>))
		repository.save(Customer(<span class="hljs-string">"David"</span>, <span class="hljs-string">"Palmer"</span>))
		repository.save(Customer(<span class="hljs-string">"Michelle"</span>, <span class="hljs-string">"Dessler"</span>))
	}
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&#x3C;<span class="hljs-type">String</span>>)</span></span> {
	SpringApplication.run(Application::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>, <span class="hljs-type">*args)</span></span>
}</code></pre>
<p>You need to mark <code>@Configuration</code> classes, some others like most <code>@Component</code> ones and <code>@Bean</code> methods as <code>open</code> because they cannot be <code>final</code> in Spring due to proxy usage (classes and methods in Kotlin are <code>final</code> by default without the <code>open</code> modifier).</p>
<h2>Additional tips</h2>
<p>Even if Spring Boot and Kotlin work pretty well together, these additional tips are worth to know.</p>
<h3>Property injection</h3>
<p>We have seen previously how to do constructor injection, since that’s the <a href="http://olivergierke.de/2013/11/why-field-injection-is-evil/">recommended approach</a> (especially with Kotlin). If you have to perform property injection, you will have to use <a href="https://kotlinlang.org/docs/reference/properties.html#late-initialized-properties">late-initialized properties</a> because normally, raw properties declared as having a non-null type must be initialized in the constructor.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@RestController</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomerController</span> </span>{

	<span class="hljs-meta">@Autowired</span>
	lateinit <span class="hljs-keyword">var</span> repository:CustomerRepository

	<span class="hljs-comment">// ...</span>
}</code></pre>
<h3>Property placeholders</h3>
<p><code>$</code> is used for <a href="https://kotlinlang.org/docs/reference/basic-types.html#string-templates">String interpolation</a> in Kotlin, so you should escape it when using property placeholders: <code>@Value("\${some.property}")</code>. As an alternative you can also use <code>@ConfigurationProperties</code> instead, see <a href="http://stackoverflow.com/a/33883230/1092077">this Stack Overflow</a> answer for more details.</p>
<h3>Array annotation attribute</h3>
<p>Unlike Java, Kotlin does not allow to specify array annotation attribute as a single value, so be aware that you will have to write <code>@RequestMapping(method = arrayOf(RequestMethod.GET))</code> or <code>@EnableAutoConfiguration(exclude = arrayOf(Foo::class))</code>.</p>
<p>It will be possible to use a shorter syntax with upcoming Spring Framework 4.3 composed annotations like <code>@GetMapping</code>, see <a href="https://jira.spring.io/browse/SPR-13992">SPR-13992</a> for more details.</p>
<h3>Jackson Kotlin Module</h3>
<p>If you are using Jackson you are likely to want to add <code>com.fasterxml.jackson.module:jackson-module-kotlin</code> dependency in order to allow it to deal with data classes with no default constructor or with Kotlin collections.</p>
<p>In addition to the dependency, you need to register it in Jackson <code>ObjectMapper</code>:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>{

	<span class="hljs-meta">@Bean</span>
	<span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">objectMapperBuilder</span><span class="hljs-params">()</span></span>: Jackson2ObjectMapperBuilder
	    = Jackson2ObjectMapperBuilder().modulesToInstall(KotlinModule())

	<span class="hljs-comment">// ...</span>
}</code></pre>
<h3>Experiment with the Java to Kotlin converter</h3>
<p>Last tip, the Java to Kotlin converter available in IntelliJ IDEA (Menu Code -> Convert Java file to Kotlin file) is quite useful when you can’t figure out how to write something in Kotlin. So do not hesitate to write something in Java and use it to find the Kotlin counterpart. This <a href="https://kotlinlang.org/docs/reference/comparison-to-java.html">comparison to Java documentation</a> can also provide some help.</p>
<h2>Feedbacks</h2>
<p>We are interested by your feedbacks about developing Spring applications with Kotlin. This blog post is just an introduction, there is much more to say especially about using Spring Boot with more Kotlin idiomatic code like with <a href="https://github.com/JetBrains/Exposed">Exposed</a> SQL library, so stay tuned ...</p>
]]></description><link>https://spring.io/blog/2016/02/15/developing-spring-boot-applications-with-kotlin</link><guid isPermaLink="true">https://spring.io/blog/2016/02/15/developing-spring-boot-applications-with-kotlin</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Spring]]></category><dc:creator><![CDATA[Sébastien Deleuze]]></dc:creator><pubDate>Mon, 15 Feb 2016 12:58:00 GMT</pubDate></item><item><title><![CDATA[Kotlin 1.0 Released: Pragmatic Language for JVM and Android]]></title><description><![CDATA[<p>This is it. 1.0 is here!</p>
<p>It’s been a long and exciting road but we’ve finally reached the first big 1.0, and we’re celebrating the release by also presenting you with the new logo:</p>
<p><img src="http://i0.wp.com/blog.jetbrains.com/kotlin/files/2016/02/1_0_Banner.png?resize=640%252C320" alt="Kotlin logo"></p>
<p>See discussions on <a href="https://www.reddit.com/r/programming/comments/45wcnd/kotlin_10_released_pragmatic_language_for_jvm_and/">Reddit</a> and <a href="https://news.ycombinator.com/item?id=11103087">Hacker News</a></p>
<h2>What is Kotlin?</h2>
<p>Kotlin is a pragmatic programming language for JVM and Android that combines OO and functional features and is focused on <strong>interoperability</strong>, <strong>safety</strong>, <strong>clarity</strong> and <strong>tooling</strong> support.</p>
<p>Being a general-purpose language, Kotlin <strong>works everywhere where Java works</strong>: server-side applications, mobile applications (Android), desktop applications. It works with all major tools and services such as</p>
<ul>
<li>IntelliJ IDEA, Android Studio and Eclipse</li>
<li>Maven, Gradle and Ant</li>
<li>Spring Boot (Kotlin support released today!)</li>
<li>GitHub, Slack and even Minecraft :)</li>
</ul>
<p>One of the key focuses of Kotlin has been interoperability and seamless support for <strong>mixed Java+Kotlin projects</strong>, making adoption easier leading to less boilerplate code and more type-safety. Additionally, Kotlin has an <strong>extensive standard library</strong> that makes everyday tasks easy and smooth while keeping the bytecode footprint <a href="http://www.methodscount.com/?lib=org.jetbrains.kotlin%253Akotlin-stdlib%253A1.0.0-rc-1036">low</a>. Of course, <strong>any Java library can be used in Kotlin</strong>, too; and vice versa. </p>
<h2>What does pragmatic mean?</h2>
<p>Understanding one’s core values is crucial for any long-running project. If I were to choose one word to describe Kotlin’s design, it would be <strong>pragmatism</strong>. This is why, early on, we said that Kotlin is not so much about invention or research. We ended up inventing quite a few things, but this was never the point of the project. Of course we were building a <strong>type system that prevents bugs</strong>, and <strong>abstraction mechanisms that facilitate code reuse</strong>, as anybody in our position would. But our (pragmatic) way of doing it was through <strong>focusing on use cases</strong> to make the language a <strong>good tool</strong>.</p>
<p>In particular, this approach lead us immediately to the notion that <strong>interoperability with existing code and infrastructure is crucial</strong>. Re-writing the world the right way, all from scratch — who never wished to? I did, quite a few times :) And Kotlin would have been a whole lot easier to design and develop if not for the Java interop, Maven integration, Android compatibility! It would definitely be more elegant in many ways. But elegance, though highly appreciated, is not the primary goal here, <strong>the primary goal is being useful</strong>. And the less our users have to re-learn, re-invent, re-do from scratch, the more they can re-use, the better.</p>
<p>— <strong><em>So, why doesn’t Kotlin have its own package manager, or its own build system?</em></strong>
— Because there’s already Maven and Gradle, and re-using their huge number of plugins is crucial for many projects.
— <strong><em>Why did we invest a lot of time and effort into making JDK-compatible collection interfaces, when it was so much easier to just redesign collections from scratch?</em></strong>
— Because tons and tons of Java code work with JDK collections, and converting data on the boundary would be a pain.
— <strong><em>Why does Kotlin support Java 6 byte code?</em></strong>
— Because many people are still running Java 6 (Android, most notably, but not only Android).</p>
<p>For us pragmatism is about <strong>creating user experience</strong>, not a language or a library alone. Many of the language design decisions were made under constraints like “Won’t this impede incremental compilation?”, “What if this increases APK method counts?”, “How will the IDE highlight this as-you-type?”, and many more like these. As a result, we are proud of our <strong>tooling as well as the language</strong>.</p>
<h2>Is it mature enough and ready for production?</h2>
<p>Yes. And it has been for quite some time. At JetBrains, we’ve not only been implementing the compiler and tooling but have also been using Kotlin <strong>in real-life projects</strong> on a rather extensive scale over the last two years. In addition to JetBrains, there are quite a few companies that have been using Kotlin <strong>in production</strong> for some time now.</p>
<p>In fact, one of the reasons it took us a long time to reach 1.0 was because we paid extra attention to validating our design decisions in practice. This was and is necessary, because moving forward the compiler will be <strong>backwards compatible</strong> and future versions of Kotlin must not break existing code. As such, whatever choices we’ve made we need to stick with them.</p>
<p>Reaching this milestone was something we couldn’t have done without the valuable <strong>help of early adopters</strong>. We want to thank each any every one of you for your bravery, energy and enthusiasm!</p>
<h2>Who’s behind Kotlin?</h2>
<p>First and foremost, Kotlin is an Open Source language</p>
<ul>
<li>Developed on <a href="https://github.com/JetBrains/kotlin">GitHub</a> <strong>under Apache 2.0 Open-Source license</strong>;</li>
<li>With <strong>over 100 contributors</strong> to date.</li>
</ul>
<p>JetBrains is the main backer of Kotlin at the moment: we have invested a lot of effort into developing it and <strong>we are committed to the project for the long run</strong>. We wrote it out of our own need to use in our own products. And we’re happy to say that to date, <strong>close to 10 JetBrains products</strong>, which include IntelliJ IDEA, <a href="https://blog.jetbrains.com/dotnet/2016/01/13/project-rider-a-csharp-ide/">JetBrains Rider</a>, JetBrains Account &#x26; E-Shop, YouTrack as well as some of our smaller IDE’s and some internal projects are using Kotlin. So <strong>it’s here to stay</strong>!</p>
<p>Since 2012 we kept Kotlin’s development very open: talking to the community all the time, gathering and addressing lots of feedback.</p>
<p>Moving forward we are planning to set up a centralized venue for design proposals and discussions, to make the process even more visible and organized. Standardization efforts have not been started for Kotlin so far, but we realize that we’ll need to do it rather sooner than later.</p>
<p>Language design and overall steering of the project is done by the team employed at JetBrains. We currently have <strong>over 20 people working full time</strong> on Kotlin, which also yet another testament to JetBrains’ commitment to Kotlin.</p>
<h2>The numbers</h2>
<p>Let’s take a look at some numbers:</p>
<ul>
<li><strong>11K+</strong> people were using Kotlin last month and near <strong>5K</strong> last week alone;</li>
<li><strong>Hundreds</strong> of <a href="http://stackoverflow.com/questions/tagged/kotlin">StackOverflow answers</a>;</li>
<li><strong>Two books</strong>: <a href="https://www.manning.com/books/kotlin-in-action">Kotlin in Action</a> and <a href="https://leanpub.com/kotlin-for-android-developers">Kotlin for Android Developers</a>;</li>
<li><strong>About 1400 people</strong> on <a href="http://kotlinlang.slack.com/">Slack</a> (<a href="http://kotlinslackin.herokuapp.com/">get an invite</a>);</li>
<li><strong>Over 500K</strong> lines of Kotlin code in projects such as IntelliJ IDEA and Rider.</li>
</ul>
<p>Talking about lines of code, the number of these in open repositories on GitHub is <strong>growing exponentially over time</strong> (JetBrains’ projects excluded):</p>
<p><img src="http://blog.jetbrains.com/kotlin/files/2016/02/KotlinAdoption.gif" alt="Kotlin GitHub Adoption"></p>
<p>And of course we have a growing list of <strong>companies using Kotlin</strong> including Prezi and Expedia. By the way, if you’re using Kotlin, make sure you send us a <a href="https://github.com/JetBrains/kotlin-web-site/blob/master/_data/companies-using-kotlin.yml">Pull Request</a>.</p>
<h2>The upcoming roadmap</h2>
<p>As of 1.0, we are committed to long-term <strong>backward compatibility</strong> of the language and its standard library (<code>kotlin-stdlib</code>):</p>
<ul>
<li><strong>a newer compiler will work with older binaries</strong> (but older compilers may not understand newer binaries, like javac 1.6 can’t read classes compiled by javac 1.8);</li>
<li><strong>older binaries will keep working with newer binaries at runtime</strong> (newer code may require newer dependencies, though).</li>
</ul>
<p>This applies to the JVM/Android support only. The JavaScript support remains experimental for now and will have its own release later on.</p>
<p>As for the plans, our nearest goals are (apart from bug fixes):</p>
<p>Constant performance improvements for the Kotlin toolchain (this includes, for example, incremental compilation in Gradle, that is in the works now);
JavaScript support (including cross-compilation into both JVM and JS where possible);
Support generating Java 8 byte code with optimized lambdas, etc (Java 6 will be actively supported as long as Android users need it).
Tooling updates and bug fixes will be released as incremental updates, i.e. 1.0.X. Bigger changes will first go though an Early Access Program (EAP) and then will be released as 1.1.</p>
<h2>How to start</h2>
<p>The easiest way to play with the language is through its <strong>online mini-IDE</strong>: <a href="https://try.kotlinlang.org/">try.kotl.in</a>, including <a href="http://try.kotlinlang.org/koans">Koans</a> — a set of introductory problems which <strong>guide you through the basics</strong> of the language.</p>
<p>To use Kotlin on your machine (and Koans can be completed <a href="https://kotlinlang.org/docs/tutorials/koans.html">offline</a> as well):</p>
<ul>
<li><strong>IntelliJ IDEA</strong> (<a href="https://www.jetbrains.com/idea/download/">Ultimate or Community</a>): just create a Kotlin project or a Kotlin file in a Java project;</li>
<li><strong>Android Studio</strong>: install the plugin through <strong><em>Plugin Manager</em></strong>;</li>
<li><strong>Eclipse</strong>: install the plugin through <a href="https://marketplace.eclipse.org/content/kotlin-plugin-eclipse">Marketplace</a>.</li>
</ul>
<p>NOTE: If you are running an older version, you may need to update your Kotlin plugin to 1.0.</p>
<p>To get up to speed with concepts, language <strong>docs and tutorials</strong> are available from the <a href="https://kotlinlang.org/">official web site</a>. Great articles and presentations given by members of our community can be found in the <a href="http://blog.jetbrains.com/kotlin/2016/01/kotlin-digest-2015/">Digest of 2015</a>.</p>
<p>If you’re introducing Kotlin to your Java project, you can make use of the <strong>Java-to-Kotlin converter</strong> built into the IDE, helping migration easier class by class.</p>
<p>Last but not least, make sure you join the discussions on our <a href="https://devnet.jetbrains.com/community/kotlin">Forum</a> or <a href="http://kotlinslackin.herokuapp.com/">Slack</a>.</p>
<p>Once again, <strong>we want to thank everyone</strong>. We couldn’t have done this without the community.</p>
<p>Have a nice Kotlin! <strong>Now</strong> :)</p>
<p>P.S. See discussions on <a href="https://www.reddit.com/r/programming/comments/45wcnd/kotlin_10_released_pragmatic_language_for_jvm_and/">Reddit</a> and <a href="https://news.ycombinator.com/item?id=11103087">Hacker News</a></p>
]]></description><link>http://blog.jetbrains.com/kotlin/2016/02/kotlin-1-0-released-pragmatic-language-for-jvm-and-android/</link><guid isPermaLink="true">http://blog.jetbrains.com/kotlin/2016/02/kotlin-1-0-released-pragmatic-language-for-jvm-and-android/</guid><category><![CDATA[JetBrains]]></category><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Andrey Breslav]]></dc:creator><pubDate>Mon, 15 Feb 2016 12:57:00 GMT</pubDate></item><item><title><![CDATA[The Journey of a Spring Boot application from Java 8 to Kotlin: The Application Class]]></title><description><![CDATA[<p>After writing a significant amount of Ruby/Rails for many years, lately I have found myself writing a ton of Spring Boot applications. <a href="http://projects.spring.io/spring-boot/">Spring Boot</a> is a great framework for the JVM that focuses on developer productivity by making "it easy to create stand-alone, production-grade Spring based Applications that you can 'just run'". It has a lot of the feel of Rails in the "convention over configuration" department but because I end up using Java 8, I have lost some of the "joy" that you get when writing in Ruby. Even though Java 8 provides significant improvements over Java 7, I wanted to find out if I could get some more of that joy back by using <a href="https://kotlinlang.org/">Kotlin</a> to write Spring Boot applications.</p>
<p>Kotlin is a new language from the folks at <a href="https://www.jetbrains.com/">JetBrains</a>, creators of IntelliJ and RubyMine, as a replacement for Java in developing their products. Their goal was to create a more concise JVM based language that helps increase developer productivity, avoid some common pitfalls in Java development and be 100% compatible with existing Java programs. It targets Java 6 as the baseline while still adding some great language features so it is quite useful for Android development as well.</p>
<p>This post, and all that follow, will use an existing Java 8/Spring Boot <a href="https://github.com/mikegehard/user-management-evolution-kotlin/tree/running-java">application</a> as a starting point for the exploration. This will allow me to see direct comparisons between Java 8 syntax and Kotlin syntax. The journey will allow me to experience first hand what a Spring Boot/Kotlin application might look like as well as learn the language as I go that is a bit more than a "Hello World" application.
If you want to follow along as I travel, you can check out the evolving source on <a href="https://github.com/mikegehard/user-management-evolution-kotlin">GitHub here</a>.</p>
<p>In addition, these posts are not meant to be a full tutorial on Kotlin and will only cover the language features pertinent to the transformation. If you want a full tutorial, the Kotlin website has a lot of <a href="https://kotlinlang.org/docs/reference/">great information</a>.</p>
<p>Finally, if you have any suggestions for improvements in <a href="https://github.com/mikegehard/user-management-evolution-kotlin">the code</a>, please feel free to submit a GitHub issue or submit a pull request.</p>
<h2>The starting line</h2>
<p>The first thing we need when starting a Spring Boot application is an application class. Here is the <a href="https://github.com/mikegehard/user-management-evolution-kotlin/blob/running-java/applications/billing/src/main/java/com/example/billing/Application.java">application class</a> that I started with:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">package</span> com.example.billing;

<span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;
<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;
<span class="hljs-keyword">import</span> org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;
<span class="hljs-keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;

<span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-meta">@EnableDiscoveryClient</span>
<span class="hljs-meta">@EnableCircuitBreaker</span>

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>{
    <span class="hljs-keyword">public</span> static void main(String[] args) {
        SpringApplication.run(Application.<span class="hljs-keyword">class</span>, args);
    }
}

...</code></pre>
<p>No surprises here. We create a static <code>main()</code> method on the Application class that Spring Boot detects when you run the executable jar file.</p>
<p>Here is that same application class in Kotlin:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">package</span> com.example.billing

<span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication
<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication
<span class="hljs-keyword">import</span> org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker
<span class="hljs-keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient

<span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-meta">@EnableDiscoveryClient</span>
<span class="hljs-meta">@EnableCircuitBreaker</span>

<span class="hljs-comment">// This class must not be final or Spring Boot is not happy.</span>
<span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>{
    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> {
        <span class="hljs-meta">@JvmStatic</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&#x3C;<span class="hljs-type">String</span>>)</span></span> {
            SpringApplication.run(Application::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>, <span class="hljs-type">*args)</span></span>
        }
    }
}</code></pre>
<p>The first difference you may notice is the lack of semicolons. Yes ladies and gentlemen, no semicolons in Kotlin. While not a huge deal for some, it was a step in the right direction for me.</p>
<p>The next difference I noticed is the <code>open</code> keyword in front of the class definition. Classes in Kotlin are final by default, as per Item 17 from <a href="http://www.oracle.com/technetwork/java/effectivejava-136174.html">Effective Java</a>: <em>Design and document for inheritance or else prohibit it</em>. This is my first experience with friction between Kotlin's "enforce good practices" and Spring Boot's conventions. The <code>@SpringBootApplication</code> is a convenience annotation that marks the class with the <code>@Configuration</code>, <code>@EnableAutoConfiguration</code> and <code>@ComponentScan</code> annotations. It is the <code>@Configuration</code> annotation that forces the use of the <code>open</code> keyword. Removing the <code>open</code> keyword causes a runtime error when the application boots:</p>
<pre><code class="hljs language-kotlin">org.springframework.beans.factory.parsing.BeanDefinitionParsingException: Configuration problem: <span class="hljs-meta">@Configuration</span> <span class="hljs-class"><span class="hljs-keyword">class</span> '<span class="hljs-title">Application</span>' <span class="hljs-title">may</span> <span class="hljs-title">not</span> <span class="hljs-title">be</span> <span class="hljs-title">final</span>. <span class="hljs-title">Remove</span> <span class="hljs-title">the</span> <span class="hljs-title">final</span> <span class="hljs-title">modifier</span> <span class="hljs-title">to</span> <span class="hljs-title">continue</span>.</span></code></pre>
<p>This is easy enough to fix since this application class doesn't contain any configuration information. Instead of using the <code>@SpringBootApplication</code> annotation you can <a href="https://github.com/mikegehard/user-management-evolution-kotlin/commit/a9045e1968193fc70b4c43a330fde265b3325f7a">substitute</a> the <code>@EnableAutoConfiguration</code> and <code>@ComponentScan</code> annotations.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">package</span> com.example.billing

<span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication
<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication
<span class="hljs-keyword">import</span> org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker
<span class="hljs-keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient

<span class="hljs-meta">@EnableAutoConfiguration</span>
<span class="hljs-meta">@ComponentScan</span>
<span class="hljs-meta">@EnableDiscoveryClient</span>
<span class="hljs-meta">@EnableCircuitBreaker</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>{
    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> {
        <span class="hljs-meta">@JvmStatic</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&#x3C;<span class="hljs-type">String</span>>)</span></span> {
            SpringApplication.run(Application::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>, <span class="hljs-type">*args)</span></span>
        }
    }
}</code></pre>
<p>The final differences that I noticed are in the definition of the <code>main()</code> method. Kotlin has an idea of <a href="https://kotlinlang.org/docs/reference/object-declarations.html#companion-objects">companion objects</a>. These objects are used in a way similar to static methods in Java but not exactly. That is where the <code>@JvmStatic</code> annotation comes in. This annotation tells Kotlin to generate an actual Java static method instead of the "kinda,sorta" one that is the default in Kotlin. This annotation is a great example of the investment in JVM compatibility.</p>
<p>The <code>main()</code> method is also missing the <code>public</code> modifier. <a href="https://kotlinlang.org/docs/reference/visibility-modifiers.html">Methods are public by default</a> in Kotlin which reduces a bit of the boilerplate present in Java applications.</p>
<p>Finally, you will notice that arrays in Kotlin are actual parameterized classes instead of the primitive type that they are in Java. Kotlin also puts the type annotation after the variable is defined. We will get into why this is important in future posts.</p>
<p>One final gotcha with the Kotlin application class is that you have to tell Spring Boot where to find the application class. In Gradle, it is as easy as this:</p>
<pre><code class="hljs language-kotlin">springBoot {
    mainClass = <span class="hljs-string">'com.example.billing.Application'</span>
}</code></pre>
<p><em>Update - Feb, 16 2016: You do not need to tell Spring Boot where the application class is any longer. I got this from an early JetBrains blog post.</em></p>
<h1>An alternate application class</h1>
<p>Kotlin also allows functions to be defined outside of classes so we can re-write the application class as:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">package</span> com.example.billing

<span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication
<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.EnableAutoConfiguration
<span class="hljs-keyword">import</span> org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker
<span class="hljs-keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient
<span class="hljs-keyword">import</span> org.springframework.context.<span class="hljs-keyword">annotation</span>.ComponentScan

<span class="hljs-meta">@EnableAutoConfiguration</span>
<span class="hljs-meta">@ComponentScan</span>
<span class="hljs-meta">@EnableDiscoveryClient</span>
<span class="hljs-meta">@EnableCircuitBreaker</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span></span>

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&#x3C;<span class="hljs-type">String</span>>)</span></span> {
    SpringApplication.run(Application::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>, <span class="hljs-type">*args)</span></span>
}</code></pre>
<p>If we do this, the <code>main()</code> method is defined on a class called <code>ApplicationKt</code>, named after the file <code>Application.kt</code>, and this slightly changes the <code>build.gradle</code> entry:</p>
<pre><code class="hljs language-kotlin">springBoot {
    mainClass = <span class="hljs-string">'com.example.billing.ApplicationKt'</span>
}</code></pre>
<p><em>Update - Feb, 16 2016: You do not need to tell Spring Boot where the application class is any longer. I got this from an early JetBrains blog post.</em></p>
<p>This definition simplifies the signature of the <code>main()</code> method a bit. Gone are the annotations and the explicit companion object so the code is a little less cluttered.</p>
<p>I'm not sure which one I prefer better. Using the companion object is more explicit about which class contains the <code>main()</code> method but the above definition is more succinct. Here we trade less code for an implicit understanding that an ApplicationKt class gets generated by the compiler.	Over time, I'm thinking the abbreviated application class will grow on me.</p>
<h1>Closing thoughts</h1>
<p>In my mind, Kotlin is a step in the right direction as a "better Java". It seems to me that the language designers did what they could to remain compatible with existing Java programs while not being handcuffed by the legacy of Java. The lack of semi colons may seem trivial but will add up in large codebases and the enforcement of best practices at the language level will also help large codebases.</p>
<p>Yes there are some slight gotchas when it comes to smoothly integrating with Spring Boot but those are outweighed by the benefits of the new syntax and language constructs.</p>
<p>In our next installment, we will take a look at Java Spring Boot configuration classes and compare them to their Kotlin brethren. I'm hoping that we will continue to see gains from Kotlin that will outweigh the friction with Spring Boot.</p>
]]></description><link>http://engineering.pivotal.io/post/spring-boot-application-with-kotlin/</link><guid isPermaLink="true">http://engineering.pivotal.io/post/spring-boot-application-with-kotlin/</guid><category><![CDATA[Spring Boot]]></category><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Mike Gehard]]></dc:creator><pubDate>Sat, 13 Feb 2016 09:35:00 GMT</pubDate></item><item><title><![CDATA[(RU) Podcast Разбор Полетов: Episode 102 — Kotlin, тесты и здоровый сон.]]></title><description><![CDATA[<h2>Мероприятия</h2>
<ol>
<li><a href="http://jbreak.ru/">http://jbreak.ru/</a></li>
<li><a href="https://fosdem.org/2016/">https://fosdem.org/2016/</a></li>
</ol>
<h2>Темки</h2>
<ol>
<li>Kotlin 1.0 RC - Философия Kotlin</li>
<li>JavaTest, TCK, JTreg и его связь с TestNG/JUnit и прочие вопросы в знатоку по этим вопросам</li>
<li>Что нужно есть и сколько нужно спать, что бы быть белым русским мужчиной в Америке</li>
</ol>
<h2>Полезняшки</h2>
<ol>
<li>Клиент для Redis - <a href="https://github.com/luin/medis">Medis</a></li>
<li><a href="http://kotlin.link/">http://kotlin.link/</a></li>
<li><a href="https://github.com/Originate/git-town">https://github.com/Originate/git-town</a></li>
<li><a href="https://libraries.io/">https://libraries.io/</a></li>
</ol>
]]></description><link>http://razbor-poletov.com/2016/02/episode-102.html</link><guid isPermaLink="true">http://razbor-poletov.com/2016/02/episode-102.html</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Podcast]]></category><dc:creator><![CDATA[Dmitry Jemerov, Viktor Gamov, Alexey Abashev, Anton Arphipov,  Dmitry Churbanov, Anton Arhipov]]></dc:creator><pubDate>Thu, 04 Feb 2016 21:54:00 GMT</pubDate><enclosure url="http://traffic.libsyn.com/razborpoletov/razbor_102.mp3" length="70319173" type="audio/mpeg"/></item><item><title><![CDATA[Kotlin & Android: A Brass Tacks Experiment, Part 4]]></title><description><![CDATA[<p><img src="https://cdn-images-1.medium.com/max/800/1*UN-S8ELMC2kpHf4tJKfbLQ.png" alt="Header Picture"></p>
<p><em>Disclaimer: I am a Google employee, but the views expressed in this article are not those of my employer.</em></p>
<h2>Kotlin &#x26; Android: A Brass Tacks Experiment, Part 4</h2>
<p>Welcome to part 4 in this a series! If you missed <a href="https://medium.com/p/kotlin-android-a-brass-tacks-experiment-part-2-c67661cfdf5f">part 2</a> and <a href="https://medium.com/p/kotlin-android-a-brass-tacks-experiment-part-3-84e65d567a37">part 3</a>, consider jumping back to those for a minute to see where we are in this journey to learn what the Kotlin® language can uniquely offer for Android development.</p>
<p>At this point, we have a pair of functions that we can use to succinctly express the creation of an entire Android view hierarchy in Kotlin code instead of the usual XML resources. Kotlin’s <em>type-safe builder</em> pattern is really shining here! However, in practice, there are still some rough edges with this scheme. Most notably, Android developers are used to having some special expressions in XML for certain Android concepts, such as sizes of Views measured in density independent pixels. This is super easy in XML and super tiresome in code!</p>
<p>Here’s an example of a tiresome way to set the maxWidth property of a TextView to 120dp using our new v function:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> view = v&#x3C;TextView>(context) {
    <span class="hljs-comment">// ugly!</span>
    maxWidth = TypedValue.applyDimension(
        TypedValue.COMPLEX_UNIT_DIP, <span class="hljs-number">120</span>, context.resources.displayMetrics).toInt()
}</code></pre>
<p><a href="https://gist.github.com/CodingDoug/abe3765f9fe641871ede">gist</a></p>
<p>Contrast that to XML layouts, where you’d simply say:</p>
<pre><code class="hljs language-xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">TextView</span> <span class="hljs-attr">android:maxWidith</span>=<span class="hljs-string">"120dp"</span> /></span></code></pre>
<p><a href="https://gist.github.com/CodingDoug/c239a76530670537ce6b">gist</a></p>
<p>Bah! We just lost all the convenience that our v functions were trying to gain!</p>
<h3>We need an abbreviated way to convert dp to px.</h3>
<p>What I’d like is a function to provide shortened syntax for specifying pixel measurements in other units. Here’s what I want to say instead of the above mess:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> view = v&#x3C;TextView>(context) {
    <span class="hljs-comment">// simpler way to set maxWidth to 120dp</span>
    maxWidth = dp_i(<span class="hljs-number">120</span>)
}</code></pre>
<p><a href="https://gist.github.com/CodingDoug/cef8e7f5fe6324ff6436">gist</a></p>
<p>What I’m proposing here is a function that takes a value measured in dp and returns the value converted to px for the current device. Why call the function “dp_i” and not just “dp”? Sometimes Android wants to take pixel measurements as a floating point number and sometimes as an integer. I don’t want to manually cast the return value (still too many more characters), so I’ll just make one function for of each type, “dp_i” and “dp_f”.</p>
<p>But there’s a wrinkle here. If you look back at the full code that computes the dp value, it requires a Context to operate. I don’t want to have to pass a Context as another argument to dp_i every time I call it. So I’m going to use a feature of Kotlin called <a href="https://kotlinlang.org/docs/reference/extensions.html">extension functions</a> to get the brevity I prefer.</p>
<p>Let’s jump right into the code. Written as extension functions, here’s what dp_i and dp_f look like:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">import</span> android.view.View

<span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">dp_f</span><span class="hljs-params">(dp: <span class="hljs-type">Float</span>)</span></span>: <span class="hljs-built_in">Float</span> {
    <span class="hljs-keyword">return</span> TypedValue.applyDimension(
        TypedValue.COMPLEX_UNIT_DIP, dp, context.resources.displayMetrics)
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">dp_i</span><span class="hljs-params">(dp: <span class="hljs-type">Float</span>)</span></span>: <span class="hljs-built_in">Int</span> {
    <span class="hljs-keyword">return</span> dp_f(dp).toInt()
}</code></pre>
<p><a href="https://gist.github.com/CodingDoug/489045d5a92be732dec9">gist</a></p>
<h3>How does an extension function work?</h3>
<p>The first thing to notice in the above code is the apparent name of the functions. You might have expected to see just “dp_f” for the first function, but instead we have “View.dp_f”. This is a special syntax in Kotlin for extension functions. There is a dot between a class name (here, android.view.View) and the name of the function to define. What we did here was tell Kotlin to augment the View class with a new two new methods called “dp_f” and “dp_i”. There’s a couple things you get with extension functions like these.</p>
<p><strong>First, code in the body of the extension functions can act like a member of View by accessing its members and methods (but only of “public” and “internal” visibility)</strong>. This means that dp_f can use the View’s Context reference as exposed by the synthetic property called “context”. Now we don’t have to pass a Context as a parameter since it comes implicitly with the View.</p>
<p><strong>Second, other code that imports these extension functions can call them as if they’re normal member methods on instances of View objects</strong>. This means that our v function’s lambda with receiver argument of type View can call these methods similarly to ordinary functions, implicitly using the receiver View object reference. So you can say “maxWidth = dp_i(120)” in the lambda, and Kotlin will recognize that you want to call the dp_i function on the View type receiver object.</p>
<p><strong>One important thing to know here is that Kotlin doesn’t actually make changes to a class definition when defining an extension function</strong>. A class will always be its own complete unit after it’s been loaded by a program, so we can only use extension functions to add code around it. Also, the existing methods on View also can’t reach back into and extension function, because it’s not a real member defined with the class.</p>
<p>The upshot of these points, for this experiment, is that we now have convenient functions for converting dp to px in our v function lambdas!</p>
<p><strong>We’re not stopping here! How about another shortcut using extension functions?</strong></p>
<p>We’ve seen that you can do tricky things with extension functions to make some kinds of functions more convenient to use. Let’s continue with that thought to tighten up our v functions.</p>
<p>Currently, we have these two function signatures, the first for building the root view using a Context and the second for creating nested child views in a parent view:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&#x3C;<span class="hljs-keyword">reified</span> TV : View></span> <span class="hljs-title">v</span><span class="hljs-params">(context: <span class="hljs-type">Context</span>, init: <span class="hljs-type">TV</span>.()</span></span> -> <span class="hljs-built_in">Unit</span>) : TV

<span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&#x3C;<span class="hljs-keyword">reified</span> TV : View></span> <span class="hljs-title">v</span><span class="hljs-params">(parent: <span class="hljs-type">ViewGroup</span>, init: <span class="hljs-type">TV</span>.()</span></span> -> <span class="hljs-built_in">Unit</span>) : TV</code></pre>
<p><a href="https://gist.github.com/CodingDoug/c91ef8277e3edae1be6e">gist</a></p>
<p>It would be nice if we didn’t have to pass the Context or ViewGroup as the first parameter. With extension functions, we achieve this just like we did above when avoiding passing a Context to dp_f. Here’s a re-implementation of both functions as extension functions, with the commented out lines showing the original code for v above the newly modified lines:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">//inline fun &#x3C;reified TV : View> v(context: Context, init: TV.() -> Unit) : TV {</span>
<span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&#x3C;<span class="hljs-keyword">reified</span> TV : View></span> Context.<span class="hljs-title">v</span><span class="hljs-params">(init: <span class="hljs-type">TV</span>.()</span></span> -> <span class="hljs-built_in">Unit</span>) : TV {
    <span class="hljs-keyword">val</span> constr = TV::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>.<span class="hljs-title">getConstructor</span></span>(Context::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>)</span>

 <span class="hljs-comment">// val view = constr.newInstance(context)</span>
    <span class="hljs-keyword">val</span> view = constr.newInstance(<span class="hljs-keyword">this</span>)

    view.init()
    <span class="hljs-keyword">return</span> view
}

<span class="hljs-comment">//inline fun &#x3C;reified TV : View> v(parent: ViewGroup, init: TV.() -> Unit) : TV {</span>
<span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&#x3C;<span class="hljs-keyword">reified</span> TV : View></span> ViewGroup.<span class="hljs-title">v</span><span class="hljs-params">(init: <span class="hljs-type">TV</span>.()</span></span> -> <span class="hljs-built_in">Unit</span>) : TV {

    <span class="hljs-keyword">val</span> constr = TV::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>.<span class="hljs-title">getConstructor</span></span>(Context::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>)</span>

 <span class="hljs-comment">// val view = constr.newInstance(parent.context)</span>
    <span class="hljs-keyword">val</span> view = constr.newInstance(context)

    parent.addView(view)
    view.init()
    <span class="hljs-keyword">return</span> view
}</code></pre>
<p><a href="https://gist.github.com/CodingDoug/43d17d44459805e51072">gist</a></p>
<p>You can see that we’re removing the first argument to each function (Context and ViewGroup), and instead, expecting those references to come from the instance of the class they are extending. The functions now have just a single argument — the lambda with receiver that modifies the created View.</p>
<p>With these modified functions, if we’re coding inside an Activity (which is a subclass of Context), we refer to v as a member of the Activity object. We can take advantage of this to build nested views even easier like this:</p>
<pre><code class="hljs language-kotlin">v&#x3C;LinearLayout> {
    layoutParams = LayoutParams(WRAP_CONTENT, WRAP_CONTENT)
    orientation = VERTICAL

    v&#x3C;TextView> {
        layoutParams = LayoutParams(WRAP_CONTENT, WRAP_CONTENT)
        text = <span class="hljs-string">"Hello"</span>
    }
    v&#x3C;TextView> {
        layoutParams = LayoutParams(WRAP_CONTENT, WRAP_CONTENT)
        text = <span class="hljs-string">"World"</span>
    }
}</code></pre>
<p><a href="https://gist.github.com/CodingDoug/3961d2ccc55376cf1274">gist</a></p>
<p>The invocations of v don’t even look like function calls because we no longer need parenthesis at all. If you recall from <a href="https://medium.com/@CodingDoug/kotlin-android-a-brass-tacks-experiment-part-2-c67661cfdf5f">part 2 in this series</a>, if the last argument to a function is a lambda, you can place it after the parenthesis. And in this case, when there’s only one argument, you don’t need the parenthesis at all!</p>
<p>Kotlin’s extension functions have just gone a long way toward helping us express an Android view hierarchy in a very readable and succinct way in code. However, there’s still some more problem spots that could use some attention. For example, lets take this code that assigns 16dp of left padding to a TextView:</p>
<pre><code class="hljs language-kotlin">v&#x3C;TextView> {
    layoutParams = LayoutParams(WRAP_CONTENT, WRAP_CONTENT)
    setPadding(dp_i(<span class="hljs-number">16</span>), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)
    text = <span class="hljs-string">"Hello"</span>
}</code></pre>
<p><a href="https://gist.github.com/CodingDoug/6119424973b9c0f3824d">gist</a></p>
<p>It’s pretty ugly to mix a method call to setPadding() with the synthetic property accessors for layoutParams and text. setPadding() is causing us problems here because it’s not a JavaBeans-style setter — it has more than one argument. Therefore, Kotlin can’t assign a synthetic property to it. But fear not! This can be fixed with clever use of another Kotlin language feature, as we’ll discover in the upcoming part 5.</p>
<p>If you want to stay on top of this series, you can follow me both <a href="https://medium.com/@CodingDoug">here on Medium</a> and <a href="https://twitter.com/CodingDoug">on Twitter</a> as CodingDoug and get instant notification of future parts!</p>
]]></description><link>https://medium.com/@CodingDoug/kotlin-android-a-brass-tacks-experiment-part-4-4b7b501fa457#.dllcmjpbu</link><guid isPermaLink="true">https://medium.com/@CodingDoug/kotlin-android-a-brass-tacks-experiment-part-4-4b7b501fa457#.dllcmjpbu</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Android]]></category><dc:creator><![CDATA[Doug Stevenson]]></dc:creator><pubDate>Thu, 04 Feb 2016 21:54:00 GMT</pubDate></item><item><title><![CDATA[Kotlin 1.0 Release Candidate is Out!]]></title><description><![CDATA[<p>Finally, Kotlin has graduated the Beta and we are happy to present the Release Candidate Build!</p>
<p><strong>NOTE</strong>: as we <a href="http://blog.jetbrains.com/kotlin/2015/12/kotlin-1-0-beta-4-is-out/">announced earlier</a>, <strong>RC requires all code to be recompiled</strong> to make sure no code compiled with older versions is kept around (please recompile even if you were on the EAP version!).</p>
<p>This blog post gives an overview of the changes made since Beta 4. Library changes are the biggest in this build. Also, some bugs have been fixed. Full list of changes is available <a href="https://github.com/JetBrains/kotlin/releases/tag/build-1.0.0-rc-1036">here</a>.</p>
<p><img src="http://i1.wp.com/blog.jetbrains.com/kotlin/files/2016/02/RC-Banner.png?resize=640%252C330" alt="Kotlin 1.0 RC"></p>
<p><em>See the discussions on <a href="https://news.ycombinator.com/item?id=11034273">Hacker News</a> and <a href="https://www.reddit.com/r/programming/comments/445jih/jvm_languages_news_kotlin_10_release_candidate_is/">Reddit</a></em>.</p>
<h2>Language</h2>
<p>First of all, as promised before, there has been a clean-up:</p>
<ul>
<li>All previously deprecated language constructs are now errors, not warnings.</li>
<li>All deprecated declarations previously generated in the byte code (such as static fields in interfaces etc) have been removed.</li>
</ul>
<p>Most other language changes are minor tweaks and bug fixes. Some highlights are given below. See the full list <a href="https://github.com/JetBrains/kotlin/releases/tag/build-1.0.0-rc-1036">here</a>.</p>
<h3>Annotations on delegate fields</h3>
<p>The new <code>@delegate:</code> annotation target (use-site) is now supported. For example, to mark the delegate object as <code>@Transient</code>, we can say:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span> </span>{
    <span class="hljs-meta">@delegate:Transient</span>
    <span class="hljs-keyword">val</span> foo <span class="hljs-keyword">by</span> Lazy { ... }
}</code></pre>
<p>In the byte code, the field holding the delegate will be annotated.</p>
<h3>Type checking for use-site variance</h3>
<p>We have fixed a number of annoying bugs connected with use-site variance (type projections). As a result, the compiler may find some previously missed bugs in your code.
For example, in the following case:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> ints = mutableListOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
<span class="hljs-keyword">val</span> strs = mutableListOf(<span class="hljs-string">"abc"</span>, <span class="hljs-string">"def"</span>)
<span class="hljs-keyword">val</span> comps: MutableList&#x3C;<span class="hljs-keyword">out</span> Comparable&#x3C;*>> = ints
comps.addAll(strs) <span class="hljs-comment">// ?! Adding strings to a list of ints</span></code></pre>
<p>This code was mistakenly accepted before and is rejected now on the last line with the message:</p>
<pre><code class="hljs language-kotlin">Projected type MutableList&#x3C;<span class="hljs-keyword">out</span> Comparable&#x3C;*>> restricts the use of addAll()</code></pre>
<h2>Java Interoperability</h2>
<p>Some improvements to synthesized properties derived from Java’s get/set pairs:</p>
<ul>
<li>such declarations (as well as SAM-converted methods) are now resolved on par with members;</li>
<li>support added for Java setters that return values.</li>
</ul>
<p>Support added for <code>@Nullable/@NotNull</code> annotations from various popular libraries such as <code>javax.annotations</code>, Android SDK, etc.
EAP users report:</p>
<blockquote>
<p>Android annotations being recognized broke a lot of my code in a good way</p>
</blockquote>
<p>And highlighted bug fixes:</p>
<ul>
<li>Private top-level Kotlin classes are now compiled to package-private Java classes</li>
<li>Members of private classes can-not be accessed from non-private inline functions</li>
</ul>
<h2>Standard Library</h2>
<ul>
<li>Library code rearranged into more granular packages (no source changes should be required)</li>
<li>Some functions have been made inline</li>
<li>Many inline functions (most of them one-liners) can no longer be called from Java code. This will help us reduce the size of the runtime library in the future.</li>
<li>All old deprecations have been removed</li>
<li><code>Map.getOrElse()</code> and <code>Map.getOrPut()</code> now treat keys associated with <code>null</code> values as <strong>missing</strong>.</li>
<li><code>mutableListOf</code>, <code>mutableSetOf</code>, <code>mutableMapOf</code> added to construct mutable collections.</li>
<li><code>toMutableList</code> added instead of <code>toArrayList</code>. The latter is deprecated</li>
<li><code>associate</code> and <code>associateBy</code> are added to aid construction of maps (instead of <code>toMap</code>/<code>toMapBy</code>)</li>
<li>Comparator- and comparison-related functions are moved to <code>kotlin.comparisons</code> package (not imported by default)</li>
</ul>
<p>More changes <a href="https://github.com/JetBrains/kotlin/releases/tag/build-1.0.0-rc-1036">here</a></p>
<h2>Tooling</h2>
<p>To enable Android Extensions in Gradle in a more idiomatic way, we now say:</p>
<pre><code class="hljs language-kotlin">apply plugin: <span class="hljs-string">'kotlin-android-extensions'</span></code></pre>
<p>in the <code>build.gradle</code> file (individually for each project).</p>
<p>The old way doesn’t work any more and prints fixing instructions to the output.</p>
<h2>IDE Changes</h2>
<ul>
<li>Intention to replace iteration over map entries with a loop using a destructuring declaration</li>
<li>Inspection and quickfix to cleanup redundant visibility modifiers</li>
<li>Inspection to replace ‘assert’ calls checking that a variable is not null with <code>!!</code> or <code>?: error(...)</code></li>
<li>Show “Kotlin not configured” notification when opening a .kt file in the IDE if the Kotlin runtime is not configured for the corresponding module</li>
<li>Action to generate the <code>toString()</code> method</li>
<li>Support for implementing members by primary constructor parameters</li>
<li>Parameter info popup works for showing type parameters</li>
<li>Completion offers name variants based on unresolved identifiers in current file</li>
<li>Quickfix for adding missing branches to a <code>when</code> expression</li>
<li>Support for moving nested classes to the upper level or into another top-level class</li>
<li><code>@Suppress</code> now works for IDE inspections</li>
</ul>
<h2>Installation Instructions</h2>
<p>For the users of IntelliJ IDEA, automatic updates may not work in the IDE, so you’ll need to download the plugin and install it from a zip file:</p>
<ul>
<li>Download <a href="https://plugins.jetbrains.com/plugin/download?pr=&#x26;updateId=23813">here</a></li>
<li>Go to <em>Preferences | Plugins</em> and click <em>Install plugin from disk...</em></li>
</ul>
<p>Sorry for the inconvenience.</p>
<h2>Stay tuned</h2>
<p>The final release is approaching, meanwhile — have a nice Kotlin! <img src="http://i2.wp.com/blog.jetbrains.com/kotlin/wp-includes/images/smilies/simple-smile.png?w=640" alt=":)"></p>
<p><em>P.S. See the discussions on <a href="https://news.ycombinator.com/item?id=11034273">Hacker News</a> and <a href="https://www.reddit.com/r/programming/comments/445jih/jvm_languages_news_kotlin_10_release_candidate_is/">Reddit</a></em>.</p>
]]></description><link>http://blog.jetbrains.com/kotlin/2016/02/kotlin-1-0-release-candidate-is-out/</link><guid isPermaLink="true">http://blog.jetbrains.com/kotlin/2016/02/kotlin-1-0-release-candidate-is-out/</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Release]]></category><dc:creator><![CDATA[Andrey Breslav]]></dc:creator><pubDate>Thu, 04 Feb 2016 14:39:00 GMT</pubDate></item><item><title><![CDATA[Kotlin Coding]]></title><description><![CDATA[<h6><em>Part 2</em></h6>
<p>As mentioned in the previous <a href="http://www.cirorizzo.net/2016/01/23/kotlin-at-glance/">post</a>, Kotlin representing a better way to program on the Android platform and the better companion for it is <a href="http://developer.android.com/sdk/index.html">Android Studio</a>.
If you're one of the kind still struggling to start to use this Official Android IDE, well this is good chance to give it a try.</p>
<h4>Setup Android Studio</h4>
<p>Android Studio comes from <a href="https://www.jetbrains.com/">JetBrains</a>, the same of Kotlin; so no worries about strange configurations or weird plugins: Android Studio has already all what you need to start coding Kotlin.</p>
<blockquote>
<p>The IDE's got another magic feature who convert Java code to Kotlin from Menu <strong><em>Code->Convert Java file to Kotlin file</em></strong></p>
</blockquote>
<p>Another cool thing is you can have a project mixing Java and Kotlin at same time across different files (of course you cannot mix Java and Kotlin in the same file/class!).</p>
<p>Let's start having a look what is needed to start or adding some Kotlin classes to an Android Project.</p>
<p>As mentioned early, you don't need to install anything else to have Kotlin on Android Studio, but you need to specify in the project build tool (Module <code>build.gradle</code> file) to include all we need.</p>
<p>At the beginning of the file, just after the standard Android plugin adding the Kotlin one</p>
<pre><code class="hljs language-groovy">apply <span class="hljs-string">plugin:</span> <span class="hljs-string">'com.android.application'</span>
apply <span class="hljs-string">plugin:</span> <span class="hljs-string">'kotlin-android'</span></code></pre>
<p>For our purpose one more plugin to use the Kotlin Android Extension (not mandatory)</p>
<pre><code class="hljs language-groovy">apply <span class="hljs-string">plugin:</span> <span class="hljs-string">'kotlin-android-extensions'</span></code></pre>
<p>And in the <code>buildscript</code> section of the same file, adding the Kotlin libraries. For the latest version check the <a href="https://kotlinlang.org/docs/reference/using-gradle.html">official page</a> to have the latest update</p>
<pre><code class="hljs language-gradle"><span class="hljs-keyword">buildscript</span> {
    <span class="hljs-keyword">repositories</span> {
        jcenter()
    }
    <span class="hljs-keyword">dependencies</span> {
        <span class="hljs-keyword">classpath</span> <span class="hljs-string">"org.jetbrains.kotlin:kotlin-gradle-plugin:&#x3C;current version>"</span>
    }
}</code></pre>
<p>It's my intention to talk on this Kotlin posts series about the basic of the language and how the standard library <em>Kotlin Android Extension</em> (the second library included above) can help and improve exponentially the Kotlin skill programming.</p>
<blockquote>
<p>There's another powerful library called <a href="https://github.com/Kotlin/anko">Anko</a>, a type-safe DSL (...and more) who can help a lot as well, we're going to go deeper later on</p>
</blockquote>
<p>And one more dependency to include at <code>dependencies</code> section</p>
<pre><code class="hljs language-groovy">dependencies {
   compile <span class="hljs-string">'org.jetbrains.kotlin:kotlin-stdlib:&#x3C;current version>'</span>
}</code></pre>
<p>If you're gonna to have your project entirely in Kotlin, your project setup is finished, but if you want to mix Java as well, or basically you want to start adding new Kotlin classes to your existing project is strongly suggested to define two different folders, one for Java and one for Kotlin</p>
<pre><code>project
   - src
      - main (root)
         - java
         - kotlin
</code></pre>
<p>and in that case adding in the <code>build.gradle</code> the following snap</p>
<pre><code class="hljs language-groovy">sourceSets {
    main.java.srcDirs += <span class="hljs-string">'src/main/java'</span>
    main.java.srcDirs += <span class="hljs-string">'src/main/kotlin'</span>
}</code></pre>
<p>Well done! Now you're ready to start coding...</p>
<h4>Starting Kotlin Project</h4>
<p>Starting a project the first class we're thinking of is an Activity class ;) so let's start from it</p>
<blockquote>
<p>At the moment is not possible starting a Kotlin project by the scratch in Android Studio using wizard template</p>
</blockquote>
<p>Let's create an Android project using the template <code>Empty Activity</code> and after it we'll have a Java class (...erm, what?)</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>{
   <span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>{
      <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);
      setContentView(R.layout.activity_main);
   }
}</code></pre>
<p>well let's using the JetBrains magic through the auto converter feature selecting the menu <code>Code->Convert Java file to Kotlin file</code> and...</p>
<pre><code class="hljs language-java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> : <span class="hljs-title">AppCompatActivity</span>() </span>{
   <span class="hljs-function">override fun <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: Bundle?)</span> </span>{
      <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)
      setContentView(R.layout.activity_main)
   }
}</code></pre>
<p>As you can notice there are a bunch of smart things like:</p>
<ul>
<li>no more semicolon <code>;</code> (it's optional, so if you still struggling to get rid of it, Kotlin is tolerant! ;)</li>
<li>The <em>scope</em> of the class or method if <code>public</code> is omitted (i.e. <code>class MainActivity</code>)</li>
<li>get rid <code>extends</code> keyword for inheritance and just colon <code>:</code> instead</li>
<li>inherited class used with brackets <code>()</code> means to be initialized with the primary constructor (i.e. <code>AppCompatActivity()</code>)</li>
<li>methods are function and the keyword is just <code>fun</code></li>
<li>function returning <code>void</code> just not needs any additional keyword</li>
<li>the type of a member, param, etc is placed after it and followed by a colon <code>:</code></li>
<li>and at last but not least the <em>Null Safety</em> concept; in Kotlin every member, variable comes from a type, is not nullable by default, if you need (permit!) to use a nullable one, has to be declared using a special keyword at the end of the type <code>?</code> (i.e. <code>savedInstanceState: Bundle?</code>)</li>
</ul>
<p>So far easy, isn't it?
Well, will be even more!</p>
<h4>Koltin Android Extensions</h4>
<p>The plugin included early at the beginning of Gradle file</p>
<pre><code class="hljs language-groovy">apply <span class="hljs-string">plugin:</span> <span class="hljs-string">'kotlin-android-extensions'</span></code></pre>
<p>is a powerful tool who helps to avoid a lots of boilerplate for binding views in our class and preventing one of the biggest feckless function in Android: <code>findViewById()</code>.</p>
<p>Starting have a look to our layout <code>activity_main.xml</code>, for sure it'll have the standard <code>TextView</code></p>
<pre><code class="hljs language-xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">TextView</span>
    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"wrap_content"</span>
    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span>
    <span class="hljs-attr">android:text</span>=<span class="hljs-string">"Hello World!"</span>
    <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/textVw"</span>/></span></code></pre>
<p>well, usually in Java we need to declare the View</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">private</span> TextView textVw;</code></pre>
<p>and then binding it with instance of the object defined in the layout through this</p>
<pre><code class="hljs language-java">textVw = (TextView) findViewById(R.id.textVw);</code></pre>
<p>and starting to use it</p>
<pre><code class="hljs language-java">textVw.setText(<span class="hljs-string">"Hello, How're You?"</span>);</code></pre>
<p>Boring, isn't it?</p>
<p>All this code in Kotlin is now <strong>useless</strong>, the only thing to do is just starting to use the view</p>
<pre><code class="hljs language-kotlin">textVw.text = <span class="hljs-string">"Hello, How're You?"</span></code></pre>
<p>That's it!</p>
<p>Koltin Android Extensions thinks all the rest...
You'll notice about the <code>import</code> added by the IDE in the class</p>
<pre><code>import kotlinx.android.synthetic.main.activity_main.*
</code></pre>
<p>This is used to have the binding with our <code>TextView</code></p>
<p>What do you think about? Still skeptical?
Well, I know you're a developer (<em><del>stubborn</del> skeptical people</em>) ;)
Let's go further on this thing improving our project step by step later on...</p>
<p>See you soon on the next post!</p>
]]></description><link>http://cirorizzo.net/2016/02/03/kotlin-code/</link><guid isPermaLink="true">http://cirorizzo.net/2016/02/03/kotlin-code/</guid><category><![CDATA[Android]]></category><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Ciro Rizzo]]></dc:creator><pubDate>Wed, 03 Feb 2016 00:38:00 GMT</pubDate></item><item><title><![CDATA[10 Kotlin Tutorials for Beginners: Dive Into Kotlin Programming]]></title><description><![CDATA[<h1>10 Kotlin Tutorials for Beginners: Dive Into Kotlin Programming</h1>
<p>There is a serious lack of Kotlin tutorials for beginners<img src="http://petersommerhoff.com/wp-content/uploads/2016/02/kotlin-programming-course-300x169.png" alt="The first Kotlin tutorial for beginners">. You only find experienced Java developers hacking down Kotlin code in record time. Don’t get me wrong — those are really great for other experienced developers and I enjoy watching them. But for beginners, they are just voodoo code appearing on the screen like magic.</p>
<p>Kotlin is actually a great language to learn first, if only the necessary tutorials were out there. So I decided to create a course that even total beginners can follow. Check out the first 10 Kotlin tutorials below or <a href="https://www.udemy.com/kotlin-course/?couponCode=AMAZINGREADERS25">check out the whole course</a> (it’s $25 with the 50% reader discount).</p>
<h2>#1: A Brief Overview of Kotlin</h2>
<p>Learn where Kotlin comes from, the language concepts it incorporates, and <em>why you should learn it</em>.</p>
<iframe src="https://www.youtube.com/embed/AcwzpPLV5HY?feature=oembed" allowfullscreen="" height="540" frameborder="0" width="960"></iframe>
<h2>#2: Try It Out in 30 Seconds</h2>
<p>This is a quick video for those who cannot wait to dive into code. Learn how to use the <a href="http://try.kotlinlang.org/">Kotlin online editor</a> to try out some of the language basics.</p>
<iframe src="https://www.youtube.com/embed/kdorCemb2v8?feature=oembed" allowfullscreen="" height="540" frameborder="0" width="960"></iframe>
<h2>#3: Installing the JDK</h2>
<p>If you already have the Java Development Kit (JDK) installed, you can happily skip this step. If not, just follow this video and use <a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">this link</a> that is mentioned in the video.</p>
<iframe src="https://www.youtube.com/embed/2rOYygAEEQQ?feature=oembed" allowfullscreen="" height="540" frameborder="0" width="960"></iframe>
<h2>#4: Installing IntelliJ</h2>
<p>If you don’t already have IntelliJ, you should change that right away — I really learned to love this powerful IDE. This tutorial guides you through the download and installation process. And <a href="http://www.jetbrains.com/idea/">here’s the link</a> mentioned in the video.</p>
<iframe src="https://www.youtube.com/embed/EbGHqY5EJvU?feature=oembed" allowfullscreen="" height="540" frameborder="0" width="960"></iframe>
<h2>#5: Setting Up IntelliJ</h2>
<p>This tutorial covers just the most basic layout settings: how you can adjust the theme and font in IntelliJ to your favorite style.</p>
<iframe src="https://www.youtube.com/embed/TtIKESmXTXQ?feature=oembed" allowfullscreen="" height="540" frameborder="0" width="960"></iframe>
<h2>#6: Using Kotlin Interactively in The REPL</h2>
<p>The Kotlin REPL allows us to use Kotlin interpreter-style, so that we can put in an expression (or any line of code) and see what Kotlin does with it. It’s great to try out some basic expressions and calculations.</p>
<iframe src="https://www.youtube.com/embed/wDkWaHYiLWk?feature=oembed" allowfullscreen="" height="540" frameborder="0" width="960"></iframe>
<h2>#7: Variables</h2>
<p>It’s time to learn about variables in Kotlin. This tutorial covers how to create and use variables of different types and the differences of the val and var keywords (to create immutable and mutable variables, respectively).</p>
<iframe src="https://www.youtube.com/embed/Nz-lMqxfUUs?feature=oembed" allowfullscreen="" height="540" frameborder="0" width="960"></iframe>
<h2>#8: Basic Types &#x26; Strings</h2>
<p>This tutorial covers all the basic types in Kotlin including strings. In the video, I go through the differences between the different data types for storing integer values, floating point numbers, text and logical values.</p>
<iframe src="https://www.youtube.com/embed/8JhPR-vojiI?feature=oembed" allowfullscreen="" height="540" frameborder="0" width="960"></iframe>
<h2>#9: Nullable Variables</h2>
<p>Kotlin gets rid of the worst enemy of all Java developers — the NullPointerException. In Kotlin, you can use nullable types to decide which variables can be set to null and which cannot. By default, a variable just cannot be assigned to null.</p>
<iframe src="https://www.youtube.com/embed/PYwJ-07I9as?feature=oembed" allowfullscreen="" height="540" frameborder="0" width="960"></iframe>
<h2>#10: Your First Standalone Application</h2>
<p>This tutorial covers how you can create a main() function in Kotlin to define the entry-point to your applications. Once you have made it through this lecture, you’re ready to go and really dive into development with Kotlin.</p>
<iframe src="https://www.youtube.com/embed/wqUfs89N5yg?feature=oembed" allowfullscreen="" height="540" frameborder="0" width="960"></iframe>
<h2>Continue Learning...</h2>
<p>If you’re as excited about Kotlin as I am, you can get my whole course on Udemy for $25 using <a href="https://www.udemy.com/kotlin-course/?couponCode=AMAZINGREADERS25">this coupon link</a>.</p>
<p>Inside the course, you’ll go from the basics to more advanced topics. These include:</p>
<ul>
<li>Conditional expressions using <em>if</em> and <em>when</em></li>
<li>Loops using <em>for</em> and <em>while</em></li>
<li>Arrays and lists</li>
<li>Functions</li>
<li>Classes, objects, interfaces, inheritance and all you need to know about object-orientation</li>
<li>Functional programming in Kotlin</li>
<li>Several coding challenges and quizzes for you to test what you’ve learned</li>
</ul>
<p>The course will be improved and extended based on student feedback and I’ll be there to help you personally whenever you get stuck. That way, there is no excuse for not learning Kotlin — even if you’re a total beginner.</p>
<p><a href="https://www.udemy.com/kotlin-course/?couponCode=AMAZINGREADERS25">Join the course now (50% discount for my readers)</a></p>
<h2>Any Thoughts?</h2>
<p>What do you think about Kotlin? Is it “better than Java” or just yet another JVM language for you?</p>
<p>What else do you want to learn about Kotlin? Let me know in the comments and I’ll respond to you personally.</p>
]]></description><link>http://petersommerhoff.com/dev/kotlin/kotlin-beginner-tutorial/</link><guid isPermaLink="true">http://petersommerhoff.com/dev/kotlin/kotlin-beginner-tutorial/</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Videos]]></category><dc:creator><![CDATA[Peter Sommerhoff]]></dc:creator><pubDate>Tue, 02 Feb 2016 17:37:00 GMT</pubDate></item><item><title><![CDATA[Kotlin & Android: A Brass Tacks Experiment, Part 2.]]></title><description><![CDATA[<p><img src="https://d262ilb51hltx0.cloudfront.net/max/800/1*UN-S8ELMC2kpHf4tJKfbLQ.png">
<em>Disclaimer: I am a Google employee, but the views expressed in this article are not those of my employer.</em></p>
<h3>Kotlin &#x26; Android: A Brass Tacks Experiment, Part 2</h3>
<p>This is part 2 of a series exploring what the Kotlin® language can uniquely offer Android developers. <a href="https://medium.com/@CodingDoug/kotlin-android-a-brass-tacks-experiment-part-1-3e5028491bcc">Last time</a> there was some detail on how to get Kotlin support added to an Android project. Now we’ll actually dive into code and see how some Kotlin language features can be used to do nifty things in an Android project.</p>
<p>When I first encountered Kotlin and pored over the list of language features, one thing in particular stood out to me. Kotlin has a feature called <a href="https://kotlinlang.org/docs/reference/type-safe-builders.html">type-safe builders</a> that lets you express object creation in a style that looks declarative. It allows a syntax that looks a lot like Gradle build files. But where Gradle and Groovy are dynamically typed, Kotlin is statically typed, so the compiler will let you know if you’re assigning values to properties that don’t make sense.</p>
<p>The typical examples of type-safe builders show how it’s possible to build nested data structures, like XML documents. When I think Android and XML, layouts and views quickly come to mind. If Kotlin is good at building up stuff like XML programmatically, perhaps it would do well with view hierarchies. So, that’s where I started. I figured I would try to create a sort of shorthand for building view hierarchies programmatically, which is code-intensive if you’re doing it in the Java® language.</p>
<p>Important note: I will be referring to <em>lambdas</em> frequently going forward. Before continuing, be sure you understand what that means in the context of computer programming, even if not specifically for Kotlin. In short, it’s a way of expressing an anonymous function that you would pass inline to another function or assign to a variable.</p>
<p>The core feature of Kotlin that makes type-safe builders possible is called <a href="https://kotlinlang.org/docs/reference/lambdas.html#function-literals-with-receiver"><em>lambda with receiver</em></a>. Let’s get straight into an example that’s actually useful. Kotlin allows you to define functions outside of classes, and that’s all I’m doing here. Also note that the names of variables come before their types, which is the opposite of the Java language.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">import</span> android.content.Context
<span class="hljs-keyword">import</span> java.lang.reflect.Constructor

<span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&#x3C;<span class="hljs-keyword">reified</span> TV : View></span></span>
        v(context: Context, init: TV.() -> <span class="hljs-built_in">Unit</span>) : TV {
    <span class="hljs-keyword">val</span> constr = TV::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>.<span class="hljs-title">getConstructor</span></span>(Context::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>)</span>
    <span class="hljs-keyword">val</span> view = constr.newInstance(context)
    view.init()
    <span class="hljs-keyword">return</span> view
}</code></pre>
<p>The above function is named v for brevity as I’ll use it a lot here and in future posts, and you can call it like this:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">import</span> android.view.ViewGroup.LayoutParams
<span class="hljs-keyword">import</span> android.view.ViewGroup.LayoutParams.WRAP_CONTENT
<span class="hljs-keyword">import</span> android.widget.TextView

<span class="hljs-keyword">val</span> view = v&#x3C;TextView>(context) {
    layoutParams = LayoutParams(WRAP_CONTENT, WRAP_CONTENT)
    text = <span class="hljs-string">"Hello"</span>
}</code></pre>
<p>That’s equivalent to inflating an XML layout that looks like this:</p>
<pre><code class="hljs language-xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">TextView</span>
    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"wrap_content"</span>
    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span>
    <span class="hljs-attr">android:text</span>=<span class="hljs-string">"Hello"</span> /></span></code></pre>
<p>Neat! Now, if this is your first time seeing Kotlin, there’s a lot to translate into English! Here’s a few bits of Kotlin syntax to unpack:</p>
<blockquote>
<p>&#x3C;reified TV : View></p>
</blockquote>
<p>The word <a href="http://dictionary.reference.com/browse/reify">reify</a> means “to make an abstract thing concrete”. As a Kotlin keyword on a <a href="https://kotlinlang.org/docs/reference/generics.html#generic-functions">function’s generic type</a>, this means that you have compile-time access to the JVM Class object specified for the generic type in the body of the function. So this bit of code says that the function v makes use of a “reified” generic type named TV (think “Type of View”) which must be View or a subclass of View. The function must also be declared inline for this to work. The caller then gives TV a specific type in angle brackets when calling the function.</p>
<blockquote>
<p>init: TV.() -> Unit</p>
</blockquote>
<p>v takes two parameters, a Context and a lambda named init. init is special because it’s a lambda with receiver type function reference. A lambda with receiver is a block of code that requires an object of a certain type. This required object is referenced by the keyword “this” in the body of the lambda. The type of the receiver object here is the reified generic type TV.</p>
<p>In our specific case, function v is declaring, “I’m going to create an object of type TV, and I need you to tell me how to initialize it”. So this new TV type object becomes the receiver of the provided lambda, and the lambda is invoked by v with view.init() so it can perform some actions with the view. The “-> Unit” in the syntax is just saying that the lambda returns type Unit, which is like the type void in Java code. In other words, it returns nothing.</p>
<p>To summarize this lambda with receiver:</p>
<ul>
<li>v declares a parameter called init which is a lambda with receiver for type TV.</li>
<li>v creates and initializes a TV type object and invokes the lambda on it to initialize it.</li>
<li>The lambda sees the TV type object as “this” in its chunk of code.</li>
</ul>
<blockquote>
<p>TV::class.java</p>
</blockquote>
<p>To reference the reified generic type TV’s implicitly available Class object in the function, you can use the expression TV::class.java. This kind of expression is a very special Kotlin feature for reified generic types that drastically reduces the amount of code you must write in functionally equivalent Java code.</p>
<p>At this point, I’m going to anticipate a couple more questions you might have about this function:</p>
<blockquote>
<p>“Why does v take two arguments, but appear to be given only one inside the argument parenthesis?”</p>
</blockquote>
<p>This is another unfamiliar syntax to Java programmers. In the Java language, all the arguments to a function always appear inside the call’s parentheses, which can be a lot of added lines if it includes an anonymous callback. But in Kotlin, there is a special syntax when a lambda is the last argument to a function. This syntax allows the lambda to appear in curly braces <em>immediately following</em> the parentheses of the function call. You <em>could</em> put the whole thing inside the parentheses, but most of the time it’s neater this way and keeps the function call parentheses on the same line, so they’re easier to track. Also, this lambda syntax is similarly available when inlining anonymous Java objects that have a single method, such as Runnable.</p>
<blockquote>
<p>“Are ‘layoutParams’ and ‘text’ some sort of variables?”</p>
</blockquote>
<p>A syntax feature of a lambda with receiver is that the “this” keyword may be omitted when referencing methods and <a href="https://kotlinlang.org/docs/reference/properties.html">properties</a> of “this” inside the lambda. But what exactly are layoutParams and text in the call example? These are provided by Kotlin as properties of the receiver type TV (a TextView in our example). Because TextView has methods for setLayoutParams() and setText(), Kotlin recognizes those as JavaBeans-style accessors and creates properties for them that can be accessed as if they were Java class members. So, text = “Hello” here is exactly equivalent to this.setText(“Hello”). Slick! Here’s a screenshot of Android Studio with the Kotlin plugin showing specifically what’s going on during autocomplete:</p>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/800/0*vDlPyDAn73AbhqQO.">
<em>The IDE’s autocomplete suggests which methods are backing Kotlin properties.</em></p>
<p>As you can see, the Kotlin plugin is pointing out to us that the property called “text” (among other properties) is derived from the underlying JavaBeans-style getter and setter methods of the TextView type receiver object.</p>
<blockquote>
<p>“What is this Constructor business? Can’t we just say “new TV(context)”?”</p>
</blockquote>
<p>Since the compiler doesn’t know exactly what a TV is yet in the method body of v, we can’t instantiate it using new + classname. However, we can use the reified class object (TV::class.java) to locate a Constructor that takes a Context as the single argument. It’s conventional for Android View types to have a constructor with this signature, and we’re depending on it. This Constructor object can be invoked to get a new instance of type TV, with the same effect as the new keyword in Java code. This is a reasonable price to pay for the flexibility of having a single function work for all types of views instead of creating a whole new function for each type of view you want to build. And we can optimize this a bit more later in a future part to this blog series.</p>
<p>That’s a whole lot of convenience for a few lines of code! If you’re new to Kotlin, you might want to go back and digest this a second time, because some of these concepts can be very foreign to Java programmers. It certainly took me a bit of studying to grok all this new stuff.</p>
<p>This is just the beginning of my experiment. There’s still many ways this function could be enhanced and made easier to use. For example, it would be great if we could build entire nested view hierarchies in a single expression. So stay tuned for <a href="https://medium.com/@CodingDoug/kotlin-android-a-brass-tacks-experiment-part-3-84e65d567a37">the next post in this series</a> to see how we can use Kotlin to do that!</p>
]]></description><link>https://medium.com/@CodingDoug/kotlin-android-a-brass-tacks-experiment-part-2-c67661cfdf5f#.x698dgmuz</link><guid isPermaLink="true">https://medium.com/@CodingDoug/kotlin-android-a-brass-tacks-experiment-part-2-c67661cfdf5f#.x698dgmuz</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Android]]></category><dc:creator><![CDATA[Doug Stevenson]]></dc:creator><pubDate>Mon, 01 Feb 2016 18:09:00 GMT</pubDate></item><item><title><![CDATA[Kotlin & Android: A Brass Tacks Experiment, Part 1.]]></title><description><![CDATA[<p><img src="https://d262ilb51hltx0.cloudfront.net/max/800/1*UN-S8ELMC2kpHf4tJKfbLQ.png">
<em>Disclaimer: I am a Google employee, but the views expressed in this article are not those of my employer.</em></p>
<h3>Kotlin &#x26; Android: A Brass Tacks Experiment, Part 1</h3>
<p>One topic that’s been gaining popularity over the past year in the world of Android development is the <a href="https://kotlinlang.org/">Kotlin</a>® language for the <a href="https://en.wikipedia.org/wiki/Java_virtual_machine">JVM</a> from <a href="https://www.jetbrains.com/">JetBrains</a>. JetBrains is the same crew who created <a href="https://www.jetbrains.com/idea/">IntelliJ Idea</a>, which is the foundation for <a href="http://developer.android.com/tools/studio/index.html">Android Studio</a>. Kotlin takes aim at the age and perceived uncoolness of the Java® language with fresh and popular language features. I imagine that the crew at JetBrains imagines it could potentially become a replacement for Java® programming for all kinds of development on the JVM. Because it’s 100% inter-operable with the Java language, you can choose to use as much or as little Kotlin in your project as you like. And because it has a relatively small standard library, it’s suitable for development on mobile devices with limited resources.</p>
<p>Kotlin can do anything the Java language can do and more, but often with a more concise and pleasant syntax. There is full IDE support in IntelliJ and Android Studio. Because I’ve been deeply involved with Android since 2009, my specific interest in Kotlin is to discover what it <em>uniquely</em> offers to Android developers. So I’m cutting through the hype in this blog series and getting down and dirty with Kotlin’s best language features, to see if I can make something truly useful.</p>
<p>In this first of a series of blog posts, I’ll go over the cleanest possible path to get Kotlin integrated into a new Android project. But if you’re looking to get straight to the code already, then go ahead and jump to <a href="https://medium.com/@CodingDoug/kotlin-android-a-brass-tacks-experiment-part-2-c67661cfdf5f">part 2</a>!</p>
<h4>Configuring an Android Project with Kotlin</h4>
<p>The <a href="https://kotlinlang.org/docs/tutorials/kotlin-android.html">official docs</a> on getting started with Kotlin will show you how to install the Kotlin IDE plugin, and use that to modify an Android project’s Gradle config to add support for compiling Kotlin source. I don’t recommend this particular process, because I found the result of the automation to be less than satisfactory. While the changes it makes to the project’s Gradle build files might technically work, they don’t seem to be consistent with the way that new Android projects are typically set up.</p>
<p>To be frank, I have never been a fan of any Android Studio plugin that tries to guess changes to make to Android builds — more often than not, they botch things up, and I have to redo everything it did to clean it up to my liking. Gradle build files are actually source code, and automated processes are not really good at making changes to existing code! So, if you’re picky like me, take the extra minute to configure your project manually.</p>
<p>If you want to follow along, we’ll take four quick steps to get up and running:</p>
<ol>
<li>Create a new Android project.</li>
<li>Modify the Gradle scripts to include the Kotlin Gradle plugin and standard library.</li>
<li>Apply the Kotlin plugin for IntelliJ or Studio.</li>
<li>Convert a Java class to Kotlin.</li>
</ol>
<p>First, create a new Android project using a template that adds an activity. When you have that, there are just five important lines of code to add across two build.gradle files, which I will highlight below. Let’s modify the top level build.gradle buildscript stanza with a couple of new lines:</p>
<pre><code class="hljs language-kotlin">buildscript {
    ext.kotlin_version = <span class="hljs-string">'1.0.0'</span>
    repositories {
        jcenter()
    }
    dependencies {
        classpath <span class="hljs-string">'com.android.tools.build:gradle:1.5.0'</span>
        classpath <span class="hljs-string">"org.jetbrains.kotlin:kotlin-gradle-plugin:<span class="hljs-subst">$kotlin_version</span>"</span>
    }
}</code></pre>
<p>This adds the Kotlin Gradle plugin into the build. Note the definition of the Kotlin version string defined in ext.kotlin_version. We’ll use it twice: once here in the buildscript classpath, and once in the app compile dependencies, and it must be the same in both places. You should of course use the latest version published via Maven. You can find the latest version documented <a href="https://kotlinlang.org/docs/reference/using-maven.html">here</a>.</p>
<p>Next, apply the kotlin-android plugin after the Android plugin in the app’s own build.gradle after the standard Android plugin. This makes the project Kotlin-aware and adds a Kotlin compile step to the build, so that all the classes generated by both the Java and Kotlin languages get bundled together in the final app:</p>
<pre><code class="hljs language-kotlin">apply plugin: <span class="hljs-string">'com.android.application'</span>
apply plugin: <span class="hljs-string">'kotlin-android'</span></code></pre>
<p>By convention, Kotlin files want to live under src/main/kotlin, but they could also live alongside Java files in src/main/java. So, let’s be conventional and tell Gradle to recognize a new source directory for Kotlin source within the Android project definition:</p>
<pre><code class="hljs language-kotlin">android {
    sourceSets {
        main.java.srcDirs += <span class="hljs-string">'src/main/kotlin'</span>
    }
}</code></pre>
<p>Don’t forget to create that directory because we’ll use it later. You’ll also need a compile dependency on Kotlin’s standard library, using the version variable from the buildscript:</p>
<pre><code class="hljs language-kotlin">dependencies {
    compile <span class="hljs-string">"org.jetbrains.kotlin:kotlin-stdlib:<span class="hljs-subst">$kotlin_version</span>"</span>
}</code></pre>
<p>But how big is this library we’re adding? This is a great question. Every Android developer should be asking this question every time a new compile dependency is added. However, we’ll save that discussion for a later post in the series.</p>
<p>At this point, you should be able to do a command line Gradle build as you would normally with gradlew, and you can also build and deploy an APK from Android Studio. Nothing should change except the size of the app, which grows with the Kotlin standard library.</p>
<p>So that’s the Kotlin Gradle plugin, and adding it to your project like this is sufficient to build and run Kotlin code in the project. But you’ll probably also want IDE support for Kotlin language features. If you haven’t already installed the Kotlin plugin for IntelliJ or Android Studio, now is a good time for that.</p>
<p>Installing the IDE plugin is just like any other. You can find that under Preferences → Plugins → Install JetBrains plugin. Be sure to restart the IDE after installation. With that, you’re done with setup. I’ve found that the IDE support for Kotlin is almost as good as for the Java language, but I would expect as much, since JetBrains makes both the IDE and Kotlin!</p>
<h4>From Java to Kotlin the Easy Way</h4>
<p>One interesting feature of the IDE plugin is its action for converting Java source to Kotlin source. The plugin is smart enough to replace Java idioms with Kotlin idioms while retaining full runtime compatibility. If you’ve created a new Android project to try this out, go find the main activity that was generated for you, select it in the project explorer on the left, and invoke the IDE action called “Convert Java File to Kotlin File”. You can do that by bringing up the action selector with Command-Shift-A (on OSX), then typing that action name. The plugin also provides a finger-bending keyboard shortcut for this action (on OSX it’s Option-Shift-Command-K). So, enjoy typing that! Note that the <a href="https://kotlinlang.org/docs/tutorials/kotlin-android.html">official documentation for this conversion</a> currently does not suggest 100% correct behavior for this action, but I haven’t encountered a problem so far.</p>
<p>If you convert a Java file like this, you’ll end up with a Kotlin .kt file in place of the original .java file like this:</p>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/800/1*IPZCPTYVWIku8lAI0G9FGw.png"></p>
<p><em>MainActivity converted from Java to Kotlin</em></p>
<p>Notice that MainActivity has a Kotlin K logo on it now (but the file extension .kt is hidden here). Since we configured and created a dedicated source folder for Kotlin, as you can also see above, why don’t we move the newly converted Kotlin file to the space for Kotlin? It’s just like refactoring a Java file by moving it into a new folder or package by dragging it in the project explorer. Be sure to retain the existing package name of the class in the kotlin source directory so that the project still runs.</p>
<p>If you only want to use Kotlin in a project, you are free to delete the java source dir completely and put all Kotlin files in the kotlin space. With that, your project will look something like this:</p>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/800/1*N5JYjlzzAcvzeSpTJ0TK6g.png"></p>
<p><em>MainActivity moved from java source dir to kotlin source dir</em></p>
<p>I’m sure you’ve already started to dig around in the converted activity, so you’ve probably already got a taste for what Kotlin looks like. I’ll point out a couple things that look different from the Java language. You’ll never see the keyword “new” in Kotlin; constructors are invoked simply by treating the name of the class as a function and passing it arguments. Also, the types of variables are typically missing from a declaration with val (final) or var (variable), and Kotlin can usually figure out what the type is.</p>
<p>I’ll leave it up to you to make the initial leap from Java world to Kotlin world, and we’ll continue <a href="https://medium.com/@CodingDoug/kotlin-android-a-brass-tacks-experiment-part-2-c67661cfdf5f">next time</a> with the beginning of a small project to see what Kotlin can uniquely offer Android developers. If you follow me, <a href="https://medium.com/@CodingDoug">@CodingDoug</a>, here on Medium, or <a href="https://twitter.com/codingdoug">the same on Twitter</a>, you’ll get notified as soon as new parts are available in this series!</p>
]]></description><link>https://medium.com/@CodingDoug/kotlin-android-a-brass-tacks-experiment-part-1-3e5028491bcc#.5c7ixfzdv</link><guid isPermaLink="true">https://medium.com/@CodingDoug/kotlin-android-a-brass-tacks-experiment-part-1-3e5028491bcc#.5c7ixfzdv</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Android]]></category><dc:creator><![CDATA[Doug Stevenson]]></dc:creator><pubDate>Mon, 01 Feb 2016 17:31:00 GMT</pubDate></item><item><title><![CDATA[Scala vs Kotlin]]></title><description><![CDATA[<p>It’s been a long time since I’ve updated this blog. Over the year I’ve moved away from Scala as my preferred language and towards Kotlin. I’ve found Kotlin a refreshing approach as its borrowed a lot of the good things I liked about Scala but kept it simple and practical by avoiding a lot of the gotchas and ambiguity that can exist in Scala.</p>
<p>Here is a collection of things I like about Scala and Kotlin and also a comparison of how these features are accomplished in each language.</p>
<h2>Type Declaration and Inference</h2>
<p>Something I love about both these languages is they both have static typing with type inference. This gives you the power of compile time type checking with out the declarative boiler plate. Largely it works the same in both languages. Both languages also have preference to immutable type declaration as well with the optional type declaration being placed after the variable name.</p>
<p>Example, the below code is the same in both languages:</p>
<p>Declare a immutable variable named age of type Int:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> age = <span class="hljs-number">1</span></code></pre>
<p>Declare a mutable variable of type String:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">var</span> greeting = <span class="hljs-string">"Hello"</span></code></pre>
<p>Both languages support lambda functions as first class citizens that can be assigned to variables or passed as function parameters.</p>
<p>Scala:</p>
<pre><code class="hljs language-scala"><span class="hljs-keyword">val</span> double = (i: <span class="hljs-type">Int</span>) => { i * <span class="hljs-number">2</span> }</code></pre>
<p>Kotlin:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> double = {i: <span class="hljs-built_in">Int</span> -> i * <span class="hljs-number">2</span>}</code></pre>
<h2>Data / Case Class</h2>
<p>Both Scala and Kotlin have a similar concept of a data class which can be use to represent a data model object.</p>
<h3>Scala’s Approach</h3>
<p>Scala calls this a case class and it can be defined like:</p>
<pre><code class="hljs language-scala"><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name: <span class="hljs-type">String</span>, age: <span class="hljs-type">Int</span></span>)</span></code></pre>
<p>This gives you the following main advantages over a normal class:</p>
<ul>
<li>Has an apply method (You don’t need to use the ‘new’ word to construct instances)</li>
<li>Accessor methods are defined for each property (If property are defined as var then setters are also defined)</li>
<li>toString, equal and hashCode is sensibly defined</li>
<li>copy function</li>
<li>Has an unapply method (which allows use in match expressions)</li>
</ul>
<h3>Kotlin’s Approach</h3>
<p>Kotlin calls this a data class and it’s defined like:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>(<span class="hljs-keyword">val</span> name: String, <span class="hljs-keyword">val</span> age: <span class="hljs-built_in">Int</span>)</code></pre>
<p>Key Features</p>
<ul>
<li>Accessor methods are defined for each property (If property are defined as var then setters are also defined). This is not unique to data class and works on any class in Kotlin.</li>
<li>Sensibly defined toString, equal and hashCode</li>
<li>copy function</li>
<li>component1..componentN functions. Similar use to unapply.</li>
<li>Implements JavaBean getter and setters defined so native Java frameworks (Hibernate, Jackson) without change</li>
</ul>
<p>Kotlin doesn’t need a special ‘apply’ method as it doesn’t require a ‘new’ keyword to instantiate class constructors. So this is a standard constructor definition like any other class.</p>
<h3>Comparison</h3>
<p>Generally data and case classes are similar.</p>
<p>This example usage works the same in Kotlin or Scala:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> jack = Person(<span class="hljs-string">"Jack"</span>, <span class="hljs-number">1</span>)
<span class="hljs-keyword">val</span> olderJack = jack.copy(age = <span class="hljs-number">2</span>)</code></pre>
<p>Generally I’ve found data and case classes interchangeable in day to day use. Kotlin does enforce some restriction on extending a data class with inheritance but its done for good reasons when you consider the implementations of equals and componentN functions and prevents the gotcha moments.</p>
<p>The Scala case classes can be more powerful in a match statements compared to Kotlin’s handling of data classes in ‘when’ statements which is something I miss.</p>
<p>Kotlin approach works a lot better when being used from existing Java frameworks as it will look like a normal java bean.</p>
<p>Both languages support supplying parameters by name and allow for default values.</p>
<h2>Null Safety / Optionality</h2>
<h3>Scala’s Approach</h3>
<p>Scala’s approach to null safety is the option monad. Simply an option can be one of two concrete types; Some(x) or None.</p>
<pre><code class="hljs language-scala"><span class="hljs-keyword">val</span> anOptionInt: <span class="hljs-type">Option</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">Some</span>(<span class="hljs-number">1</span>)</code></pre>
<p>OR</p>
<pre><code class="hljs language-scala"><span class="hljs-keyword">val</span> anOptionInt: <span class="hljs-type">Option</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">None</span></code></pre>
<p>You can operate on the option using functions on the option class like “isDefined” and “getOrElse” (to provide a default value) but more commonly you would use monad operations like map, foreach or fold which will treat the option as a collection containing 0 or 1 elements.</p>
<p>For example to sum two Optionally defined Ints you could do:</p>
<pre><code class="hljs language-scala"><span class="hljs-keyword">val</span> n1Option: <span class="hljs-type">Option</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">Some</span>(<span class="hljs-number">1</span>)
<span class="hljs-keyword">val</span> n2Option: <span class="hljs-type">Option</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">Some</span>(<span class="hljs-number">2</span>)
<span class="hljs-keyword">val</span> sum = <span class="hljs-keyword">for</span> (n1 &#x3C;- n1Option; n2 &#x3C;- n2Option) <span class="hljs-keyword">yield</span> { n1 + n2 }</code></pre>
<p>The variable sum will have the value Some(3). This is leveraging Scala’s for comprehension which can be foreach or a flat map function depending on the use of the yield keyword.</p>
<p>Another example of chaining could be:</p>
<pre><code class="hljs language-scala"><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name: <span class="hljs-type">String</span>, age: <span class="hljs-type">Option</span>[<span class="hljs-type">Int</span>]</span>)</span>
<span class="hljs-keyword">val</span> person:<span class="hljs-type">Option</span>[<span class="hljs-type">Person</span>] = <span class="hljs-type">Some</span>(<span class="hljs-type">Person</span>(<span class="hljs-string">"Jack"</span>,<span class="hljs-type">Some</span>(<span class="hljs-number">1</span>)))
<span class="hljs-keyword">for</span> (p &#x3C;- person; age &#x3C;- p.age) {
 println(<span class="hljs-string">s"The person is aged <span class="hljs-subst">$age</span>"</span>)
}</code></pre>
<p>This will print “The person is aged 1”</p>
<h3>Kotlin’s Approach</h3>
<p>Kotlin’s approach borrows from groovy style syntax and is very practical in every day use. In Kotlin all types are non-nullable and must be explicitly declared nullable using ‘?’ if it can contain null.</p>
<p>The same example could be written</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> n1: <span class="hljs-built_in">Int</span>? = <span class="hljs-number">1</span>
<span class="hljs-keyword">val</span> n2: <span class="hljs-built_in">Int</span>? = <span class="hljs-number">2</span>
<span class="hljs-keyword">val</span> sum = <span class="hljs-keyword">if</span> (n1 != <span class="hljs-literal">null</span> &#x26;&#x26; n2 != <span class="hljs-literal">null</span>) n1 + n2 <span class="hljs-keyword">else</span> <span class="hljs-literal">null</span></code></pre>
<p>This is much closer to Java syntax except Kotlin will enforce compile time checks so its not possible to use a nullable variable without checking it is not null first so you won’t fear NullPointerExceptions. Its also not possible to assign a null to a variable declared as non-nullable. The compiler is quite smart in checking branch logic so you don’t have the situation of over guarding that you see in Java where the same variable is checked for null multiple times.</p>
<p>An equivalent Kotlin code for the second example of chaining is:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>(<span class="hljs-keyword">val</span> name: String, <span class="hljs-keyword">val</span> age: <span class="hljs-built_in">Int</span>?)
<span class="hljs-keyword">val</span> person:Person? = Person(<span class="hljs-string">"Jack"</span>, <span class="hljs-number">1</span>)
<span class="hljs-keyword">if</span> (person?.age != <span class="hljs-literal">null</span>) {
  println(<span class="hljs-string">"The person is aged <span class="hljs-subst">${person?.age}</span>"</span>)
}</code></pre>
<p>An alternative is also available using “let” which could replace the if block with</p>
<pre><code class="hljs language-kotlin">person?.age?.let {
  println(<span class="hljs-string">"The person is aged <span class="hljs-subst">$it</span>"</span>)
}</code></pre>
<h2>Comparison</h2>
<p>I really prefer the Kotlin approach. It’s a lot easier to read and understand what’s going on and multiple levels of nesting is easy to handle. The scala approach has symmetry in that other monads can be acted on the same as option can (e.g. futures) which some people like but I’ve found it can get complicated really fast once there is a little bit of nesting. There are also a lot of gotcha’s with for comprehension as under the covers they are maps or flat maps but you don’t get the compile time warnings if you do something wrong like mix monads or do a pattern match without covering alternative paths which leads to runtime exceptions that are cryptic.</p>
<p>Kotlin’s approach also bridges the gap when integrating with Java code as they can default to nullable types where as Scala still has to support null as a concept without null safety protection.</p>
<h2>Functional Collections</h2>
<p>Scala of course supports many functional goodies. Kotlin is a little more restrictive but the basics are covered.</p>
<p>There isn’t much difference in the basic fold and map functions.</p>
<p>Scala</p>
<pre><code class="hljs language-scala"><span class="hljs-keyword">val</span> numbers = <span class="hljs-number">1</span> to <span class="hljs-number">10</span>
<span class="hljs-keyword">val</span> doubles = numbers.map {_ * <span class="hljs-number">2</span>}
<span class="hljs-keyword">val</span> sumOfSquares = doubles.fold(<span class="hljs-number">0</span>) {_ + _}</code></pre>
<p>Kotlin</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> numbers = <span class="hljs-number">1.</span><span class="hljs-number">.10</span>
<span class="hljs-keyword">val</span> doubles = numbers.map {it * <span class="hljs-number">2</span>}
<span class="hljs-keyword">val</span> sumOfSquares = doubles.fold(<span class="hljs-number">0</span>) {x,y -> x+y}</code></pre>
<p>Both support the concept of lazy evaluated sequences. For example printing first 10 even squares.</p>
<p>Scala</p>
<pre><code class="hljs language-scala"><span class="hljs-keyword">val</span> numbers = <span class="hljs-type">Stream</span>.from(<span class="hljs-number">1</span>) <span class="hljs-comment">// all natural numbers</span>
<span class="hljs-keyword">val</span> squares = numbers.map {x => x * x}
<span class="hljs-keyword">val</span> evenSquares = squares.filter {_%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>}
println(evenSquares.take(<span class="hljs-number">10</span>).toList)</code></pre>
<p>Kotlin</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> numbers = sequence(<span class="hljs-number">1</span>) {it + <span class="hljs-number">1</span>} <span class="hljs-comment">// all natural numbers</span>
<span class="hljs-keyword">val</span> squares = numbers.map {it * it}
<span class="hljs-keyword">val</span> evenSquares = squares.filter {it%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>}
println(evenSquares.take(<span class="hljs-number">10</span>).toList())</code></pre>
<h2>Implicits Conversion vs Extension Functions</h2>
<p>This is an area where Scala and Kotlin diverge a little.</p>
<h3>Scala’s Approach</h3>
<p>Scala has a a concept of implicit conversion that allows you to add extra behaviour to a class by automatically converting to another class when needed. An example of this</p>
<pre><code class="hljs language-scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Helpers</span> </span>{
 <span class="hljs-keyword">implicit</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntWithTimes</span>(<span class="hljs-params">x: <span class="hljs-type">Int</span></span>) </span>{
   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">times</span></span>[<span class="hljs-type">A</span>](f: => <span class="hljs-type">A</span>): <span class="hljs-type">Unit</span> = {
    <span class="hljs-keyword">for</span> (i &#x3C;- <span class="hljs-number">1</span> to x) {
     f
    }
  }
 }
}</code></pre>
<p>Then later in the code you can do:</p>
<pre><code class="hljs language-scala"><span class="hljs-keyword">import</span> <span class="hljs-type">Helpers</span>._
<span class="hljs-number">5.</span>times(println(<span class="hljs-string">"Hello"</span>))</code></pre>
<p>This will print “Hello” 5 times. How this works is when you try to use the “times” function which doesn’t exist on the Int the object will be automatically boxed into an IntWithTimes object and the times function will executed on that.</p>
<h3>Kotlin’s Approach</h3>
<p>Kotlin has the concept of extension functions that can be used to accomplish a similar job. In the Kotlin approach you define a normal function but prefix the function name with a type to extend.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">times</span><span class="hljs-params">(f: ()</span></span>-><span class="hljs-built_in">Unit</span>) {
  <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span>.<span class="hljs-keyword">this</span>) {
    f()
  }
}
 
<span class="hljs-number">5.</span>times {println(<span class="hljs-string">"Hello"</span>)}</code></pre>
<h3>Comparison</h3>
<p>Kotlin approach fits the use case that I generally would use this Scala capability for and has the advantage of being a little simpler to understand.</p>
<h2>Scala Features Not Present in Kotlin that I won’t Miss</h2>
<p>One of the best part of the Kotlin language for me is not the features it has but more the features from Scala that are not in Kotlin</p>
<ul>
<li>Call by name – This destroys readability. If a function is being passed its a lot easier when its visible that its a function pointer in a basic review of the code. I don’t see any advantage this gives over passing explicit lambdas</li>
<li>Implicit parameters – This is something I’ve really hated. It leads to situation of code changing drastically based on a change of import statement. It makes it really hard to tell what values will be passed to a function without good IDE support</li>
<li>Overloaded FOR comprehension – To me this is a clunk to get around the problem with dealing with multiple monads</li>
<li>The mess with optional syntax on infix and postfix operators – Kotlin is little more prescriptive and means that the code is less ambiguous to read and not as easy for simple typo to become a non-obvious error</li>
<li>Operator Overload to the Max – Kotlin allows basic operator overloads for the basic operators (+, – etc.) but Scala allows any bunch of characters to be used and it seems to have been embraced by library developers. Am I really meant to remember difference between “~%#>” and “~+#>”?</li>
<li>Slow compile times</li>
</ul>
]]></description><link>https://agilewombat.com/2016/02/01/scala-vs-kotlin/</link><guid isPermaLink="true">https://agilewombat.com/2016/02/01/scala-vs-kotlin/</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Scala]]></category><dc:creator><![CDATA[Lionel]]></dc:creator><pubDate>Mon, 01 Feb 2016 11:11:00 GMT</pubDate></item><item><title><![CDATA[KillerTask, the solution to AsyncTask implementation]]></title><description><![CDATA[<h2>Introduction</h2>
<p><a href="https://github.com/inaka/KillerTask">KillerTask</a> is an Android library to create asynchronous background tasks.</p>
<p>Developed in <a href="https://kotlinlang.org/">Kotlin</a> and inspired by <a href="https://github.com/inaka/TinyTask">TinyTask</a>, this is more beautiful and easy to use for Kotlin Android developments.</p>
<h3>Wait... Kotlin?</h3>
<p>To learn what Kotlin is, how to use it in Android and their characteristics, you can take a look at: <a href="http://inaka.net/blog/2016/01/15/android-development-with-kotlin/">"Android development with Kotlin"</a>.</p>
<h3>So, is this the same as TinyTask? :/</h3>
<p>Well, both are just wrappers around AsyncTask, with a funny looking API. But no, is not exactly the same.</p>
<p>The main difference between KillerTask and TinyTask is that this library is written in Kotlin language, very different from Java. If you use Kotlin for develop your Android apps, you will find this much more clear and reliable.</p>
<p>In addition, KillerTask has a better management of threads compared to TinyTask's actual last version (1.0.1).</p>
<h2>Include it in your project</h2>
<p>Add the following to your <code>app/build.gradle</code> file:</p>
<pre><code class="hljs language-groovy">repositories {
  maven {
    url <span class="hljs-string">"https://jitpack.io"</span>
  }
}

dependencies {
  <span class="hljs-comment">// ...</span>
  compile <span class="hljs-string">'com.github.inaka:killertask:v1.2'</span>
  <span class="hljs-comment">// ...</span>
}</code></pre>
<h2>How it works</h2>
<p>Create a new KillerTask</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">var</span> killerTask = KillerTask(doWork, onSuccess, onFailed)</code></pre>
<p>Having for example:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">// task function</span>
<span class="hljs-keyword">val</span> doWork: () -> String = {
  <span class="hljs-keyword">var</span> connection: URLConnection? = <span class="hljs-literal">null</span>;

  <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">var</span> url = URL(<span class="hljs-string">"https://api.github.com/gists"</span>)
      connection = url.openConnection();
  } <span class="hljs-keyword">catch</span> (e: Exception) {
      e.printStackTrace()
  }

  <span class="hljs-keyword">var</span> httpConn = connection <span class="hljs-keyword">as</span> HttpURLConnection;
  httpConn.connectTimeout = <span class="hljs-number">3000</span>;
  httpConn.readTimeout = <span class="hljs-number">5000</span>;

  <span class="hljs-comment">// implicit return</span>
  httpConn.responseCode.toString() + <span class="hljs-string">" "</span> + httpConn.responseMessage
}

<span class="hljs-comment">// onSuccess function</span>
<span class="hljs-keyword">val</span> onSuccess: (String) -> <span class="hljs-built_in">Unit</span> = {
  result: String ->
  Log.wtf(<span class="hljs-string">"success result"</span>, result)
}

<span class="hljs-comment">// onFailed function</span>
<span class="hljs-keyword">val</span> onFailed: (Exception?) -> <span class="hljs-built_in">Unit</span> = {
  e: Exception? ->
  Log.wtf(<span class="hljs-string">"error result"</span>, e.toString())
  e?.printStackTrace()
}</code></pre>
<p>To execute it:</p>
<pre><code class="hljs language-kotlin">killerTask.go()</code></pre>
<p>To cancel it:</p>
<pre><code class="hljs language-kotlin">killerTask.cancel()</code></pre>
<h3>All together</h3>
<p>You can write it all together, for example:</p>
<pre><code class="hljs language-kotlin">KillerTask(
    { <span class="hljs-string">"test"</span> }, <span class="hljs-comment">// main task returning "test"</span>
    {result: String -> Log.wtf(<span class="hljs-string">"result"</span>, result)}, <span class="hljs-comment">// onSuccess actions</span>
    {e: Exception? -> Log.wtf(<span class="hljs-string">"result"</span>, e.toString())} <span class="hljs-comment">// onFailed actions</span>
  ).go()</code></pre>
<h3>Variable parameters</h3>
<p>Actually, the only strongly necessary parameter is the first one (the main task).</p>
<ul>
<li>Example without onSuccess and onFailed actions:</li>
</ul>
<pre><code class="hljs language-kotlin">KillerTask(
    { Log.wtf(<span class="hljs-string">"LOG"</span>, <span class="hljs-string">"KillerTask is awesome"</span>) }, <span class="hljs-comment">// main task</span>
    { Log.wtf(<span class="hljs-string">"LOG"</span>, <span class="hljs-string">"Super awesome!"</span>)} <span class="hljs-comment">// onSuccess</span>
  ).go()</code></pre>
<ul>
<li>Example only with on Failed actions:</li>
</ul>
<pre><code class="hljs language-kotlin">KillerTask(
    { <span class="hljs-comment">// main task</span>
        Log.wtf(<span class="hljs-string">"LOG"</span>, <span class="hljs-string">"KillerTask is awesome"</span>)
        <span class="hljs-string">"super"</span> <span class="hljs-comment">// implicit return</span>
    },
    {}, <span class="hljs-comment">// onSuccess is empty</span>
    { e: Exception? -> Log.wtf(<span class="hljs-string">"LOG"</span>, e.toString()) } <span class="hljs-comment">// onFailed</span>
  ).go()</code></pre>
<h3>Example of an app using KillerTask</h3>
<p><a href="https://github.com/inaka/kotlillon">kotlillon</a> Compilation of simple Kotlin examples, all together in one Android app.</p>
<h2>Support</h2>
<p>For questions or general comments regarding the use of this library, please use our public <a href="http://inaka.net/hipchat">hipchat room</a>.</p>
<p>If you find any bugs or have a problem while using this library, please <a href="https://github.com/inaka/KillerTask/issues/new">open an issue</a> (or send a pull request with your solution).</p>
<p>You can check all of our open-source projects at <a href="http://inaka.github.io/">inaka.github.io</a>.</p>
]]></description><link>http://inaka.net/blog/2016/01/25/killertask-the-solution-to-asynctask-implementation/</link><guid isPermaLink="true">http://inaka.net/blog/2016/01/25/killertask-the-solution-to-asynctask-implementation/</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Android]]></category><dc:creator><![CDATA[Fernando Ramirez]]></dc:creator><pubDate>Mon, 25 Jan 2016 21:54:00 GMT</pubDate></item><item><title><![CDATA[My Kotlin Adventure]]></title><description><![CDATA[<h6><em>Part 1</em></h6>
<p>My first thought when I heard about Kotlin for the first time was "<em>Just another language to write the same thing using new keywords!</em>"</p>
<p>Luckily, I’m hugely curious and this thought wasn’t enough to stop me looking into it further. I started reading about it and the more I read, the more I became intrigued...</p>
<p>Now let me say:</p>
<blockquote>
<p>Kotlin is not just another language, it uses another <strong>paradigm</strong> to help developers to solve everyday challenges</p>
</blockquote>
<h4>Android Developers</h4>
<p>I’ve been working with Android since 2010, initially just because I was curious to explore the potential of the promising platform from the big *G, but later for several commissioned projects. For each project, I used the standard language that was available: <strong>Java</strong> (just in some spare cases using C with NDK). From it’s release, the Android SDK promised to give a boost to Java using a custom library for Mobile developing and so far it’s been good.</p>
<p>Since the beginning The Android SDK really has been oriented to solve the Mobile challenges (UI responsiveness, Network availability, Sensors API), release after release, improving every time. The first JVM Dalvik did a very good job and the ART even more...<br>
But I was still getting still stuck with Java (<em>enhanced 1.6</em>) and all its Ceremonies in the code.</p>
<h4>Android Studio</h4>
<p>My first projects were on Eclipse IDE and to be honest I found it very useful and reliable with a plenty of documentation and a vivid community, but Google had other plans. They called it <strong>Android Studio</strong>.<br>
The first version of it was really unreliable, plenty of bugs and not easy to use, so I decided to wait a few versions before using it for my projects.<br>
Fortunately it didn't take so much time to release a very good, stable and absolutely reliable version of a proper <strong>Android Studio</strong> with all the quality of <strong>JetBrains</strong> products.<br>
But still Java was the language...</p>
<h4>New kids in town</h4>
<p>Meanwhile the Developer community starting to use new paradigms offered by different kinds of programming languages like the brand new <em>Swift2</em> by <strong>Apple</strong> (and soon Open Source and available for <strong>Linux</strong> too), <em>Scala</em>, <em>Haskell/Miranda</em>, <em>F#</em>, etc. The functional programming paradigm rocked the Developers community like a tsunami, waking them up from the deep sleep of spending too many years working with imperative and procedural languages.</p>
<p>But the Android community still were stuck on Java, and even if the new Java 8 promised to refresh the language, the Android framework couldn't move on it due to the backward compatibility with the oldest version of libraries used by the framework.<br>
In the meantime <strong>JetBrains</strong> was working on it’s own language, <strong>Kotlin</strong>.</p>
<p><img src="http://cirorizzo.net/content/images/2016/02/xKotlin-logo.png.pagespeed.ic.3prhfChkMF.png" alt="Kotlin Logo"></p>
<h4>Kotlin</h4>
<p>Since from the early Beta versions, Kotlin has astonished the Android Community (and even more like Back End and Front End developers, etc). It is definitely a <em>Concise</em>, <em>Neat</em> language with 100% Java interoperability, studied by people who deeply know the issues and routines of development issues and how to afford them as best as they can.<br>
In other words I started to experiment with it several months ago and have since decided to use it in my existing and further projects.</p>
<h4>Having a look to some code</h4>
<p>This is just an example of how concise coding with Kotlin can be:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">thisIsTheMethod</span><span class="hljs-params">(message: <span class="hljs-type">String</span>)</span></span> {
    buttonMessage.setOnClickListener {
        Toast.makeText(context, <span class="hljs-string">"Here the message: <span class="hljs-subst">$message</span>"</span>, 
                Toast.LENGTH_LONG).show()
    }
}</code></pre>
<p>The above method is a clear example of how easy it can be to simplify typical Android code using Java. It usually looks like:</p>
<pre><code class="hljs language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">thisIsTheMethod</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String message)</span> </span>{
    buttonMessage.setOnClickListener(<span class="hljs-keyword">new</span> OnClickListener() {
        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>{
            Toast.makeText(getBaseContext(),
                    String.format(<span class="hljs-string">"Here the message: %s"</span>, message),
                    Toast.LENGTH_LONG).show();
        }
    });
}</code></pre>
<p>Most of the boilerplate code used to write in Android can be reduced with Kotlin, still having a clean and understandable code.</p>
<p>At a glance, the method or function <em>thisIsTheMethod</em> in Kotlin is implicitly <em>public</em> a if hasn't any return (<em>void</em> in Java, in Kotlin will see next what is) doesn't need any further keywords</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">thisIsTheMethod</span><span class="hljs-params">(message: <span class="hljs-type">String</span>)</span></span> {...}</code></pre>
<p>Also the signature has param declaration quite different from Java. The type follow the param name but it hides something more: <strong>Null Safety</strong> type system.</p>
<p>I like to report from the official documentation the following:</p>
<blockquote>
<p>Kotlin’s type system is aimed to eliminate NullPointerException’s from our code</p>
</blockquote>
<p>Just this should be something Android developers will love.</p>
<p>And last but not least the <em>setOnClickListener</em> for the view (<em>buttonMessage</em>) that can be reduced in a SAM (Single Abstract Method) through the Lambda Expression. Yes, finally!</p>
<pre><code class="hljs language-kotlin">buttonMessage.setOnClickListener() {...}</code></pre>
<p>Well, that’s it for now. I'm gonna go further in future posts to share more about the language and the benefits Kotlin has brought to my Android coding</p>
<p>It really is easy to switch to Kotlin from Java. Maybe now is the time for you to give it a closer look?<br>
<a href="http://www.cirorizzo.net/2016/02/03/kotlin-code/">Jump to part two</a></p>
]]></description><link>http://cirorizzo.net/2016/01/23/kotlin-at-glance/</link><guid isPermaLink="true">http://cirorizzo.net/2016/01/23/kotlin-at-glance/</guid><category><![CDATA[Android]]></category><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Ciro Rizzo]]></dc:creator><pubDate>Sat, 23 Jan 2016 23:43:00 GMT</pubDate></item><item><title><![CDATA[Mimicking Kotlin Builders in Java and Python]]></title><description><![CDATA[<h2><strong>Intro</strong></h2>
<p>Kotlin is probably my favorite language right now, and possibly one of the coolest things it has to offer is type-safe builders, built upon several features (explained in a bit). I find myself really <em>really</em> wanting to have this feature in my other two primary languages, Java and Python. This article explains what I believe to be the closest we can get to having type-safe builders in those languages</p>
<h2><strong>Kotlin</strong></h2>
<p>To start, I need to explain Kotlin’s ability to do type-safe builders. For a quick explanation of what these builders are, you should check out <a href="https://kotlinlang.org/docs/reference/type-safe-builders.html">their page about them</a>. In this article, we’ll be implementing a tiny subset of their html builder.</p>
<p>Kotlin’s ability to create type-safe builders is due to many small features. The first is the lambda syntax; <code>{param, list -> block.of.code()}</code>. If the lambda has zero parameters, you can ignore the parameter list and the arrow. The same is true when it only has one parameter, as that parameter is implicitly called <code>it</code>. For example, <code>{doSomethingWith(it)}</code> is a legitimate lambda, assuming <code>doSomethingWith()</code> takes an object that is the same type as what is being passed into the lambda.</p>
<p>The next feature is how to pass lambdas into functions. If the last argument is a lambda, it can be passed <em>after</em> the parentheses of the function call. For example, <code>myFunc(arg1){lambdaArg()}</code>. If the lambda is the <em>only</em> argument, the parentheses can be ignored altogether: <code>aFunc{lambdaArg()}</code>. This allows you to define functions that can look like language features. You could technically define your own if-else blocks, or any of the loops, if it weren’t for the fact that those keywords are reserved.</p>
<p>Next is extension methods and the fact that you can define lambdas that work like them. Extension methods are new methods that are defined for a class or interface <em>outside</em> the class of the interface. For example, you could create new methods for the <code>String</code> class. In actuality, they’re just static methods that take an implicit first parameter of the type they’re for. In the Kotlin code, that first parameter is assigned to the <code>this</code> identifier, which is used implicitly, just like in a real method.</p>
<p>You can define lambdas that work like extension methods (<code>SomeClass.() -> Unit</code> instead of <code>(SomeClass) -> Unit</code>, too, so that inside the lambda, you can make calls on the object without explicitly referencing it.</p>
<p>All these features, plus really good type inferencing, come together to create the ability to make type-safe builders from functions taking extension lambdas. So, we can write this:</p>
<pre><code class="hljs language-kotlin">html {
   head {
      title(<span class="hljs-string">"A Title"</span>)
   }
   body {
      p = <span class="hljs-string">"paragraph"</span>
      p = <span class="hljs-string">"'nother one"</span>
      p = <span class="hljs-string">"last paragraph"</span>
   }
}</code></pre>
<p>To return an <code>Html</code> object that contains a <code>Head</code> and a <code>Body</code>, the <code>Head</code> containing a <code>Title</code> with the text, “A Title”. The <code>Body</code> contains 3 <code>Paragraphs</code>.</p>
<p>You may note that <code>title</code> and [p] are different in how they’re defined. It probably would have been smarter to have <code>title</code> to use the <code>=</code> syntax instead of <code>p</code>, but <code>p</code> shows off how creative these builders can be better than <code>title</code>. I did a similar thing with Python, since it also supports properties.</p>
<p>Let’s look at the Kotlin code that allows up to create these objects</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">html</span><span class="hljs-params">(htmlBuilder: <span class="hljs-type">Html</span>.()</span></span> -> <span class="hljs-built_in">Unit</span>): Html {
   <span class="hljs-keyword">val</span> html = Html()
   html.htmlBuilder()
   <span class="hljs-keyword">return</span> html
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Html</span> </span>{
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> head: Head? = <span class="hljs-literal">null</span>
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> body: Body? = <span class="hljs-literal">null</span>

   <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">head</span><span class="hljs-params">(headBuilder: <span class="hljs-type">Head</span>.()</span></span> -> <span class="hljs-built_in">Unit</span>) {
      head = Head()
      head?.headBuilder()
   }

   <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">body</span><span class="hljs-params">(bodyBuilder: <span class="hljs-type">Body</span>.()</span></span> -> <span class="hljs-built_in">Unit</span>) {
      body = Body()
      body?.bodyBuilder()
   }
}</code></pre>
<p>We start with the <code>Html</code> class and the <code>html()</code> function used to start the builder. The <code>html</code> function isn’t necessary, since the code could be used as an <code>Html</code> constructor, but it allows us to keep the constructor simple and all the functions lowercase without going against naming conventions.</p>
<p>You’ll note that everything is actually pretty darn short. Only the <code>html</code> function is 3 lines, and that’s only because it has to return the result at the end. If we used a constructor on <code>Html</code> instead, it would only have the line <code>htmlBuilder()</code>.</p>
<p>Here’s <code>Head</code> and <code>Title</code>.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Head</span> </span>{
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> title: Title? = <span class="hljs-literal">null</span>

   <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">title</span><span class="hljs-params">(text: <span class="hljs-type">String</span>)</span></span> {
      title = Title(text)
   }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Title</span> </span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> text: String) { }</code></pre>
<p>Still going pretty nicely. <code>Title</code> doesn’t require a builder, since it just holds text. If it weren’t for the fact that there would need to be some more complex build mechanics, I’d actually have <code>Head</code> just hold the <code>String</code> itself instead of creating a <code>Title</code> class and object.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Body</span> </span>{
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> paragraphs: ArrayList&#x3C;Paragraph> = ArrayList()

   <span class="hljs-keyword">var</span> p: String
      <span class="hljs-keyword">private</span> <span class="hljs-keyword">get</span>() = <span class="hljs-literal">null</span>!!
      <span class="hljs-keyword">set</span>(value) {
         paragraphs.add(Paragraph(value))
      }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Paragraph</span> </span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> text: String) { }</code></pre>
<p>Here’s the really interesting thing. Instead of having a <code>p()</code> method, like we did for <code>Title</code>, we used <code>p</code>‘s setter to keep adding <code>Paragraph</code> objects to the list. In this case, it’s not the most intuitive; it’s just there to show you how creative one could get with these builders.</p>
<p>Keep in mind, too that these classes are just the builder classes, so they’re allowed to be stateful. There should be a <code>build()</code> method that recursively calls the <code>build()</code> methods of all the the enclosed objects to create a nice, immutable object.</p>
<h2><strong>Java</strong></h2>
<p>In Java, you can pretty much create the exact same classes, except that the builder doesn’t look as clean, since it doesn’t have all the lovely features above. So, to start you off, here’s what the builder code ends up looking like.</p>
<pre><code class="hljs language-kotlin">html(html -> {
   html.head(head ->
      head.title(<span class="hljs-string">"A Title"</span>)
   );
   ht.body(body -> {
      body.p(<span class="hljs-string">"paragraph"</span>);
      body.p(<span class="hljs-string">"'nother one"</span>);
      body.p(<span class="hljs-string">"last paragraph"</span>);
   });
});</code></pre>
<p>And <em>that</em> is as close to the builder syntax that you can get in Java. Note that there’s no difference in the way that <code>title()</code> and <code>p()</code> are called, since Java doesn’t provide any property-like construct. Also, notice that you need to have a name for everything. With the implicit <code>this</code>, you must write something like <code>hd.title(...)</code> rather than just <code>title(...)</code>, and that’s not even mentioning the fact that we have to define the parameter list for the lambda.</p>
<p>There’s a couple other things you could do, but those are even worse, the first being just using normal code:</p>
<pre><code class="hljs language-java">Html html = <span class="hljs-keyword">new</span> Html();
   Head head = html.head();
      head.title(<span class="hljs-string">"A Title"</span>);
   Body body = html.body();
      body.p(<span class="hljs-string">"paragraph"</span>);
      body.p(<span class="hljs-string">"'nother one"</span>);
      body.p(<span class="hljs-string">"last paragraph"</span>);</code></pre>
<p>This isn’t <em>terrible</em>, but it ends up being relatively verbose because of the lack of full type inference (I have to specify that <code>head</code> and <code>body</code> are of their respective types), and the extra tabbing is purely for looks, since no brackets are used. The other way I thought of doing it will be shown after the Python version, since it tries to sort of replicate <em>that</em> version.</p>
<p>So, let’s look at the code</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Html</span> </span>{
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Html <span class="hljs-title">html</span><span class="hljs-params">(Consumer&#x3C;Html> htmlBuilder)</span>
   </span>{
      Html html = <span class="hljs-keyword">new</span> Html();
      htmlBuilder.accept(html);
      <span class="hljs-keyword">return</span> html;
   }

   <span class="hljs-keyword">private</span> Head head = <span class="hljs-keyword">null</span>;
   <span class="hljs-keyword">private</span> Body body = <span class="hljs-keyword">null</span>;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">head</span><span class="hljs-params">(Consumer&#x3C;Head> headBuilder)</span> </span>{
      head = <span class="hljs-keyword">new</span> Head();
      headBuilder.accept(head);
   }

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">body</span><span class="hljs-params">(Consumer&#x3C;Body> bodyBuilder)</span> </span>{
      body = <span class="hljs-keyword">new</span> Body();
      bodyBuilder.accept(body);
   }
}</code></pre>
<p>This is as direct of a port to Java as it gets. The <code>html()</code> function was moved into the <code>Html</code> class as static method, since it has to go <em>somewhere</em> in Java. We used a <code>Consumer&#x3C;Html></code>, since that’s the closest thing Java has to the kind of lambdas we want.</p>
<p>Here are <code>Head</code> and <code>Title</code>:</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Head</span> </span>{
   <span class="hljs-keyword">private</span> Title title = <span class="hljs-keyword">null</span>;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">title</span><span class="hljs-params">(String text)</span> </span>{
      title = <span class="hljs-keyword">new</span> Title(text);
   }
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Title</span> </span>{
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String text;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Title</span><span class="hljs-params">(String text)</span> </span>{
      <span class="hljs-keyword">this</span>.text = text;
   }
}</code></pre>
<p>Not much of note here. It’s probably about what you expected. Now to finish off with <code>Body</code> <code>Paragraph</code>.</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Body</span> </span>{
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List paragraphs = <span class="hljs-keyword">new</span> ArrayList&#x3C;>();

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">p</span><span class="hljs-params">(String text)</span> </span>{
      paragraphs.add(<span class="hljs-keyword">new</span> Paragraph(text));
   }
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Paragraph</span> </span>{
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String text;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Paragraph</span><span class="hljs-params">(String text)</span> </span>{
      <span class="hljs-keyword">this</span>.text = text;
   }
}</code></pre>
<p>It almost feels like it’s not worth writing these classes, doesn’t it, they’re so simple. Keep in mind, this is the bare-bones builder part. Again, this code doesn’t actually include the functionality for building the actual, immutable DOM tree.</p>
<p>That’s what it takes to build the Java version. Other that some of the syntax verbosity, it’s almost easier to create in Java than in Kotlin because there aren’t any extra features to think about and apply<img src="https://s0.wp.com/wp-content/mu-plugins/emoji/twemoji/svg/1f61b.svg" alt="😛"></p>
<h2><strong>Python</strong></h2>
<p>Trying to figure out a way to do something like this in Python required me to get lucky enough to see a video that showed a novel (but unintuitive) way of using context managers (<code>with</code> statements). The problem in Python is that lambdas are only allowed to have a single expression or statement. Context managers allow a (very limited) way of getting around single-line lambdas by effectively allowing you to return an object (or nothing) at entry that can be used while within the context manager as if being within lambda.</p>
<p>So, for example, the builder would look like this in Python:</p>
<pre><code class="hljs language-python">myhtml = Html()
<span class="hljs-keyword">with</span> myhtml <span class="hljs-keyword">as</span> html:
    <span class="hljs-keyword">with</span> html.head() <span class="hljs-keyword">as</span> head:
        head.title(<span class="hljs-string">"A Title"</span>)
    <span class="hljs-keyword">with</span> html.body() <span class="hljs-keyword">as</span> body:
        body.p = <span class="hljs-string">"paragraph"</span>
        body.p = <span class="hljs-string">"'nother one"</span>
        body.p = <span class="hljs-string">"last paragraph"</span></code></pre>
<p>This may actually look like a waste because this can written as the following almost as easily:</p>
<pre><code class="hljs language-python">html = Html()
head = html.head()
head.title(<span class="hljs-string">"A Title"</span>)
body = html.body()
body.p = <span class="hljs-string">"paragraph"</span>
body.p = <span class="hljs-string">"'nother one"</span>
body.p = <span class="hljs-string">"last paragraph"</span></code></pre>
<p>The biggest benefit of the <code>with</code> blocks is the indentation, since Python has indentation restrictions due to it using indentation over curly braces. Context managers are possibly worth it just for <em>that</em> benefit. But there’s another benefit that I’ll bring up near the end, after showing you the basic code required for making these in Python</p>
<pre><code class="hljs language-python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Html</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__enter__</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__exit__</span><span class="hljs-params">(self, exc_type, exc_val, exc_tb)</span>:</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">head</span><span class="hljs-params">(self)</span>:</span>
        self._head = Head()
        <span class="hljs-keyword">return</span> self._head

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">body</span><span class="hljs-params">(self)</span>:</span>
        self._body = Body()
        <span class="hljs-keyword">return</span> self._body</code></pre>
<p>Here, you can see that the <code>Html</code> class has the required <code>__enter__()</code> and <code>__exit__()</code> methods to be a context manager. They do practically nothing; <code>__enter__()</code> only returns <code>self</code>, and <code>__exit__()</code> simply signifies that it didn’t deal with any exceptions that may have been passed in. The <code>head()</code> and <code>body()</code> methods do pretty much what you’d expect by now, with the assumption that <code>Head</code> and <code>Body</code> are also context manager types.</p>
<pre><code class="hljs language-python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Head</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__enter__</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__exit__</span><span class="hljs-params">(self, exc_type, exc_val, exc_tb)</span>:</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">title</span><span class="hljs-params">(self, text)</span>:</span>
        self._title = Title(text)

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Title</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, text)</span>:</span>
        self.text = text

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Body</span>:</span>
    p = property()

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__enter__</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__exit__</span><span class="hljs-params">(self, exc_type, exc_val, exc_tb)</span>:</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>

<span class="hljs-meta">    @p.setter</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">p</span><span class="hljs-params">(self, text)</span>:</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> hasattr(self, <span class="hljs-string">'paragraphs'</span>):
            self.paragraphs = []
        self.paragraphs.append(Paragraph(text))

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Paragraph</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, text)</span>:</span>
        self.text = text</code></pre>
<p>The only new thing here to bother looking at is the use of <code>property</code> on <code>Body</code> for its <code>p</code> tag. Luckily, we can don’t need getters on <code>property</code>s that we need to have return <code>None</code>, like in Kotlin.</p>
<p>Okay, now we look at the interesting, less obvious reason why it’s helpful to use context managers for this situation. In Java and Kotlin, we would have needed an additional call at the end to a <code>build()</code> method (or else have the <code>html()</code> function do it for us) and have it do a recursive traversal all at once in the end to take care of it. With the context manager, the <code>__enter__()</code> and <code>__exit__()</code> methods could pass out the builder version of the object upon entry, then build it on exit. That means that each intermediate stage of the builders already contain the fully built versions by the time they exit.</p>
<p>This can actually be a little difficult to wrap your head around. Here’s an example that does a partial implementation using <code>Html</code>, <code>HtmlBuilder</code>, and <code>Head</code>:</p>
<pre><code class="hljs language-python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Html</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__enter__</span><span class="hljs-params">(self)</span>:</span>
        self._builder = HtmlBuilder()
        <span class="hljs-keyword">return</span> self._builder

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__exit__</span><span class="hljs-params">(self, exc_type, exc_val, exc_tb)</span>:</span>
        self.head = self._builder._head
        self.body = self._builder._body
        <span class="hljs-keyword">del</span> self._builder
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HtmlBuilder</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">head</span><span class="hljs-params">(self)</span>:</span>
        self._head = Head()
        <span class="hljs-keyword">return</span> self._head

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">body</span><span class="hljs-params">(self)</span>:</span>
        ...

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Head</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__enter__</span><span class="hljs-params">(self)</span>:</span>
        self._builder = HeadBuilder()
        <span class="hljs-keyword">return</span> self._builder

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__exit__</span><span class="hljs-params">(self, exc_type, exc_val, exc_tb)</span>:</span>
        self.title = self._builder._title
        <span class="hljs-keyword">del</span> self._builder
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span></code></pre>
<p>Here, the <code>Html</code> object’s <code>__enter__()</code> method creates and saves a builder on itself, then returns it. Upon <code>__exit__()</code>, it builds itself from values stored on the builder and deletes the builder from itself. Upon first thought, at least for me, one might think that the objects stored on the builder aren’t finished objects, but they are. The methods on the builder object return a proper class with its own <code>__enter__()</code> and <code>__exit__()</code> methods which will also guarantee that it’s built properly, as is seen with <code>HtmlBuilder</code>‘s <code>head()</code> method and with the implementation of <code>Head</code>. With this setup, the calling code is actually still the same as it was the first time.</p>
<p>Last thing: now that we know that we can use context managers to do this, you might think that Java’s <code>try</code> resource manager might actually work okay for it. And you’d be right. In fact, it ends up with a cleaner syntax (other than the random <code>try</code> keywords) than the lambda version, too. Here’s what the resource manager version would look like when called:</p>
<pre><code class="hljs language-java">Html html = Html();
<span class="hljs-keyword">try</span>(html) {
   <span class="hljs-keyword">try</span>(Head head = html.head()) {
      head.title(<span class="hljs-string">"A Title"</span>);
   }
   <span class="hljs-keyword">try</span>(Body body = html.body()) {
      body.p(<span class="hljs-string">"paragraph"</span>);
      body.p(<span class="hljs-string">"'nother one"</span>);
      body.p(<span class="hljs-string">"last paragraph"</span>);
   }
}</code></pre>
<p>At this point, I’ll leave it to you to try and figure out how to implement this. Hint: I don’t think it can work like the second version of the Python build, where it builds as it goes. I think everything in this Java version of the code requires builders until, at the end, you call the <code>build()</code> method on <code>html</code> to create the true versions.</p>
<h2><strong>Outro</strong></h2>
<p>Holy cow, this thing ended up being kind of long, didn’t it? I hope that you had some fun with this exercise, since I’m not sure how useful it really is (other than learning that you could potentially simulate 0- or 1-parameter lambdas with context managers.</p>
<p>Sadly, I never did get around to talking about adding the additional parameters like the Kotlin site’s example does, such as assigning a class, id, etc in the function calls. There are additional features that Kotlin has that makes this really clean and easy, but this article clearly doesn’t have room for it. I’ll tackle it next week.</p>
<p>Thanks for reading!</p>
<p>Note: As of yesterday, all editing is finished. From here, I “just” need to get a cover designed, which I have an idea for; get all the formatting figured out for both print and e-book versions; write the appendix (mostly just a collection of code snippets from the book, fleshed out more); and finish writing the GitHub repo that will have all the super helpful classes and functions for building your own descriptors more quickly, easily, and with fewer problems. I expect to get all of this done by the end of summer, but hopefully sooner. My life is about to get a little busier, so I don’t know how much time I’ll be able to devote to all of this.</p>
]]></description><link>https://programmingideaswithjake.wordpress.com/2016/01/16/mimicking-kotlin-builders-in-java-and-python/</link><guid isPermaLink="true">https://programmingideaswithjake.wordpress.com/2016/01/16/mimicking-kotlin-builders-in-java-and-python/</guid><category><![CDATA[Builders]]></category><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Jacob Zimmerman]]></dc:creator><pubDate>Sat, 16 Jan 2016 10:00:00 GMT</pubDate></item><item><title><![CDATA[Android development with Kotlin]]></title><description><![CDATA[<h2>What is Kotlin?</h2>
<p><a href="https://kotlinlang.org/">Kotlin</a> is a statically typed programming language for the Java Virtual Machine, Android and web browsers. Inside Android apps we can use Kotlin language to replace Java code, but also we can use both together having Java classes and Kotlin classes in the same project.</p>
<h2>Getting started</h2>
<p>Using Android Studio</p>
<h3>1. Install the Kotlin plugin</h3>
<p>Go to "Android Studio" menu, "Preferences", "Plugins", search 'Kotlin' and install the plugin. Then you will have to restart Android Studio.</p>
<h3>2. Start a new Android project</h3>
<p>Let's create a new Android project: go to "Start a new Android Studio project" or "File" menu, and click "New project".</p>
<h3>3. Configure gradle</h3>
<p>You can configure Kotlin in the project by clicking "Help" on the menu, then "Find Action" (or press ⇧⌘A) and finally enter "Configure Kotlin in Project". Then you should choose the Kotlin version that you want. After that, the app/build.gradle file should be updated. Also, instead of using "Find Action", you can edit the app/build.gradle file manually. Here is an example:</p>
<pre><code class="hljs language-groovy">apply <span class="hljs-string">plugin:</span> <span class="hljs-string">'com.android.application'</span>
apply <span class="hljs-string">plugin:</span> <span class="hljs-string">'kotlin-android'</span>

android {
    compileSdkVersion <span class="hljs-number">23</span>
    buildToolsVersion <span class="hljs-string">"23.0.2"</span>

    defaultConfig {
        applicationId <span class="hljs-string">"examples.kotlin.inaka.com"</span>
        minSdkVersion <span class="hljs-number">17</span>
        targetSdkVersion <span class="hljs-number">23</span>
        versionCode <span class="hljs-number">1</span>
        versionName <span class="hljs-string">"1.0"</span>
    }
    buildTypes {
        release {
            minifyEnabled <span class="hljs-literal">false</span>
            proguardFiles getDefaultProguardFile(<span class="hljs-string">'proguard-android.txt'</span>), <span class="hljs-string">'proguard-rules.pro'</span>
        }
    }
    sourceSets {
        main.java.srcDirs += <span class="hljs-string">'src/main/kotlin'</span>
    }
}

buildscript {
    ext.kotlin_version = <span class="hljs-string">'1.0.0-beta-4583'</span>
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath <span class="hljs-string">"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"</span>
        classpath <span class="hljs-string">"org.jetbrains.kotlin:kotlin-android-extensions:$kotlin_version"</span>
    }
}

repositories {
    mavenCentral()
}

dependencies {
    compile fileTree(<span class="hljs-string">dir:</span> <span class="hljs-string">'libs'</span>, <span class="hljs-string">include:</span> [<span class="hljs-string">'*.jar'</span>])
    compile <span class="hljs-string">'com.android.support:appcompat-v7:23.1.1'</span>
    compile <span class="hljs-string">"org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version"</span>
}</code></pre>
<h3>4. Convert .java to Kotlin (.kt) files</h3>
<p>Open a Java file and choose "Help" on the menu, then "Find Action" (or press ⇧⌘A) and enter the action "Convert Java File to Kotlin File". Alternatively you can call this option via "Code" menu, "Convert Java File to Kotlin File".</p>
<h2>Some characteristics</h2>
<p>Using Kotlin to develop Android apps introduce many differences and 'advantages' compared to Java development. Here I will mention some of them:</p>
<h3>Variables and type inference</h3>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">var</span> age = <span class="hljs-number">5</span> <span class="hljs-comment">// you don't need to declare as an Int</span></code></pre>
<p>But if you want to declare the type:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">var</span> age: <span class="hljs-built_in">Int</span> = <span class="hljs-number">5</span></code></pre>
<p>Java's 'final' = Kotlin's 'val':</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> name = <span class="hljs-string">"Fernando"</span> <span class="hljs-comment">// 'val' can't be reassigned</span></code></pre>
<h3>Pattern matching</h3>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">valueDependingOnType</span><span class="hljs-params">(type: <span class="hljs-type">Int</span>)</span></span> {
    <span class="hljs-keyword">var</span> value = <span class="hljs-number">0</span>
    <span class="hljs-keyword">when</span> (type) {
        <span class="hljs-number">1</span> -> toast(value.toString())
        <span class="hljs-number">2</span> -> {
            value = <span class="hljs-number">100</span>
            toast(value.toString())
        }
        <span class="hljs-keyword">else</span> -> toast(type.toString())
    }
}</code></pre>
<h3>Safe call - null verification</h3>
<p>Verifying null object with Java:</p>
<pre><code class="hljs language-kotlin">int len;
<span class="hljs-keyword">if</span>(list != <span class="hljs-literal">null</span>){
  len = list.size();
}</code></pre>
<p>Same as above but using Kotlin language:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">var</span> len = list?.size</code></pre>
<p>Safe cast example:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> x: String? = y <span class="hljs-keyword">as</span>? String</code></pre>
<h3>Properties</h3>
<p>Avoid usage of getters and setters:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">var</span> user = User()
user.name = <span class="hljs-string">"Fernando"</span> <span class="hljs-comment">// set user's name</span>
toast(user.name)       <span class="hljs-comment">// get user's name</span></code></pre>
<h3>Companion object</h3>
<p>A Kotlin class can have a companion object. This is like the static variable for Java classes. For example:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span></span>() {

  <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> {
      <span class="hljs-keyword">val</span> PICK_CONTACT = <span class="hljs-number">100</span>
  }

  ...
}</code></pre>
<p>Then you can call MainActivity.PICK_CONTACT and it will receive the value 100.</p>
<h3>String templates</h3>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printFirst</span><span class="hljs-params">(array: <span class="hljs-type">Array</span>&#x3C;<span class="hljs-type">String</span>>)</span></span> {
  <span class="hljs-keyword">if</span> (array.size == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>
  print(<span class="hljs-string">"First value: <span class="hljs-subst">${array[<span class="hljs-number">0</span>]}</span>"</span>)
}</code></pre>
<h3>Ranges</h3>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">if</span> (x <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span>.y)
print(<span class="hljs-string">"x is  >= 1 and &#x3C;= y"</span>)</code></pre>
<h3>Lambda expressions</h3>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">(numbers: <span class="hljs-type">ArrayList</span>&#x3C;<span class="hljs-type">Int</span>>)</span></span> {
   <span class="hljs-keyword">val</span> doubled = numbers.map { elem -> elem * <span class="hljs-number">2</span> }
   ...
}</code></pre>
<p>or</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">(numbers: <span class="hljs-type">ArrayList</span>&#x3C;<span class="hljs-type">Int</span>>)</span></span> {
   <span class="hljs-keyword">val</span> doubled = numbers.map { it * <span class="hljs-number">2</span> }
   ...
}</code></pre>
<h3>Kotlin extensions - finding views</h3>
<p>You don't need to call the findViewById() method. For example, if you want to change programatically the text of a TextView with id "textView1" from activity_main.xml you can do:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">import</span> kotlinx.android.synthetic.main.activity_main.*</code></pre>
<p>And then into onCreate method:</p>
<pre><code class="hljs language-kotlin">textView1.text = <span class="hljs-string">"example text"</span></code></pre>
<h2>Resources</h2>
<p><a href="https://kotlinlang.org/docs/reference/">Kotlin language official documentation</a></p>
<h3>Some open source example projects</h3>
<ul>
<li><a href="https://github.com/inaka/kotlillon">kotlillon</a> Compilation of simple Kotlin examples, all together in one Android app</li>
<li><a href="https://github.com/ramabit/restful-android-kotlin">restful_android_kotlin</a> Restful Android app example, using Kotlin with Realm, Retrofit, Picasso, Robospice and more</li>
</ul>
<h3>Some interesting Kotlin libraries for Android development</h3>
<ul>
<li><a href="https://github.com/Kotlin/anko">Anko</a></li>
<li><a href="https://github.com/ReactiveX/RxKotlin">RxKotlin</a></li>
<li><a href="https://github.com/JakeWharton/kotterknife">kotterknife</a></li>
<li><a href="https://github.com/cheptsov/kotlin-nosql">kotlin-nosql</a></li>
</ul>
]]></description><link>http://inaka.net/blog/2016/01/15/android-development-with-kotlin/</link><guid isPermaLink="true">http://inaka.net/blog/2016/01/15/android-development-with-kotlin/</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Android]]></category><dc:creator><![CDATA[Fernando Ramirez]]></dc:creator><pubDate>Fri, 15 Jan 2016 21:54:00 GMT</pubDate></item><item><title><![CDATA[Kotlin, the somewhat obscure modern Android-friendly programming language]]></title><description><![CDATA[<h3>Kotlin, the somewhat obscure modern Android-friendly programming language</h3>
<p><a href="https://developer.apple.com/swift/">Swift</a> is a terse functional programming language with high Objective-C interoperability used for iOS development.</p>
<p>Swift is better than Objective-C.</p>
<p>You already know this.</p>
<p>But you probably don’t know what Kotlin is.</p>
<p><a href="https://kotlinlang.org/">Kotlin</a> is Swift for Android. [1]</p>
<p>You’re not using Objective-C anymore, so why are you using Java?</p>
<p>We built <a href="http://tryroll.com">Roll for Android</a> in <a href="https://kotlinlang.org/">Kotlin</a>.</p>
<h3>What is Kotlin? Really.</h3>
<p>Kotlin is a terse swift-like functional programming language on the JVM platform with high Java interoperability. Kotlin is unique in that its standard library and runtime are extremely small in bytes, yet very powerful. Most is eliminated at compile time (in contrast to <a href="http://www.scala-lang.org/">Scala</a>), so it can feasibly be used in memory “constrained” environments like Android (not embedded systems, but smartphones):</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> immutableVariable = <span class="hljs-string">"a string"</span>

<span class="hljs-comment">// a function</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">inc</span><span class="hljs-params">(x: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> {
  <span class="hljs-keyword">return</span> x+<span class="hljs-number">1</span>
}

<span class="hljs-comment">// anonymous function bound to a variable</span>
<span class="hljs-keyword">val</span> inc: (<span class="hljs-built_in">Int</span>) -> <span class="hljs-built_in">Int</span> = { it + <span class="hljs-number">1</span> }</code></pre>
<h3>Why Kotlin and not “X”?</h3>
<p>We wanted to iterate on a lot of the software structure we came up with for our <a href="http://tryroll.com">Swift iOS app</a>, and for a bunch of pieces we needed a powerful type-system. So rather than just stick with Java — it’s way too verbose — we started looking at alternatives. We wanted a strong static type system, yet the obvious choice, Scala, has too much overhead for Android. Kotlin really stood out for us. <a href="https://docs.google.com/document/d/1ReS3ep-hjxWA8kZi0YqDbEhCqTt29hG8P44aA9W0DM8/edit?hl=en&#x26;forcehl=1">This document by Jake Wharton at Square</a> made the decision easier. So we took the risk.</p>
<h3>Great Features</h3>
<ul>
<li><a href="https://kotlinlang.org/docs/reference/null-safety.html">Null type safety!</a></li>
</ul>
<p>In Kotlin, just like in Swift, optional values are tracked through the type-system. You will not have null pointer exceptions in your Kotlin code:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> x: String? = tryToGetString()
<span class="hljs-comment">// x is not a String (it could be null)</span>

<span class="hljs-keyword">if</span> (x != <span class="hljs-literal">null</span>) {
  <span class="hljs-comment">// x is smart-casted to a String here!</span>
}</code></pre>
<ul>
<li><a href="https://kotlinlang.org/docs/reference/inline-functions.html">Lambdas can be inlined!</a></li>
</ul>
<p>An under appreciated feature of Kotlin (if you’re targeting Android for example) is the zero overhead higher order functions on collections.</p>
<p>In Kotlin these standard library functions are inlined and desugared to for-loops.</p>
<p>Thus, you can write expressive Scala-like code but without all the anonymous inner class overhead (which while negligible on servers, is <a href="http://developer.android.com/training/articles/memory.html">an issue in Dalvik</a> and possibly Android’s new runtime ART [no evidence], so Android devices will be affected):</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> strs = listOf(<span class="hljs-string">"this"</span>, <span class="hljs-string">"is"</span>, <span class="hljs-string">"a"</span>, <span class="hljs-string">"bunch"</span>, <span class="hljs-string">"of"</span>, <span class="hljs-string">"words"</span>)

<span class="hljs-keyword">val</span> charCount = strs.map{ it.length }.fold(<span class="hljs-number">0</span>, { a, b -> a + b })

<span class="hljs-keyword">val</span> evenWords = strs.filter{ it.length % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> }</code></pre>
<ul>
<li><a href="https://kotlinlang.org/docs/reference/inline-functions.html#reified-type-parameters">Reified generics!</a></li>
</ul>
<p>Reified generics in Kotlin let you use the generic T in your code at runtime. For example, we’ve used reified generics to implement a clean API for dictionary deserialization to model data classes. Here, we attempt to deserialize an untyped map into some strongly typed data class of type T (like a User):</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> deserialize<span class="hljs-type">&#x3C;<span class="hljs-keyword">reified</span> T></span><span class="hljs-params">(dict: <span class="hljs-type">Map</span>&#x3C;<span class="hljs-type">String</span>, Any?>)</span></span>: T { ... }
<span class="hljs-comment">// usage val model = deserialize&#x3C;ModelData>(modelDataDict)</span></code></pre>
<ul>
<li><a href="https://kotlinlang.org/docs/reference/extensions.html">Statically resolved extension functions!</a></li>
</ul>
<p>Extension functions in Kotlin allow you to add “methods” to objects. These are resolved statically so there is no performance overhead or runtime confusion.</p>
<p>Extension functions even work on generic “primitives” like Functions or optional types.</p>
<p>For example, we have defined monadic bind on options (like if-let in Swift if it were an expression and not a statement) and use it all over our codebase [2]:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&#x3C;T, R></span> T?.<span class="hljs-title">bind</span><span class="hljs-params">(transform: (<span class="hljs-type">T</span>)</span></span> -> R?): R? =
    <span class="hljs-keyword">this</span>?.let(transform)</code></pre>
<ul>
<li><a href="https://kotlinlang.org/docs/reference/classes.html#sealed-classes">Algebraic data types and pattern matching!</a></li>
</ul>
<p>Algebraic data types or (ADTs) (also called Sum types or tagged unions) allow you model data that can be one of several different variants. Once you’ve used ADTs, you can’t live with out them. The compiler will enforce that you have exhaustively handled all the cases. Swift has them, and as of recently Kotlin does too.</p>
<p>Here is an example of the model for a button that is either disabled, shows a number, or shows info about a user:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ButtonState</span> </span>{
  <span class="hljs-keyword">object</span> Disabled: ButtonState()
  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShowingNum</span></span>(<span class="hljs-keyword">val</span> num: <span class="hljs-built_in">Int</span>): ButtonState()
  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShowingPerson</span></span>(<span class="hljs-keyword">val</span> u: User): ButtonState()
}

<span class="hljs-comment">// this state shows 5</span>
<span class="hljs-keyword">val</span> showFiveState = ShowingNum(<span class="hljs-number">5</span>)

<span class="hljs-comment">// all states handled (enforced by the compiler!)</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printbutton</span><span class="hljs-params">(state: <span class="hljs-type">ButtonState</span>)</span></span>: String = <span class="hljs-keyword">when</span> (state) {
  <span class="hljs-keyword">is</span> ShowingNum -> <span class="hljs-string">"&#x3C;{state.num}>"</span>
  <span class="hljs-keyword">is</span> ShowingPerson -> <span class="hljs-string">"&#x3C;{state.u.name}>"</span>
  Disabled -> <span class="hljs-string">"-&#x3C;>-"</span>
}</code></pre>
<ul>
<li>Single-method interfaces/classes can be represented as lambdas! aka</li>
</ul>
<pre><code class="hljs language-java">view.setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() {
  <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>{
    <span class="hljs-comment">/* do something */</span>
  }
});</code></pre>
<p>becomes</p>
<pre><code class="hljs language-kotlin">view.setOnClickListener { <span class="hljs-comment">/* do something */</span> }</code></pre>
<p>This is great for things like <a href="http://reactivex.io/">RxJava</a>.</p>
<p>Speaking of which, the Java interoperability is first-class and fantastic. Any Android Java libraries we’ve tried work great from Kotlin.</p>
<h3>Libraries Created</h3>
<p>Using these features, we’ve built:</p>
<ul>
<li>a simple dependency injection framework</li>
<li>a handful of really useful extensions on things like T? (for example monadic bind)</li>
<li>a hack for algebraic data types and pattern matching (before sealed class was released)</li>
<li>a single-atom-state functional reactive UI component framework</li>
<li>and of course a fairly complex app.</li>
</ul>
<p>Android Studio’s Kotlin support is fantastic (good job JetBrains!) — it’s a pleasure to use.</p>
<h3>Build Time</h3>
<p>The biggest issue for us is the build time. Gradle builds used to take around 5–10 minutes. We invested a week of engineering time in getting a <a href="https://buckbuild.com/">Buck</a> build working alongside Gradle. Buck builds are 3 minutes max and usually are around 45 seconds. With the most recent Android Studio update, incremental Gradle builds are back down under a minute. This is not too much longer than a pure Java app of our size would take to build.</p>
<h3>Use Kotlin!</h3>
<p>Kotlin is great! The time saved due to the benefits of Kotlin make up for any time lost optimizing build times.</p>
<p>If you’re interested in learning more, get in touch. We’re hiring!</p>
<p>Note: this post was adapted from an earlier <a href="https://news.ycombinator.com/item?id=9947020">HackerNews comment</a></p>
<p>[1] aside: It is more accurate to say Swift is the Kotlin of iOS since Kotlin has existed in the open for many more years than Swift. Due to Kotlin’s obscurity, however, we’re forced to make the Kotlin to Swift comparison.</p>
<p>[2] Thanks @<a href="https://twitter.com/daniil_vodopian">daniil_vodopian</a> for the terser bind definition</p>
]]></description><link>https://medium.com/math-camp-engineering/kotlin-3e963864db9e#.jumx6jh63</link><guid isPermaLink="true">https://medium.com/math-camp-engineering/kotlin-3e963864db9e#.jumx6jh63</guid><category><![CDATA[Android]]></category><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Brandon Kase]]></dc:creator><pubDate>Fri, 15 Jan 2016 15:44:00 GMT</pubDate></item><item><title><![CDATA[Fun with Kotlin]]></title><description><![CDATA[<p><a href="https://vimeo.com/151846078">Fun with Kotlin</a></p>
]]></description><link>https://vimeo.com/151846078</link><guid isPermaLink="true">https://vimeo.com/151846078</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Eder Bastos]]></dc:creator><pubDate>Thu, 14 Jan 2016 18:54:00 GMT</pubDate></item><item><title><![CDATA[Playing with Spring Boot, Vaadin and Kotlin]]></title><description><![CDATA[<p>It’s no mystery that I’m a fan of both Spring Boot and Vaadin. When the <a href="https://github.com/vaadin/spring">Spring Boot Vaadin add-on</a> became <abbr title="General Availability">GA</abbr>, I was ecstatic. Lately, I became interested in <a href="https://kotlinlang.org/">Kotlin</a>, a JVM-based language offered by JetBrains. Thus, I wanted to check how I could develop a small Spring Boot Vaadin demo app in Kotlin – and learn something in the process. Here are my discoveries, in no particular order.</p>
<h3>Spring needs non-final stuff</h3>
<p>It seems Spring needs <code>@Configuration</code> classes and <code>@Bean</code> methods to be non-final. As my previous Spring projects were in Java, I never became aware of that because I never use the <code>final</code> keyword. However, Kotlin classes and methods are final <em>by default</em>: hence, you have to use the open keyword in Kotlin.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfiguration</span> </span>{
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-meta">@UIScope</span>
    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">mainScreen</span><span class="hljs-params">()</span></span> = MainScreen()
}</code></pre>
<h3>No main class</h3>
<p>Spring Boot applications require a class with a <code>public static void main(String... args)</code> method to reference a class annotated with <code>@SpringBootApplication</code>. In general, those two classes are the same.</p>
<p>Kotlin has no concept of such static methods, but offers pure functions and objects. I tried to be creative by having an annotated object referenced by a pure function, both in the same file.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BootVaadinKotlinDemoApplication</span></span>

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">vararg</span> args: <span class="hljs-type">String</span>)</span></span> {
    SpringApplication.run(arrayOf(BootVaadinKotlinDemoApplication::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>), <span class="hljs-type">args)</span></span>
}</code></pre>
<h3>Different entry-point reference</h3>
<p>Since the main function is not attached to a class, there’s no main class to reference to launch inside the IDE. Yet, Kotlin creates a .class with the same name as the file name suffixed with <code>Kt</code>.</p>
<p>My file is named <code>BootVaadinKotlinDemoApplication.kt</code>, hence the generated class name is <code>BootVaadinKotlinDemoApplicationKt.class</code>. This is the class to reference to launch the application in the IDE. Note that there’s no need to bother about that when using <code>mvn spring-boot:run</code> on the command-line, as Spring Boot seems to scan for the main method.</p>
<h3>Short and readable bean definition</h3>
<p>Java syntax is seen as verbose. I don’t think it’s a big issue when its redundancy is very low compared to the amount of useful code. However, in some cases, even I have to admit it’s a lot of ceremony for not much. When of such case is defining beans with the Java syntax:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@Bean</span> <span class="hljs-meta">@UIScope</span>
<span class="hljs-keyword">public</span> MainScreen mainScreen() {
    <span class="hljs-keyword">return</span> new MainScreen();
}</code></pre>
<p>Kotlin cuts through all of the ceremony to keep only the meat:</p>
<ul>
<li>No semicolon required</li>
<li>No new keyword</li>
<li>Block replaced with an equal sign since the body consists of a single expression</li>
<li>No return keyword required as there’s no block</li>
<li>No return type required as it can easily be inferred</li>
</ul>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@Bean</span> <span class="hljs-meta">@UIScope</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">mainScreen</span><span class="hljs-params">()</span></span> = MainScreen()</code></pre>
<p>Spring configuration files are generally quite long and hard to read. Kotlin makes them much shorter, without sacrificing readability.</p>
<h3>The init block is your friend</h3>
<p>In Java, the constructor is used for different operations:</p>
<ol>
<li>storing arguments into attributes</li>
<li>passing arguments to the super constructor</li>
<li>other initialization code</li>
</ol>
<p>The first operation is a no-brainer because attributes are part of the class signature in Kotlin. Likewise, calling the super constructor is handled by the class signature. The rest of the initialization code is not part of the class signature and should be part of an <code>init</code> block. Most applications do not this part, but Vaadin needs to setup layout and related stuff.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainScreenPresenter</span></span>(tablePresenter: TablePresenter,
                          buttonPresenter: NotificationButtonPresenter,
                          view: MainScreen, eventBus: EventBus) : Presenter&#x3C;MainScreen>(view, eventBus) {

    init {
        view.setComponents(tablePresenter.view, buttonPresenter.view)
    }
}</code></pre>
<h3>Use the apply method</h3>
<p>Kotlin has a standard library offering small dedicated functions. One of them is apply, defined as <code>inline fun T.apply(f: T.() -> Unit): T (source)</code>. It’s an extension function, meaning every type will have it as soon as it’s imported into scope. This function requires an argument that is a function and that returns nothing. Inside this function, the object that has been apply-ed is accessible as <code>this</code> (and <code>this</code> is implicit, as in standard Java code). It allows code like this:</p>
<pre><code class="hljs language-kotlin">VerticalLayout(button, table).apply {
    setSpacing(<span class="hljs-literal">true</span>)
    setMargin(<span class="hljs-literal">true</span>)
    setSizeFull()
}</code></pre>
<h3>Factor view and presenter into same file</h3>
<p>Kotlin makes code extremely small, thus some files might be only a line long (not counting import). Opening different files to check related classes is useless. Packages are a way to organize your code; I think files might be another way in Kotlin. For example, Vaadin views and presenters can be put into the same file.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NotificationButton</span>: <span class="hljs-type">Button</span></span>(<span class="hljs-string">"Click me"</span>)

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NotificationButtonPresenter</span></span>(view: NotificationButton, eventBus: EventBus): Presenter&#x3C;NotificationButton>(view, eventBus) { ... }</code></pre>
<h3>Lambdas make great listeners</h3>
<p>As of Java 8, single-method interfaces implemented as anonymous inner classes can be replaced with lambdas. Kotlin offers the same feature plus:</p>
<ul>
<li>it allows to omit parentheses if the lambda is the only argument</li>
<li>if the lambda has a single argument, its default name is <code>it</code> and it doesn’t need to be declared</li>
</ul>
<p>Both make for a very readable syntax when used in conjunction with the Vaadin API:</p>
<pre><code class="hljs language-kotlin">view.addValueChangeListener {
    <span class="hljs-keyword">val</span> rowId = it.property.value
    <span class="hljs-keyword">val</span> rowItem = view.containerDataSource.getItem(rowId)
    eventBus.publish(SESSION, rowItem)
}</code></pre>
<p>Note: still, more complex logic should be put into its <a href="https://morevaadin.com/content/lambdas-java-8/">own function</a>.</p>
]]></description><link>https://blog.frankel.ch/playing-with-spring-boot-vaadin-and-kotlin</link><guid isPermaLink="true">https://blog.frankel.ch/playing-with-spring-boot-vaadin-and-kotlin</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Spring]]></category><category><![CDATA[Vaadin]]></category><dc:creator><![CDATA[Nicolas Frankel]]></dc:creator><pubDate>Sun, 10 Jan 2016 17:54:00 GMT</pubDate></item><item><title><![CDATA[Kotlin XML Binding]]></title><description><![CDATA[<p>I like creating DSLs in <a href="https://kotlinlang.org/">Kotlin</a>. It was fun to try creating a DSL for
XML data binding. Of course there are so many other libraries for JVM that implements it in the other way.</p>
<p>I was looking for a way to use XPath like queries for data binding. I did not want to parse
queries from raw strings. The DSL inherited some ideas from XPath queries.</p>
<p>In Kotlin I used
<a href="https://kotlinlang.org/docs/reference/delegated-properties.html">Delegated Properties</a>
to achieve better readability, avoid explicit type names for serialization/deserialization rules.</p>
<p>Let's consider an example. Say you have an XML:</p>
<pre><code class="hljs language-xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">project</span>></span>
  <span class="hljs-tag">&#x3C;<span class="hljs-name">settings</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"q"</span>></span>
     <span class="hljs-tag">&#x3C;<span class="hljs-name">name</span>></span>Foo<span class="hljs-tag">&#x3C;/<span class="hljs-name">name</span>></span>
  <span class="hljs-tag">&#x3C;/<span class="hljs-name">settings</span>></span>
  <span class="hljs-tag">&#x3C;<span class="hljs-name">keys</span>></span>
     <span class="hljs-tag">&#x3C;<span class="hljs-name">key</span>></span>A<span class="hljs-tag">&#x3C;/<span class="hljs-name">key</span>></span>
     <span class="hljs-tag">&#x3C;<span class="hljs-name">key</span>></span>B<span class="hljs-tag">&#x3C;/<span class="hljs-name">key</span>></span>
     <span class="hljs-tag">&#x3C;<span class="hljs-name">key</span>></span>C<span class="hljs-tag">&#x3C;/<span class="hljs-name">key</span>></span>
  <span class="hljs-tag">&#x3C;/<span class="hljs-name">keys</span>></span>
<span class="hljs-tag">&#x3C;/<span class="hljs-name">project</span>></span></code></pre>
<p>Thanks to the <a href="https://github.com/jonnyzzz/kotlin.xml.bind">kotlin.xml.bind</a>, you may
parse it with the following DSL in Kotlin:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Project</span> </span>{
  <span class="hljs-keyword">var</span> type <span class="hljs-keyword">by</span> JXML / XAttribute(<span class="hljs-string">"type"</span>)
  <span class="hljs-keyword">var</span> name <span class="hljs-keyword">by</span> JXML / <span class="hljs-string">"name"</span> / XText
  <span class="hljs-keyword">var</span> keys <span class="hljs-keyword">by</span> JXML / <span class="hljs-string">"keys"</span> / XElements(<span class="hljs-string">"key"</span>) / XText
  <span class="hljs-keyword">var</span> any <span class="hljs-keyword">by</span> JXML / <span class="hljs-string">"parameters"</span> / XAnyElements / XSub(Sub::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>)</span>
  <span class="hljs-keyword">var</span> unknownElements <span class="hljs-keyword">by</span> JXML / XUnknown
}</code></pre>
<p>Kotlin compiler infers types for properties, so one should not write types at all.
In the example above <code>type</code> and <code>name</code> properties are <code>String?</code>,
<code>keys</code> is <code>List&#x3C;String>?</code>. <code>XAnyElements</code> means result will be as collection, <code>XSub</code>
parses sub-elements as <code>XSub</code> objects.</p>
<p><a href="https://github.com/jonnyzzz/kotlin.xml.bind">kotlin.xml.bind</a> provides serialization and deserialization.</p>
<h1>Sources / Binaries</h1>
<p>Sources are on GitHub under Apache 2.0 license. Binaries are published to a maven repo.</p>
<p>For more information, see <a href="https://github.com/jonnyzzz/kotlin.xml.bind">kotlin.xml.bind</a> project on GitHub.</p>
<h1>Implementation details</h1>
<p>I use <a href="http://www.jdom.org/">JDOM</a> to work with XML. DSL is done in separate module that does not depend on JDOM directly.</p>
<p>You may find API declarations <a href="https://github.com/jonnyzzz/kotlin.xml.bind/blob/master/api/src/main/kotlin/org/jonnyzzz/kotlin/xml/bind/XBind.API.kt">here</a>.
For every DSL <a href="https://en.wikipedia.org/wiki/Terminal_and_nonterminal_symbols">grammar rule</a> of the DSL I created an interface in Kotlin.</p>
<p>The main trick is that expressions like <code>JXML / "keys" / XElements("key") / XText</code> returns an object
that implements requirements of
<a href="https://kotlinlang.org/docs/reference/delegated-properties.html">Delegated Properties</a>
.</p>
<p>The library adds a tiny overhead on every object creation. So now to create an object (e.g. <code>Project</code> class above)
it has to create a number of objects from the DSL that are used behind delegated properties. Reflections
are still in use to scan available object properties too on serialization/deserialization.</p>
<p>For tests I created yet another DSL to generate XML easily.
You may find more details in <a href="https://github.com/jonnyzzz/kotlin.xml.dsl">kotlin.xml.dsl</a> on GitHub.
This is an example of unit test</p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@Test</span>
<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test_read_any_element_does_not_include_parsed</span><span class="hljs-params">()</span></span> {
  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Data</span> </span>{
    <span class="hljs-keyword">var</span> X <span class="hljs-keyword">by</span> JXML / <span class="hljs-string">"x"</span> / XUnknown
    <span class="hljs-keyword">var</span> Y <span class="hljs-keyword">by</span> JXML / <span class="hljs-string">"Y"</span> / XUnknown
    <span class="hljs-keyword">var</span> Z <span class="hljs-keyword">by</span> JXML / XAnyElements / XUnknown
  }

  <span class="hljs-keyword">val</span> el = jdom(<span class="hljs-string">"aaa"</span>) {
    element(<span class="hljs-string">"x"</span>) { text(<span class="hljs-string">"yohoho"</span>)}
    element(<span class="hljs-string">"Y"</span>) { text(<span class="hljs-string">"123"</span>)}
    element(<span class="hljs-string">"z"</span>) { text(<span class="hljs-string">"www"</span>)}
    element(<span class="hljs-string">"p"</span>) { text(<span class="hljs-string">"www"</span>)}
  }

  <span class="hljs-keyword">val</span> d : Data = JDOM.load(el , Data::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>)</span>

  Assert.assertEquals(d.Z?.size, <span class="hljs-number">2</span>)
  Assert.assertEquals(d.Z?.<span class="hljs-keyword">get</span>(<span class="hljs-number">0</span>)?.name, <span class="hljs-string">"z"</span>)
  Assert.assertEquals(d.Z?.<span class="hljs-keyword">get</span>(<span class="hljs-number">1</span>)?.name, <span class="hljs-string">"p"</span>)
}</code></pre>
<p>I use <a href="https://gradle.org/">Gradle</a> as project model now.
Artifacts are deployed to <a href="https://bintray.com/jonnyzzz/maven">Bintray</a></p>
<h1>Future Work</h1>
<p>The ides of the DSL are easily mapped to JSON too. So it's possible to read/write/update JSON files in the same way
Get rid of reflections and use <a href="https://kotlinlang.org/docs/reference/object-declarations.html#companion-objects">Companion Objects</a>
Support other XML implementations, not only JDOM
Improve, finalize and document binding DSL
Invite contributors!
Have more fun!</p>
]]></description><link>http://jonnyzzz.com/blog/2016/01/06/kotlin-xml/</link><guid isPermaLink="true">http://jonnyzzz.com/blog/2016/01/06/kotlin-xml/</guid><category><![CDATA[kotlin]]></category><category><![CDATA[xml]]></category><category><![CDATA[dsl]]></category><dc:creator><![CDATA[Eugene Petrenko]]></dc:creator><pubDate>Wed, 06 Jan 2016 21:02:00 GMT</pubDate></item><item><title><![CDATA[Early Impressions of Kotlin]]></title><description><![CDATA[<p>We’ve been using the <a href="https://kotlinlang.org">Kotlin</a> programming language for a few weeks on our latest project to perform technical experiments, explore the problem space, and write a few HTTP services. I’ve also ported <a href="https://github.com/hamcrest/JavaHamcrest">Hamcrest</a> to Kotlin, as <a href="https://github.com/npryce/hamkrest">HamKrest</a>, to help us write tests, and written a small library for <a href="https://github.com/npryce/konfig">type safe configuration</a> of our services.</p>
<h2>Why Kotlin?</h2>
<p>The organisation I’m working with has mature infrastructure for deploying JVM services in their internal <a href="https://en.wikipedia.org/wiki/Platform_as_a_service">PaaS</a> cloud. They use a mix of Java and Scala but have found Scala builds too slow. Watching my colleague struggle to use Java 8 streams to write what should have been basic functional map-and-fold code, I decided to have a look at some other “post-Java” JVM languages.</p>
<p>We wanted a typed language. We wanted <a href="http://c2.com/cgi/wiki?LanguageAwareEditor">language aware editing</a>. And we wanted a language that had an organisation behind its development and enough people using it that we could get questions answered, even the stupid ones we’d be likely to ask while learning.</p>
<p>That eliminated dynamically typed languages (<a href="http://www.groovy-lang.org/">Groovy</a>, <a href="http://openjdk.java.net/projects/nashorn/">JavaScript</a>, <a href="http://clojure.org/">Clojure</a>) and languages that are less popular or have small, informal development teams behind them (<a href="http://www.eclipse.org/xtend/index.html">Xtend</a>, <a href="https://gosu-lang.github.io/">Gosu</a>, <a href="http://fantom.org/">Fantom</a>, <a href="https://github.com/Frege/frege">Frege</a>, etc.). In the end it came down to Red Hat’s <a href="http://ceylon-lang.org/">Ceylon</a> and JetBrains’ <a href="https://kotlinlang.org">Kotlin</a>. Of the two, Ceylon is the most innovative, and therefore (to me, anyway) the most interesting, but Kotlin met more of our criteria. Kotlin has a more active community, is being used for commercial development by JetBrains and a number of other companies<a href="#fn1"><sup>1</sup></a>, has good editing support within <a href="http://www.intellij.com">IntelliJ</a>, has an active community on social media, and promises easy interop with existing Java libraries.</p>
<h2>Good points</h2>
<p>Kotlin was very quick to learn. Kotlin is a conservative increment to Java that smooths off a lot of Java’s rough edges. Kotlin is small and regular, with few special cases and gotchas to learn. In many ways it feels a bit like a compiled, typed Python with curly brace syntax.</p>
<p>The type system is a breath of fresh air compared to Java. Type inferencing makes code less cluttered. There is no distinction between primitive &#x26; reference types. Generics and subtyping work together far better than Java: the type system uses <a href="https://kotlinlang.org/docs/reference/generics.html#declaration-site-variance">declaration site variance</a>, not <a href="https://docs.oracle.com/javase/tutorial/java/generics/bounded.html">use site variance</a>, and variance does not usually have to be specified at all for functions. You never have unavoidable compiler warnings, as you do with Java’s type system.</p>
<p>Functional programming is more convenient in Kotlin than Java. You can define free-standing functions and constants at the top level of a module, instead of having to define them in a <a href="https://en.wikipedia.org/wiki/Utility_class">“Utils” class</a>. Function definitions can be nested. There is language support for immutable value types (aka “<a href="https://kotlinlang.org/docs/reference/data-classes.html">data classes</a>”) and algebraic data types (“<a href="https://kotlinlang.org/docs/reference/classes.html#sealed-classes">sealed classes</a>”). Null safety is enforced by the type system and variables and fields are non-nullable by default. The language defines standard function types and a lambda syntax for anonymous functions.</p>
<p>You can define <a href="https://kotlinlang.org/docs/reference/extensions.html">extension methods</a> on existing types. They are only syntactic sugar for free-standing functions, but nevertheless can lead to more concise, expressive code. The Kotlin standard library defines a number of useful extension methods, especially on the Iterable and String types.</p>
<p>Kotlin supports, and carefully controls, <a href="https://kotlinlang.org/docs/reference/operator-overloading.html">operator overloading</a>. You can overload operators that act as functions (e.g. arithmetic, comparison, function call) but not those that perform flow control (e.g. short-cut logical operators). You cannot define your own operators, which will stop me going down the rabbit hole of “ascii-art programming”, which I found hard to resist when writing Scala.</p>
<p><a href="https://kotlinlang.org/docs/reference/classes.html">Class definitions</a> require a lot less boilerplate than in Java. Using old fashioned getter-and-setter style Java code is made more convenient by <a href="https://kotlinlang.org/docs/reference/properties.html">language support for bean properties</a>.</p>
<p><a href="https://kotlinlang.org/docs/reference/lambdas.html#function-literals-with-receiver">Anonymous extension methods</a> (borrowed from Groovy, I believe) make <a href="https://kotlinlang.org/docs/reference/type-safe-builders.html">domain specific embedded languages</a> easier to write. Method chaining builder APIs are unnecessary in Kotlin and more awkward than using the <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/apply.html">apply</a> function to set properties of an object.</p>
<p>Kotlin has a philosophy of preferring behaviour to be explicitly specified. For example, there is no automatic coercion between numeric types, even from low to high precision. That means you have to explicitly convert from Int to Long, for example. I like that, but I expect some people will find it annoying.</p>
<h2>Surprises</h2>
<h3>I didn’t miss destructuring pattern match</h3>
<p>Kotlin doesn’t have destructuring pattern match &#x26; language support for tuples. <a href="https://kotlinlang.org/docs/reference/multi-declarations.html">A limited form of destructuring</a> can be used in for loops and assignments. The <a href="https://kotlinlang.org/docs/reference/control-flow.html#when-expression">when expression</a> is an alternative conditional expression that doesn’t do destructuring.</p>
<p>I was surprised to find that I didn’t really miss destructuring. Without tuples you have to use data classes with named fields. The flow-sensitive typing then works rather well where destructuring would be necessary in a language where the type system is not flow-sensitive. For example:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Result</span>&#x3C;<span class="hljs-type">out T</span>> </span>{
   <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Success</span>&#x3C;<span class="hljs-type">T</span>></span>(<span class="hljs-keyword">val</span> value: T) : Result&#x3C;T>()
   <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Failure</span></span>(<span class="hljs-keyword">val</span> exception: Throwable): Result&#x3C;Any>()
}

...

<span class="hljs-keyword">val</span> e : Result&#x3C;String> = doSomething()
<span class="hljs-keyword">if</span> (e <span class="hljs-keyword">is</span> Result.Success&#x3C;String>) {
    <span class="hljs-comment">// e is known to be a Result.Success&#x3C;String> and</span>
    <span class="hljs-comment">// can be used as such without a downcast</span>
    println(e.value)
}</code></pre>
<h3>Sealed classes cannot be data classes</h3>
<p>An algebraic data type cannot be be a data class, so you have to write equals, hashCode, etc. yourself. This is a surprising omission, since I always want an algebraic data type to be a value type. The Kotlin developers say that this will be fixed after version 1.0 is released.</p>
<h3>Functions are not quite first-class objects</h3>
<p>There’s a difference between f1 and f2 below:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> f1 = {i:<span class="hljs-built_in">Int</span> -> i+<span class="hljs-number">1</span>}
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">f2</span><span class="hljs-params">(i:<span class="hljs-type">Int</span>)</span></span> = i + <span class="hljs-number">1</span></code></pre>
<p>Code can refer to the value of <code>f1</code> directly, but must use the “::” operator to obtain a reference to <code>f2</code>:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> f = ::f2</code></pre>
<h3>Null safe operators push me to write more extension functions</h3>
<p>The null safe operators (<code>?.</code> and <code>?:</code>) only help when dereferencing a nullable reference. When you have a nullable reference and want to pass a value (if it exists) to a function as a parameter, you have to use the awkward construct:</p>
<pre><code class="hljs language-kotlin">nullableThing?.let{ thing -> fn(thing, other, parameters) }</code></pre>
<p>I find myself refactoring my functions to extension functions to reduce the syntactic noise, letting me rewrite the code above as:</p>
<pre><code class="hljs language-kotlin">nullableThing?.fn(other, parameters)</code></pre>
<p>Is that a good thing? I’m not sure. Sometimes it feels a little forced.</p>
<h3>Companion objects</h3>
<p>Kotlin borrows the concept of <a href="#companion-objects">companion objects</a> from Scala. Why can’t classes be objects? Perhaps it’s a limitation of the JVM but compared to, say, Python, it feels clunky.</p>
<h2>Frustrations</h2>
<p>I only have a couple of frustrations with Kotlin.</p>
<h3>Lack of polymorphism</h3>
<p>Operators and the for loop are syntactic sugar that desugar to method calls. The methods are invoked statically and structurally — the target does not need to implement an interface that defines the method.</p>
<p>For example, <code>a + b</code> desugars to <code>a.add(b)</code>. However, there’s no way to write a generic function that sums its parameters, because <code>add</code> is not defined on an interface that can be used as an upper bound.</p>
<p>There’s no way to define the following function for any type that has an add operator method.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&#x3C;T></span> <span class="hljs-title">sum</span><span class="hljs-params">(T first, T second)</span></span> : T = first + second</code></pre>
<p>You would have to define overloads for different types, but then wouldn’t be able to call <code>sum</code> within a generic function.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sum</span><span class="hljs-params">(first: <span class="hljs-type">Int</span>, second: <span class="hljs-type">Int</span>)</span></span> = first + second
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sum</span><span class="hljs-params">(first: <span class="hljs-type">Long</span>, second: <span class="hljs-type">Long</span>)</span></span> = first + second
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sum</span><span class="hljs-params">(first: <span class="hljs-type">Double</span>, second: <span class="hljs-type">Double</span>)</span></span>= first + second
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sub</span><span class="hljs-params">(first: <span class="hljs-type">Matrix</span>&#x3C;<span class="hljs-type">Double</span>>, second: <span class="hljs-type">Matrix</span>&#x3C;<span class="hljs-type">Double</span>>)</span></span>= first + second
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sum</span><span class="hljs-params">(first: <span class="hljs-type">Money</span>, second: <span class="hljs-type">Money</span>)</span></span>= first + second
...</code></pre>
<p>That kind of duplication is what generics are meant to avoid!</p>
<p>Extension methods are also statically bound. That means you cannot write a generic function that calls an extension method on the value of a type parameter.</p>
<p>For example, the standard library defines the same extension methods on unrelated types — <code>forEach</code>, <code>map</code>, <code>flatMap</code>, <code>fold</code>, etc. But there is no concept of, for example, “mappable” or “foldable”. Nor is there a way of defining such a concept and applying it to existing types to allow you to write generic functions over unrelated types. Kotlin doesn’t have <a href="https://en.wikipedia.org/wiki/Kind_(type_theory)">higher kinded types</a> that would let you express this kind of generic function or <a href="https://en.wikipedia.org/wiki/Type_class">type classes</a> that would let you add polymorphism without modifying existing type definitions.</p>
<p>Compared to <a href="https://doc.rust-lang.org/book/traits.html">Rust’s traits</a>, which support extension methods, operator overloading, type classes for parametric polymorphism, <em>and</em> interfaces for subtype polymorphism, Kotlin’s monomorphic extension methods and operator overloading are quite limited and do not help refactor duplicated logic.</p>
<p>However, for typical monomorphic, procedural Java code this is probably not an issue.</p>
<h3>Optionality is a Special Case</h3>
<p>Kotlin’s support for nullable types is implemented by a special case in the type system and special case operators that only apply to nullable references. The operators do not desugar to methods that can be implemented for other types. For example, <code>optionalThing?.foo</code> can be considered a map of the function <code>{thing -> thing.foo}</code> over the option <code>optionalThing</code>. If <code>foo</code> itself is nullable, then it can be considered a flatMap. But the expressions do not desugar to <code>map</code> and <code>flatMap</code> And if you want to map or flatMap a function, you have to use a different syntax: <code>optionalThing?.let(theFunction)</code>.</p>
<p>For typical Java code, which is monomorphic and uses null references with wild abandon, language support for nullability is invaluable. But I would find it more convenient if it could be used polymorphically, or if Kotlin used a common naming convention for optional and other functor types.</p>
<p>Null safety is not enforced when you interop with Java code. And you do that a lot. Kotlin doesn’t have many libraries or much of a runtime and makes it easy to call existing Java libraries directly. Kotlin expects you to know what you’re doing with respect to null references when calling Java code, and doesn’t force you to treat every value returned from Java as nullable. As a result, null safety is a bit of an illusion in a lot of our Kotlin code and it has come back to bite us.</p>
<h2>Conclusion</h2>
<p>The code we’ve been writing has been a mix of coordinating and piping data between existing Java libraries – Apache HTTP client, Undertow HTTP server, JDBC, Sesame, JSON and XML parsers, and so on – and algorithmic code that analyses human readable text. For that kind of work, Kotlin has been very useful. The Kotlin code is far more concise than the equivalent Java. In our domain models and algorithmic code, Kotlin’s type safety and especially null safety, has been a big help.</p>
<p>Exactly how happy we’ve been with Kotlin has depended on the design style of the code we’re writing:</p>
<p>For functional programming, Kotlin has occasionally been frustrating, because we cannot use parametric polymorphism to factor out duplicated logic as much as we’d like.</p>
<p>For object-oriented programming, Kotlin’s concise syntax for class definitions and <a href="https://kotlinlang.org/docs/reference/delegation.html">language support for delegation</a> avoids a lot of Java’s boilerplate.</p>
<p>However, most Java out there is monomorphic, procedural code moving data between “<a href="http://puttingtheteaintoteam.blogspot.co.uk/2008/10/is-that-pojo-or-nojo.html">NOJOs</a>” and APIs that expect objects to have “bean” getters and setters. Kotlin has made working with that kind of API much easier and far more concise than doing so in Java.</p>
<ol>
<li>As far as I can tell, RedHat sponsor development of Ceylon but do not actually use it to develop their own products. If I’m wrong, please let me know in the comments.<a href="#fnref1">↩</a></li>
</ol>
]]></description><link>http://natpryce.com/articles/000815.html</link><guid isPermaLink="true">http://natpryce.com/articles/000815.html</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Nat Pryce]]></dc:creator><pubDate>Wed, 30 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[Kotlin for Java Developers: 10 Features You Will Love About Kotlin]]></title><description><![CDATA[<h1>Kotlin for Java Developers: 10 Features You Will Love About Kotlin</h1>
<p>Kotlin is a statically typed JVM language built by Jetbrains, the makers of the IntelliJ IDE. <a href="https://kotlinlang.org/">Kotlin</a> is built upon Java and provides useful features such as null-safety, data classes, extensions, functional concepts, smart casts, operator overloading and more.</p>
<p>This crash course into Kotlin for Java developers demonstrates the most important advantages that Kotlin has over Java and compares some of the language concepts. You can skim the code snippets and boldly marked parts for a quick overview but I recommend you read the whole article (even though it is rather long).</p>
<h2>Contents</h2>
<ol>
<li>Why Would I Care About Kotlin?</li>
<li>Null Safety</li>
<li>Data Classes</li>
<li>Extension Functions</li>
<li>Smart Casts</li>
<li>Type Inference</li>
<li>Functional Programming</li>
<li>Objects (aka Easily Create Singletons)</li>
<li>Default Arguments</li>
<li>Named Arguments</li>
<li>Bonus: Enforcing Best Practices</li>
<li>What Now?</li>
</ol>
<h2>Why Would I Care About Kotlin?</h2>
<p>What made me particularly interested in Kotlin is the fact that it is <strong>uber-interoperable with Java</strong> and is backed up by Jetbrains and their popular Java IDE IntelliJ. Why did that make me more interested in Kotlin you ask?</p>
<p>Well, interoperability with Java is majorly important because Java has been one of the <a href="http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html">most widely used programming language</a> for quite a while now. From a business perspective, this means that most real-world code is written in Java and that companies want to maintain their Java code base as long as possible — typically, the value of the legacy code is in the millions.</p>
<p><strong>With Kotlin, organizations have the chance to try out a new programming language with minimal risk.</strong> Java files can be converted to equivalent Kotlin files which can then be worked on. Similarly, all types defined in Kotlin (like classes and enums) can be used from within Java just like any other Java type. From a developer point of view, it is great to be able to use the Java libraries that you are used to. You can use Java IO, JavaFX, Apache Commons, Guava and all your own classes right from Kotlin.</p>
<p>Also, hyperbolically, <strong>a programming language is only as good as its tool support</strong>. This is why the second point speaking in favor of Kotlin for me was that IntelliJ provides built-in language support. It also contains the aforementioned Java-to-Kotlin converter and code generators for Java and JavaScript from Kotlin code.</p>
<p>These two points also separate Kotlin from other JVM languages such as Scala, Ceylon, Clojure or Groovy.</p>
<p><strong>Alright, enough talk.</strong> Let’s jump into the actual language features of Kotlin.</p>
<h2>1) Null Safety</h2>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>{
    <span class="hljs-keyword">val</span> givenName: String = <span class="hljs-string">""</span>
    <span class="hljs-keyword">val</span> familyName: String = <span class="hljs-string">""</span>
    <span class="hljs-keyword">val</span> address: Address? = <span class="hljs-literal">null</span>
}</code></pre>
<p>In this example, givenName and familyName cannot be null — the program would <strong>fail at compile-time</strong>. You must explicitly make a variable nullable to be able to assign null to it. This is done via the “?” after the variable type. So the address property may be null in the given code.</p>
<p>Kotlin also fails at compile-time whenever a NullPointerException may be thrown at run-time — that is, when you try to call a method or reference a property from a nullable type:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> givenName: String? = <span class="hljs-literal">null</span>
<span class="hljs-keyword">val</span> len = givenName.length</code></pre>
<p>If you try to compile this, the Kotlin compiler will give you an error: “Only safe (?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type kotlin.String?”. We’ll see how to handle these cases where you <em>know</em> the variable <em>cannot</em> be null in a second.</p>
<p>So far so good, but what are those safe and non-null asserted calls the compiler is talking about? <strong>Safe calls simply return the value of the call as normally if the callee is not null, and return null otherwise:</strong></p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> givenName: String? = <span class="hljs-string">""</span>
<span class="hljs-keyword">val</span> len = givenName?.length</code></pre>
<p>In this case, len will be zero as expected. If givenName was null, len would also be assigned null. Thus the return type of givenName?.length is Int?, a nullable integer.</p>
<p>With non-null asserted calls, you assert to the compiler that you <em>know</em> the variable <em>cannot</em> be null at run-time at the position you use it:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> givenName: String? = <span class="hljs-string">"Roger"</span>
<span class="hljs-keyword">val</span> len = givenName!!.length</code></pre>
<p>To work with nullable types effectively, the <strong>Elvis operator</strong> comes in handy. It allows you to use a nullable if it is not null and a default value otherwise:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> text: String? = <span class="hljs-literal">null</span>
<span class="hljs-keyword">val</span> len = text?.length ?: <span class="hljs-number">-1</span></code></pre>
<p>In this example, len will be -1 because the nullable text is in fact null so that the defined default value is used. You may have noticed that this is basically just the widely known <em>ternary operator</em> where the first operand is equal to the expression itself:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> len = text?.length ?: <span class="hljs-number">-1</span>
<span class="hljs-keyword">val</span> len = text?.length ? text?.length : <span class="hljs-number">-1</span></code></pre>
<p>These two lines are semantically the same.</p>
<h2>2) Data Classes</h2>
<p>For simple classes which mainly hold data, you can avoid a lot of boilerplate compared to Java code. Consider the following <strong>typical data class in Java:</strong></p>
<pre><code class="hljs language-java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> </span>{
    <span class="hljs-keyword">private</span> String title;
    <span class="hljs-keyword">private</span> Author author;

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getTitle</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> title;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTitle</span><span class="hljs-params">(String title)</span> </span>{
        <span class="hljs-keyword">this</span>.title = title;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> Author <span class="hljs-title">getAuthor</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> author;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAuthor</span><span class="hljs-params">(Author author)</span> </span>{
        <span class="hljs-keyword">this</span>.author = author;
    }
}</code></pre>
<p>Lots of boilerplate code that you’ll skip when trying to find out what the class really does. <strong>In Kotlin, you can define the same class concisely in one line:</strong></p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span></span>(<span class="hljs-keyword">var</span> title: String, <span class="hljs-keyword">var</span> author: Author)</code></pre>
<p>Kotlin will also <strong>generate useful hashCode(), equals(), and toString()</strong> implementations. Printing a book will create an output like Book(title=Effective Java, author=Author(name=Joshua Bloch)).</p>
<p><strong>Challenge</strong>: <a href="http://try.kotlinlang.org/">Write an Author class</a> that will lead to an output like this!</p>
<p>Not only that, it will also allow you to <strong>easily make copies of data classes:</strong></p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> book = Book(<span class="hljs-string">"Effective Java"</span>, Author(<span class="hljs-string">"Joshua Bloch"</span>))
<span class="hljs-keyword">val</span> copy = book.copy()
<span class="hljs-keyword">val</span> puzzlers = book.copy(title = <span class="hljs-string">"Java Puzzlers"</span>)
<span class="hljs-keyword">val</span> gof = book.copy(title = <span class="hljs-string">"Design Patterns"</span>, author = Author(<span class="hljs-string">"Gang of Four"</span>))</code></pre>
<p>You can change arbitrary properties of the copied object by adding named parameters to the copy() method.</p>
<p>One more goody is the possibility to use <strong>destructuring declarations</strong> on data classes, retrieving the respective property values:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> book = Book(<span class="hljs-string">"The Phoenix Project"</span>, Author(<span class="hljs-string">"Kevin Behr"</span>))
<span class="hljs-keyword">val</span> (title, author) = book</code></pre>
<h2>3) Extension Functions</h2>
<p>Kotlin allows us to <strong>extend the functionality of existing classes without inheriting from them</strong>. This is enabled by extension functions and extension properties. Let’s say you want to extend the GridPane class from the JavaFX GUI framework with a method to retrieve the elements in row i and column j:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> GridPane.<span class="hljs-title">getElementAt</span><span class="hljs-params">(rowIndex: <span class="hljs-type">Int</span>, columnIndex: <span class="hljs-type">Int</span>)</span></span>: Node? {
    <span class="hljs-keyword">this</span>.children.forEach {
        <span class="hljs-keyword">if</span> (GridPane.getColumnIndex(it) == columnIndex &#x26;&#x26; GridPane.getRowIndex(it) == rowIndex) {
            <span class="hljs-keyword">return</span> it;
        }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}</code></pre>
<p>There are several things to mention here. First, inside the extension function you can refer to the object on which it was called using “this”. Second, you use Kotlin’s forEach() function on the list of child nodes. This is equivalent to the forEach() method included in Java 8 and allows some functional-style programming. Third, inside the forEach(), you can refer to the current element using the implicit loop variable “it”.</p>
<p>Note that the return type comes after the parentheses containing the parameters and is a nullable Node since the method may return null.</p>
<p><strong>There’s one thing to be aware of:</strong> If you try to call an extension function with the arguments that are also applicable for an existing member function inside the class, the member will always “win” — meaning that it will take precedence and overshadow your extension function.</p>
<h2>4) Smart Casts</h2>
<p>How often have you already cast objects where it was actually redundant? More often than you can count I bet, like this:</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> Leaf) {
    <span class="hljs-keyword">return</span> ((Leaf) node).symbol;
}</code></pre>
<p>The Kotlin compiler on the other hand is really intelligent when it comes to casts. Meaning: <strong>it will handle all those redundant casts for you</strong>. This is called <strong>smart casts</strong>.</p>
<p>The equivalent Kotlin code for the code snippet above looks like this:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">if</span> (node <span class="hljs-keyword">is</span> Leaf) {
    <span class="hljs-keyword">return</span> node.symbol;
}</code></pre>
<p>The instanceof operator in Kotlin is called “is”. And, more importantly, there is no need to clutter your code with casts that the compiler can actually take care of.</p>
<p>Now this goes much further than just this simple case:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">if</span> (person !<span class="hljs-keyword">is</span> Student)
    <span class="hljs-keyword">return</span>

person.immatriculationNumber</code></pre>
<p>In this case, if person were not a student, the control flow would never reach line 4. Accordingly, the Kotlin compiler knows that person must be Student object and performs a smart cast.</p>
<p>Let’s look at some <strong>lazily evaluated conditional expressions</strong>:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">if</span> (document <span class="hljs-keyword">is</span> Payable &#x26;&#x26; document.pay()) {  <span class="hljs-comment">// Smart cast</span>
    println(<span class="hljs-string">"Payable document <span class="hljs-subst">${document.title}</span> was payed for."</span>)
}</code></pre>
<p>Conditionals like these use lazy evaluation in Kotlin, just like in Java. So if the document were not a Payable, the second part would not be evaluated in the first place. Hence, if evaluated, Kotlin knows that document is a Payable and uses a smart cast.</p>
<p>The same goes for disjunction:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">if</span> (document !<span class="hljs-keyword">is</span> Payable || document.pay() == <span class="hljs-literal">false</span>) {  <span class="hljs-comment">// Smart cast</span>
    println(<span class="hljs-string">"Cannot pay document <span class="hljs-subst">${document.title}</span>."</span>)
}</code></pre>
<p>When expressions are another place where Kotlin will apply smart casts wherever possible:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> result = <span class="hljs-keyword">when</span> (expr) {
    <span class="hljs-keyword">is</span> Expr.Number      -> expr.value
    <span class="hljs-keyword">is</span> Expr.Sum         -> expr.first + expr.second
    <span class="hljs-keyword">is</span> Expr.Difference  -> expr.first - expr.second
    <span class="hljs-keyword">is</span> Expr.Exp         -> Math.pow(expr.base, expr.exponent)
}</code></pre>
<p>Depending on the type of the object, you can simply use the respective properties in each when block.</p>
<p>Note: For the example above, the Expr class must be a sealed class with only these exact four subclasses.</p>
<h2>5) Type Inference</h2>
<p><strong>In Kotlin, you don’t have to specify the type of each variable explicitly, even though Kotlin <em>is</em> strongly typed</strong>. You can choose to explicitly define a data type, for example if you don’t want a small integer to be stored in an Int variables but rather a Short or even a Byte. You can do that using the colon notation where the data type stands behind the variable name:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> list: Iterable&#x3C;<span class="hljs-built_in">Double</span>> = arrayListOf(<span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">3.1415</span>, <span class="hljs-number">2.718</span>)  <span class="hljs-comment">// Only need Iterable interface</span>

<span class="hljs-keyword">val</span> arrayList = arrayListOf(<span class="hljs-string">"Kotlin"</span>, <span class="hljs-string">"Scala"</span>, <span class="hljs-string">"Groovy"</span>)  <span class="hljs-comment">// Type is ArrayList</span></code></pre>
<p>You can choose to use explicit types as in Java but you’re also free to write more concise Python-like variable declarations. Explicit types are useful to reference the most general interface (which you should always do).</p>
<h2>6) Functional Programming</h2>
<p>While Java evolved to incorporate several functional programming concepts since Java 8, Kotlin has functional programming baked right in. This includes <strong>higher-order functions, lambda expressions, operator overloading, lazy evaluation</strong> and lots of useful methods to work with collections.</p>
<p>The combination of lambda expressions and the Kotlin library really makes your day easier when working with collections:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> numbers = arrayListOf(<span class="hljs-number">-42</span>, <span class="hljs-number">17</span>, <span class="hljs-number">13</span>, <span class="hljs-number">-9</span>, <span class="hljs-number">12</span>)
<span class="hljs-keyword">val</span> nonNegative = numbers.filter { it >= <span class="hljs-number">0</span> }
println(nonNegative)</code></pre>
<p>Note that, when using lambda expressions with a single argument, Kotlin creates an implicit variable called “it” which refers to the lambda expression’s only argument. So the second line above is equivalent to:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> nonNegative = numbers.filter { it -> it >= <span class="hljs-number">0</span> }</code></pre>
<p>Kotlin provides all essential functional facilities such as <strong>filter, map &#x26; flatMap, take &#x26; drop, first &#x26; last, fold &#x26; foldRight, forEach, </strong>reduce<em>,</em> and anything else the pragmatic functional programmer’s heart longs for:</p>
<pre><code class="hljs language-kotlin">println(numbers.take(<span class="hljs-number">2</span>))  <span class="hljs-comment">// First two elements: [-42, 17]</span>

println(numbers.drop(<span class="hljs-number">2</span>))  <span class="hljs-comment">// List without first two elements: [13, -9, 12]</span>

println(numbers.foldRight(<span class="hljs-number">0</span>, { a, b -> a + b }))  <span class="hljs-comment">// Sum of all elements: -9</span>

numbers.forEach { print(<span class="hljs-string">"<span class="hljs-subst">${it * <span class="hljs-number">2</span>}</span> "</span>) }  <span class="hljs-comment">// -84 34 26 -18 24</span>

---

<span class="hljs-keyword">val</span> genres = listOf(<span class="hljs-string">"Action"</span>, <span class="hljs-string">"Comedy"</span>, <span class="hljs-string">"Thriller"</span>)
<span class="hljs-keyword">val</span> myKindOfMovies: Iterable&#x3C;String> = genres.filter { it.length &#x3C;= <span class="hljs-number">6</span> }.map { it + <span class="hljs-string">" Movie"</span> }
println(myKindOfMovies)  <span class="hljs-comment">// [Action Movie, Comedy Movie]</span></code></pre>
<h2>7) Objects (aka Easily Create Singletons)</h2>
<p>Kotlin has a keyword called <em>object</em> which allows us to define an object, similar to a class. But of course, that object then only exists as a <strong>single instance</strong>. <strong>This is a useful way to create singletons</strong> but the feature is not restricted to only singletons.</p>
<p>Creating an object is as simple as this:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">object</span> CardFactory {

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getCard</span><span class="hljs-params">()</span></span>: Card {
        <span class="hljs-comment">// ...</span>
    }
}</code></pre>
<p>And you can then use that object like a class with static members:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&#x3C;<span class="hljs-type">String</span>>)</span></span> {
    <span class="hljs-keyword">val</span> card = CardFactory.getCard()
}</code></pre>
<p>You can even <strong>let your objects have superclasses</strong>:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">object</span> SubmitButtonListener : ActionListener {

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">actionPerformed</span><span class="hljs-params">(e: <span class="hljs-type">ActionEvent</span>?)</span></span> {
        <span class="hljs-comment">// Submit form...</span>
    }
}</code></pre>
<p>This concept is a powerful extension to the classes, interfaces &#x26; enums available in Java because oftentimes, elements of the domain model are inherently objects (they exist only once and thus should always have at most instance at runtime).</p>
<h2>8) Default Arguments</h2>
<p>Default arguments are a feature I’m dearly missing in Java because it’s just so convenient, makes your code more concise, more expressive, more maintainable, more readable, more everything-that’s-good.</p>
<p>In Java, you often have to duplicate code in order <strong>define different variants of a method or constructor</strong>. Take a look at this:</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NutritionFacts</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String foodName;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> calories;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> protein;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> carbohydrates;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> fat;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String description;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NutritionFacts</span><span class="hljs-params">(String foodName, <span class="hljs-keyword">int</span> calories)</span> </span>{
        <span class="hljs-keyword">this</span>.foodName = foodName;
        <span class="hljs-keyword">this</span>.calories = calories;
        <span class="hljs-keyword">this</span>.protein = -<span class="hljs-number">1</span>;
        <span class="hljs-keyword">this</span>.carbohydrates = -<span class="hljs-number">1</span>;
        <span class="hljs-keyword">this</span>.fat = -<span class="hljs-number">1</span>;
        <span class="hljs-keyword">this</span>.description = <span class="hljs-string">""</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NutritionFacts</span><span class="hljs-params">(String foodName, <span class="hljs-keyword">int</span> calories, <span class="hljs-keyword">int</span> protein, <span class="hljs-keyword">int</span> carbohydrates, <span class="hljs-keyword">int</span> fat)</span> </span>{
        <span class="hljs-keyword">this</span>.foodName = foodName;
        <span class="hljs-keyword">this</span>.calories = calories;
        <span class="hljs-keyword">this</span>.protein = protein;
        <span class="hljs-keyword">this</span>.carbohydrates = carbohydrates;
        <span class="hljs-keyword">this</span>.fat = fat;
        <span class="hljs-keyword">this</span>.description = <span class="hljs-string">""</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NutritionFacts</span><span class="hljs-params">(String foodName, <span class="hljs-keyword">int</span> calories, <span class="hljs-keyword">int</span> protein, <span class="hljs-keyword">int</span> carbohydrates, <span class="hljs-keyword">int</span> fat, String description)</span> </span>{
        <span class="hljs-keyword">this</span>.foodName = foodName;
        <span class="hljs-keyword">this</span>.calories = calories;
        <span class="hljs-keyword">this</span>.protein = protein;
        <span class="hljs-keyword">this</span>.carbohydrates = carbohydrates;
        <span class="hljs-keyword">this</span>.fat = fat;
        <span class="hljs-keyword">this</span>.description = description;
    }
}</code></pre>
<p>Ugh, pretty bad. But it gets even worse if you want to provide more different constructors or add more possible attributes.</p>
<p>The example above demonstrate the so-called <em>telescoping anti-pattern</em> prevalent in Java. You can improve this design by using the Builder pattern instead.</p>
<p>But with Kotlin, you can do this even easier using default values for arguments:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NutritionFacts</span></span>(<span class="hljs-keyword">val</span> foodName: String,
                     <span class="hljs-keyword">val</span> calories: <span class="hljs-built_in">Int</span>,
                     <span class="hljs-keyword">val</span> protein: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span>,
                     <span class="hljs-keyword">val</span> carbohydrates: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span>,
                     <span class="hljs-keyword">val</span> fat: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span>,
                     <span class="hljs-keyword">val</span> description: String = <span class="hljs-string">""</span>) {
}</code></pre>
<p>This makes each of the parameters with a default value an <em>optional parameter</em>. And it actually gives you many more possibilities to invoke the constructor than the Java class above:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> pizza = NutritionFacts(<span class="hljs-string">"Pizza"</span>, <span class="hljs-number">442</span>, <span class="hljs-number">12</span>, <span class="hljs-number">27</span>, <span class="hljs-number">24</span>, <span class="hljs-string">"Developer's best friend"</span>)
<span class="hljs-keyword">val</span> pasta = NutritionFacts(<span class="hljs-string">"Pasta"</span>, <span class="hljs-number">371</span>, <span class="hljs-number">14</span>, <span class="hljs-number">25</span>, <span class="hljs-number">11</span>)
<span class="hljs-keyword">val</span> noodleSoup = NutritionFacts(<span class="hljs-string">"Noodle Soup"</span>, <span class="hljs-number">210</span>)</code></pre>
<p>Note that you may also want to make this sort of class a <em>data class</em> to have methods like equals() and toString() generated for you.</p>
<p><strong>In short: You get more for less. And keep your code clean at the same time.</strong></p>
<h2>9) Named Arguments</h2>
<p>Default arguments become even more powerful in combination with named arguments:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> burger = NutritionFacts(<span class="hljs-string">"Hamburger"</span>, calories = <span class="hljs-number">541</span>, fat = <span class="hljs-number">33</span>, protein = <span class="hljs-number">14</span>)
<span class="hljs-keyword">val</span> rice = NutritionFacts(<span class="hljs-string">"Rice"</span>, <span class="hljs-number">312</span>, carbohydrates = <span class="hljs-number">23</span>, description = <span class="hljs-string">"Tasty, nutritious grains"</span>)</code></pre>
<p><strong>Anyone reading the code knows what’s going on</strong> without having to look at what the parameters mean. This increases readability and can make you more productive when used correctly. For example, this is especially useful when you have several boolean parameters like this:</p>
<pre><code class="hljs language-kotlin">myString.transform(<span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>)</code></pre>
<p>Unless you’ve implemented that function 10 seconds ago, there’s no way you know what’s going on here (there’s no guarantee you know even <em>if</em> you’ve implemented it 10 seconds ago).</p>
<p>Make your life (and that of your fellow developers) easier by using named arguments:</p>
<pre><code class="hljs language-kotlin">myString.transform(
    toLowerCase = <span class="hljs-literal">true</span>,
    toUpperCase = <span class="hljs-literal">false</span>,
    toCamelCase = <span class="hljs-literal">false</span>,
    ellipse = <span class="hljs-literal">true</span>,
    normalizeSpacing = <span class="hljs-literal">false</span>
)</code></pre>
<h2>10) Bonus: Enforcing Best Practices</h2>
<p>Generally, Kotlin enforces many of the best practices you should follow when using Java. You can read about them in Josh Bloch’s book <a href="http://www.oracle.com/technetwork/java/effectivejava-136174.html">“Effective Java”</a>.</p>
<p>First of all, the use of <strong>val vs. var</strong> promotes making every variable final that is not supposed to change — while also providing a more concise syntax for it. This is useful when creating immutable objects for example.</p>
<p>This way, beginners learning the language will also learn to follow this practice right from the start because you tend to think about whether to use <strong>val</strong> or <strong>var</strong> each time and learn to prefer val to var when possible.</p>
<p>Next, Kotlin also supports the principle to either design for inheritance or prohibit it — because in Kotlin, you have to explicitly declare a class as <strong>open</strong> in order to inherit from it. That way, you have to remember to <em>allow</em> inheritance instead of having to remember to <em>disallow</em> it.</p>
<h2>What Now?</h2>
<p><strong>If this overview made you curious</strong> to learn more about Kotlin, you can <a href="http://petersommerhoff.com/dev/kotlin/kotlin-beginner-tutorial/">check out my 10 beginner tutorial videos for Kotlin</a> or <strong><a href="https://www.udemy.com/kotlin-course/?couponCode=READERSONLY9USD">go straight to the full course</a> (with 95% reader discount)</strong>.</p>
<p><strong>The course is beginner-friendly and starts completely from scratch.</strong> If you already know Java or a comparable language, you’ll still find it a valuable resource to get to know Kotlin.</p>
]]></description><link>http://petersommerhoff.com/dev/kotlin/kotlin-for-java-devs/</link><guid isPermaLink="true">http://petersommerhoff.com/dev/kotlin/kotlin-for-java-devs/</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Peter Sommerhoff]]></dc:creator><pubDate>Sat, 12 Dec 2015 10:06:00 GMT</pubDate></item><item><title><![CDATA[Setting up Kotlin with Android and tests]]></title><description><![CDATA[<p>I recently heard about <a href="https://kotlinlang.org/">Kotlin</a> with the release of their 1.0 Beta last week. Kotlin is a modern programming language that runs in the JVM and is interoperable with Java. Kotlin can also be used to create Android apps.</p>
<p>I was curious, so I decided to set up a small Android app using Kotlin and try out some different methods of testing.</p>
<h2>Setting up the app</h2>
<p>Setting up a hello word Android app in Kotlin was actually quite easy!  The Kotlin plugin for IntelliJ / Android Studo has a tool for converting your Java code to Kotlin, so you can get started really quickly! I was able to follow this <a href="https://kotlinlang.org/docs/tutorials/kotlin-android.html">tutorial</a> to get my Android app set up.</p>
<p>Two points to watch out for:</p>
<ol>
<li>
<p>Make sure you have installed the Kotlin plugins in Android Studio before you start</p>
</li>
<li>
<p>I had to highlight the text of my java file before selecting "Convert Java File to Kotlin File" in order to get the converter to work.</p>
</li>
</ol>
<h2>Android instrumentation tests</h2>
<p>I started by writing a simple Android Instrumentation test in Java (you can freely mix Java files and Kotlin files in your project and it seems to work fine).  Once that was working, I converted it to Kotlin:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivityTest</span> : <span class="hljs-type">ActivityInstrumentationTestCase2</span>&#x3C;<span class="hljs-type">MainActivity</span>></span>(MainActivity::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>) </span>{
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> mainActivity: Activity? = <span class="hljs-literal">null</span>

   <span class="hljs-meta">@Throws(Exception::class)</span>
   <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span></span> {
       <span class="hljs-keyword">super</span>.setUp()
       mainActivity = activity
   }

   <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test_itDisplaysHelloWorld</span><span class="hljs-params">()</span></span> {
       <span class="hljs-keyword">val</span> textView = mainActivity!!.findViewById(R.id.main_text) <span class="hljs-keyword">as</span> TextView
       <span class="hljs-keyword">val</span> actual = textView.text.toString()
       Assert.assertEquals(<span class="hljs-string">"Hello World!"</span>, actual)
   }
}</code></pre>
<p>The only trouble I had was that after I converted the file, the Android Studio test runner configuration was broken.  To fix it I had to edit my run configuration in Android Studio by navigating to <code>Run -> Edit Configurations -> Android Tests</code> and setting the instrumentation runner to <code>android.test.InstrumentationTestRunner</code>.  After that, lo and behold, the test worked fine in Kotlin!</p>
<h2>Robolectric tests</h2>
<p>After my resounding success at getting the Android Instrumentation Tests to work, I decided to try my luck at Robolectric.  It turns out, Robolectric pretty much Just Worked too.  Here's a Robolectric test written in Kotlin, equivalent to the instrumentation test above:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@RunWith(RobolectricGradleTestRunner::class)</span>
<span class="hljs-meta">@Config(constants = BuildConfig::class)</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleRobolectricTest</span> </span>{

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">itShouldDisplayHelloWorld</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">val</span> activity = Robolectric.setupActivity(MainActivity::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>)</span>
        <span class="hljs-keyword">val</span> textView = activity.findViewById(R.id.main_text) <span class="hljs-keyword">as</span> TextView

        assertThat(textView.text).isEqualTo(<span class="hljs-string">"Hello World!"</span>)
    }
}</code></pre>
<h2>Unit tests with Spek</h2>
<p><a href="https://jetbrains.github.io/spek/">Spek</a> is a testing framwork written in Kotlin with a pretty, rspec-like syntax. I would love to be able to write my Android tests using something like Spek, so I decided to try!</p>
<h3>Bad news #1: Android Instrumentation tests + Spek</h3>
<p>Spek requires your tests to inherit from a base class called <code>Spek</code>.  Android instrumentation tests require your tests to inherit from <code>InstrumentationTestCase</code>.  As far as I can tell, this is a deal-breaker for using the two systems together, for the moment.</p>
<h3>Bad news #2: Robolectric tests + Spek</h3>
<p>Robolectric doesn't specifically require your tests to inherit from any particular class, which theoretically opens the door to using it together with Spek.  However, naively combining them doesn't work as expected, as the test runner cannot find any tests.  I think the reason for this is that Robolectric relies on using the RobolectricTestRunner, which extends the <code>BlockJUnit4ClassRunner</code> (which identifies tests based on annotations), while Spek runs with it's own <code>JUnitClassRunner</code>.</p>
<p>In the future I may look into writing a RobolectricSpek test runner, but for now, it looks like these two systems do not play nicely together.</p>
<h3>Finally, the good news</h3>
<p>Although Spek does not seem to be compatible with either Robolectric or Android instrumentation tests, it actually works fine as a replacement for vanilla JUnit tests.  I think this kind of test is of dubious utility in a typical Android project, since there's usually not a lot of code that can be tested purely with JUnit, but if you have these kinds of tests, you could easily convert them to use Spek.  Here's a sample test I wrote in my hello world app:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">import</span> org.jetbrains.spek.api.Spek
<span class="hljs-keyword">import</span> kotlin.test.assertEquals

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleUnitTest</span> : <span class="hljs-type">Spek</span></span>() {
    init {
        given(<span class="hljs-string">"Two numbers"</span>) {
            <span class="hljs-keyword">val</span> firstNumber = <span class="hljs-number">3</span>
            <span class="hljs-keyword">val</span> secondNumber = <span class="hljs-number">5</span>
            on(<span class="hljs-string">"adding the numbers"</span>) {
                <span class="hljs-keyword">val</span> result = firstNumber + secondNumber
                it(<span class="hljs-string">"should return the correct sum"</span>) {
                    assertEquals(<span class="hljs-number">8</span>, result)
                }
            }
        }
    }
}</code></pre>
<h2>Conclusion</h2>
<p>Kotlin seems like a promising new language with a lot of features that make it nicer to use than Java.  Setting up a "Hello World" Android app was extremely simple, and getting tests to run with Robolectric or the Android instrumentation runner was no problem.  I look forward to trying it out more in the future!</p>
]]></description><link>http://engineering.pivotal.io/post/setting-up-kotlin-with-android-and-tests/</link><guid isPermaLink="true">http://engineering.pivotal.io/post/setting-up-kotlin-with-android-and-tests/</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Android]]></category><dc:creator><![CDATA[Laura Kogler]]></dc:creator><pubDate>Wed, 11 Nov 2015 14:39:00 GMT</pubDate></item><item><title><![CDATA[Functional Programming with Kotlin]]></title><description><![CDATA[<p>The recording of our October 22nd webinar, <strong>Functional Programming with Kotlin</strong>, is now available on <a href="https://youtu.be/AhA-Q7MOre0">JetBrainsTV YouTube channel</a>.</p>
<p>In this talk, Mike Hearn provides a brief introduction to programming in Kotlin via practical example: creating a textfield with the autocomplete suggestions while typing. Demo project is available on <a href="https://github.com/mikehearn/KotlinFPWebinar">GitHub</a>.</p>
<p>Topics covered include:</p>
<ul>
<li>Use of functional transforms</li>
<li>Immutability</li>
<li>Lazyness and working with lazy infinite sequences</li>
<li>The use of <a href="https://github.com/MarioAriasC/funKTionale">funKTionale</a>, a library that extends Kotlin with a few features known from Haskell</li>
<li>Pattern matching</li>
<li>Reactive user interfaces</li>
</ul>
<iframe src="https://www.youtube.com/embed/AhA-Q7MOre0" allowfullscreen="" height="480" frameborder="0" width="960"></iframe>
<p>The video includes the time stamps following the <a href="http://blog.jetbrains.com/kotlin/2015/10/join-live-webinar-functional-programming-with-kotlin/">agenda announced</a>:</p>
<ul>
<li><code>00:08</code> — Intoduction and demo application</li>
<li><code>05:00</code> — <code>apply</code> function</li>
<li><code>05:45</code> — Introduce NGram data class</li>
<li><code>08:22</code> — Creating extension methods</li>
<li><code>09:55</code> — Working with lazy infinite sequences</li>
<li><code>10:35</code> — <code>map</code> function</li>
<li><code>11:10</code> — <code>to</code> function and infix notation</li>
<li><code>14:35</code> — Destructuring of data classes</li>
<li><code>19:20</code> — <code>filter</code>, <code>let</code> and <code>all</code> functions</li>
<li><code>23:00</code> — Debug lazy code</li>
<li><code>24:20</code> — Add completions to UI</li>
<li><code>25:18</code> — Load data in a functional way</li>
<li><code>28:30</code> — Improve performance of the data loading</li>
<li><code>33:20</code> — Improve the UI responsiveness in RX style</li>
<li><code>40:05</code> — Using <a href="https://github.com/mplatvoet/kovenant">Kovenant</a> library</li>
<li><code>42:03</code> — Using <a href="https://github.com/MarioAriasC/funKTionale">funKTionale</a> library</li>
<li><code>44:10</code> — Currying</li>
<li><code>45:35</code> — Questions</li>
</ul>
<p>About the Presenter:</p>
<p><img src="http://i2.wp.com/info.jetbrains.com/rs/426-QVD-114/images/Mike_Hearn_200x200.jpg?resize=100%252C100" alt="Mike Hearn" title="Mike Hearn"> <a href="http://plan99.net/~mike/">Mike Hearn</a> is a Java, Kotlin and C++ developer who works on digital currency related software. Prior to that he was a senior software engineer at Google, where he spent over seven years working on a range of products including Earth, Maps, Gmail and the accounts system.</p>
<p>Thanks to all the attendees for the questions! If you still have some, please, contact Mike or our team.</p>
<p>You are welcome to suggest themes for future webinars in comments.</p>
<p><em>Let’s kotlin!</em></p>
]]></description><link>http://blog.jetbrains.com/kotlin/2015/11/webinar-recording-functional-programming-with-kotlin/</link><guid isPermaLink="true">http://blog.jetbrains.com/kotlin/2015/11/webinar-recording-functional-programming-with-kotlin/</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Fp]]></category><category><![CDATA[Functional]]></category><category><![CDATA[Webinar]]></category><dc:creator><![CDATA[Roman Belov]]></dc:creator><pubDate>Thu, 05 Nov 2015 09:21:00 GMT</pubDate></item><item><title><![CDATA[Exploring the Kotlin standard library]]></title><description><![CDATA[<p><a href="https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/src/kotlin/util/Standard.kt">Standard.kt</a> is part of the Kotlin library and it defines some essential functions. What’s really striking about this source file is that it’s less than fifty lines long and that each of the function it defines (less than ten) is a one liner. Yet, each of these functions is very powerful. Here is a quick overview of the most important ones.</p>
<h2>let()</h2>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&#x3C;T, R></span> T.<span class="hljs-title">let</span><span class="hljs-params">(f: (<span class="hljs-type">T</span>)</span></span> -> R): R = f(<span class="hljs-keyword">this</span>)</code></pre>
<p><code>let()</code> is a scoping function: use it whenever you want to define a variable for a specific scope of your code but not beyond. It’s extremely useful to keep your code nicely self-contained so that you don’t have variables “leaking out”: being accessible past the point where they should be.</p>
<pre><code class="hljs language-kotlin">DbConnection.getConnection().let { connection ->
}
<span class="hljs-comment">// connection is no longer visible here</span></code></pre>
<p><code>let()</code> can also be used as an alternative to testing against null:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> map : Map&#x3C;String, Config> = ...
<span class="hljs-keyword">val</span> config = map[key]
<span class="hljs-comment">// config is a "Config?"</span>
config?.let {
    <span class="hljs-comment">// This whole block will not be executed if "config" is null.</span>
    <span class="hljs-comment">// Additionally, "it" has now been cast to a "Config" (no question mark)</span>
}</code></pre>
<h2>apply()</h2>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&#x3C;T></span> T.<span class="hljs-title">apply</span><span class="hljs-params">(f: <span class="hljs-type">T</span>.()</span></span> -> <span class="hljs-built_in">Unit</span>): T { f(); <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span> }</code></pre>
<p><code>apply()</code> defines an extension function on all types. When you invoke it, it calls the closure passed in parameter and then returns the receiver object that closure ran on. Sounds complicated? It’s actually very simple and extremely useful. Here is an example:</p>
<pre><code class="hljs language-kotlin">File(dir).apply { mkdirs() }</code></pre>
<p>This snippet turns a <code>String</code> into a <code>File</code> object, calls <code>mkdirs()</code> on it and then returns the file. The equivalent Java code is a bit verbose:</p>
<pre><code class="hljs language-java"><span class="hljs-function">File <span class="hljs-title">makeDir</span><span class="hljs-params">(String path)</span> </span>{
  File result = <span class="hljs-keyword">new</span> File(path);
  result.mkdirs();
  <span class="hljs-keyword">return</span> result;
}</code></pre>
<p><code>apply()</code> turns this kind of ubiquitous code into a one liner.</p>
<h2>with()</h2>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&#x3C;T, R></span> <span class="hljs-title">with</span><span class="hljs-params">(receiver: <span class="hljs-type">T</span>, f: <span class="hljs-type">T</span>.()</span></span> -> R): R = receiver.f()</code></pre>
<p><code>with()</code> is convenient when you find yourself having to call multiple different methods on the same object. Instead of repeating the variable containing this object on each line, you can instead “factor it out” with a with call:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> w = Window()
with(w) {
  setWidth(<span class="hljs-number">100</span>)
  setHeight(<span class="hljs-number">200</span>)
  setBackground(RED)
}</code></pre>
<h2>run()</h2>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&#x3C;T, R></span> T.<span class="hljs-title">run</span><span class="hljs-params">(f: <span class="hljs-type">T</span>.()</span></span> -> R): R = f()</code></pre>
<p><code>run()</code> is another interesting one liner from the standard library. Its definition is so simple that it looks almost useless but it’s actually a combination of <code>with()</code> and <code>let()</code>, which reinforces what I was saying earlier about the fact that because all these functions from the standard library are regular functions, they can be easily combined to create more powerful expressions.</p>
<h2>Tying it all together</h2>
<p>Of course, it’s actually possible (and encouraged) to combine these functions:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">configurationFor</span><span class="hljs-params">(id: <span class="hljs-type">String</span>)</span></span> = map[id]?.let { config ->
  config.apply {
    buildType = <span class="hljs-string">"DEBUG"</span>
    version = <span class="hljs-string">"1.2"</span>
  }
}</code></pre>
<p> This code looks up a Config object from an id and if one is found, sets a few additional properties on it and then returns it. But we can simplify this code even further. This time, I’m providing a fully self-contained snippet so you can copy and paste it directly into <a href="http://try.kotlinlang.org/">Try Kotlin</a> in order to run it yourself:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Config</span></span>(<span class="hljs-keyword">var</span> buildType: String, <span class="hljs-keyword">var</span> version: String)

<span class="hljs-keyword">val</span> map = hashMapOf&#x3C;String, Config>()

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">configurationFor</span><span class="hljs-params">(id: <span class="hljs-type">String</span>)</span></span> = map[id]?.let { config ->
    config.apply {
        buildType = <span class="hljs-string">"DEBUG"</span>
        version = <span class="hljs-string">"1.2"</span>
    }
}</code></pre>
<p>Don’t you feel that this combination of <code>let()</code> and <code>apply()</code> feels a bit boilerplatey? Let’s rewrite it a bit more idiomatically:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">configurationFor</span><span class="hljs-params">(id: <span class="hljs-type">String</span>)</span></span> = map[id]?.apply {
    buildType = <span class="hljs-string">"DEBUG"</span>
    version = <span class="hljs-string">"1.2"</span>
}</code></pre>
<p> Let’s unpack this rather dense snippet:</p>
<ul>
<li>Looking up a value on a hash map can be done either with <code>get()</code> or with the bracket notation, which is preferred.</li>
<li>Since the key might not be present in the map, we use the safe dereference operator <code>?.</code> which guarantees that we will only enter <code>apply()</code> if the result is non null.</li>
<li>Inside the <code>apply()</code> block, the this object is a <code>Config</code>, which lets us invoke functions on this object without any prefix. In this case, all we have is properties, but obviously, you could invoke regular functions just as well.</li>
<li>Once that code has run, the altered <code>Config</code> is returned.</li>
</ul>
<h2>use()</h2>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&#x3C;T : Closeable, R></span> T.<span class="hljs-title">use</span><span class="hljs-params">(block: (<span class="hljs-type">T</span>)</span></span> -> R): R</code></pre>
<p>Another interesting function of the standard library is <a href="https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/src/kotlin/io/ReadWrite.kt#L154">use()</a>, which gives us the equivalent of <a href="https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html">Java’s try-with-resources</a> and of C#’s <a href="https://msdn.microsoft.com/en-us/library/yh598w02.aspx?f=255&#x26;MSPPError=-2147217396">using</a> statement.</p>
<p>This function applies to all objects of type <code>Closeable</code> and it automatically closes its receiver on exit. Note that as opposed to Java and C#, Kotlin’s <code>use()</code> is a regular library function and <strong>not</strong> directly baked in the language with a special syntax. This is made possible by Kotlin’s extension functions and closure syntax used coinjointly.</p>
<pre><code class="hljs language-java"><span class="hljs-comment">// Java 1.7 and above</span>
Properties prop = <span class="hljs-keyword">new</span> Properties();
<span class="hljs-keyword">try</span> (FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"config.properties"</span>)) {
    prop.load(fis);
}
<span class="hljs-comment">// fis automatically closed</span></code></pre>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">// Kotlin</span>
<span class="hljs-keyword">val</span> prop = Properties()
FileInputStream(<span class="hljs-string">"config.properties"</span>).use {
    prop.load(it)
}
<span class="hljs-comment">// FileInputStream automatically closed</span></code></pre>
<p>Because Kotlin’s version is just a regular function, it’s actually much more composable than Java’s. For example, did you want to return this prop object after loading it?</p>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">// Kotlin</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">readProperties</span><span class="hljs-params">()</span></span> = Properties().apply {
    FileInputStream(<span class="hljs-string">"config.properties"</span>).use { fis ->
        load(fis)
    }
}</code></pre>
<p>The <code>apply()</code> call tells us that the type of this expression is that of the object <code>apply()</code> is invoked on, which is <code>Properties</code>. Inside this block, <code>this</code> is now of type <code>Properties</code>, which allows us to call <code>load()</code> on it directly. In between, we create a <code>FileInputStream</code> that we use to populate this property object. And once we call <code>use()</code> on it, that <code>FileInputStream</code> will be automatically closed before this function returns, saving us from the ugly <code>try/catch/finally</code> combo that Java requires.</p>
<p>You will find a lot of these constructs in the <a href="http://beust.com/kobalt">Kobalt build tool</a> code, feel free to browse it.</p>
]]></description><link>http://beust.com/weblog/2015/10/30/exploring-the-kotlin-standard-library/</link><guid isPermaLink="true">http://beust.com/weblog/2015/10/30/exploring-the-kotlin-standard-library/</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Cédric Beust]]></dc:creator><pubDate>Fri, 30 Oct 2015 17:30:00 GMT</pubDate></item><item><title><![CDATA[Kotlin NoSQL for MongoDB in Action]]></title><description><![CDATA[<iframe width="960" height="480" src="https://www.youtube.com/embed/80xgl3KThvM" frameborder="0" allowfullscreen></iframe>
]]></description><link>https://www.youtube.com/watch?v=80xgl3KThvM</link><guid isPermaLink="true">https://www.youtube.com/watch?v=80xgl3KThvM</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[SQL]]></category><dc:creator><![CDATA[Andrey Cheptsov]]></dc:creator><pubDate>Thu, 22 Oct 2015 21:54:00 GMT</pubDate></item><item><title><![CDATA[Quasar: Efficient and Elegant Fibers, Channels and Actors]]></title><description><![CDATA[<p>The recording of our September 16th webinar, <strong>Quasar: Efficient and Elegant Fibers, Channels and Actors</strong>, is now available on <a href="https://youtu.be/Nmob2MB2Qo8">JetBrainsTV YouTube channel</a>.</p>
<p>In this webinar, Fabio Tudone shows how to use Quasar for creation of highly concurrent software. He covers basics of Kotlin syntax and shows how Quasar uses Kotlin strengths to offer concise and expressive API.</p>
<p>Demo project is available on <a href="https://github.com/circlespainter/quasar-kotlin-jetbrains-webinar/releases">GitHub</a>.</p>
<p>The video includes the time stamps following the <a href="http://blog.jetbrains.com/kotlin/2015/09/join-live-webinar-quasar-and-kotlin/">agenda announced</a>:</p>
<ul>
<li><code>00:55</code> – What are Quasar and Fibers?</li>
<li><code>12:22</code> – What are Quasar Channels?</li>
<li><code>15:50</code> – What are and why using Quasar Fibers?</li>
<li><code>21:15</code> – From Async to efficient Fiber-Sync with Quasar</li>
<li><code>27:13</code> – Quasar Actors and Selective Receive</li>
<li><code>37:54</code> – Quasar Dataflow</li>
<li><code>45:19</code> – Pulsar: Quasar’s idiomatic API for Clojure</li>
<li><code>45:19</code> – Comsat: existing APIs on steroids with Quasar Fibers</li>
<li><code>47:07</code> – Comsat Web Actors for HTTP, SSE and WebSockets</li>
<li><code>49:58</code> – Capsule: deploy Quasar and any JVM applications</li>
</ul>
<iframe src="https://www.youtube.com/embed/Nmob2MB2Qo8" allowfullscreen="" height="480" frameborder="0" width="960"></iframe>
<p>About the Presenter:</p>
<p><a href="https://twitter.com/ftudone">Fabio Tudone</a> works on Quasar, Pulsar and Comsat at Parallel Universe. He has been writing mostly JVM software during his entire career, and before joining <a href="http://www.paralleluniverse.co/">Parallel Universe</a> he led the development of a cloud-based enterprise content governance platform. His interests include Dev and DevOps practices, scalability, concurrent and functional programming as well as runtime platforms at large.</p>
<p>Thanks to all the attendees for the questions! If you still have some, please, contact Fabio or our team.</p>
<p>You are welcome to suggest themes for future webinars in comments.</p>
<p><em>Let’s kotlin!</em></p>
]]></description><link>http://blog.jetbrains.com/kotlin/2015/09/webinar-recording-quasar-efficient-and-elegant-fibers-channels-and-actors/</link><guid isPermaLink="true">http://blog.jetbrains.com/kotlin/2015/09/webinar-recording-quasar-efficient-and-elegant-fibers-channels-and-actors/</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Webinar]]></category><category><![CDATA[Fibers]]></category><category><![CDATA[Channels]]></category><category><![CDATA[Actors]]></category><dc:creator><![CDATA[Roman Belov]]></dc:creator><pubDate>Mon, 21 Sep 2015 09:40:00 GMT</pubDate></item><item><title><![CDATA[Kotlin ❤ FP]]></title><description><![CDATA[<h4>Functional programming in Kotlin, a new language from JetBrains</h4>
<p>I did <a href="http://blog.jetbrains.com/kotlin/2015/11/webinar-recording-functional-programming-with-kotlin/">a video tutorial on FP in Kotlin</a>, which can be viewed online.</p>
<p>If you use .NET you probably heard about F#, a multi-paradigm but essentially functional programming language for the CLR. And you probably heard good things about it. You may also have heard of Haskell, which is similar.</p>
<p>Perhaps you would like languages such as these on the JVM, but with great tool support and without <em>mandating</em> a functional style ... just making it available when you want it.</p>
<p><a href="http://kotlinlang.org/"><strong>The Kotlin language</strong></a> may at first glance appear to be nothing more than an upgraded Java: lots of syntax conveniences, some type inference and so on. But dig a little deeper and you will discover that many of the most popular and advanced features of functional languages are available.</p>
<p>Let’s get started with some simple examples.</p>
<hr>
<h3>Algebraic data types</h3>
<p>It’s normal for functional languages to support syntax like this:</p>
<pre><code class="hljs language-haskell"><span class="hljs-class"><span class="hljs-keyword">data</span>  <span class="hljs-type">Maybe</span> a  =  <span class="hljs-type">Nothing</span> | <span class="hljs-type">Just</span> a</span>
  <span class="hljs-keyword">deriving</span> (<span class="hljs-type">Eq</span>, <span class="hljs-type">Ord</span>)</code></pre>
<p>That’s Haskell, and it defines a type called “Maybe” that has two so called <em>type constructors</em>, Nothing and Just. The Just type constructor takes a single parameter of unspecified type. The deriving keyword here means a Maybe can be compared for equality, and ordered. It can also be called a <em>tagged union</em>.</p>
<p>Kotlin doesn’t need a Maybe type because it has optionality as a built in part of the type system. Optionality is so common in programs that it makes sense to integrate it at a deep level, for both convenience and performance reasons:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> s: String? = <span class="hljs-keyword">if</span> (Math.random() &#x3C; <span class="hljs-number">0.5</span>) <span class="hljs-string">"Yay!"</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">null</span>
println(<span class="hljs-string">"length of string is .... <span class="hljs-subst">${s.length()}</span>"</span>)</code></pre>
<p>Here, we get a compile error on the second line, because we’re trying to read the length of a string we might not actually have, depending on a coin flip. There’s a simple fix:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> s: String? = <span class="hljs-keyword">if</span> (Math.random() &#x3C; <span class="hljs-number">0.5</span>) <span class="hljs-string">"Yay!"</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">null</span>
println(<span class="hljs-string">"length of string is .... <span class="hljs-subst">${s?.length() ?: <span class="hljs-number">-1</span>}</span>"</span>)</code></pre>
<p>Here, s?.length() will yield null if s was null, and the ?: operator uses the right hand side if the left hand side is null. So this prints -1 if the coin flip didn’t yield the string.</p>
<p>However, we won’t think about that more here.</p>
<p>Because the Maybe type is so familiar to functional programmers, let’s define an equivalent of it here just for illustration.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Maybe</span>&#x3C;<span class="hljs-type">out T</span>> </span>{
    <span class="hljs-keyword">object</span> None : Maybe&#x3C;<span class="hljs-built_in">Nothing</span>>()
    <span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Just</span>&#x3C;<span class="hljs-type">T</span>></span>(<span class="hljs-keyword">val</span> t: T) : Maybe&#x3C;T>()
}</code></pre>
<p>The syntax isn’t as terse as Haskell, but isn’t bad either. The data modifier here is optional, but adding it gives us useful features.</p>
<p>We can do a variety of functional things with this:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> j = Maybe.Just(<span class="hljs-number">1</span>)
<span class="hljs-keyword">val</span> (i) = j</code></pre>
<p>Here, we define a “just” containing an integer, and then we destructure it to get the integer back. Notice the lack of types: it’s all inferred. If the type had defined multiple fields, we could <a href="http://kotlinlang.org/docs/reference/multi-declarations.html">destructure all of them</a>, which is how this is actually meant to be used:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pet</span></span>(<span class="hljs-keyword">val</span> name: String, <span class="hljs-keyword">val</span> age: <span class="hljs-built_in">Int</span>)
<span class="hljs-keyword">val</span> alice = Pet(<span class="hljs-string">"Alice"</span>, <span class="hljs-number">6</span>)
<span class="hljs-keyword">val</span> (name, age) = alice</code></pre>
<p>What about pattern matching? This is where the word “sealed” above comes in handy; we can do an exhaustive pattern match without an else/otherwise branch:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span></span>(<span class="hljs-keyword">val</span> age: <span class="hljs-built_in">Int</span>)

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">lookupFromDB</span><span class="hljs-params">(s: <span class="hljs-type">String</span>)</span></span>: Maybe&#x3C;User> = Maybe.None

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printUser</span><span class="hljs-params">(username: <span class="hljs-type">String</span>)</span></span> {
    <span class="hljs-keyword">val</span> rec = lookupFromDB(username)
    <span class="hljs-keyword">when</span> (rec) {
        <span class="hljs-keyword">is</span> Maybe.None -> println(<span class="hljs-string">"not found"</span>)
        <span class="hljs-keyword">is</span> Maybe.Just&#x3C;User> -> println(<span class="hljs-string">"<span class="hljs-subst">${rec.t.age}</span> years old"</span>)
    }
}</code></pre>
<p>Here, we define a simple class with a single immutable property (age), and a couple of functions. We have a lookupFromDB function that returns a Maybe: in this case, always a None, but that’s just an example.</p>
<p>Then we use <a href="http://kotlinlang.org/docs/reference/control-flow.html#when-expression">the when expression</a> to do a pattern match on the type. When expressions are pretty flexible. They can use arbitrary expressions on the left hand side of each case and if the expression is a type query, the code on the right has the cast applied automatically. That’s why we can just access the t property of rec immediately.</p>
<h3>Immutability</h3>
<p>Kotlin is not a pure FP language and does not have a ‘default’ for mutable vs immutable. It gently encourages immutability in a few places by choice of syntax, but otherwise makes you choose each and every time.</p>
<p>Here’s some code:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>(<span class="hljs-keyword">var</span> name: String, <span class="hljs-keyword">var</span> age: <span class="hljs-built_in">Int</span>)
<span class="hljs-keyword">val</span> p = Person(<span class="hljs-string">"Mike"</span>, <span class="hljs-number">31</span>)
p.name = <span class="hljs-string">"Bob"</span></code></pre>
<p>Here “p” is an immutable <strong>val</strong>ue: it cannot be reassigned. It’s like a final variable in Java, or a let expression in Haskell/F#. But then the contents of this structure are mutable <strong>var</strong>iables, so they can be reassigned later. The IDE highlights identifiers differently if they’re mutable.</p>
<p>Here’s how it looks like, fully immutable</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>(<span class="hljs-keyword">val</span> name: String, <span class="hljs-keyword">val</span> age: <span class="hljs-built_in">Int</span>)
<span class="hljs-keyword">val</span> mike = Person(<span class="hljs-string">"Mike"</span>, <span class="hljs-number">31</span>)
<span class="hljs-keyword">val</span> olderMike = mike.copy(age = <span class="hljs-number">32</span>)</code></pre>
<p>The copy method is auto generated whenever the data modifier is used. It has a named argument for every property, with the default value of that argument being whatever the current value is. Net result, you can use it to create a fresh object with tweaked fields.</p>
<p>Lists are immutable by default:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> people = listOf(mike, olderMike)
people.add(Person(<span class="hljs-string">"Bob"</span>, <span class="hljs-number">50</span>))                     <span class="hljs-comment">// ERROR</span>

<span class="hljs-keyword">val</span> peopleDB = arrayListOf(mike, olderMike)
peopleDB.add(Person(<span class="hljs-string">"Bob"</span>, <span class="hljs-number">50</span>))

<span class="hljs-keyword">val</span> view: List&#x3C;Person> = peopleDB
<span class="hljs-keyword">val</span> snapshot = peopleDB.toList()</code></pre>
<p>The second line won’t compile: listOf() returns an immutable list. The fourth line does because we specifically picked an array list (vs a linked list), which is mutable. We can, of course, cast away the mutability to create a read only view, or clone the list to create a snapshot of it.</p>
<p>Currently there’s no dedicated list literal syntax. There might be in future, but for now, we must use functions.</p>
<h3>Mapping, filtering, reducing etc</h3>
<p>Kotlin has support for efficient lambdas, and extends the default JDK collections classes to support common functions from FP standard libraries. This can even be used on Java 6 and thus Android:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> nums = listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)
<span class="hljs-keyword">val</span> r = nums.map { it * <span class="hljs-number">2</span> }.sum()       <span class="hljs-comment">// r == 20</span></code></pre>
<p>Here, the “it” identifier is a convenience: if a lambda has only one argument, it’s called “it” automatically. We can specify an explicit name when “it” would get too confusing, like in nested lambdas.</p>
<p>Map is an <em>extension function</em>. Where Java programmers would define a FooUtils class with static methods to add functionality to Foo classes, Kotlin lets you extend the class with a (statically dispatched) method directly. And then it uses that to give Java platform types like Iterable <a href="http://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-iterable/index.html">new features</a>.</p>
<p>A more advanced example:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> strs = listOf(<span class="hljs-string">"fish"</span>, <span class="hljs-string">"tree"</span>, <span class="hljs-string">"dog"</span>, <span class="hljs-string">"tree"</span>, <span class="hljs-string">"fish"</span>, <span class="hljs-string">"fish"</span>)
<span class="hljs-keyword">val</span> freqs = strs.groupBy { it }.mapValues { it.value.size() }
println(freqs)     <span class="hljs-comment">// {fish=3, tree=2, dog=1}</span></code></pre>
<h3>Recursive functions</h3>
<p>Functional programmers like to express solutions to problems using recursion. This often needs an optimisation called <em>tail call optimisation</em> to work well. Kotlin supports this in certain circumstances.</p>
<p>Here’s a simple example. A <em>fixpoint</em> of a mathematical function is an input that gives itself as an output. To find a fixpoint of cosine, you can keep feeding the output back as an input until things stabilise. Here’s an example in an imperative fashion:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">cosFixpoint</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Double</span> {
    <span class="hljs-keyword">var</span> x = <span class="hljs-number">1.0</span>
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">val</span> y = Math.cos(x)
        <span class="hljs-keyword">if</span> (x == y) <span class="hljs-keyword">return</span> y
        x = y
    }
}</code></pre>
<p>Pretty simple: starting at 1.0 we keep calling cos until cos(a) == a.</p>
<p>Here’s the same written in a recursive manner:</p>
<pre><code class="hljs language-kotlin">tailrec <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">cosFixpoint</span><span class="hljs-params">(x: <span class="hljs-type">Double</span> = <span class="hljs-number">1.0</span>)</span></span>: <span class="hljs-built_in">Double</span> {
    <span class="hljs-keyword">val</span> r = Math.cos(x)
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (x == r) x <span class="hljs-keyword">else</span> cosFixpoint(r)
}</code></pre>
<p>It could also be a one liner (or two here, with big fonts):</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">import</span> java.lang.Math.cos

tailrec
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">f</span><span class="hljs-params">(x: <span class="hljs-type">Double</span> = <span class="hljs-number">1.0</span>)</span></span>: <span class="hljs-built_in">Double</span> = <span class="hljs-keyword">if</span> (x == cos(x)) x <span class="hljs-keyword">else</span> f(cos(x)))</code></pre>
<p>That version relies on the JIT compiler to notice that it can eliminate the duplicated call to Math.cos(x).</p>
<h3>Currying, partial application, composition</h3>
<p>These are features you’ll find in F# and Haskell, though I never felt a need for them myself. Currying turns a function into a chain of functions. Partial application lets you ‘fix’ certain parameters to a function, resulting in a new function.</p>
<p>Kotlin doesn’t support these out of the box. But it’s flexible enough that they can be added by <a href="https://github.com/MarioAriasC/funKTionale/wiki">a library called funKtionale</a>, in a natural manner:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">import</span> org.funktionale.currying.*

<span class="hljs-keyword">val</span> sum2ints = { x: <span class="hljs-built_in">Int</span>, y: <span class="hljs-built_in">Int</span> -> x + y }
<span class="hljs-keyword">val</span> curried: (<span class="hljs-built_in">Int</span>) -> (<span class="hljs-built_in">Int</span>) -> <span class="hljs-built_in">Int</span> = sum2ints.curried()
assertEquals(curried(<span class="hljs-number">2</span>)(<span class="hljs-number">4</span>), <span class="hljs-number">6</span>)
<span class="hljs-keyword">val</span> add5 = curried(<span class="hljs-number">5</span>)
assertEquals(add5(<span class="hljs-number">7</span>), <span class="hljs-number">12</span>)</code></pre>
<p>... and ...</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">import</span> org.funktionale.partials.*

<span class="hljs-keyword">val</span> format = { prefix: String, x: String, postfix: String ->
    <span class="hljs-string">"<span class="hljs-subst">${prefix}</span><span class="hljs-subst">${x}</span><span class="hljs-subst">${postfix}</span>"</span>
}

<span class="hljs-keyword">val</span> prefixAndBang = format(p3 = <span class="hljs-string">"!"</span>)

<span class="hljs-comment">// Passing just the first parameter will return a new function</span>
<span class="hljs-keyword">val</span> hello = prefixAndBang(p1 = <span class="hljs-string">"Hello, "</span>)

println(hello(<span class="hljs-string">"world"</span>))</code></pre>
<h3>Lazyness</h3>
<p>Kotlin is a strict/eager language, and this is how it should be. As far as I’m aware, no other well known language uses lazy-by-default except Haskell.</p>
<p>However you can do lazy computations if you want to. Here’s a dead simple real world example: avoiding the work of building a string if logging is disabled.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> loggingEnabled = System.getProperty(<span class="hljs-string">"log"</span>) != <span class="hljs-literal">null</span>

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">log</span><span class="hljs-params">(s: <span class="hljs-type">String</span>)</span></span>: <span class="hljs-built_in">Unit</span> = <span class="hljs-keyword">if</span> (loggingEnabled) println(s)

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">log</span><span class="hljs-params">(ls: ()</span></span> -> String): <span class="hljs-built_in">Unit</span> = <span class="hljs-keyword">if</span> (loggingEnabled) println(ls())</code></pre>
<p>The log function is overloaded: it can take an actual string, or a function that calculates a string:</p>
<pre><code class="hljs language-kotlin">log(<span class="hljs-string">"now!"</span>)
log { <span class="hljs-string">"calculate me later"</span> }</code></pre>
<p>Functional programming occasionally involves building infinite lists of things and operating on them in a lazy and possibly parallel manner. <a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/stm/STMTokyoApr10.pdf">This is often seen as a key selling point for FP</a> (see slide 10).</p>
<p>Since version 8 Java can do this too, and therefore so can Kotlin. For example:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> ONE = BigInteger.ONE
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">primes</span><span class="hljs-params">(n: <span class="hljs-type">Long</span>)</span></span> =
        Stream.iterate(ONE) { it + ONE }.
        filter { it.isProbablePrime(<span class="hljs-number">16</span>) }.
        limit(n).
        toList()</code></pre>
<p>Java calls infinite lazy lists <em>streams.</em> Here, we build a list of all the positive BigIntegers. Then we select only the ones that are probably prime numbers with chance 2^16, according to the Miller-Rabin primality test. Then we take <em>n</em> of them and put them into a regular non-lazy list. This is classical functional programming.</p>
<p>How fast is this?</p>
<pre><code class="hljs language-kotlin">repeat(<span class="hljs-number">3</span>) {
    <span class="hljs-keyword">val</span> t = measureTimeMillis {
        primes(<span class="hljs-number">100000</span>)
    }
    println(<span class="hljs-string">"Took <span class="hljs-subst">$t</span> msec"</span>)
}</code></pre>
<p>On my laptop, after the first run when the JIT compiler has crunched, it takes about 1.5 seconds.</p>
<p>One nice thing about pipelines of pure functions is you can parallelise them. Let’s do that now:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">primes</span><span class="hljs-params">(n: <span class="hljs-type">Long</span>)</span></span> =
        Stream.iterate(ONE) { it + ONE }.
        parallel().
        filter { it.isProbablePrime(<span class="hljs-number">16</span>) }.
        limit(n).
        toArray()</code></pre>
<p>We inserted a call to parallel() in our stream. This tells the JVM to run the rest of the pipeline in multiple threads. Rerunning the program shows that this improved performance 3x: it now only takes half a second. Not bad!</p>
<h3>STM</h3>
<p>Software transactional memory is a way to write concurrent code. It is well explained in <a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/stm/beautiful.pdf">this paper by Simon Peyton-Jones</a>, one of the architects of Haskell.</p>
<p>Instead of using locks you write code like this:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">var</span> account1 = <span class="hljs-number">5</span>
<span class="hljs-keyword">var</span> account2 = <span class="hljs-number">0</span>

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">transfer</span><span class="hljs-params">(amount: <span class="hljs-type">Int</span>)</span></span> {
    atomic {
        account1 -= amount
        account2 += amount
    }
}</code></pre>
<p>From the programmers perspective, anything that happens inside the atomic block takes effect all at once when the block is exited and there can be no race conditions inside it. But multiple threads can all be inside the atomic block at once, doing useful work. Pretty neat, right?</p>
<p>A simple implementation would be to have a giant global lock, but that’d be very slow. So fancier implementations record every change made inside the block by threads running concurrently, and detect conflicts: if there is a conflict, the block is retried. Haskell has an implementation of such a thing.</p>
<p>Kotlin does not have language support for software transactional memory. However, this is not such a big deal because via the JVM it gets support using libraries like <a href="http://nbronson.github.io/scala-stm/quick_start.html">Scala STM</a> (see below), and even something better: <em>hardware</em> transactional memory. Yup.</p>
<p>Modern (very modern) Intel chips support a set of processor extensions called TSX. TSX allows code to create an atomic transaction at the hardware level. Changes to RAM are buffered up in cache lines and interference between threads is tracked by the CPU itself. If there was a conflict, the CPU aborts the transaction and expects the code to either try again or fall back to regular locking. If no thread bumped into you, your writes are flushed to RAM in one go at the end.</p>
<p>Starting with Java 8 Update 40, so-called “RTM locking” is enabled by default when the CPU supports it. This converts <em>every</em> Java synchronized block into a hardware level atomic transaction using TSX. That means you will have multiple threads running inside synchronized blocks at once. The JVM profiles the app to find blocks that experience frequent thread interference, where the CPU is wasting time due to constantly rolling back/retrying, and converts them back to using regular locks. As Kotlin runs on the JVM it gets this functionality for free.</p>
<p>This lets you write code in the “one big lock” style without suffering the performance downsides, as long as you are on sufficiently new hardware.</p>
<p>I should note here that STMs often provide extra features, like the ability to pause/retry a code block when the dependencies change, or the ability to explicitly cancel a transaction without retrying it (by throwing an exception). Hardware TM doesn’t offer this, or rather the JVM doesn’t surface the support at the moment. If you want more control, you must use a library and explicitly change your data model to incorporate transactional variables:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">import</span> scala.concurrent.stm.japi.STM.*

<span class="hljs-keyword">val</span> counter = newRef(<span class="hljs-number">10</span>)
<span class="hljs-keyword">try</span> {
    atomic {
        increment(counter, <span class="hljs-number">1</span>)
        println(<span class="hljs-string">"counter is <span class="hljs-subst">${counter.get()}</span>"</span>)    <span class="hljs-comment">// -> 11</span>
        <span class="hljs-keyword">throw</span> Exception(<span class="hljs-string">"roll back!!"</span>)
    }
} <span class="hljs-keyword">catch</span>(e: Exception) {
    println(<span class="hljs-string">"counter is <span class="hljs-subst">${counter.get()}</span>"</span>)        <span class="hljs-comment">// -> 10</span>
}</code></pre>
<p>Haskell has one other neat trick up its sleeve —using its type system it can ensure that variables are only accessed inside atomic blocks, so you can never forget to wrap your code up properly. We can do something a bit similar in Kotlin:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadBox</span>&#x3C;<span class="hljs-type">T</span>></span>(v: T) {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> value = v
    <span class="hljs-meta">@Synchronized</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> locked<span class="hljs-type">&#x3C;R></span><span class="hljs-params">(f: <span class="hljs-type">T</span>.()</span></span> -> R): R = value.f()
}

<span class="hljs-keyword">val</span> bank = ThreadBox(<span class="hljs-keyword">object</span> {
    <span class="hljs-keyword">val</span> accounts = intArrayOf(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)
})

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">transfer</span><span class="hljs-params">(from: <span class="hljs-type">Int</span>, to: <span class="hljs-type">Int</span>, amount: <span class="hljs-type">Int</span>)</span></span> {
    bank.locked {
        accounts[from] -= amount
        accounts[to] += amount
    }
}</code></pre>
<p>A ThreadBox is a simple class that takes a pointer to some object in its constructor. It keeps that pointer privately. So, if there’s no other reference to the passed object it can only be accessed via the ThreadBox. When we declare <em>bank</em>, we use the object keyword to create an anonymous object and pass it in — so we know the only way to reach the accounts array is via the ThreadBox. And the ThreadBox only gives out that pointer inside an atomic block.</p>
<p>The compiler won’t let us access the array outside an atomic block ... unless we let a reference escape. So this is not as strong as the Haskell type system approach, but it’s a good start.</p>
<p>There’s a version of this code that can catch more mistakes <a href="https://gist.github.com/mikehearn/1ad4a9c375e59e52b8cf">here</a>.</p>
<p>The atomic method is a higher order function protected by a regular Java synchronized method, and it just immediately calls the provided code block under the lock. The JVM will ignore the lock on hardware that supports TSX and all threads can proceed in parallel, in an atomic transaction. As long as the two threads are using different account IDs for <em>from</em> and <em>to</em>, no locking is done at all: that makes it nice and fast.</p>
<h3>Things Kotlin lacks</h3>
<p>At the moment there is no way to control side effects: any function call can be potentially side effecting. It would be nice if a future version of the language introduced something like the C++ const keyword, or D’s transitive const, to reduce the reliance on actually immutable data structures. The JVM offers features that can seal off common sources of external state, such as the disk and network, however the heap is still available. It may be an interesting project to make the JVM’s sandboxing features easily available via a Kotlin DSL.</p>
<p>There is not at this moment any high performance immutable collections library. Both Clojure and Scala have maps and sets in which mutating the collection returns a new collection, with internal data sharing to make performance practical. The Kotlin standard library does not. If someone were to make one, using <a href="http://michael.steindorfer.name/publications/oopsla15.pdf">the CHAMP code</a> published this year would give significant improvements over the algorithms used in Scala/Clojure.</p>
]]></description><link>https://medium.com/@octskyward/kotlin-fp-3bf63a17d64a</link><guid isPermaLink="true">https://medium.com/@octskyward/kotlin-fp-3bf63a17d64a</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Functional]]></category><dc:creator><![CDATA[Mike Hearn]]></dc:creator><pubDate>Fri, 18 Sep 2015 21:52:00 GMT</pubDate></item><item><title><![CDATA[Production Ready Kotlin]]></title><description><![CDATA[<p>I see a lot of people asking "Is Kotlin ready for production?" ... maybe these are people that are not already using Kotlin wanting a bit of comfort before they put effort into their own investigation. Most people I know that do actually use Kotlin daily think it is obvious Kotlin is already ready. here is why:</p>
<ul>
<li>If it compiles, it runs perfectly</li>
<li>If it doesn't compile due to some rare compiler bug, there is always a work around</li>
<li>If that doesn't work, drop to Java for 1 class and come back (really rare)</li>
</ul>
<p>The only real breaking point is source code level changes between versions. And JetBrains even helps with those by providing global refactorings in IntelliJ IDEA that will update your code.</p>
<p>A huge benefit to Kotlin is that the company doing a lot of the development has a very high quality level of focus, represented in the extensive tests that back and protect each Kotlin build. This is a company that knows the cost of an error after shipping a product. And if there is an error, the responsiveness of the team is stellar. Bugs are triaged within a day, breaking bugs are fixed quickly, and other issues are considered thoughtfully. You can also submit pull requests and help out when something is within your coding grasp.</p>
<p>We have taken Kotlin into production via Solr-Undertow at some really large companies who trust it more than they trusted "Solr on Jetty" which has been around for many years. With Kotlin, back in my consulting days, we built a billion record processing pipeline that kicked the pants off of the previous Scala version, and it is the livelihood behind a billion dollar education company's search system. And now we have Kotlin in production in our startup, in fact we ONLY have Kotlin and are using it happily with Vert-x3, Amazon AWS services, ElasticSearch and other Java libraries.</p>
<p>Here is what is NOT helping Kotlin to be perceived as production ready:</p>
<ul>
<li>
<p>version number sounds fishy, 0.12.1230. This is solely a perception problem and ignores the years of work and the quality level behind that number.</p>
</li>
<li>
<p>few major up-to-date Kotlin libraries. First, you don't need a Kotlin library to replace every Java library. Scala loved doing that, and used Killer Frameworks to sell Scala. Kotlin doesn't need it. In some areas bigger libraries are coming because they will be end-to-end more "Kotlin-loving" but it isn't required.</p>
</li>
<li>
<p>trash left laying around. If you see an old GitHub repository from 2 years ago with M6 Kotlin code, ask the owner to delete it. A library should be active, at least current to M12, ready for M13 when it arrives, or the owner should hand it off or close it down so they do not confuse and hurt an emerging ecosystem around Kotlin. GitHub has so much trash these days, but it is important place in which people look for libraries.</p>
</li>
<li>
<p>LinkedIn seems to resist Kotlin as a skill / search keyword. For 1 day we had Kotlin appearing in search, then it vanished again. LinkedIn engineering says we need higher frequency of the term in skills and CV's (positions). So if you use Kotlin, add it to your LinkedIn and help it break through the threshold.</p>
</li>
</ul>
<p>To help out, my company is open-sourcing anything we can, and are taking this approach with the Kotlin community:</p>
<p>"We will open-source anything we can that does not hurt our competitiveness, we will document it, release it on maven central, we will keep it up to date to any Kotlin milestone/release changes, we will integrate nicely with other Kotlin libraries, we will report all bugs and issues to Kotlin YouTrack and follow up with testing; and we will not stop supporting Kotlin until every one of the key players in Kotlin sphere show up at a bar in Dublin, and we all agree to quit together. Until then, we are all in."</p>
<p>If you are a Kotlin supporter, step up your support because Kotlin can be the biggest player in the JVM space, is the best candidate, and deserves help from those that benefit from its existence.</p>
]]></description><link>https://www.linkedin.com/grp/post/7417237-6042285669181648896</link><guid isPermaLink="true">https://www.linkedin.com/grp/post/7417237-6042285669181648896</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Jayson Minard]]></dc:creator><pubDate>Wed, 26 Aug 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[JVMLS 2015 - Flexible Types in Kotlin]]></title><description><![CDATA[<iframe width="960" height="480" src="https://www.youtube.com/embed/2IhT8HACc2E" frameborder="0" allowfullscreen></iframe>
]]></description><link>https://www.youtube.com/watch?v=2IhT8HACc2E</link><guid isPermaLink="true">https://www.youtube.com/watch?v=2IhT8HACc2E</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Andrey Breslav]]></dc:creator><pubDate>Wed, 12 Aug 2015 21:54:00 GMT</pubDate></item><item><title><![CDATA[Building APIs on the JVM Using Kotlin and Spark – Part 1]]></title><description><![CDATA[<p><img src="http://nordicapis.com/wp-content/uploads/Building-APIs-JVM-kotlin-spark-java-nordic-apis-pt-1.png" alt="Building-APIs-JVM-kotlin-spark-java-nordic-apis-pt-1"></p>
<p>When you start a new API project, one of the first questions to answer is what programming language to use. Picking the right one can make all the difference. Some languages help solve certain problems while others inhibit solutions. Even after a language is chosen and tens-of-thousands of lines of code have been written, there is the possibility of reducing complexity by using new languages on the same <strong>runtime</strong>.</p>
<p>In this two-part blog series, we’ll explain why the <strong>JVM</strong> provides a strong basis on which to run your APIs, and how to simplify their construction using a framework called <strong>Spark</strong> and a new programming language called <strong>Kotlin</strong>. In this first part, we will introduce you to the JVM and how it can execute code written in many programming languages, including Kotlin. We’ll discuss a number of Kotlin’s features and show them in the context of APIs.</p>
<p>In our <a href="http://nordicapis.com/building-apis-on-the-jvm-using-kotlin-and-spark-part-2/">second post</a>, we explore the Spark framework in detail, and how to complement this toolkit with additional components like Inversion of Control (IoC). During the series, we’ll develop a boilerplate that you can use to <strong>create robust APIs with Kotlin and Spark</strong>. The code can be <a href="https://github.com/travisspencer/kotlin-spark-demo/">found on Github</a>, so refer to it there as you read through the snippets below.</p>
<p>Watch Travis Spencer present on this topic at the Stockholm Java Meetup <iframe src="https://www.youtube.com/embed/eDHUabQMRb4" allowfullscreen="allowfullscreen" height="315" frameborder="0" width="560"></iframe></p>
<h2>Introducing the JVM</h2>
<p>The <strong>Java Virtual Machine (JVM)</strong> is a runtime that offers a range of language choices. Adoption of Clojure, Groovy, Scala, Jython, and other JVM-based languages are widespread. Aside from the broad range of language choices, another uncommon aspect of the JVM is its openness. You can get an implementation of the JVM not just from Oracle but also from an <a href="https://en.wikipedia.org/wiki/List_of_Java_virtual_machines">expansive list of other providers</a>. Many distributions of Linux come preloaded with <a href="https://en.wikipedia.org/wiki/OpenJDK">OpenJDK</a>, which is the reference implementation of Java, allowing API developers to host their service with very little cost and hassle.</p>
<p>One of the core tenants of Java is that each new version is <strong>backward compatible</strong> with previous ones. This has caused the Java programming language to evolve more slowly than others like C#, where major changes in the language come with massive upgrade efforts. <img src="http://combineoverwiki.net/images/thumb/d/dc/Lambda_logo.svg/365px-Lambda_logo.svg.png">This has improved a lot over the years, and <a href="http://www.oracle.com/technetwork/java/javase/overview/java8-2100321.html">Java 8</a> has removed a lot of cruft in the language with the introduction of <strong>lambdas</strong>. Regardless of the pace of Java’s evolution, this commitment to backward compatibility has resulted in a <strong>very stable base</strong>.</p>
<p>The openness and ongoing compatibility of the JVM offers a number of very compelling reason to build APIs on this platform:</p>
<ul>
<li><strong>Return on Investment (ROI)</strong>: Code that continues to run can continue to produce a return on the investment made to write it.</li>
<li><strong>Knowledge remains relevant</strong>: Since old code continues to run, all the knowledge gained to write that code continues to be useful. With new versions of the JVM, you can keep writing old-style code. You don’t have to retrain yourself when the runtime’s vendor upgrades the platform.</li>
<li><strong>Ecosystem</strong>: These factors have caused a very large ecosystem to flourish around the JVM. This system includes massive corporations and some of the biggest open source communities that will work hard to ensure its longevity.</li>
</ul>
<p>Probably one of the biggest drawbacks of selecting Java to code up your API is that it is <em><strong>so</strong></em> verbose. Who would use it if they didn’t have to?! ROI is often enough of a reason for companies to select it even for greenfield work, putting programmers through the pains of its verbosity even with the advent of alternatives like Node.js and <a href="http://nordicapis.com/writing-microservices-in-go/">Golang</a>.</p>
<p>But what if you had the most sugary syntax you could ever dream of without having to change anything else? What if you could retain your build system, packaging, dependencies, existing code and performance, <em>and</em> get the language you’ve been longing for?</p>
<h1>Enter Kotlin</h1>
<p><strong><img src="https://upload.wikimedia.org/wikipedia/en/b/b5/Kotlin-logo.png">Kotlin</strong> is a new programming language from Jetbrains, the makers of some of the best programming tools in the business, including <a href="https://www.jetbrains.com/idea/">Intellij IDEA</a>, an IDE for Java and other languages. As a leader in the Java community, Jetbrains understands the pains of Java and the many benefits of the JVM. Not wanting to throw the baby out with the bathwater, Jetbrains designed Kotlin to run on the JVM to get the best out of that platform.</p>
<p>They didn’t constrain it to this runtime, however — developers can also compile their Kotlin code into <strong>JavaScript</strong>, allowing it to be used in environments like <strong>Node.js</strong>. To work with untyped and typed environments like these, Kotlin is statically typed by default, but allows developers to define dynamic types as well. This balance provides great power and many opportunities.</p>
<h2>Why Kotlin?</h2>
<p><a href="https://twitter.com/OctSkyward">Mike Hearn</a> does a spectacular job explaining <a href="https://medium.com/@octskyward/why-kotlin-is-my-next-programming-language-c25c001e26e3">why you should consider using Kotlin</a>. In his article, he lists the following reasons:</p>
<ul>
<li>Kotlin compiles to JVM bytecode and JavaScript</li>
<li>Kotlin comes from industry, not academia</li>
<li>Kotlin is open source and costs nothing to adopt</li>
<li>Kotlin programs can use existing Java or JavaScript frameworks</li>
<li>The learning curve is very low</li>
<li>Kotlin doesn’t require any particular style of programming (OO or functional)</li>
<li>Kotlin can be used in Android development in addition to others where Java and JavaScript work</li>
<li>There is already excellent IDE support (Intellij and Eclipse)</li>
<li>Kotlin is highly suitable for enterprise Java shops</li>
<li>It has the strong commercial support of an established software company</li>
</ul>
<p>Read through <a href="https://medium.com/@octskyward/why-kotlin-is-my-next-programming-language-c25c001e26e3">Mike’s article</a> for more on the rationale for using Kotlin. Hopefully though, this list is enough to convince you to seriously consider Kotlin for your next API. To see how easy this can be, we’ll explain how to use Kotlin with a <a href="http://www.sparkjava.com/">micro-services framework called Spark</a>. We’ll delve deep into Spark in the next part of this series, but now we’ll explain some of the great Kotlin language features with some <a href="https://github.com/travisspencer/kotlin-spark-demo/commit/3ebce75345c6a4ac08710578de42bbc7a5a1d297#diff-600376dffeb79835ede4a0b285078036">sample code</a>.</p>
<h1>Examples of Kotlin’s Syntax</h1>
<p>To see how Kotlin can be used to <a href="http://nordicapis.com/top-5-development-tips-for-a-killer-api/">create killer APIs</a>, we’ll walk through a sample that demonstrates many of the language’s features in the context of APIs. You can find the <a href="https://github.com/travisspencer/kotlin-spark-demo/">entire code on Github</a>, and it’s all open source.</p>
<p>To start, here’s the API’s entry point:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>)</span></span> = api(composer = ContainerComposer()) {
    route(path(<span class="hljs-string">"/login"</span>, to = LoginController::<span class="hljs-class"><span class="hljs-keyword">class</span>, <span class="hljs-type">renderWith = "login.vm")</span>,
          <span class="hljs-type">path</span></span>(<span class="hljs-string">"/authorize"</span>, to = AuthorizeController::<span class="hljs-class"><span class="hljs-keyword">class</span>, <span class="hljs-type">renderWith = "authorize.vm")</span>,
          <span class="hljs-type">path</span></span>(<span class="hljs-string">"/token"</span>, to = TokenController::<span class="hljs-class"><span class="hljs-keyword">class</span>))</span>
}</code></pre>
<p>Note that what we have is very readable even with zero knowledge of Kotlin. <strong>This snippet starts an API that exposes various paths that are routed to controllers, some of which are rendered by a template and others that are not.</strong> Easy. Kotlin lends itself to creating fluent APIs like this one, making for very readable code and approachable frameworks.</p>
<h2>Functions and Constructors</h2>
<p>To create our Domain Specific Language (<a href="https://en.wikipedia.org/wiki/Domain-specific_language">DSL</a>) for hosting APIs, we’re using several of Kotlin’s syntactic novelties and language features. Firstly:</p>
<ul>
<li><strong>Constructors</strong>: In Kotlin, you do not use the <code>new</code> keyword to instantiate objects; instead, you use the class name together with parenthesis, as if you were invoking the class as a function (a la Python). In the above snippet, a new <code>ContainerComposer</code> object is being created by invoking its <a href="http://kotlinlang.org/docs/reference/classes.html#constructors">default constructor</a>.</li>
<li><strong>Functions</strong>: <a href="http://kotlinlang.org/docs/reference/functions.html#function-declarations">Functions</a>, which begin with the <code>fun</code> keyword, can be defined in a class or outside of one (like we did above). This syntax means that we can write Object Oriented (OO) code or not. This will give you more options and potentially remove lots of boilerplate classes.</li>
<li><strong>Single expression functions</strong>: The fluent API allows us to wire up all our routes in a single expression. When a <a href="http://kotlinlang.org/docs/reference/functions.html#single-expression-functions">function consists of a single expression</a> like this, we can drop the curly braces and specify the body of our function after an equals symbol.</li>
<li><strong>Omitting the return type</strong>: When a function does not return a value (i.e., when it’s “void”), the return type is <code>Unit</code>. In Kotlin, <a href="http://kotlinlang.org/docs/reference/functions.html#unit-returning-functions">you do not have to specify this</a>; it’s implied.</li>
</ul>
<p>If we weren’t to use these last two features, the slightly more verbose version of our main function would be this:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>)</span></span> : <span class="hljs-built_in">Unit</span> {
    <span class="hljs-comment">// ...</span>
}</code></pre>
<p>The difference is only a few characters, but the result is less noisy.</p>
<h2>Named Arguments and Passing Function Literals</h2>
<p>The next part of this main method is the call to the <code>api</code> function. This function uses a few other interesting features:</p>
<ul>
<li>
<p><strong>Named arguments</strong>: When calling the <code>path</code> function, we’re <a href="http://kotlinlang.org/docs/reference/functions.html#named-arguments">specifying certain arguments by name</a> (e.g., <code>to</code> and <code>renderWith</code>). Doing so makes the code more fluid.</p>
</li>
<li>
<p><strong>Passing function literals outside the argument list</strong>: When a function, like our <code>api</code> function, expects an argument that is itself a function, you can pass it after closing the argument list. This cleans up the code a lot. To see what we mean by this, observe the <code>api</code> function definition:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">api</span><span class="hljs-params">(composer: <span class="hljs-type">Composable</span>, routes: ()</span></span> -> List&#x3C;Controllable>) {
    <span class="hljs-comment">// ...</span>
}</code></pre>
</li>
</ul>
<p>This function takes two arguments:</p>
<ol>
<li>The composer (more on that in the next part of this series)</li>
<li>The routes as a function that takes no arguments and produces a list</li>
</ol>
<p>The second argument is the interesting one. It is a <a href="http://kotlinlang.org/docs/reference/lambdas.html">lambda expression</a>. In Kotlin, <strong>lambdas</strong> are written as <code>() -> T</code> where the parentheses contain the possibly-empty list of arguments and their types, an arrow symbol (i.e., <code>-></code> or “produces”), and the return type. Our <code>api</code> function uses this syntax to define it’s last argument. In Kotlin, when the last argument of a function is also a function, we can pass the lambda expression <em>outside</em> of the call. Without this capability, calling the <code>api</code> method would look like this:</p>
<pre><code class="hljs language-kotlin">api(ContainerComposer(), {
    <span class="hljs-comment">// ...</span>
})</code></pre>
<p>See the difference? If you’re a jQuery programmer, you’re probably numb to it. Have a look at this contrived example that shows the difference more clearly:</p>
<pre><code class="hljs language-kotlin">a({
    b({
        c({
        })
    })
})</code></pre>
<p>See it now? When a method takes a function literal as an argument, you end of with a grotesque interchange of parentheses and braces. Instead, Kotlin allows us to pass the body of the function literal after the method call. JQuery programmers unite! This is your way out of the flip-flopping trap of delimiters you’ve found yourself in! Instead, Kotlin allows you write this sort of oscillation like this:</p>
<pre><code class="hljs language-kotlin">a() {
    b() {
        c()
    }
}</code></pre>
<p>So clear. So easy to understand. This convention is what we’re using in the call to the <code>api</code> function. Our routes are defined in a lambda that returns a list of <a href="http://kotlinlang.org/docs/reference/data-classes.html">data objects</a> (which we’ll explain shortly). The result is <a href="https://github.com/travisspencer/kotlin-spark-demo/blob/master/src/main/kotlin/com/nordicapis/kotlin_spark_sample/main.kt">half a dozen lines of code</a> that start a Web server which hosts our API, sets up three routes, maps them to controllers, and associates templates to certain endpoints. That’s the powerful triad we mentioned early — <strong>language, runtime, and JVM-based frameworks</strong> — that allow us to quickly start serving up APIs!</p>
<h2>Generics</h2>
<p>As you saw in the definition of the of the <code>api</code> function, Kotlin has support for <strong>generics</strong> (i.e., function templates). In Kotlin, generics aren’t confusing like they are in Java. The thing that makes Java’s generics so tricky is <a href="http://www.angelikalanger.com/GenericsFAQ/FAQSections/ParameterizedTypes.html#WIldcard%20Instantiations">wildcard parameterized types</a>. These were needed to ensure backward compatibility with older Java code. Kotlin doesn’t have wildcards, making it much easier to use generics in this new language. In fact, generics are so easy for Java and C# developers that there’s very little to say.</p>
<p>One aspect of Kotlin’s generics that may be unclear at first is the use of the <code>out</code> annotation on some template parameters. This is seen in the definition of the <code>RouteData</code> class <a href="https://github.com/travisspencer/kotlin-spark-demo/commit/3ebce75345c6a4ac08710578de42bbc7a5a1d297#diff-600376dffeb79835ede4a0b285078036">included in the sample code</a>:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RouteData</span></span>(
    <span class="hljs-keyword">val</span> path: String,
    <span class="hljs-keyword">val</span> controllerClass: Class,
    <span class="hljs-keyword">val</span> template: String? = <span class="hljs-literal">null</span>)</code></pre>
<p>This class is parameterized along with the constructor argument; <code>controllerClass</code>. Both have this extra modifier on <code>T</code> though. What does this mean? It means that the output type <code>T</code> will not be passed in as input; instead, the <code>RouteData</code> class will only produce objects of type <code>T</code> as output. This is what is referred to as <a href="http://kotlinlang.org/docs/reference/generics.html#declaration-site-variance">declaration-site variance</a>. Because the <code>RouteData</code> class does not consume any values of type <code>T</code> but only produces them as return values, the compiler knows that it is safe for any class that extends <code>Controllable</code> to be used as a parameter value, since they can always safely be upcast at runtime to the <code>Controllable</code> interface.</p>
<p>If <code>T</code> were not an output-only type, a potentially unsafe downcast would be required at run-time. By providing this extra bit of info to the compiler, we can avoid wildcards (i.e., something like <code>RouteData&#x3C;? extends Controllable></code> in Java) and end up with safer, more easy-to-use generics.</p>
<h2>Data Classes</h2>
<p><a href="http://kotlinlang.org/docs/reference/data-classes.html">The <code>data</code> annotation</a> is another interesting feature of Kotlin that we’re using in the <code>RouteData</code> class. This modifier tells the compiler that objects of this type will only hold data. This allows it to synthesize a bunch of boilerplate code for us. Specifically, the compiler will implement the following methods for us:</p>
<ul>
<li><code>equals</code></li>
<li><code>hashCode</code></li>
<li><code>toString</code></li>
<li><code>copy</code>; and</li>
<li>Getters and setters for each constructor parameter that is marked with <code>val</code> (i.e., read-only variables).</li>
</ul>
<p>After we define a data class we can also use it to <a href="http://kotlinlang.org/docs/reference/data-classes.html#data-classes-and-multi-declarations">declare and set the values of multiple variables simultaneously</a> like this:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> (path, controllerClass, template) = routeData</code></pre>
<p>Given a data object of type <code>RouteData</code>, we can sort of pull it apart into constituent parts, where each property of the class is assigned to respective variables. This can help you write self-documenting code, and can also be used to return more than one value from a function.</p>
<h3>Multiple Return Values from Functions</h3>
<p>One attractive language feature of <a href="http://nordicapis.com/writing-microservices-in-go/">Golang</a> is its syntax that allows developers to define multiple return values for a function. In Go, you can write very descriptive code like this:</p>
<pre><code class="hljs language-kotlin">func (file *File) Write(b []byte) (n int, err error) {
    <span class="hljs-comment">// ...</span>
}</code></pre>
<p>This says that the function <code>Write</code> returns two values: an integer called <code>n</code> and <code>err</code>, an <code>error</code> object. This unique language construct obviates the need to pass references to objects that the function will modify when an additional return value is also needed. This is what one has to do in Java, which you can see in a <a href="https://github.com/travisspencer/stockholm-java-meetup-java-spark-demo/blob/master/src/main/java/java_meetup_spark_demo/Example08/Controllable.java">Java-based version of our <code>Controllable</code> type</a>:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Controllable</span> </span>{
    <span class="hljs-keyword">default</span> boolean <span class="hljs-keyword">get</span>(Request request, Response response,
        <span class="hljs-keyword">final</span> Map&#x3C;String, Object> model) { <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; }

    <span class="hljs-keyword">default</span> boolean post(Request request, Response response,
        <span class="hljs-keyword">final</span> Map&#x3C;String, Object> model) { <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; }

    <span class="hljs-keyword">default</span> boolean put(Request request, Response response,
        <span class="hljs-keyword">final</span> Map&#x3C;String, Object> model) { <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; }

<span class="hljs-comment">// ...</span>
}</code></pre>
<p>We want to return two things from <code>get</code>, <code>post</code>, <code>put</code>, etc. — a Boolean flag that will be used to abort routing if <code>false</code>, and the model that contains the template values (if templating is used by the view). Here the Java language is actually working against us, forcing us to write unclear code. Google Go would help us write this more clearly, and so does Kotlin.</p>
<p>In Kotlin, our <code>Controllable</code> type is defined like this:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Controllable</span> </span>{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">get</span><span class="hljs-params">(request: <span class="hljs-type">Request</span>, response: <span class="hljs-type">Response</span>)</span></span>:
        ControllerResult = ControllerResult()

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">post</span><span class="hljs-params">(request: <span class="hljs-type">Request</span>, response: <span class="hljs-type">Response</span>)</span></span>:
        ControllerResult = ControllerResult()

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">put</span><span class="hljs-params">(request: <span class="hljs-type">Request</span>, response: <span class="hljs-type">Response</span>)</span></span>:
        ControllerResult = ControllerResult()

    <span class="hljs-comment">// ...</span>
}</code></pre>
<p>Kotlin allows us to say that our controller’s methods return a <code>ControllerResult</code> type. Like <code>RouteData</code> described above, <code>ControllerResult</code> is a data class:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ControllerResult</span></span>(
        <span class="hljs-keyword">val</span> continueProcessing: <span class="hljs-built_in">Boolean</span> = <span class="hljs-literal">true</span>,
        <span class="hljs-keyword">val</span> model: Map&#x3C;String, Any> = emptyMap())</code></pre>
<p>With this one line, we can easily define a result type that we can use in the <code>Router</code> to control the flow of processing requests and provide views with model data.</p>
<p>Big deal, you may say. Create a class in Java and do the same. Sure. With Java though, our <code>ControllerResult</code> class becomes 50 annoying lines of code after we implement <code>equals</code>, <code>toString</code>, <code>hashCode</code>, a copy constructor, getters, and setters. As we described above, data classes include all these in <strong>one line of code</strong>. Take that in like a cool refreshing drink after a long day’s work in the hot summer sun!</p>
<p>Using data classes, our controllers can override methods in the <code>Controllable</code> class like this:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">get</span><span class="hljs-params">(request: <span class="hljs-type">Request</span>, response: <span class="hljs-type">Response</span>)</span></span>: ControllerResult =
    ControllerResult(model = mapOf(
        <span class="hljs-string">"user"</span> to request.session(<span class="hljs-literal">false</span>).attribute(<span class="hljs-string">"username"</span>),
        <span class="hljs-string">"data"</span> to mapOf(
                <span class="hljs-string">"e1"</span> to <span class="hljs-string">"e1 value"</span>,
                <span class="hljs-string">"e2"</span> to <span class="hljs-string">"e2 value"</span>,
                <span class="hljs-string">"e3"</span> to <span class="hljs-string">"e3 value"</span>)))</code></pre>
<p>Using the <code>to</code> keyword and a read-only map produced by the standard Kotlin library’s <code>mapOf</code> function, we end up with a very succinct yet readable implementation of this method. Refer to the Kotlin docs for more info about <a href="http://kotlinlang.org/docs/reference/idioms.html#read-only-map">creating maps with the <code>to</code> keyword</a>, <a href="http://kotlinlang.org/api/latest/jvm/stdlib/kotlin/map-of.html">the <code>mapOf</code> function</a>, and <a href="http://kotlinlang.org/docs/reference/classes.html#overriding-members">overriding methods defined in a base class</a>. For now though, let’s see how we can use the <code>ControllerResult</code> objects in a safe and intuitive manner using one of the coolest Kotlin language features.</p>
<h2>Smart Casts</h2>
<p>As we’ll discuss more in the next part of this blog series, the methods of our Controllers are invoked dynamically depending on the HTTP method used by the client. This is done in <a href="https://github.com/travisspencer/kotlin-spark-demo/blob/master/src/main/kotlin/com/nordicapis/kotlin_spark_sample/Router.kt">the <code>Router</code> class</a> like this:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> httpMethod = request.requestMethod().toLowerCase()
<span class="hljs-keyword">val</span> method = controllerClass.getMethod(httpMethod, javaClass(), javaClass())
<span class="hljs-keyword">val</span> result = method.invoke(controller, request, response)

<span class="hljs-keyword">if</span> (result <span class="hljs-keyword">is</span> ControllerResult &#x26;&#x26; result.continueProcessing) {
   controller.after(request, response)

   model = result.model
}</code></pre>
<p>In the first three lines, we are using reflection to invoke a method on the controller that has the same name as the HTTP method specified by our API consumer. <code>Invoke</code> is defined in the Java runtime to return an <code>Object</code> which Kotlin represents as <code>Any</code>. This is helpful because two of our <code>Controllable</code>’s methods, <code>before</code> and <code>after</code>, do not return <code>ControllerResult</code> objects while the bulk of them do. Using <a href="http://kotlinlang.org/docs/reference/typecasts.html#smart-casts">Kotlin’s smart casting language feature</a>, we can write <strong>very clear and safe code</strong> to handle this discrepancy.</p>
<p>In the snippet above, we check at run time to see if the <code>Any</code> object is of type <code>ControllerResult</code>. This is done using <a href="http://kotlinlang.org/docs/reference/typecasts.html#smart-casts">Kotlin’s is operator</a> in the if statement. If it is, we also check to see if the data object’s <code>continueProcessing</code> property returns <code>true</code>. We do this <em>without</em> casting it. On the right side of the logical <code>&#x26;&#x26;</code> operator, Kotlin treats the <code>result</code> object not as type <code>Any</code> but as type <code>ControllerResult</code>. Without having to write code to perform the cast, we can access the object’s <code>ContinueProcessing</code> property. Without smart casting and without properties, we’d have to write this conditional statement verbosely in Java like this:</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">if</span> (result <span class="hljs-keyword">instanceof</span> ControllerResult) {
    ControllerResult controllerResult = (ControllerResult)result;

    <span class="hljs-keyword">if</span> (controllerResult.getContinueProcessing()) {
        <span class="hljs-comment">// ...</span>
    }
}</code></pre>
<p>Even with C#’s <code>as</code> operator, we end up with code that isn’t as clear as Kotlin’s. In C#, we’d have to write this:</p>
<pre><code class="hljs language-kotlin">ControllerResult controllerResult = result <span class="hljs-keyword">as</span> ControllerResult

<span class="hljs-keyword">if</span> (controllerResult != <span class="hljs-literal">null</span> &#x26;&#x26; controllerResult.continueProcessing) {
    <span class="hljs-comment">// ...</span>
}</code></pre>
<p>Kotlin lets us avoid all this confusing, verbose code. This will ensure that our intent is more clear, and help us find and fix bugs in our APIs more quickly.</p>
<p><a href="http://www.meetup.com/Stockholm-Java-User-Group/events/224295980/"><img src="http://nordicapis.com/wp-content/uploads/Java-Meetup-Medium-CTA-01.png" alt="Java Meetup Medium CTA-01"></a></p>
<h1>Using Kotlin</h1>
<p>Because of its interoperability with other tools in the Java ecosystem, it is very easy to start using Kotlin. You can leverage all of the same tools and knowledge that you are using today in your Java development. Building with Ant or Maven? Those work with Kotlin. Writing code in Intellij IDEA, Eclipse, or Sublime? Keep using them!</p>
<p>To get started using your favorite tools with Kotlin, here’s some helpful links:</p>
<ul>
<li><a href="http://kotlinlang.org/docs/tutorials/getting-started.html">Intellij IDEA</a></li>
<li><a href="https://github.com/vkostyukov/kotlin-sublime-package">Kotlin Sublime Text 2 Package</a></li>
<li><a href="http://kotlinlang.org/docs/tutorials/getting-started-eclipse.html">Eclipse</a></li>
<li><a href="http://kotlinlang.org/docs/reference/using-maven.html">Maven usage guide</a></li>
<li><a href="http://kotlinlang.org/docs/reference/using-gradle.html">Using Gradle with Kotlin</a></li>
<li><a href="http://kotlinlang.org/docs/reference/using-ant.html">Ant integration</a></li>
</ul>
<h2>Converting Existing Code</h2>
<p>When you start using Kotlin, it can help to convert an existing Java project to this new language. Then, you can see how familiar code looks using Kotlin. To convert existing code, you have to use <a href="http://kotlinlang.org/docs/tutorials/getting-started.html">Intellij</a>, <a href="http://kotlinlang.org/docs/tutorials/getting-started-eclipse.html">Eclipse</a>, or (if you only have a snippet) the <a href="http://try.kotlinlang.org/">Kotlin on-line console</a>. In the end, you will probably rewrite a lot of the converted code to use more idioms and Kotlinic styles, but converting existing code is a great starting point.</p>
<h2>Compiling Kotlin</h2>
<p>Whether you convert your code or write it from scratch, you are going to need to compile it. The IDE plug-ins make this easy while you’re working. In order to use this language in larger projects, however, you are going to need to automate those builds. This will require integration with Maven, Ant, or Gradle. Jetbrains and the Kotlin community provides these out of the box, and usage is as you would expect. For an existing Java-based project using one of these, switching to Kotlin can be done by replacing just a few lines in your build script. For instance, the sample project accompanying this series was converted to compile Kotlin code instead of Java <a href="https://github.com/travisspencer/kotlin-spark-demo/commit/3ebce75345c6a4ac08710578de42bbc7a5a1d297#diff-600376dffeb79835ede4a0b285078036">with just a few dozen lines</a>.</p>
<h2>Debugging</h2>
<p>Compiling code isn’t necessarily working code. To make your software functional, you can use one of the many JVM-based logging frameworks to print out debug statements. You can see this in the sample project that uses SLF4J and Log4j to print statements about API requests and responses. Here’s an indicative sample from the <code>AuthorizationController</code>:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthorizeController</span> : <span class="hljs-type">Controllable</span></span>() {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _logger = LoggerFactory.getLogger(javaClass())

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">before</span><span class="hljs-params">(request: <span class="hljs-type">Request</span>, response: <span class="hljs-type">Response</span>)</span></span>: <span class="hljs-built_in">Boolean</span> {
        _logger.trace(<span class="hljs-string">"before on Authorize controller invoked"</span>)

        <span class="hljs-keyword">if</span> (request.session(<span class="hljs-literal">false</span>) == <span class="hljs-literal">null</span>) {
            _logger.debug(<span class="hljs-string">"No session exists. Redirecting to login"</span>)

            response.redirect(<span class="hljs-string">"/login"</span>)

            <span class="hljs-comment">// Return false to abort any further processing</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
        }

        _logger.debug(<span class="hljs-string">"Session exists"</span>)

        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
    }

    <span class="hljs-comment">// ...</span>
}</code></pre>
<p>A few things to note about that snippet before we move on:</p>
<ul>
<li>It’s normal SLF4J stuff, so there’s no learning curve for Java devs.</li>
<li>The SLF4J <code>LoggerFactory</code> requires a static class to initialize it. This is a Java class, so we use Kotlin’s <code>::class</code> syntax to get <a href="http://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-class/">a <code>KClass</code> object</a> and then call its <code>java</code> extension property. Voila! Java interop :)</li>
</ul>
<p>Basic instrumentation will only take you so far; sometimes you need to roll up your sleeves and dive into the running code though. You can do this <em>easily</em> in Intellij and Eclipse using those tools’ debuggers just as you would with your Java code. In these environments, you have all the same tools you have come to rely on when debugging other JVM-based code. For instance, the <strong>call stack</strong>, list of <strong>running threads</strong>, <strong>expression evaluation</strong>, and of course <strong>breakpoints</strong>, are all available to you! Here’s a screenshot of the above code running in Intellij with the debugger attached:</p>
<p><img src="http://nordicapis.com/wp-content/uploads/debugging.png" alt="debugging"></p>
<p>Finding bugs will be <del>easy</del> <em>easier</em> with that. This is a <em>very</em> compelling example of why Kotlin is a better choice for creating large-scale APIs than some other languages (e.g., Go). (<a href="http://golang.org/doc/gdb">Golang can be debugged using GDB</a>, but that tool is not nearly as user-friendly as Intellij’s and Eclipse’s debuggers.)</p>
<h1>Conclusion</h1>
<p>Unlike other programming environments, the JVM gives you both language and vendor choices that can help you create incredible API. On the JVM you can choose between <strong>dynamic</strong> languages like Groovy, <strong>functional</strong> ones like Scala and Clojure, and now another rival — <a href="http://kotlinlang.org/">Kotlin</a>. We talked through a number of reasons to use this language, and showed some of the features this new JVM upstart delivers.</p>
<p>All this is great, you may be saying, but what’s the catch? There are <a href="https://medium.com/@octskyward/why-kotlin-is-my-next-programming-language-c25c001e26e3#5cef">some drawbacks</a>, but they are minor. The strongest argument against Kotlin is its immaturity — it isn’t at v1 yet. This is a problem that will inevitably be fixed with a bit more time. Even now at milestone 12, the compiler gives you warnings about the use of deprecated language features that will not be included in the initial release. This makes it easy to pivot and prepare.</p>
<p><a href="https://2015.battlehack.org/stockholm"><img src="http://nordicapis.com/wp-content/uploads/battlehack.png" alt="battlehack"></a>In <a href="http://nordicapis.com/building-apis-on-the-jvm-using-kotlin-and-spark-part-2/">part 2</a> of this series, we delve deeper into <a href="http://www.sparkjava.com/">Spark</a> and explain it more using the <a href="https://github.com/travisspencer/kotlin-spark-demo/">sample Kotlin code</a> we started developing in this post. In the meantime, be sure to <a href="http://www.meetup.com/Stockholm-Java-User-Group/events/224295980/">register for our upcoming event in Stockholm</a> where we’ll be discussing Kotlin, Clojure, Groovy, and building APIs on the JVM. Learning more about Kotlin could also give you the edge you’ll need if you plan to participate in PayPal’s upcoming hackathon, <a href="https://2015.battlehack.org/stockholm">BattleHack</a>, which is happening on November 14th and 15th in Stockholm.</p>
<p>Continue to Part 2: <a href="http://nordicapis.com/building-apis-on-the-jvm-using-kotlin-and-spark-part-2/">Building APIs on the JVM Using Kotlin and Spark – Part 2</a></p>
<h2>Kotlin Resources</h2>
<p>If you aren’t going to be in Stockholm this month for the meetup, you can also learn more about this new language from these resources:</p>
<ul>
<li><a href="http://kotlinlang.org/docs/reference/">Kotlin language reference</a> (start here)</li>
<li><a href="https://gist.github.com/dodyg/5823184">Kotlin programming language cheat sheet</a></li>
<li><a href="http://blog.jetbrains.com/kotlin/2011/10/dsls-in-kotlin-part-1-whats-in-the-toolbox-builders/">Designing DSLs in Kotlin</a></li>
<li><a href="https://www.reddit.com/r/programming/comments/3chgp3/why_kotlin_is_my_next_programming_language/?submit_url=https%253A%252F%252Fmedium.com%252F%2540octskyward%252Fwhy-kotlin-is-my-next-programming-language-c25c001e26e3&#x26;already_submitted=true&#x26;submit_title=%22Why+Kotlin+is+my+next+programming+language%22+by+Mike+Hearn">RE: Why Kotlin is my next programming language – SubReddit discussion</a></li>
<li><a href="https://github.com/travisspencer/kotlin-spark-demo/commit/3ebce75345c6a4ac08710578de42bbc7a5a1d297#diff-600376dffeb79835ede4a0b285078036">Sample Web API project using Kotlin and Spark</a></li>
<li><a href="http://www.meetup.com/Stockholm-Java-User-Group/events/224295980/">Getting the most from the JVM using Java, Clojure, Kotlin &#x26; Groovy meetup in Stockholm</a></li>
<li><a href="http://nordicapis.com/building-apis-on-the-jvm-using-kotlin-and-spark-part-2/">Building APIs on the JVM Using Kotlin and Spark – Part 2</a></li>
</ul>
<p><em>[Disclosure: PayPal is a sponsor of the Java Stockholm meetup being produced by Nordic APIs]</em></p>
]]></description><link>http://nordicapis.com/building-apis-on-the-jvm-using-kotlin-and-spark-part-1/</link><guid isPermaLink="true">http://nordicapis.com/building-apis-on-the-jvm-using-kotlin-and-spark-part-1/</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Travis Spencer]]></dc:creator><pubDate>Thu, 06 Aug 2015 09:00:00 GMT</pubDate></item><item><title><![CDATA[(RU) Без слайдов: интервью с Дмитрием Жемеровым из JetBrains]]></title><description><![CDATA[<p>Сегодня пятница, а пятница на хабре — это отличный день для чего-то необычного. Сегодня я предлагаю вашему вниманию интервью с <strong>Дмитрием <a href="https://habrahabr.ru/users/yole/">yole</a> Жемеровым</strong>, человеком, который приложил руку и к IntelliJ IDEA, PyCharm, Kotlin и многим другим продуктам компании JetBrains.</p>
<p>О чем мы поговорили:</p>
<ul>
<li>как развивается IDEA, куда она движется</li>
<li>в чем разница между IntelliJ и JetBrains</li>
<li>зачем в компании два CEO</li>
<li>что происходит в Kotlin'e</li>
<li>с какими трудностями столкнулась команда Kotlin в процессе разработке языка</li>
<li>что такое Language Design Review</li>
<li>что представляет собой современный Google</li>
<li>почему закрылся Google Code</li>
<li>почему хабр важен для разработчиков IDE</li>
</ul>
<iframe src="https://www.youtube.com/embed/pr7faOqruQY?feature=oembed" allowfullscreen="" height="315" frameborder="0" width="560"></iframe>
<p>— <strong>Добрый день! Это «Без слайдов». У нас выпуск сегодня с Дмитрием Жемеровым, ветераном компании JetBrains. Дима, давай начнем с того, что ты чуть-чуть о себе расскажешь: что делал, и в JetBrains в том числе?</strong></p>
<p>В JetBrains я пришел в 2003 году. Я был 28-м или 29-м сотрудником, и за это время успел довольно много чем позаниматься. Я вначале был руководителем разработки проекта <a href="https://www.jetbrains.com/omea/">Omea</a> – был такой information-агрегатор, то есть это программа, которая собирала информацию из разных источников типа почты, news’ов, RSS-фидов. Он позволял делать по ним всем поиск, это все организовывать, категоризовывать и так далее. Потом проект Omea был закрыт, и я перешел в команду IntelliJ IDEA. Можно сказать, стоял у истоков такой сущности, как IntelliJ-платформа, то есть занимался переводом монолитной среды разработки IntelliJ IDEA в платформу, на базе которой можно строить IDE для разных языков, а не только для Java. Понятно, что в этом много кто поучаствовал, но я тоже там довольно много сделал. Потом я занимался различными IDE на базе этой платформы: я успел позаниматься и RubyMine, и PyCharm, и WebStorm.</p>
<p>— <strong>Куда, по-твоему, сейчас движется вообще IDEA как продукт, как платформа? Есть ощущение, что возникла некоторая стагнация: мне как пользователю IntelliJ IDEA кажется, что ничего не происходит. Выходят новые версии, они, может быть, быстрее работают, поддерживают новые framework'и. Так это, не так?</strong></p>
<p>Быстрее – это самое главное. Скорость – это такая фича, от которой никто никогда не отказывается. Мы уже довольно долгое время вкладываемся в качество пользовательских интерфейсов, юзабилити, в то, чтобы было все аккуратно, гладенько. Большие фичи, которые меняют ваш experience как девелопера, тоже появляются в каком-то количестве. Например, Inline Debugging, который у нас появился в 14ой версии. Когда вы step’аетесь по коду, вы сразу прямо в коде, в редакторе видите значение переменных, которые на этих строчках вычисляются. Или, например, незадолго до этого появилась поддержка нескольких кареток в редакторе – это тоже большая фича, которая для многих имеет значение. Что будет следующим, я сказать на самом деле не могу, потому что у нас процесс разработки не очень сильно далеко вперед планируется, и просто разработчику может внезапно прийти в голову идея: «Давайте-ка я займусь этой функциональностью. Давайте-ка я ее сделаю». Он пойдет и сделает, и она появится в релизе, и будет все здорово.</p>
<p>— <strong>Около 3 лет назад Олег Степанов и Максим Шафиров стали CEO компании JetBrains. Во-первых, почему их два? Я не помню каких-то таких случаев, когда CEO сразу двое. Что изменилось за эти годы? Какие, может быть, задачи и цели перед ними ставились, если это открытая информация, и насколько это успешно? Что в компании изменилось?</strong></p>
<p>Два CEO — это довольно удобно оказалось, потому что два офиса. Олег живет в Мюнхене, Макс живет в Питере, и каждый из них отвечает в первую очередь за то, что происходит в их офисе. Там просто много работы, и они как-то эту работу между собой делят. Макс сейчас очень активно занимается вообще всей нашей инфраструктурой продаж, то есть нашей внутренней корпоративной информационной системой, если угодно, магазином. Тем, чтобы пользователи имели в этом месте хороший experience. Олег занимается довольно много нашими серверными инструментами, чтобы из нашего зоопарка в лице YouTrack, TeamCity и Upsource, сделать какое-то единое решение, которое можно просто поставить, и оно решит все проблемы с процессом разработки, которые есть в вашей в команде.</p>
<p>— <strong>То есть, кроме разделения по офисам, есть еще разделение по продуктам?</strong></p>
<p>Это даже не столько по продуктам, сколько по областям деятельности. У нас, как и все в JetBrains, это как-то органически случается. Когда мы эту схему внедряли, у нас не было такого сразу, что давайте договоримся, кто за что отвечает – просто по ходу дела получается, что эта деятельность, ею надо заниматься, и, соответственно, тот человек, который может ее на себя взять, ее на себя берет.</p>
<p>— <strong>Как ты оцениваешь эти 3 года? Что изменилось глобально?</strong></p>
<p>В плане организации работы в принципе, JetBrains остался тем же самым. Случились какие-то довольно большие проекты, например, переезд в наш новый офис на Васильевском острове, в котором Сергей Дмитриев, который до этого был руководителем компании, вообще никакого участия не принимал. Или, например, в организации продаж. Много чего изменилось за это время у нас внутри компании, какие-то вещи смогли сделать большие.</p>
<p>— <strong>Два CEO — это такой эксперимент, который продолжается? Уже видны его результаты, или все еще в процессе? Или в принципе не ожидалось каких-то глобальных изменений?</strong></p>
<p>Нет, на самом деле просто в первую очередь мотивация для этого решения была очень простая. Сергей Дмитриев в какой-то момент сказал: «Я уже не молодой, грубо говоря. Я могу либо продолжать делать дальше JetBrains, либо я могу оставить JetBrains, который был сделан, каким-то другим людям из команды, и сам пойти заниматься какой-то другой деятельностью». Судя по тому, что он эти 3 года успешно занимается другой деятельностью, не отвлекаясь на JetBrains или очень мало отвлекаясь на JetBrains, то, в общем-то, все получилось. JetBrains за это время растет, успешно разется и так далее. Эта задача была в полной мере выполнена.</p>
<p>— <strong>На твоем <a href="http://yole.ru">старом сайте</a> есть запись, датированная 2003 годом, что ты устроился в IntelliJ Labs. Сейчас мы компанию знаем как JetBrains. Ты можешь немножко рассказать о связи JetBrains и IntelliJ Labs?</strong></p>
<p>Это очень просто. IntelliJ Labs – это название, под которым компания появилась. В 2000-2001 году первые версии IntelliJ IDEA были выпущены под маркой IntelliJ Software или IntelliJ Labs. Потом, когда стало понятно, что мы хотим делать продукты не только для Java, соответственно, название с буквой «J» нам не годится. Мы поставили букву «J» в начало и придумали название JetBrains. IntelliJ Labs до сих пор сохранилось в названии российского юридического лица нашей компании — ООО «ИНТЕЛЛИДЖЕЙ ЛАБС». «JetBrains» – это, соответственно, юрлицо headquarters компании.</p>
<p>— <strong>JetBrains, который был в середине 2000-х, и JetBrains образца 2015 года — чувствуешь ли ты какую-то разницу между ними, и если да, то что тебе нравится, что тебе не нравится?</strong></p>
<p>Понятно, что в компании такого размера просто уже другой уровень личных связей. Когда я из Мюнхена приезжаю в Питер, я хожу по офису и вижу массу людей, про которых я часто даже не знаю: они работают у нас в компании, они зашли к кому-то в гости или они просто пиццу привезли. Это люди, которых я не знаю; я не знаю, чем они занимаются. Положительно то, что JetBrains очень долгое время был хронически understaffed, то есть все время было состояние, что работы было больше, чем людей, которые имеются, чтобы ее делать. Мне кажется, что в последнее время в очень многих проектах мы из этого состояния выходим – не во всех, но во многих. Грубо говоря, у нас столько людей, сколько нужно, чтобы реально продукты вперед двигать.</p>
<p>— <strong>Сейчас у вас 300 человек, 400?</strong></p>
<p>400 с чем-то.</p>
<p>— <strong>Это в основном Питер и Мюнхен, да?</strong></p>
<p>Да, у нас сейчас, наверное, 80 человек в Мюнхене и, соответственно, 400 с чем-то в Питере пока.</p>
<p>— <strong>Сотни людей. Распределенность создает вам какие-то сложности?</strong></p>
<p>Мне не кажется, что создает. Как правило, в Мюнхен уезжают люди, которые уже какое-то время проработали в питерском офисе, которые уже знакомы с командой, с которой они вместе работают. Соответственно, нет такого, что у тебя появляется какой-то внезапный человек в другом офисе, с которым тебе нужно как-то налаживать отношения. Плюс к этому, мы часто друг к другу ездим.
— <strong>Ты сам часто ездишь сюда?</strong></p>
<p>Каждые два-три месяца я точно в Питере бываю. Плюс к тому, у нас каждый день стендапы по видеоконференции, то есть каждый день есть какое-то количество личного общения через видеосвязь. Мне кажется, что у нас нет проблем из-за того, что мы распределенные.</p>
<p>Более того, я бы хотел, чтобы мы были более распределенными. Я бы хотел, чтобы мы имели возможность нанимать на работу людей, например, в Silicon Valley. Тех, которых там все устраивает, и они не хотят переезжать.</p>
<p>— <strong>У вас рабочий язык английский, русский?</strong></p>
<p>Русский. Комментарии в коде всегда по-английски, всякая внутренняя коммуникация – стараемся всегда по-английски, а устное общение всегда по-русски, за исключением тех редких случаев. У нас все-таки есть некоторое количество не говорящих на русском сотрудников, и с ними, конечно, мы по-английски общаемся.</p>
<p>— <strong>Понятно. Теперь еще одна интересная история. Буквально пару недель назад Андрей Бреслав выпустил <a href="http://megamozg.ru/p/15794/">пост</a>, на который очень многие обратили внимание, в котором, в общем, активно искал на самом деле product-менеджеров. Такой вопрос отсюда: вы недовольны своими product-менеджерами или просто ищите?</strong></p>
<p>Мы ищем людей на позицию, которая называется «Product Marketing Manager» (PMM). На самом деле, у нас очень хорошая команда подобралась. Насколько я знаю, мы довольны всеми, кто у нас сейчас на этой позиции работает. Андрей искал человека конкретно в Kotlin, где сейчас PMM просто нет. Или, например, в IntelliJ IDEA сейчас всего один человек, Андрей Чепцов, занимается продуктовым маркетингом. Это большой продукт, сложный, с большим количеством разных фич, и понятно, что там есть работа и на второго человека, и, может быть, на третьего тоже.</p>
<p>— <strong>Около года назад в Kotlin пришел Илья Рыженков. Разве он не на позицию PMM пришел?</strong></p>
<p>Сейчас, по факту, получилось так, что Илья занимается в первую очередь библиотеками и инфраструктурой вокруг Kotlin'а. Он руководит командой, которая делает фреймворки для Kotlin’а, сам тоже код пишет. Мы постоянно экспериментируем с новыми фреймворками для Kotlin'а. Один у нас уже есть, но мы пробуем другие варианты, ищем, как можно было бы лучше сделать.</p>
<p>— <strong>А Андрей Бреслав?</strong></p>
<p>Андрей, во-первых, главный дизайнер языка, а во-вторых, он до недавних пор был проектным менеджером всей команды. Я недавно у него забрал менеджмент IDE-команды — у нас уже есть 5 человек, которые занимаются плагинами для IntelliJ IDEA, и теперь я их руководитель. Программировать Андрей как раз решил перестать недавно, потому что не хватает на это все времени. Мы стремимся сделать релиз поскорее, и в данный момент просто есть какое-то количество открытых вопросов по дизайну языка. Мы хотим как можно скорее их закрыть, и Андрей в первую очередь сосредоточен сейчас на этом.</p>
<p>— <strong>Пять человек — в одной только IDE? Когда я в последний раз плотно общался с командой Kotlin'а, это было пару лет назад, там было всего, по-моему, 9 человек. Видать, команда Kotlin’a с тех пор сильно выросла?</strong></p>
<p>Там больше 20 человек сейчас.</p>
<p>— <strong>То есть, компания реально инвестирует в Kotlin?</strong></p>
<p>Да.</p>
<p>— <strong>Два-три года назад складывалось ощущение, что выйдет Java 8, и все, дальше Kotlin будет не нужен. А вы сейчас только увеличили инвестиции. Вы делаете на него какую-то серьезную ставку? Пишете ли вы сами на нем?</strong></p>
<p>Да, у нас сейчас есть какое-то количество проектов, которые разрабатываются на Kotlin'e, но не так много, как мне лично бы хотелось. Например, следующая версия YouTrack пишется на Kotlin'е. У нас есть один не анонсированный продукт, он пишется тоже на Kotlin'е. Новая CRM-система, про которую я упоминал, вся на Kotlin'е от начала и до конца написана. Это business critical решение, через него все наши продажи проходят. Мы доверяем коду на Kotlin'е наши продажи, и это, как мне кажется, говорит о чем-то.</p>
<p>Ребята постоянно берут Kotlin из master'а, то есть они сидят не на релизных версиях, а каждые несколько дней апгрейдятся на самую последнюю версию Kotlin'а из свежесобранного. При этом довольны, все работает.</p>
<p>Насчет Kotlin vs. Java 8 — на самом деле, это некоторая распространенное заблуждение. В первую очередь, Java довольно сильно завязана на свое legacy. В <a href="http://habr.ru/p/255219/">прошлом выпуске</a> «Без слайдов» это тоже обсуждалось. Сергей Куксенко говорил, что было бы здорово все выкинуть и написать с нуля. Он, наверное, скорее имел в виду библиотеку и виртуальную машину, но с точки зрения дизайна языка Java тоже есть решения, которые когда-то были приняты и которые будут с нами навсегда. Например, Raw Types, Wildcards, разделение на примитивные и непримитивные типы и так далее – это никуда не денется, и сколько бы Java не развивалась, эта legacy останется навсегда. Само по себе то, что мы не завязаны на эту обратную совместимость, нам уже развязывает руки, уже дает нам возможность делать какие-то интересные вещи.</p>
<p>Сейчас, когда я кому-то рассказываю о Kotlin'е, а я время от времени делаю доклады, я первые примерно 20 минут вообще никаких лямбд не упоминаю – просто показываю разные фичи Kotlin'а. Там есть очень много всего, что вообще не затрагивает тех изменений, которые произошли между седьмой и восьмой Jav'ой — просто вещи, в которых мы улучшаем ту часть Java, которая никак этим всем не затронута.</p>
<p>Потом уже, конечно, лямбды. У нас есть лямбды, и они лучше, чем в Java 8, потому что у нас есть на уровне языка поддержка инлайнинга. Смысл в том, что когда вы используете лямбду просто для того, чтобы пройтись по циклу какой-то очень простой функции – например, найти все элементы, которые больше, чем 8. Наивный способ это транслировать – сгенерировать inner class с одним методом, который проверяет, что число больше, чем 8. Потом у вас есть функция filter, которая, собственно, получает экземпляр этого класса и применяет его к каждому элементу коллекции, и есть код, из которого это все вызывается.</p>
<p>В Java все примерно так и работает. Там используется invokedynamic и method handle. Поэтому там часть этого генерируется во время исполнения. Как мы <a href="https://vimeo.com/131394615">узнали</a> на конференции Geekout, Java на данный момент не умеет это все инлайнить. А у нас есть поддержка на уровне языка. Мы просто говорим, что функция Filter помещается в инлайн. Это означает, что этот код, который внутри самой лямбды, и само тело функции записываются прямо в место, где мы вызываем. Соответственно, получается, что у нас нет никакого оверхеда по перформансу. У нас нет создания отдельных объектов. У нас нет каких-то виртуальных вызовов, не дай бог, еще мегаморфных. Наш код делает ровно то же, что происходило бы, если бы вы написали все руками без использования лямбды.</p>
<p>— <strong>Я так понимаю, что именно invokedynamic является какой-то помехой для инлайна?</strong></p>
<p>Нет, я бы не сказал, что именно в invokedynamic'е дело, но инлайнинг так работает, что он не умеет понимать, что сквозь лямбду и функцию, через которую она передается, можно это все заинлайнить. Возможно, когда-нибудь этот недостаток в JVM будет устранен. Насколько я понимаю, над этим ведется работа, но в Kotlin'е на уровне языка это решено.</p>
<p>— <strong>Понятно. А сам Kotlin когда появился? Как вообще идея такая пришла в голову?</strong></p>
<p>Начинали мы, насколько я помню, примерно в конце 2010 года. Я не буду говорить, что это прямо я все придумал. В какой-то момент я пришел к Сергею Дмитриеву (одному из основателей JetBrains — прим. автора) и сказал, что было бы клево, если бы в JetBrains появился свой язык. Для меня это выглядело как естественное развитие. Наш слоган, —«Develop with pleasure», по-русски — «Разрабатывай с удовольствием». Мы довольно много делаем в области инструментов, чтобы люди действительно разрабатывали с удовольствием: рефакторинг, комплишен, подсветка ошибок – все, что мы очень хорошо умеем делать для 25 разных языков. Все равно мы видим, что IDE приходится делать затычки для недостатков языка.</p>
<p>Например, IDEA умеет анонимный класс показывать в виде лямбд. Если вы используете Java 6 или Java 7, вы пишете анонимные классы: new Instance, декларация метода, тело. В IDEA все это сворачивается в лямбду. Это в чистом виде затычка для недостатка языка. Мы решили, что мы можем попробовать просто сделать язык, в котором затычки будут не нужны, на котором будет просто приятно писать.</p>
<p>IDEA, конечно, все равно полезна и помогает, но она не является каким-то костылем. Было ощущение, что мы это сможем сделать, потому что у нас достаточно накоплен релевантный опыт с разработкой IDE-плагинов и поддержкой языков. Было ощущение, что у нас достаточно веса на рынке, чтобы народ это заинтересовало. Было ощущение, что это нам нужно самим, потому что мы так все там написали в поддержку того, сего, пятого, десятого, а сами программируем на Java.</p>
<p>Вся IDEA до сих пор написана на Java 6. Мы начали использовать Kotlin, но все остальное написано на Java 6. Было ощущение, что это то, что может выстрелить. Понятно было, что это история долгая, но наверное, я недооценивал, насколько она долгая.
Дальше это заронило какое-то зерно, там тоже это обсуждалось с разными другими людьми в разных других контекстах и так далее. Потом нам очень повезло познакомиться с Андреем Бреславом, и мы, собственно, начали делать сам язык. Я на начальном этапе тоже приложил руку — писал первую версию генератора байт-кода для JVM. Потом этим занимались другие люди, а я переключился на другие проекты. Я довольно долгое время Kotlin'ом не занимался и сейчас я вернулся именно в Kotlin.
А еще я название придумал. В какой-то момент пришел Дмитриев и сказал, что нужно название прямо сейчас. Типа, придумай название – и стоит над душой!</p>
<p>— <strong>Нравится название?</strong></p>
<p>Поначалу мы немного смущались, потому что у нас немецкий офис есть, а в немецком языке словом Kot обозначают нечто не очень благозвучное. Но на самом деле ни немцы, ни кто-то другой – не слышали этого. Так что вначале это было как временное название, коднейм, «Project Kotlin». Мы лишь потом поняли, что нам никакое другое название не нужно, нам и так неплохо.</p>
<p>— <strong>Буквально недавно анонсировалось, что вы со <a href="https://www.youtube.com/watch?v=-BvN0X5tqjw">Светой Исаковой</a> будете писать книжку про Kotlin. Расскажи, пожалуйста, что за книжка, кто был инициатором этого проекта, и как вообще весь процесс написания технической книги про язык устроен?</strong></p>
<p>Мы хотим сделать книжку про Kotlin именно для Java-разработчиков. Kotlin, конечно, не ограничен одной только Java: в нем есть поддержка компиляции в JavaScript, но на данный момент мы просто не готовы говорить про это, потому что у нас там много чего не доделано и будет доделываться, скорее всего, после релиза 1.0. Сейчас мы сосредоточены на поддержке компиляции под JVM: cерверная разработка, веб-разработка, компиляция под Android. Android на самом деле — сейчас очень горячее направление для нас.
Соответственно, книжка будет для людей, которые уже умеют программировать на Javа, которые знают про Generics и про JVM. Наличие такой книги позволит им легко переключиться на Kotlin. Книга расскажет, как именно при помощи Kotlin'а решить их задачи, и в частности, как интегрировать Kotlin в существующий Java-проект.</p>
<p>Важное свойство Kotlin'а заключается в том, что вам не нужно ничего выкидывать или менять — вы просто берете один класс и переписываете на Kotlin'е. Он становится в полтора раза меньше, в два раза красивее. Потом вы повторяете процедуру, в общем-то, с любым кодом, который вам зачем-то нужно менять. Код, который вы написали на Java и не трогаете, может оставаться на Java: он никому не мешает, никому не вредит. Зачем лишний шум вносить? А код, который вы активно модифицируете, вы просто по мере модификации переписываете на Kotlin. Мы, собственно, в IDEA планируем ровно таким путем пойти.</p>
<p>Теперь насчет того, как появилась книжка. Хорошо известно, что книжка — это очень полезная штука для популярности языка. Про Scala есть книжка, которую тоже очень многие читали и хвалили, и популярность Ruby on Rails началась с книжки. Поэтому в какой-то момент я понял, что заняться написанием книги было бы самой значимой штукой, которую я мог бы сделать. Я поговорил с коллегами, и они одобрили эту идею. Света Исакова, инженер Kotlin’а, сказала, что ей тоже было бы интересно этим заниматься.
Мы почитали, как устроен процесс написания книги про язык программирования. Нужно иметь Table of Contents (оглавление) и иметь первую главу. С этим можно идти в издательство. Мы накидали какое-то оглавление и начали собираться писать первую главу. В этот момент параллельно пришло письмо от издательства Manning, довольно абстрактное, мол, давайте поговорим про Kotlin. Не то, что они прямо звали нас писать книжку. Мы сказали им, что мы собираемся писать книжку, и что если им интересно, то мол, давайте приступать. Они ответили, что им интересно. Так мы и начали работу.</p>
<p>— <strong>Как будет называться книжка?</strong></p>
<p>«Kotlin in Action». In Action – это название серии их книг.</p>
<p><img src="https://habrastorage.org/files/7d8/46b/e36/7d846be36989482a9d078dd573c64c9f.jpg"></p>
<p>— <strong>А как Manning вас заметил в плане Kotlin'а? Они как-то мониторят информационное пространство?</strong></p>
<p>Да, есть такие люди, называются acquisition editors, обязанность которых заключается в том, чтобы выискивать темы, про которые было бы интересно издать книжку, и выискивают людей, которые могут такую книжку написать. Они на нас вышли, и мы с ними договорились. Тут взаимный интерес.</p>
<p>— <strong>Тогда немного странный вопрос. Обычно, когда автор пишет книжку, ему за это платят гонорар. Тут вы пишете книгу про продукт, который разрабатывается не только вами, но вашей компанией. Как этот вопрос вообще решается? Какие есть подходы к этому?</strong></p>
<p>Мы просто пишем книжку, нам платят гонорар. У нас будет гонорар, у нас прописано в контракте – обычные совершенно условия royalty.</p>
<p>— <strong>А JetBrains просто выделяет вам со Светой бюджет времени на это?</strong></p>
<p>Да. Дело в том, что у нас нет какого-то жесткого регламента, мол, можно вот этим заниматься Х часов в неделю. Книжка – это не единственное, чем я сейчас занимаюсь. Возможно, я об этом еще пожалею, но сейчас я книжку сочетаю с какой-то еще работой.</p>
<p>— <strong>Есть люди типа Венката Субраманиама, для которых написание книг и тренинги – это вообще основное направление деятельности.</strong></p>
<p>Я все-таки программист, я не могу не программировать.</p>
<p>— <strong>Понятно. У вас в какой-то момент это было вообще частью культуры</strong></p>
<p>До сих пор так, все программируют, оба CEO программируют.</p>
<p>— <strong>Интересно, что язык Kotlin в том виде, в котором он будет зарелизен, это не все, о чем думают люди, которые его разрабатывают. Есть такое ощущение, что вы еще думаете на несколько лет вперед. Почему это ощущение возникло? Я услышал в одном из выступлений Ильи Рыженкова о процедуре Language Design Review. Он тогда объяснил, что это делается для того, чтобы вы примерно понимали, какие проблемы в будущем у вас могут возникнуть. Не мог бы ты поподробнее про этот момент рассказать?</strong></p>
<p>У нас есть в голове какое-то количество направлений, куда может развиваться язык. Понятно, за 5 лет у нас накопилось какое-то количество мыслей. Мы понимаем, что это и это хорошо было бы сделать. Мы примерно знаем, если мы это будем делать, в каком месте нам нужно будет менять язык. Соответственно, мы сейчас хотим зафиксировать синтаксис в таком состоянии, чтобы те направления изменений, которые мы планируем, не требовали от нас сломать обратную совместимость с кодом.</p>
<p>Это для компании JetBrains, на самом деле, совершенно новая тема. Те, кто занимался разработкой плагинов IntelliJ IDEA, с проблемой ломающегося API сталкивались постоянно. В Kotlin’е мы хотим избежать этих проблем. Более того, мы знаем, что ничего не получится, если у нас будет совместимость Kotlin'а на том же уровне, на котором существует совместимость плагинов в IDEA. Мы берем на себя commitment, что если вы напишете код для версии Kotlin'а 0.1, то следующая версия Kotlin'а 1.Х, а может быть, и 2.Х, если что-то такое когда-нибудь будет, будут продолжать этот код компилировать.</p>
<p>Насколько у нас получится, насколько мы сейчас подстилаем соломку в правильных местах, неизвестно. Жизнь покажет. Может быть, нам придется идти на какие-то корявые компромиссы, чтобы сделать какие-то вещи, которых у нас сейчас в голове вообще нет. По крайней мере, те вещи, которые мы хотим менять в будущем, мы стараемся зафиксировать в таком состоянии, чтобы у нас была возможность для развития.</p>
<p>— <strong>Ты можешь какой-то пример привести? Или это трудно?</strong></p>
<p>Ну, например, мы думаем про то, чтобы сделать литералы для коллекций. И хотим в литералах для коллекций иметь возможность использовать символ двоеточия.</p>
<p>— <strong>А что такое литералы для коллекций?</strong></p>
<p>Чтобы как в Python могли написать что-то в квадратных скобочках, просто. Не <code>new ArrayList</code> от параметров, а просто написать в квадратных скобочках что-то, и это был бы там <code>new ArrayList</code>. И, соответственно, мы резервируем символ двоеточия, например, чтобы его можно было в какой-то роли использовать.</p>
<p>— <strong>То есть, свободный символ, это как раз пример такого зазора на будущее?</strong></p>
<p>Да, мы просто оставляем возможность для развития синтаксиса. И на самом деле, еще более насущно – мы просто понимаем, что мы вот сейчас в релизе 1.0 какие-то элементы оставим не в идеальном состоянии. Потому что мы не можем делать релиз вечно, нам нужно в этом году его выпустить. Соответственно, мы находим такой вариант функциональности, такое состояние, которое можно будет расширять, не ломая совместимость.</p>
<p>— <strong>Правильно ли я услышал, что релиз будет в этом году?</strong></p>
<p>Очень хочется. У нас сейчас есть список задач, которые нужно до релиза делать. И мы пытаемся спланировать, сколько это все займет точно времени, чтобы точно понять, успеем ли мы до конца года зарелизить.</p>
<p>— <strong>Интересная очень история, ты затронул – это история API для плагинов. В свое время очень долго команда NetBeans билась с этой проблемой, и решили они следующим образом: они взяли специальный фреймворк, кажется SigTest, и просто зафиксировали сигнатуры своих методов, API-шных, и ввели некие правила, по которым API может меняться. То есть, условно говоря, добавить метод можно, а удалить нельзя. И какие-то другие простые вещи. А как это делали вы?</strong></p>
<p>Мы очень долгое время ее не решали никак, и не могли решать. На сегодняшний день в IDEA нет Plugin API как отдельной сущности, нет фасада, который представляет некие функции, которыми вы пользуетесь. В очень многих местах у людей есть доступ непосредственно к внутренностям IDEA. То есть, плагинописатель может работать напрямую с теми классами, которые какую-то функциональность реализуют. И поэтому нам очень сложно иметь совместимость, потому что она будет сильно ограничивать развитие продукта.</p>
<p>Развитие кода за 15 лет было довольно феноменальное. Вначале это была монолитная Java IDE, у которой не было вообще никакого API. То есть когда делался релиз 1.0 мы поняли, что сделать API для плагинов – это два лишних месяца работы, а денег тогда было очень ограниченное количество. Надо было выпускать продукт, и получать деньги от продаж. Потом в версии 3.0 появился какой-то Plugin API, потом он постоянно расширялся. Потом появилась поддержка не только Java, но и других языков. В версии 5.0 появился JavaScript в частности. В итоге получилось сделать IDE, в которой про Java нет ничего.
В PyCharm нет ничего про Java внутри. Это стоило заметного количества усилий. Потом у нас появились компилятор Kotlin и Upsource. Код, который был распилен по одной оси, чтобы отделить Java от не Java, нужно было теперь распилить по другой оси, чтобы отделить UI от не-UI. В Kotlin’овском компиляторе нет никакого редактора. Там компилятор. Там есть файловая система, есть PSI, то есть, модель для работы с кодом. Есть еще несколько таких абстракций. Но там нет ничего визуального.</p>
<p>Соответственно, это была отдельная большая работа – сделать так, чтобы можно было сложить в такую кучку классы и платформы, чтобы они этим свойствам удовлетворяли. Не было никаких шансов сохранить совместимость API в процессе всех этих трансформаций.</p>
<p>— <strong>Для этого все используют механизм версионности. Вы можете сказать, что внутри Major-версии у вас API фиксированный. От Major к Major менять API и сопровождать изменения гайдлайнами или туториалами.</strong></p>
<p>Это мы старались делать. Все большие пертурбации обычно происходили между major-релизами. Мы старались писать migration guides, когда у нас были большие пертурбации, правда, нам это не всегда удавалось. Конкретно сейчас стало заметно лучше, потому что сейчас вроде как все большие пертурбации завершены. У нас просто есть build-конфигурация на TeamCity, которая для каждого build'a IDEA берет все плагины из плагин-репозитория, и проверяет, что ни один из них не отвалился. — <strong>Статические сигнатурные проверки?</strong></p>
<p>Да. Просто проверка, что там не будет NoSuchMethodError или еще чего-то в этом духе.</p>
<p>— <strong>А идеи выносить все это в какой-то публичный API?</strong></p>
<p>Там есть какой-то API.</p>
<p>— <strong>Там есть разделение насчет того, что вот это можно использовать, а вот это лучше нельзя?</strong></p>
<p>Нет, и я не очень верю, что оно когда-либо появится.</p>
<h4>Год без JetBrains</h4>
<p>— <strong>Года два назад ты на какое-то время JetBrains покинул. Можешь ли ты про это немножко рассказать?</strong></p>
<p>Я уходил из JetBrains в Google. На тот момент я провел уже 10 лет в JetBrains. Хотелось чему-то новому научиться.</p>
<p>— <strong>Чем ты занимался в тот момент, когда уходил?</strong></p>
<p>На тот момент я формально был CTO, но выполнять эту роль уже не очень получалось. Я скорее был тимлидом PyCharm и WebStorm. Это были две основные задачи, которыми я тогда занимался. И, кажется, это был довольно хороший момент, чтобы уйти, потому что какой-то большой следующей задачи, в которой мне надо было бы обязательно участвовать, не было. Было кому передать мои проекты.</p>
<p>Я хотел попробовать чего-то нового. И я был готов и к такому варианту, что я вернусь в JetBrains, и к тому варианту, что я останусь в Google. Я заранее обговаривал возможность вернуться, и мне сказали: Да, будем рады тебя видеть. В итоге, так и получилось.</p>
<p>— <strong>Если не секрет, чем ты занимался в Google? В какой области ты работал?</strong></p>
<p>Я делал инструменты для разработки под Google Cloud Platform. Например, есть такая штука — Сloud Debugger: вы можете на своем production-приложении, на App engine, на compute engine ставить какие-то точки. Но это не точки останова, это точки снятия информации. Прямо в source code в этом месте у вас собирается call stack, собираются значения всех локальных переменных. И вам это все отсылается, и при этом не останавливается процесс. То есть это реально происходит в production’е. Вы там можете ставить условные breakpoint’ы. Наконец, это довольно эффективно по производительности, то есть, не приводит к какому-то заметному замедлению. Мы занимались фронтендом: возможностью в браузере смотреть call stack, значения переменных, source code</p>
<p>— <strong>В итоге тебе там не понравилось? Или какие-то обстоятельства были, вынудившие тебя?</strong></p>
<p>Нет, меня ничего не вынуждало. В Google довольно важно найти свое правильное место. Google – компания большая, компания очень разная. У них есть слоган «do cool things that matter», то есть, «занимайся клевыми штуками, которые имеют значение». Но это верно совсем не для всех сотрудников компании Google. То есть, есть сотрудники, которые занимаются очень клевыми штуками, которые очень имеют большое значение, но есть сотрудники, которые занимаются просто разной работой, которая должна быть сделана.</p>
<p>— <strong>Современный Google — это более 50 тысяч человек. А сколько там девелоперов?</strong></p>
<p>Тысяч 25-30.</p>
<p>— <strong>Вокруг Google существует огромное количество мифов, вплоть до таких, что некоторые сотрудники жалуются, что не могут работать, потому что справа и слева от их рабочего места находятся на одинаковом расстоянии находятся два бассейна, и они мучаются от того, что не знают, какой выбрать. Насколько это соответствует действительности?</strong></p>
<p>На самом деле, не соответствует. То есть как сказать? В Google можно довольно долго искать себя. А заниматься этим можно с очень разной степенью продуктивности.</p>
<p>— <strong>Ты решил пойти по другому пути, ты решил не искать. Ты решил вернуться.</strong></p>
<p>Если бы я был готов еще 3-4 года потратить на такие поиски, съездить в Mountain View на годик, попробовать разные команды, близко познакомиться с большим количеством разных людей, то у меня было бы все хорошо в Google через какое-то время. Но я просто понял, что сейчас, сегодня, есть Kotlin, с которого меня очень прет, и в который я могу прийти и начать делать, я очень хочу, чтобы у JetBrains с ним все получилось. И не надо ничего искать.</p>
<p>Там, опять же, это одни из самых сильных людей в JetBrains, с которыми я работал — Андрей Бреслав, Илья Рыженков и многие другие ребята в команде. Лучше я в JetBrains, чем в Google буду куда-то тыкаться. На самом деле, я очень рад, что сходил в Google, это был ценный опыт, я получил желаемую смену обстановки. И очень рад, что вернулся.</p>
<p>— <strong>Ты затронул тему команды Kotlin. Она формировалась где-то в 2011ом году. Ребята, которые нанимались в тот период (я просто знаю довольно много людей из этой команды), фактически были на тот момент вчерашними выпускниками ВУЗов. И тут получается некоторый казус. С одной стороны, вы на всех углах тогда трубили, что мол, JetBrains накопила большой опыт по написанию компиляторов и поддержке языков, и поэтому сейчас будете делать свой язык. А с другой стороны, вы наняли на это вчерашних студентов в большом количестве, у которых очевидно такого опыта нет. Как так? Как этот факт вообще повлиял на разработку?</strong></p>
<p>Я думаю, что повлиял. Например, команде пришлось потратить какое-то время, прежде, чем performance плагина стал таким, чтобы можно с ним было нормально работать. С другой стороны, что какие-то из старожилов всегда участвовали в разработке. Например, Максим Шафиров участвовал и на самой ранней стадии. Да и сейчас он пользуется Kotlin, приходит на дизайн-митинги, дает feedback по поводу развития языка. А в целом, команда сейчас довольно молодая. То есть там есть несколько старожилов, например, Валя Кипятков, я, Илья Рыженков. И в принципе этого достаточно, как мне кажется, чтобы передавать опыт.</p>
<p>— <strong>Были ли в этапе в жизненном в развитии Kotlin какие-то большие ошибки? То есть было ли такое, что вас куда-нибудь уносило не в ту сторону надолго? Или в принципе такого не было?</strong></p>
<p>Было. Я не буду говорить, что это ошибка, это скорее, поиски пути, которые заняли время. Одним из ключевых пунктов в дизайне языка было то, что мы хотим решить проблему nullability, чтобы мы всегда знали, где у нас значения могут быть null, а где они не могут.</p>
<p>— <strong><a href="https://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions">The billion dollar mistake.</a></strong></p>
<p>Да-да, она самая. Мы живем на платформе Java, и в Java этих средств нет. Соответственно, нам нужно уметь работать с кодом на Java, в котором этой информации нет. Соответственно, для того, чтобы эту информацию для Java-класса получить, нам нужно что-то изобрести.</p>
<p>Изначально у нас была модель фиксированной аннотации: есть класс, и где-то рядышком для него лежит файлик, который откуда-то взялся, в котором в xml про каждый метод написано, что это метод, у которого два параметра: первый – not nullable, второй – nullable, и возвращаем значение nullable. Мы написали такой файлик для JDK и решили, что какие-то другие люди напишут такие файлики для известных библиотек. А если у вас свой проект, то вы можете для своего кода просто прямо в коде писать аннотации, обычные Java. Это не взлетело.</p>
<p>Потом мы придумали KAnnotator – решение, которое сканирует байткод и делает анализ. Например, если где-то передается параметр, который сразу же дереференсится, значит, он not nullable. И возвращаемые значение тоже трекаются. Соответственно, KAnnotator — это внешний инструмент, который генерирует вот эти же файлики с фиксированными аннотациями. Фактически, это глобальный data flow анализ в программе. Это оказалось штукой прикольной, но тоже не очень практичной. Потому что исходный код распадается на две независимых части — сам код и вот эти аннотации, которые могут потеряться или могут разъехаться по версиям. И мы в итоге признали, что это тоже не работает.</p>
<p>И теперь у нас более простое решение — платформенные типы. Это отдельные сущности, типы, для которых у нас нет nullability информации. Они пришли из Java. Когда человек имплементирует метод Java-интерфейса, он может у типов параметров написать любое nullability. То есть он сам знает, какая nullability правильная, и либо пишет вопросик, либо не пишет вопросик. И то, и другое компилятор разрешает. И ведет себя в соответствии с тем, что написал пользователь. Но при этом никакого отдельного файла, никакого осложнения workflow нет. Если хочется, в Java-коде можно написать аннотации Nullable и NotNullable — мы их по-прежнему понимаем.</p>
<p>Вся эта история с KAnnotator'ом отняла у нас довольно много сил и времени. Но с другой стороны, мы не знали, что это неработающий вариант, когда начинали.</p>
<p>— <strong>Не каждый же день пишешь новый язык программирования. Я вот не уверен, что если бы команда была существенно более опытная, вас бы это спасло от всех ошибок.</strong></p>
<p>Может быть.</p>
<p>— <strong>Если я правильно понял, вы теперь даете пользователям самим решать, где выстраивать периметр вот этой null-защиты?</strong></p>
<p>Периметр – это граница между Java и Kotlin кодом. То есть мы все равно генерим assertion, если там нет вопросиков. Просто конфигурация этого периметра задается пользователем самостоятельно.</p>
<p>— <strong>То есть он сам может выбрать, где на стэке вызовов он будет это проверять?</strong></p>
<p>Это проверятся всегда на уровне перехода между Java и Kotlin.</p>
<p>— <strong>Окей. Тогда, может быть, чуть-чуть возвращаясь к Google. Когда ты туда уходил, ты, наверное, ожидал чего-то. И насколько это совпало с тем, что ты реально увидел?</strong></p>
<p>Да, у меня были разного рода ожидания, и не все из них оправдались. Например, наивное ожидание, что у меня будет менеджер, которые меня будет «менеджерить», будет заботиться о моем развитии и совершенствовании. Нет.</p>
<p>— <strong>Но ведь в JetBrains, я так понимаю, тоже такого не было?</strong></p>
<p>В JetBrains такого не было, и мне как раз хотелось посмотреть, как это.</p>
<p>— <strong>Если не секрет, в JetBrains в каком возрасте попал примерно?</strong></p>
<p>Мне было 22, получается. Я работал до этого разных компаниях, я очень рано начал работать. Фактически, первая работа, за которую мне какие-то денежки платили – мне было лет 17.</p>
<p>— <strong>Это было программирование?</strong></p>
<p>Да, программирование. А первая работа, за которую мне вообще платили деньги — переводы. Мне вообще 13 тогда было. Поэтому у меня какой-то опыт уже был на тот момент. У меня был успешный OpenSource-проект, например.</p>
<p>Возвращаясь к Google. Google делает обалденно фантастические вещи. Ты заходишь на их сайт, печатаешь, он тебе в реальном времени показывает результаты поиска того, что ты тут 100 миллисекунд назад печатал. Ты нажал клавишу, и через 100 миллисекунд ты видишь результаты поиска фразы с этой клавишей, с этой буковкой по всему мировому интернету. Это же реально очень круто.</p>
<p>И глядя на Google, ты думаешь, что вот, я туда приду, и там просто что-то совершенно волшебное, благодаря чему это все так работает, и на чем это все держится. Оказывается, нет. Оказывается, секретного ингредиента не существует. Рецепт, как я сформулировал для себя (наверное, это главное, что я вынес из Google) — это рецепт, как делать, чтобы так получалось.</p>
<p>Во-первых, очень важное значение имеет хорошая storage-система. С репликацией, с масштабированием. То есть система хранения данных — это действительно то, на чем все держится. Не зря сейчас появляются десятки стартапов, которые пишут свои NoSQL-хранилища.</p>
<p>— <strong>Правильно ли я понимаю, что это ноу-хау Google? И что это, за счет чего компания вообще является технологическим лидером?</strong></p>
<p>Трудно сказать. На самом деле Google довольно много всего рассказывает. И про BigTable, на котором до сих пор дофига всего написано. Есть статья, в которой написано, как он работает. Потом новая система Spanner, на которую сейчас довольно много сервисов мигрирует внутри Google, которая делает вообще волшебные вещи — прозрачную репликацию между континентами. Про нее тоже статья есть о том, как она работает.</p>
<p>То есть большого секрета, как такового, нет, и слово «ноу-хау» не очень применимо. То, что написано в статье дальше это нужно правильно, хорошо, грамотно реализовать. А вот это дано не всем. Соответственно, если у вас хороший data storage, то вам можно и нужно запускать много копий вашего приложения. Если ты все что угодно запускаешь в Google, то по умолчанию ты запускаешь три экземпляра. Соответственно, по сравнению с этим, мне очень грустно смотреть на TeamCity, Youtrack, которые все такие монолитные, все, у Youtrack вообще встроенная база данных.</p>
<p>— <strong><a href="https://github.com/JetBrains/xodus">Xodus</a>.</strong></p>
<p>Xodus, да. Репликации нету, масштабирования нету... То есть понятно, что такое решение на каком-то этапе упрощает жизнь. Но я говорю, что мне на это смотреть грустно. Потому что понятно, что Youtrack не будет работать также хорошо, как Google поиск.</p>
<p>— <strong>Вадим Гуров (бывший менеджер Youtrack — прим. автора) рассказывал, что как-то раз на одной из конференций они спросили ребят из Atlassian, сколько людей у них занимается поддержкой SaaS-версии JIRA. Оказалось, что 30 человек. А в Youtrack поддержкой SaaS-версии занимается всего один разработчик.</strong></p>
<p>Это история про understaffed, которую я упоминал. Может быть, с какой-то точки зрения она не настолько разрешилась, как мне кажется.</p>
<p>Cледующий ингредиент Google — это не стесняться использовать ресурсы. Оперативная память вообще не очень дорого стоит. Можно загрузить все данные в память, то есть, иметь столько оперативной памяти, чтобы, например, загрузить в нее всю базу данных боевого Youtrack, без attachment-ов. Можно поставить сервер, или несколько серверов, в которых будет столько оперативки, скольконужно. Потом сделать шардинг, репликацию, по науке. Следующий ингредиент, обязательный — это мониторинг производительности. То есть нужно обязательно всегда следить за тем, как это все работает. 95 перцентиль lanency, median latency — нужно за всем этим следить. И нужно просто постоянно работать над улучшением всего, что у вас есть. И, в конце концов, если это все сделать, то получается Google Search.</p>
<p>— <strong>Иными словами, это не какая-то магия и волшебство, а просто отлаженный процесс. Этот процесс работает только в каких-то топовых продуктах типа поиска? Или эта культура распространяется по всей компании, по всем продуктам?</strong></p>
<p>По-разному. Всем рассказывают, как правильно. Даже не столько рассказывают, сколько показывают примеры. Но, например, настройка мониторинга, о которой я говорил, это довольно большая, сложная задача. Которая, причем, ни в какой момент не заканчивается. То есть мониторинг, alerting, что-то еще в этом духе — непрерывно подкручивается. Вот этот alert слишком шумный, он разбудил ночью программиста, чтобы он бежал чинить, а чинить ничего не надо. Было там, на самом деле, все хорошо, просто alert сработал не по тому условию. И есть проекты, которым помогают SRE (Site Reliability Engineers), это роль такая в Google, многие про это знают, много где рассказывали. Это одна из основных вещей, которыми они занимаются. Весь мониторинг, alerting, распределение ресурсов, правильное распределение по кластерам.</p>
<p>И если у вас SRE есть, то у вас все хорошо. Но есть много мелких сервисов, у которых просто SRE нету. То есть программисты сами занимаются поддержкой. И на самом деле, это занимает страшное количество времени и сил — поддержание сервисов в работающем состоянии. Что у сервиса всего хватает, что он не падает, что у него не кончилась storage quota, у него нормальный response time по всем запросам, которые к нему, что его никто не DoS-ит и так далее.</p>
<p>— <strong>Из последнего, что было больно – это закрытие Google Сode. Что-то знаешь про это?</strong></p>
<p>Я собственно даже пытался спасти Google Code. История простая: Google Code просто был сделан на довольно старом, не поддерживаемом наборе фреймворков, как очень часто бывает в Google. Это проблема, которая автоматически случается, когда у вас в компании 20 000 программистов. Программисты – они программируют. Они любят делать всякие фреймворки, технологии, middleware какой-то. И потом на этом middleware строят продукты. А потом с этим middleware становится неинтересно, или люди, которые его делали, уходят и приходят другие люди и так далее. И появляется какое-то новое middleware, на котором теперь все полагается писать.</p>
<p>Google Code — продукт, написанный на довольно старом наборе технологий, который довольно долго и дорого переводить в состояние, чтобы его можно было нормально поддерживать и нормально сопровождать. И плюс к тому, это как сервис, который позволяет хостить всякие штуки в интернете, он всегда был большой мишенью для abuse разного рода. Раз туда можно залить файлики, давайте туда зальем порнушку, или, например, крякнутое какое-нибудь android-приложение, или еще что-то такое. И народ тратил много сил на то, чтобы с этим бороться. Там в какой-то момент функциональность download просто исчезла. Но были там другие способы abuse...</p>
<p>И вот это просто все тянулось, и было ощущение, что это, на самом деле, не нужно. Потому что GitHub победил, и все равно все, все равно жизнь вся там, и у Google на тот момент была куча своих проектов на GitHub. И поэтому решили Google Code закрыть.</p>
<p>— <strong>Ты говоришь, что как-то пытался его реанимировать?</strong></p>
<p>Я решил, что нельзя же так, это же плохо и грустно. И решил поговорить с соответствующими людьми. Вроде я придумал, что можно сделать. Потом пришел к людям, но оказалось, что они про все это уже подумали, придумали, у них есть документ на 15 страниц, в котором написано почему это не сработает, и... «спасибо за ваш фидбек, но мы и сами все знаем». Если ты думаешь, что самый умный, то в Google это гарантировано не так. Если ты хочешь что-то предложить — с вероятностью 75% другие люди уже про это подумали. И либо поставили в план и собираются сделать, либо знают почему это не сработает, либо знают почему это не соответствует каким-то целям и так далее.</p>
<p>— <strong>Это эффект большой компании или чего-еще?</strong></p>
<p>В Google все-таки хорошие люди, сильные работают. Это эффект гуглового рекрутинга.</p>
<h4>ЖЖ и хабр</h4>
<p>— <strong>Пара вопросов, которые лично меня интересуют. ЖЖ-сообщество ru_java, ты участвовал в этом комьюнити. Сейчас пациент скорее мертв. Как ты думаешь, как так вышло? То есть эволюция того, то есть тот дискуcс, он куда-то сместился, отпала вообще необходимость в таких дискуссиях?</strong> Я не то, чтобы там что-то активно делал, насколько я помню. Но я там отвечал на какие-то вопросы об IDEA. Сам ЖЖ — довольно странная платформа. А сейчас все перешло на хабр, как мне кажется.</p>
<p>— <strong>Я ждал от тебя такого ответа. На хабре <a href="http://habrahabr.ru/post/134544/">твой последний пост</a> датирован 2011 годом, а твой последний заход, внимание, залогиненый, на хабр, это конец 2013 года.</strong></p>
<p>Это странно, потому что мне приходит еженедельный newsletter с интересными материалами.</p>
<p>— <strong>Но, тем не менее, видимо ты 2 года уже не логинишься и не отвечаешь на комментарии, и так далее.</strong></p>
<p>Да, я видимо не залогиненым читаю.</p>
<p>— <strong>Писать в ближайшее время не собираешься? Другие люди у вас уже этим занимаются?</strong></p>
<p>Про хабр стоит сказать отдельно. Для PhpStorm, на его ранних стадиях, этот канал был крайне важен, как возможность для общения с пользователями. Мы постоянно рассказывали, что там появилось, что поменялось. Шла дискуссия, там всегда было много обсуждений, всегда разработчики отвечали. Мы с PyCharm тоже всегда активно участвовали в обсуждениях.</p>
<p>Наверное, надо туда постить что-нибудь и про Kotlin. Просто у нас никто специально не занимается сейчас промоушеном в соцсетях, скажем так. Мы пишем, на англоязычных ресурсах что-то, на Reddit у нас появляются дискуссии. Есть <a href="https://www.reddit.com/r/Kotlin">subreddit про Kotlin</a>, еще что-то. А на русскоязычное сообщество нам, наверное, просто не сил не хватает. И опять-же, я сейчас пишу книжку. Поэтому вписываться в то, что сейчас писать еще что-то большое, другое, я не очень хочу.</p>
<h4>JUG и конференции</h4>
<p>— <strong>И такой, еще личный. У нас на <a href="http://jug.ru/">новом сайте JUG.ru</a>, есть кавер-фотография, я не знаю, ты видел или нет. На ней ты. Что рассказывал на старом JUG?</strong></p>
<p><a href="http://jug.ru/history"><img src="https://habrastorage.org/files/ea8/e53/a9e/ea8e53a9e1d54e1a8db6aaca95822e8b.jpg"></a></p>
<p>На JUG я точно рассказывал про TeamCity, когда-то давно, еще в 2006, по-моему, году. И что-то я еще рассказывал, но сейчас не вспомню. Я знаком с Яшей Сироткиным довольно хорошо.</p>
<p>— <strong>Я хочу сейчас официально пригласить в твой, наверное, следующий уже, или через следующий твой приезд в Питер. Да, обязательно что-нибудь у нас на JUG рассказать. И может быть выступить на ближайшей какой-то конференции. Это официальное приглашение перед всеми зрителями и читателями.</strong></p>
<p>Да, я с удовольствием расскажу.</p>
<hr>
<p><em>P.S.: И действительно расскажет:</em></p>
<p><strong>Дмитрий Жемеров на Joker 2015</strong></p>
<p><strong>Опыт использования Kotlin в JetBrains</strong></p>
<p><img src="https://habrastorage.org/files/0f7/9ea/71f/0f79ea71f8974a39ae5266c4cc9b9da5.jpg" alt="jemerov">
Kotlin — новый язык программирования для JVM, Android и JavaScript, который с 2010 года разрабатывается компанией JetBrains. Язык ориентирован на написание элегантного, компактного и безопасного кода, свободно интегрируется с существующим Java-кодом и имеет мощную поддержку в IDE. В последнее время язык все более активно используется как внутри JetBrains, так и внешними разработчиками.</p>
<p>В докладе Дмитрий расскажет об использовании Kotlin в двух проектах JetBrains — в системе поддержки продаж и менеджмента лицензий (это Web-приложение, целиком сделанное на Kotlin) и в IntelliJ IDEA (здесь Kotlin интегрируется в большой существующий проект). Будут показаны различные фреймворки, которые появились в процессе разработки и которые могут пригодиться и вам. Так же Дмитрий расскажет о том, какие плюсы они получили от внедрения Kotlin и с какими трудностями встретились.</p>
<hr>
<p>Этот и другие доклады Joker 2015 — <strong><a href="http://jokerconf.com/#talks">на сайте конференции</a></strong>.</p>
]]></description><link>https://habrahabr.ru/company/jugru/blog/263905/</link><guid isPermaLink="true">https://habrahabr.ru/company/jugru/blog/263905/</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Алексей Фёдоров]]></dc:creator><pubDate>Fri, 31 Jul 2015 12:00:00 GMT</pubDate></item><item><title><![CDATA[Android + Kotlin = <3]]></title><description><![CDATA[<p>The Android SDK has come a long way since its early days to make developing for Android as comfortable and efficient as possible. Yet there’s one thing that still gets in our way: The Java language. While more modern languages like C# or Swift make it possible to write code that is elegant and at the same time easy to read and understand, we’re still stuck with Java 7 for Android Development. Its cumbersome syntax for executing code on a different thread asynchronously, for example, or the fact that you require separate libs for even the most basic tasks like null-safe string comparison really make it a pain for development.</p>
<h2>A New Hope</h2>
<p>At this year’s Berlin DroidCon, I found one session in the conference schedule very intriguing: <a href="http://www.droidcon.de/session/kotlin-swift-android">A talk by Svetlana Isakova from JetBrains</a> on <a href="http://kotlinlang.org/">the Kotlin language</a> – “The Swift of Android”, according to the session title. Of course I attended, and during the talk I couldn’t help but start to smile, and that smile grew bigger and bigger: Kotlin and its accompanying extensions and plugins for Android addressed so many annoying issues of Java development for Android! No more enviously looking over to Apple’s Swift for iOS development! Also I found the syntax to be very intuitive. I simply had to try it out ASAP – and what better opportunity to do so than Zühlke’s educational Camp?</p>
<h2>An Easy Language To Get Into</h2>
<p>For the 2015 Camp, there were already plans for exploring the development for Android Wear by writing an app that connected to a sensor via Bluetooth Low Energy. The app should get historic data from the sensor and forward it to a connected Android Wear device, including notifications for certain events.</p>
<p>The colleague who was going to develop the Android app together with me wasn’t aware of my decision to use Kotlin for the project until right before we started coding. But nevertheless, we both were able to pick up the new language and start writing our app very quickly. This is due to several things.</p>
<p>First of all, the <a href="http://kotlinlang.org/docs/reference/">reference documentation</a> is very well written and easy to get into. JetBrains also provides a plugin for IntelliJ, Android Studio and Eclipse that greatly helps development in Kotlin. The Android Studio plugin we used not only provides proper debugging, auto-completion, code navigation and full refactoring support, but it also lets developers convert existing Java code files to Kotlin with just one click.</p>
<p>Another thing that makes it easy to use Kotlin in your Android project is the fact that, much like Scala, it’s <strong>100% interoperable with Java code</strong>! Kotlin compiles to regular Java Byte Code, and you can use existing Java classes in your project from Kotlin and vice versa. If you are familiar to Android development and want to write a new Activity you can do it like this:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyActivity</span> : <span class="hljs-type">Activity</span></span>() {
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> {
        <span class="hljs-keyword">super</span>&#x3C;Activity>.onCreate(savedInstanceState)
        ...
    }
}</code></pre>
<p>Simply inherit from <code>Activity</code> as before! The language is different, but you can use the framework and your own existing code, or for that matter, any existing Java library. Therefore you can gradually migrate to Kotlin if you don’t want to convert all your Java code to Kotlin right away.</p>
<p>The most important thing though is the incredible <strong>ease of use</strong> of the language. Being under development since 2010 and having gone open source in 2012, Kotlin has become very mature by now. It has adapted the great features of so many other languages. Here are some examples.</p>
<h2>Some Nifty Kotlin Features</h2>
<p>When adding a property to your class, you don’t write the backing field and getters and setters separately. Instead, you do:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> context: Context? = <span class="hljs-literal">null</span>
    <span class="hljs-keyword">get</span>
    <span class="hljs-keyword">set</span> (value) {
        $context = value
        <span class="hljs-keyword">if</span> (context != <span class="hljs-literal">null</span>) {
            setupBluetooth()
        }
    }</code></pre>
<p>Looks familiar? Yup, that’s <strong>C#-style properties</strong> right there, which are accessed without calling the getter/setter explicitly. Also <strong>classes and their member functions are final by default</strong> and need to be declared <code>open</code> or <code>abstract</code> in order to be overridden.</p>
<p>Like Scala, Kotlin does away with static methods and fields, which are so easily misused in Java. Instead of using those, Kotlin facilitates the declaration of <strong>singleton objects</strong>. Instead of declaring a class with some “instance” method, you simply declare an object right away, which can be used directly:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">object</span> MySingleton {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">myFunction</span><span class="hljs-params">()</span></span> { [...] }
}
MySingleton.myFunction()</code></pre>
<p><strong>Null-safety</strong> is also an important aspect of Kotlin. Every type is non-nullable by default, and you get a compile error when trying to assign or pass <code>null</code> to it. A type is made nullable by putting a question mark behind it. When accessing a nullable variable, Kotlin enforces a null check:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">var</span> foo: String? = <span class="hljs-string">"bar"</span> <span class="hljs-comment">// foo is nullable now</span>
<span class="hljs-keyword">var</span> length = foo.length() <span class="hljs-comment">// Compile error</span>
<span class="hljs-keyword">var</span> character = foo?.charAt(<span class="hljs-number">0</span>) <span class="hljs-comment">// OK; result is null if foo == null</span>
<span class="hljs-keyword">var</span> length2: <span class="hljs-built_in">Int</span> = <span class="hljs-keyword">if</span> (foo != <span class="hljs-literal">null</span>) foo.length() <span class="hljs-keyword">else</span> <span class="hljs-number">0</span> <span class="hljs-comment">// Inlined null check</span>
<span class="hljs-keyword">var</span> nonNullFoo: String = foo ?: <span class="hljs-string">"baz"</span> <span class="hljs-comment">// Elvis operator; result is "baz" if foo = null</span>
<span class="hljs-keyword">var</span> letter = foo?.subSequence(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>) ?: <span class="hljs-keyword">return</span>
<span class="hljs-keyword">if</span> (foo != <span class="hljs-literal">null</span>) { <span class="hljs-comment">// Null check in the surrounding code</span>
    character = foo.last() <span class="hljs-comment">// -> Smart-cast to non-null</span>
}
<span class="hljs-keyword">var</span> bang = foo!!.capitalize() <span class="hljs-comment">// Forced to non-null. CAUTION: If it is null, you get an NPE!</span></code></pre>
<p>The concept is similar to Swift’s Optionals or Nullable Types in C#, though the syntax is a little different here. But it’s extremely comfy to use, and it prevents the dreaded <code>NullPointerException</code>s effectively.</p>
<p>If you’re missing a useful method on a foreign class, simply write an <strong>extension function</strong>:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> String?.<span class="hljs-title">append</span><span class="hljs-params">(other: <span class="hljs-type">String</span>)</span></span>: String {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> other
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span> + other
}
<span class="hljs-keyword">var</span> hi: String? = <span class="hljs-string">"Hello "</span>
<span class="hljs-keyword">var</span> all = hi.append(<span class="hljs-string">"World"</span>)</code></pre>
<p>Notice how the method extends the <em>nullable</em> String? This way you can gracefully handle <code>null</code> objects without using null checks as shown above.</p>
<h2>At last – Lambdas!</h2>
<p>And last but not least there’s Kotlin’s <strong>Lambda</strong> support. Especially in the context of any asynchronous communication, this is a godsend. For example, lambdas provide an elegant way of handling the many asynchronous callbacks that are used by Android’s Bluetooth Low Energy API. The syntax for declaring and using lambdas looks like this:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">var</span> filtered = intArray.filter { it > <span class="hljs-number">0</span> }
intArray.forEachIndexed { index, element ->
    println(index + “:” + element)
}</code></pre>
<p>And here’s a function declaration that takes a lambda argument:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">myFunction</span><span class="hljs-params">(param1: <span class="hljs-type">String</span>, callback: (<span class="hljs-type">result</span>: <span class="hljs-type">Int</span>?, error: <span class="hljs-type">String</span>?)</span></span> -> <span class="hljs-built_in">Unit</span>) {
    [...]
}</code></pre>
<p>When passing Lambdas to functions, they are usually in-lined in the function call, but you can also assign them to variables as <strong>first-class objects</strong> and pass them around later. Here’s how that looks like:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> myCallback: Function1&#x3C;String, <span class="hljs-built_in">Unit</span>> = { param1: String ->
    println(<span class="hljs-string">"Hi <span class="hljs-subst">$param1</span>"</span>)
}</code></pre>
<p>And it doesn’t stop there; these features of Kotlin and many more make it possible to write code that’s elegant and easily understandable. But let’s get into some Android stuff.</p>
<h2>Android Development With Pleasure</h2>
<p>In addition to Kotlin’s own features, the <a href="https://github.com/JetBrains/anko">Anko library</a> provides Extensions that eliminate a lot of the boilerplate code typically found in Android projects. One example is the <strong>simplified “toast” statement</strong>. Instead of the usual “Toast-makeText-context-content-length-show” sermon, you just do:</p>
<pre><code class="hljs language-kotlin">toast(<span class="hljs-string">"A toast to Android!"</span>)</code></pre>
<p>The <strong>findViewById</strong> procedure has also been simplified:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> myText: TextView = find(R.id.myTextView)</code></pre>
<p><strong>View hierarchies</strong> can be quickly defined in Kotlin in the Activity code, including layout and listeners:</p>
<pre><code class="hljs language-kotlin">linearLayout {
    button(<span class="hljs-string">"Login"</span>) {
        textSize = <span class="hljs-number">26</span>f
        onClick {
            doSomeStuff()
        }
    }.layoutParams(width = wrapContent) {
        horizontalMargin = dip(<span class="hljs-number">5</span>)
        topMargin = dip(<span class="hljs-number">10</span>)
    }
}</code></pre>
<p>Another extremely helpful feature is the simplified use of Android’s ugly and unwieldy <code>AsyncTask</code>. With Anko, <strong>executing asynchronous code</strong> on a worker thread and processing results on the UI thread is as simple as:</p>
<pre><code class="hljs language-kotlin">async {
    doSomeWork() <span class="hljs-comment">// Long background task</span>
    uiThread {
        result.text = <span class="hljs-string">"Done"</span>
    }
}</code></pre>
<p>Tired of <strong>SQLite handling</strong>, with all its <code>Cursor</code> handling and countless <code>try...catch</code> blocks? Just extend Anko’s <code>ManagedSQLiteOpenHelper</code>! It contains lots of little utilities that greatly simplify your database access code. Here’s an <code>INSERT</code> using your <code>ManagedSQLiteOpenHelper</code>:</p>
<pre><code class="hljs language-kotlin">use { <span class="hljs-comment">// Now "this" is the SQLiteDatabase, opened for read/write</span>
    <span class="hljs-keyword">try</span> {
        insert(<span class="hljs-string">"ShoppingList"</span>, <span class="hljs-comment">// Table name</span>
                <span class="hljs-string">"id"</span> to item.id,
                <span class="hljs-string">"title"</span> to item.title,
                <span class="hljs-string">"checked"</span> to item.checked)
    } <span class="hljs-keyword">catch</span> (exception: SQLiteException) { <span class="hljs-comment">// SQL exceptions can still occur, of course</span>
        error(<span class="hljs-string">"INSERT threw exception: <span class="hljs-subst">$exception</span>"</span>)
    }
} <span class="hljs-comment">// At the end of the block the DB is automatically closed</span></code></pre>
<p>Looks neat? Wait till you see some <code>SELECT</code> code:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">var</span> result: List&#x3C;ShoppingItem> = ArrayList&#x3C;ShoppingItem>()
use {
    <span class="hljs-keyword">try</span> {
        result = select(<span class="hljs-string">"ShoppingList"</span>, <span class="hljs-string">"id"</span>, <span class="hljs-string">"title"</span>, <span class="hljs-string">"checked"</span>)
                .where(<span class="hljs-string">"checked = {checkedArg}"</span>, <span class="hljs-string">"checkedArg"</span> to <span class="hljs-number">1</span>)
                .orderBy(<span class="hljs-string">"id"</span>, SqlOrderDirection.ASC)
                .exec {
            parseList(classParser&#x3C;ShoppingItem>())
        }
    } <span class="hljs-keyword">catch</span> (exception: SQLiteException) {
        error(<span class="hljs-string">"SELECT threw exception: <span class="hljs-subst">$exception</span>"</span>)
    }
}
<span class="hljs-comment">// Now process the result list</span></code></pre>
<p>How’s that for brevity? Just assemble your <code>SELECT</code> statement using fluent-style syntax, then automatically transform the returned <code>Cursor</code> into a <code>List</code> of your data items. The Parser is automatically generated from your data class, provided it has a constructor that matches the selected columns.</p>
<p>And this is just the tip of the iceberg! Anko also provides simplified mechanisms for Intent dispatching, Service retrieval, Logging and a lot more.</p>
<h2>Conclusion</h2>
<p>Having tried out Kotlin in the context of Android development now, I can definitely see it becoming my new language of choice for Android development. It’s well made, mature and makes coding an absolute joy. The official Android documentation may be written for Java, but it’s easy to “translate” it to Kotlin, so any Android developer should definitely give Kotlin &#x26; Anko a try. Here’s hoping that Google will provide an Android API reference &#x26; guide in Kotlin in the near future, and that it will eventually become the de-facto standard for Android!</p>
]]></description><link>http://blog.zuehlke.com/en/android-kotlin/</link><guid isPermaLink="true">http://blog.zuehlke.com/en/android-kotlin/</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Android]]></category><dc:creator><![CDATA[Michael Sattler]]></dc:creator><pubDate>Mon, 20 Jul 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[Why Kotlin is my next programming language]]></title><description><![CDATA[<p><img src="https://d262ilb51hltx0.cloudfront.net/max/1600/1*YnF7hY2ymS54iTNLuxVT8A.jpeg">
<em>A lighthouse on Kotlin Island, Russia</em></p>
<h2>An ode to the language you’ve never heard of</h2>
<p><a href="http://kotlinlang.org/">Kotlin</a> is a new programming language from <a href="http://jetbrains.com%5C">JetBrains</a>, the maker of the world’s best IDEs. After much searching, I have settled on it as the programming language I will probably use for the next 5–10 years or so.</p>
<p>I like Kotlin a lot and think it will be a very successful project. Someone who saw me using it in my open source work asked me to write about it, so in this article I’ll explain why I think Kotlin is good. Then I will discuss some of the problems and hiccups you may encounter if you start using it today. Finally, I’ll argue that now Kotlin is on the scene you should consider using the JVM if you aren’t already (e.g. because you use Go or Node).</p>
<h3>Why Kotlin is good</h3>
<p>At first this article may seem strange: normally language advocacy articles start by listing all the cool features the new language has. This article does not; we will get to them later.</p>
<p>I am going to start by telling you about other things, because <a href="http://sns.cs.princeton.edu/docs/asr-oopsla13.pdf">a 2013 study showed that language features matter little compared to ecosystem issues</a> when developers evaluate programming languages. That tallies with my own experience, so, here we go:</p>
<p><strong>Kotlin compiles to JVM bytecode or JavaScript</strong>. It is not a language you will write a kernel in. It is of greatest interest to people who work with Java today, although it could appeal to <em>all</em> programmers who use a garbage collected runtime, including people who currently use Scala, Go, Python, Ruby and JavaScript.</p>
<p><strong>Kotlin comes from industry</strong>, not academia. It solves problems faced by working programmers today. As an example, the type system helps you avoid null pointer exceptions.</p>
<p><strong>Kotlin costs nothing to adopt!</strong> It’s open source, but that’s not what I mean here. What I mean is there’s a high quality, one-click Java to Kotlin converter tool, and a strong focus on Java binary compatibility. You can convert an existing Java project one file at a time and everything will still compile, even for complex programs that run to millions of lines of code. This is how I am adopting Kotlin and I expect it to be how most developers do.</p>
<p>As an obvious implication of the above, <strong>Kotlin programs can use all existing Java frameworks and libraries</strong>, even advanced frameworks that rely on annotation processing. The interop is seamless and does not require wrappers or adapter layers. It integrates with Maven, Gradle and other build systems.</p>
<p>It is approachable and <strong>it can be learned in a few hours</strong> by simply reading the language reference. The syntax is lean and intuitive. Kotlin looks a lot like Scala, but is simpler. The language balances terseness and readability well.</p>
<p><strong>It enforces no particular philosophy of programming</strong>, such as overly functional or OOP styling.</p>
<p>It <strong>imposes no runtime overhead.</strong> The standard library is small and tight: it consists mostly of focused extensions to the Java standard library. Heavy use of compile-time inlining means functional constructs like pipelines of map/filter/reduce compile similarly to an imperative version of the same code.</p>
<p>Combined with the appearance of frameworks like <a href="https://github.com/JetBrains/anko">Anko</a> and <a href="http://kovenant.komponents.nl/android/features/">Kovenant</a>, this resource lightness means <strong>Kotlin is starting to become popular with Android developers</strong>. If you’re working on Android, you will soon be in good company. You can read <a href="https://docs.google.com/document/d/1ReS3ep-hjxWA8kZi0YqDbEhCqTt29hG8P44aA9W0DM8/edit?hl=en&#x26;forcehl=1">a report written by a developer at Square</a> on their experience with Kotlin and Android.</p>
<p>Kotlin allows you to keep using your productivity enhancing tools. If you use IntelliJ, <strong>IDE interop is entirely seamless</strong>: code can be refactored, searched, navigated and auto completed as if the Kotlin code was Java and vice-versa. There is full support for debugging, unit testing, profiling and so on.</p>
<p>Beyond Android, I think <strong>Kotlin is highly suitable for enterprise Java shops</strong>. If you spend all day working on big Java codebases at even bigger companies, you should investigate Kotlin because:</p>
<ul>
<li>It has <strong>strong commercial support from an established company</strong>. JetBrains is committed to the project, has a large and highly competent team working on it, has a stable business model and is even converting parts of their own flagship product to use it. Kotlin is unlikely to be abandoned any time soon.</li>
<li><strong>Adopting Kotlin is low risk</strong>: it can be trialled in a small part of your code base by one or two enthusiastic team members without disrupting the rest of your project: Kotlin classes export a Java API that looks identical to that of regular Java code.</li>
<li>Because Kotlin focuses on readable syntax, <strong>code reviews are not a problem</strong>: they can still be done by team members who aren’t familiar with the language.</li>
<li><strong>It targets</strong> <strong>Java 6</strong>, so you can use it even if your deployment makes upgrading to a newer JVM difficult.</li>
</ul>
<p>Earlier this year I presented Kotlin to a team of Java and .NET architects at Swiss Re, a large reinsurance company. I started by defining a simple Java class with a few fields, toString, equals, hashCode etc. It was about 50 lines of code. By the time we had finished converting it to Kotlin (mostly automatically), it had shrunk to just one line of code. I then demoed other time saving features. They were enthusiastic and saw it as a potentially strong competitor to C# for their own projects.</p>
<p>I think Kotlin hits the sweet spot for enterprise Java devs, so even though Kotlin is free I expect JetBrains to make a killing from increased sales of the commercial version of their IDE. This will incentivise them to keep improving it according to the wishes of their customers.</p>
<p>Contrast this with many other language developers who are subsidised by unrelated products, meaning they have little reason to respond to the demands of their users when those demands conflict with pre-held ideologies.</p>
]]></description><link>https://medium.com/@octskyward/why-kotlin-is-my-next-programming-language-c25c001e26e3</link><guid isPermaLink="true">https://medium.com/@octskyward/why-kotlin-is-my-next-programming-language-c25c001e26e3</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Mike Hearn]]></dc:creator><pubDate>Mon, 06 Jul 2015 22:39:00 GMT</pubDate></item><item><title><![CDATA[Exploring Kotlin]]></title><description><![CDATA[<p><em>This post is outdated, because Kotlin have a lot changes from June, 2015</em></p>
<p>Welcome to the start of an intermittent series of blog posts where I just talk about various bits of technology that I’m in the process of discovering. Don’t expect much in the way of teaching, but do expect much in the way of erroneous comments as I discuss stuff I don’t yet properly understand.</p>
<p>I’m starting the series with Kotlin, one of a new wave of languages for the JVM. I say wave, but the only other one I can think of is Ceylon. Still, Kotlin and Ceylon are important because, as I understand it, they both aim to provide a solid alternative (AKA replacement) to Java. As you’d expect if you follow me, this post has a definite Groovy flavour with most of the comparisons between that and Kotlin.</p>
<p>So why am I looking at Kotlin anyway? Partly to expand my horizons, partly in search of a statically-typed alternative to Java that I’m happy with, and partly because I think it has a reasonable chance of picking up a sizeable following. It seems like a pragmatic evolution to Java that respects the need for good Java integration and doesn’t introduce anything that’s terribly hard for an older programmer like me to understand. It does include a whole bunch of features I like.</p>
<h2>There is no static</h2>
<p>Sometimes the best way to learn about a language is to just jump into the deep end. In this case, I thought I’d try to migrate my Lazybones project from Groovy to Kotlin. I do have a small ulterior motive for doing this: the Lazybones tool has a small but noticeable startup delay when running it. If I can eliminate that, I’ll be very happy.</p>
<p>You can follow my progress on <a href="https://github.com/pledbrook/lazybones-kotlin">GitHub</a>. One thing to bear in mind is that the code would probably look a bit different if I started with Kotlin. I tend to rely on Groovy’s dynamic features, which don’t translate so well to a statically-typed language. All the more surprising then that the migration has gone fairly smoothly.</p>
<p>The first thing that struck me though, and had me scratching my head for a while, was the complete lack of the <code>static</code> keyword. It’s not even available on the <code>import</code> statement. I first came across <code>static</code> a long time ago when I was learning C and it took an embarrassingly long time to work out what it did. Almost as embarrassing as not knowing how many ‘r’s are in ‘embarrass’. It did eventually click and that understanding has helped me through C, C++, Java and Groovy. So I was a bit at sea initially, especially as I had lots of <code>static</code>s dotted around the code base.</p>
<p>After that initial shock, I admit I quickly came around to Kotlin’s way of thinking. The <code>static</code> keyword is mostly a kludge in Java and has a variety of use cases that could be handled differently. For example, functions can’t exist independently of a class, even if they don’t belong on an object. This is the tyranny of Java’s particular Object-oriented viewpoint. Kotlin eliminates this use case by allowing functions defined outside of classes. The same goes for constants. Sharing data between objects of the same type can be achieved through companion objects. If you absolutely need a static field or method, for example when you’re calling Kotlin code from Java, you can use a <code>@platformStatic</code> annotation.</p>
<h2>The good stuff</h2>
<p>Subsequent work highlighted a lot of similarities with Groovy, such as the Elvis operator (not sure if it’s called that in Kotlin), null-safe navigation, lambda function syntax, embedded string expressions, and multi-line strings. The Kotlin extension methods for the standard types are also a reasonably close match to those of Groovy, although Kotlin thankfully uses the more standard names such as ‘map’, ‘fold’ and ‘filter’. Just remember to add the ‘kotlin-stdlib’ JAR to your project’s classpath, or you’ll miss out on a lot of essential features like I did and remain confused as to why none of the examples on the web work for you.</p>
<p>On the flip side, there were a lot of repetitive tasks I had to undertake during the migration. Types always go after variable and function declarations, which allows for the essential <code>fun</code>, <code>val</code> and <code>var</code> keywords, but does result in a lot of cutting and pasting. Kotlin also handles properties differently. The <code>get()</code> and <code>set()</code> syntax is nice, but getters and setters on Java and Groovy code are not treated as properties. This means you have to invoke the methods explicitly. Yuck.</p>
<p>Beyond the feeling of familiarity, Kotlin provides some other very pleasant surprises. Unlike Java 8, you don’t need to define or use an interface to take advantage of lambdas:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NameType</span></span>(<span class="hljs-keyword">val</span> intermediateType : NameType?,
                    <span class="hljs-keyword">val</span> toIntermediateFn : (String) -> String,
                    <span class="hljs-keyword">val</span> fromIntermediateFn : (String) -> String) {
    ...
}</code></pre>
<p>Simply use the syntax <code>(&#x3C;arg types>) -> &#x3C;return type></code> on your properties or function signatures.</p>
<p>The most far-reaching feature is Kotlin’s null handling. Types come in two forms: those that allow null values, and those that don’t. It’s easy to distinguish between them because the former have a ‘?’ suffix, for example <code>String?</code> vs <code>String</code>. The compiler then checks that you don’t attempt to use a potentially null value for an argument or variable that can’t be null. This causes all sorts of fun when using non-Kotlin libraries because almost every value can potentially be null, but Kotlin provides some nice get out of jail free cards for such occasions. And most importantly, it forces you to really think about when and where you want to allow null values and how you should be dealing with them.</p>
<p>I won’t go into any more details, but what could have been a really frustrating feature when working with existing code and libraries turned out to be less bothersome than expected once I’d become familiar with most of its aspects. It even highlighted bits of code that probably weren’t handling nulls properly. I was particularly shocked at how laissez-faire my Groovy code appeared to be with regard to nulls.</p>
<p><strong>Update</strong> Jetbrains provide a tool called <a href="https://github.com/jetbrains/kannotator">KAnnotator</a> that analyses Java libraries for whether they accept and/or return nulls. This makes the libraries much easier to integrate into Kotlin code. Thanks to Rob Fletcher for the pointer.</p>
<p>The compiler is also a lot more intelligent than Java’s (I suspect at the cost of compilation speed). It follows branches appropriately and can tell when they return with what types. This picked up at least one bug in my code, albeit nothing major. It also seems to be aware of null and <code>instanceof</code> checks (although in Kotlin these use is instead). That means you don’t need an explicit cast or null-safe navigation after such a check. Unfortunately this feature only seemed to work some of the time and I couldn’t work out why it didn’t in those cases. Hopefully the edge cases will be ironed out or at least well documented as Kotlin approaches 1.0.</p>
<h2>What I miss</h2>
<p>It’s not all great for a Groovy developer like me. The number one concern is that I can’t seem to mix the two languages in the same project. At least with the Gradle integration the Kotlin compilation takes place before Java, which in turn comes before Groovy. My limited understanding suggests that you can use Kotlin-compiled code from Groovy, but not vice versa. This is a shame as Groovy is particularly strong in dealing with configuration data, JSON, and the like.</p>
<p>I initially thought that Kotlin’s <code>dynamic</code> keyword, which disables type checking on the marked object, would give me similar behaviour to Groovy in such cases, but IntelliJ IDEA kept on saying that it couldn’t be used in the current context. Err...what? What context would that be? It transpires that in this case the context is the JVM! In other words, <code>dynamic</code> only seems to work for KotlinJS (a version that compiles to Javascript). This seems like a lost opportunity considering the addition of <code>invokedynamic</code> to the JVM. Perhaps the implementation would complicate the language or maybe the language designers want to maintain Java 6 as the minimum JVM version.</p>
<p>I also desperately miss Groovy Truth. This allows you to treat various values, such as empty strings, as if they were equivalent to the boolean <code>true</code> or <code>false</code>. For example, if I have a nullable string and just want to check whether it contains at least one character I prefer:</p>
<pre><code class="hljs language-groovy"><span class="hljs-keyword">if</span> (str) doSomething()</code></pre>
<p>rather than</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">if</span> (str != <span class="hljs-keyword">null</span> &#x26;&#x26; str.isNotEmpty()) doSomething()</code></pre>
<p>The kludge I’ve gone for seems a bit dangerous as I don’t know how widely applicable it is:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">if</span> (str?.isNotEmpty() ?: <span class="hljs-literal">false</span>) doSomething()</code></pre>
<p>Anyway, I’m hoping that I’ve missed a particular feature of Kotlin that prevents the return of the dreaded explicit null checks.</p>
<p>List and map literals would have been nice, but methods like <code>arrayListOf()</code> and <code>hashMapOf()</code> do the job fine. Regular expression literals plus something like the <code>=~</code> operator would also have made my life easier, but the Kotlin approach isn’t massively worse. In fact, the <code>Regex</code> class is growing on me.</p>
<p>Lastly, I really wanted to make use of method references in the <code>NameType</code> class, but I just couldn’t get them to work the way I want. I suspect that method references on instance methods have a different signature to function references. Unfortunately, this area of Kotlin isn’t particularly well documented. That’s not too surprising when you consider that the language hasn’t even hit 1.0 yet, but I do think that adoption is only for the brave right now.</p>
<h2>Do I like it?</h2>
<p>When all is said and done, I’m pleasantly surprised by Kotlin. Although I perhaps hadn’t realised how reliant I was on some of Groovy’s more dynamic features, the transition to a fully statically typed language wasn’t nearly as bad as it had every right to be. There were a few struggles, but nothing that kept me from almost completing the transition in a short timeframe. The only thing left to do is convert a couple of configuration-related classes – probably the hardest ones to do over all.</p>
<p>One final thing I learned is that I hate generics. Really. I think Kotlin’s ‘*’ wildcard was the only thing that helped me retain my sanity.</p>
<p>As I said at the beginning of the post, Kotlin is an evolution rather than a revolution. That’s why I think it has a reasonable chance of success. Will it prove a significant competitor to Java? I don’t know, but I doubt it. There is so much inertia around Java that sometimes it feels like nothing will supersede it. Nonetheless, Kotlin is definitely worth an investigation if you’re looking for a statically-typed alternative to Java for your own projects. As I understand it, Jetbrains are pretty reliant on it, so it’s unlikely to disappear soon if at all. And you’re guaranteed first class support in at least one IDE!</p>
<p>Do remember that this is a first impressions account of the language, so don’t take anything as gospel truth other than these were my experiences. I’ll try to post additional articles as I gain a better understanding of the language.</p>
]]></description><link>http://blog.cacoethes.co.uk/software/exploring-kotlin</link><guid isPermaLink="true">http://blog.cacoethes.co.uk/software/exploring-kotlin</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Groovy]]></category><dc:creator><![CDATA[Peter Ledbrook]]></dc:creator><pubDate>Sat, 27 Jun 2015 21:54:00 GMT</pubDate></item><item><title><![CDATA[RxAndroid and Kotlin (Part 1)]]></title><description><![CDATA[<p><img src="https://d262ilb51hltx0.cloudfront.net/max/2000/1*bTttcFdSLyvWIPg91OaNEw.png"></p>
<h3>RxAndroid and Kotlin (Part 1)</h3>
<p>I started with <a href="https://github.com/ReactiveX/RxAndroid">RxAndroid</a> about a week ago. At first, I didn’t really get it... I mean, I grasped the concept but I didn’t understand where I should be using it. But then after going through a few examples and a few really good articles (links at the end)... I just got it! (to a good extent) And my reaction was pretty much:</p>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/800/1*rjlr5GxQIx8o28U5nhtDxg.gif"></p>
<h5><em>Such Rx. Much Reactive. Wow!</em></h5>
<p>In short, you can use Rx almost everywhere — but <strong>you shouldn’t</strong>. You should intelligently figure out where it should go. Because in some instances, Rx can be a 100 times more productive and better than normal imperative programming, and in others, it just isn’t necessary.</p>
<p>I’ll demonstrate a few examples in both <strong>Kotlin</strong> and <strong>Java</strong> so that you get an idea of Rx as well as a comparison of the two languages.</p>
<blockquote>
<p>Now if you’re not familiar with Kotlin, then I suggest that you visit these links</p>
<p><a href="http://kotlinlang.org">Official Kotlin Website</a></p>
<p><a href="http://kotlinlang.org/docs/tutorials/kotlin-android.html">Getting Started on Android</a></p>
<p><a href="https://docs.google.com/document/d/1ReS3ep-hjxWA8kZi0YqDbEhCqTt29hG8P44aA9W0DM8/edit?usp=sharing">Jake Wharton’s Paper on Kotlin</a></p>
<p><a href="https://medium.com/@ahmedrizwan/android-programming-with-kotlin-6ce3f9b0cbe6">My Blog</a> ;)</pre></p>
<p>Short Summary : Kotlin is an awesometacular alternative to Java, that works amazingly well on Android. And oh, it's developed by JetBrains!</p>
<p>P.S. There are no semicolons in Kotlin. *_*</p>
</blockquote>
<h4>Rx: The Concept</h4>
<p>If you already have a good concept of Rx, then you can skip this topic. Otherwise... read on!</p>
<p>Ok so what is Rx? Well... It’s “reactive programming”... Reactive programming is, in easy words, a programming pattern closely related to the <strong>Observer</strong> <strong>Pattern</strong>. In which, Subscribers “react” to the events emmited by the Observable(s).</p>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/800/1*Oa7zxVaeyF4TO6Mres4E5w.png"></p>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/400/1*ATqZ5sek2uAPfZMdmsWHSg.png"></p>
<h5><em>Transformations as the subscriber receives data from observable.</em></h5>
<p>Rx is also a subset of <strong>Functional Programming</strong>. Hence often referred to as Functional Reactive Programming. Because... As the subscribers receive data, they can apply a sequence of <strong>transformations</strong> on them. (Similar to what we can do with Streams in Java 8)</p>
<p>We can even combine/merge different streams too. It’s that <strong>flexible</strong>! So... For now, just remember there are tons of different things we can do with the data we (the subscribers) receive from observables, on the fly!</p>
<p>Now that the concept is somewhat clear, lets come back to RxJava.</p>
<p>In Rx, the <strong>subscriber</strong> implements three methods to interact with observable</p>
<ol>
<li>onNext(Data) : Receives the data from Observable</li>
<li>onError(Exception) : Gets called if an exception is thrown</li>
<li>onCompleted() : Gets called when the data stream ends</li>
</ol>
<p>This can be compared to the <strong>Iterables</strong> in Java. The difference is that iterables are <strong>pull</strong>-based, and Rx observables are <strong>push</strong>-based as the Observable pushes out data to its subscribers. Here’s the comparison table...</p>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/800/1*6xrzAdP_wa6aR80UrNxiIw.png"></p>
<blockquote>
<p>Another thing to note is that Rx is <strong>asynchronous</strong> in nature, meaning subscribers aren’t going to be waiting for other subscribers to finish. They’ll “asynchronously” process the streams.</p>
</blockquote>
<p>So... Observables push out <strong>streams of data</strong> to their subscribers, and subscribers can consume those streams (with the help of the methods listed above)<strong>.</strong> We can understand “streams” a bit better with the help of <a href="http://rxmarbles.com">Marble Diagrams</a>...</p>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/800/1*2-sTf0tHsmDlent1HLIhrg.png"></p>
<h5><em>A marble diagram representing two different streams.</em></h5>
<p>The cirlces on these streams represent <strong>data objects</strong>. And the arrows represent that the data is flowing in one direction (not referring to the boy band), in an orderly fashion! Have a look at this marble diagram...</p>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/800/1*ju5YD8bRZhdCGmptRQdmlw.png"></p>
<h5><em>A mapping of a stream.</em></h5>
<p>Like I mentioned before, we can <strong>transform</strong> the data (as well as streams) using <a href="https://github.com/ReactiveX/RxJava/wiki/Alphabetical-List-of-Observable-Operators"><strong>operators</strong></a> like map, filter, zip etc. The image above represents a simple mapping. So after this transformation, the subscriber to this stream will get the transformed version of the stream. Cool, right?</p>
<p>I think you should now have a good concept of how things work in Rx, so lets get to the actual implementation.</p>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/800/1*-nTq2bHQbJZctDZZoPnBYQ.png"></p>
<h4>Implementing Observables</h4>
<p>The first thing we have to do is meditate.</p>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/800/1*I6aMRP_WrXdse197zfBh1Q.jpeg"></p>
<p>After that, creating an Observable is not that difficult.</p>
<p>There are a number of ways we can <a href="https://github.com/ReactiveX/RxJava/wiki/Creating-Observables">create observables</a>, I’ll list down just three here.</p>
<ol>
<li><strong>Observable.from()</strong> : Creates an observable from an Iterable, a Future, or an Array.</li>
</ol>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">//Kotlin</span>
Observable.from(listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>))
<span class="hljs-comment">//Java</span>
Observable.from(Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>));

<span class="hljs-comment">//It will emit these numbers in order : 1 - 2 - 3 - 4 - 5</span>
<span class="hljs-comment">//Which should be pretty obvious I guess.</span></code></pre>
<ol start="2">
<li><strong>Observable.just()</strong> : Creates observable from an object or several objects</li>
</ol>
<pre><code class="hljs language-kotlin">Observable.just(<span class="hljs-string">"Hello World!"</span>)
<span class="hljs-comment">//this will emit "Hello World!" to all its subscribers</span></code></pre>
<ol start="3">
<li><strong>Observable.create()</strong> : Creates an Observable from scratch by means of a function. We just implement the OnSubscribe interface and tell the observable what it should send to its subscriber(s).</li>
</ol>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">//Kotlin</span>
Observable.create(<span class="hljs-keyword">object</span> : Observable.OnSubscribe&#x3C;<span class="hljs-built_in">Int</span>> {
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">call</span><span class="hljs-params">(subscriber: <span class="hljs-type">Subscriber</span>&#x3C;<span class="hljs-type">in</span> <span class="hljs-type">Int</span>>)</span></span> {
        <span class="hljs-keyword">for</span>(i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span> .. <span class="hljs-number">5</span>)
            subscriber.onNext(i)

        subscriber.onCompleted()
    }
})</code></pre>
<p>And the java version of the same code...</p>
<pre><code class="hljs language-java"><span class="hljs-comment">//Java</span>
Observable.create(<span class="hljs-keyword">new</span> Observable.OnSubscribe&#x3C;Integer>() {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Subscriber&#x3C;? <span class="hljs-keyword">super</span> Integer> 
subscriber)</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &#x3C;= <span class="hljs-number">5</span>; i++)
            subscriber.onNext(i);

        subscriber.onCompleted();
    }
});

<span class="hljs-comment">//Using the implementation above, we're telling the observer what //it should do when a subscriber subscribes to it. Hence the name //"onSubscribe".</span></code></pre>
<p>The code I’ve written above is equivalent to the example I wrote for Observable.from() but as you can see, we have full control as to what should be emitted and when should the stream end. I can also send caught exceptions with the use of <strong>subscriber.onError(e)</strong>.</p>
<p>Now we need subscribers!</p>
<h4>Implementing Subscribers</h4>
<p>After we have implemented our Observables... All we need is a subscriber! For Android, to subscribe to an observable, we first tell the observable about the threads on which we’re going to be subscribing and observing. RxAndroid gives us <a href="https://github.com/ReactiveX/RxJava/wiki/The-RxJava-Android-Module"><strong>Schedulers</strong></a>, through which we can specify the thread<strong>s</strong>. So lets take a simple “Hello World” observable for example in which I want the subscription to be done on a <strong>worker thread</strong>, and observation on the <strong>main thread</strong>.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">//Kotlin</span>
Observable.just(<span class="hljs-string">"Hello World"</span>)
          .subscribeOn(Schedulers.newThread())
          <span class="hljs-comment">//each subscription is going to be on a new thread.</span>
          .observeOn(AndroidSchedulers.mainThread()))
          <span class="hljs-comment">//observation on the main thread</span>
          <span class="hljs-comment">//Now our subscriber!</span>
          .subscribe(<span class="hljs-keyword">object</span>:Subscriber&#x3C;String>(){
            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">()</span></span> {
             <span class="hljs-comment">//Completed</span>
            }

            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onError</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>?)</span></span> {
             <span class="hljs-comment">//TODO : Handle error here</span>
            }

            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onNext</span><span class="hljs-params">(t: <span class="hljs-type">String</span>?)</span></span> {
             Log.e(<span class="hljs-string">"Output"</span>,t);
            }
           })</code></pre>
<pre><code class="hljs language-java"><span class="hljs-comment">//Java </span>
Observable.just(<span class="hljs-string">"Hello World"</span>)
        .subscribeOn(Schedulers.newThread())
        .observeOn(AndroidSchedulers.mainThread())
        .subscribe(<span class="hljs-keyword">new</span> Subscriber&#x3C;String>() {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">()</span> </span>{
                <span class="hljs-comment">//Completion</span>
            }

            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Throwable e)</span> </span>{
                <span class="hljs-comment">//TODO : Handle error here</span>
            }

            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String s)</span> </span>{
                Log.e(<span class="hljs-string">"Output"</span>,s);
            }
        });

<span class="hljs-comment">//You can get more info about schedulers and threading here.</span></code></pre>
<p>So... What does it do?</p>
<p>When you run this code — It’ll display a log message</p>
<pre><code>Output: Hello World!
</code></pre>
<p>And that’s it! This is how simple “subscription” is... You can get more details about subscribe <a href="http://reactivex.io/documentation/operators/subscribe.html">here</a>.</p>
<h4>A Practical Example : Debounce!</h4>
<p>Ok by now... You know how to create simple observables, right? So let’s do one of my favorite RxExamples... I want to implement this :</p>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/400/1*lyOcKYAvTjDnArAN4rEDNw.gif"></p>
<p>In this example, I enter text into an EditText and against this text, a response is triggered automatically —in which I print out the text. Now the response could be a call to an API. So if I trigger this call for every character I enter — that would be a waste because I only need the last one, meaning it should trigger a call only when I stop typing — let’s say after 1 second of typing-inactivity.</p>
<p>So how do we do this in non-reactive programming?</p>
<p>Well it ain’t pretty!</p>
<p><strong>Non-Reactive Solution</strong></p>
<p>I use a Timer, and schedule it to call <strong>run</strong>() method after a 1000 milliseconds delay in <strong>afterTextChanged()</strong> method. Oh and don’t forget to add <strong>runOnUiThread</strong>() in there as well. -_-</p>
<p>Conceptually it’s not that difficult but the code becomes very cluttered, even more so in Java!</p>
<p>Java version</p>
<pre><code class="hljs language-java"><span class="hljs-comment">//Java</span>
Timer timer = <span class="hljs-keyword">new</span> Timer();

<span class="hljs-keyword">final</span> TextView textView = (TextView) findViewById(R.id.textView);
<span class="hljs-keyword">final</span> EditText editText = (EditText) findViewById(R.id.editText);

editText.addTextChangedListener(<span class="hljs-keyword">new</span> TextWatcher() {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforeTextChanged</span><span class="hljs-params">(CharSequence s, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> count,
                                  <span class="hljs-keyword">int</span> after)</span> </span>{
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onTextChanged</span><span class="hljs-params">(<span class="hljs-keyword">final</span> CharSequence s, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> before,
                              <span class="hljs-keyword">int</span> count)</span> </span>{
        <span class="hljs-keyword">if</span> (timer != <span class="hljs-keyword">null</span>)
            timer.cancel();
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterTextChanged</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Editable s)</span> </span>{
        timer = <span class="hljs-keyword">new</span> Timer();
        timer.schedule(<span class="hljs-keyword">new</span> TimerTask() {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
                runOnUiThread(<span class="hljs-keyword">new</span> Runnable() {
                    <span class="hljs-meta">@Override</span>
                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
                        textView.setText(<span class="hljs-string">"Output : "</span> + editText.getText());
                    }
                });
            }

        }, <span class="hljs-number">1000</span>);
    }
});</code></pre>
<p>Kotlin</p>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">//Kotlin</span>
<span class="hljs-keyword">var</span> timer: Timer? = Timer()

<span class="hljs-keyword">val</span> editTextStop = findViewById(R.id.editText) <span class="hljs-keyword">as</span> EditText
editTextStop.addTextChangedListener(<span class="hljs-keyword">object</span> : TextWatcher {
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">beforeTextChanged</span><span class="hljs-params">(s: <span class="hljs-type">CharSequence</span>, start: <span class="hljs-type">Int</span>, count: <span class="hljs-type">Int</span>, after: <span class="hljs-type">Int</span>)</span></span> = <span class="hljs-built_in">Unit</span>

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onTextChanged</span><span class="hljs-params">(s: <span class="hljs-type">CharSequence</span>, start: <span class="hljs-type">Int</span>, before: <span class="hljs-type">Int</span>, count: <span class="hljs-type">Int</span>)</span></span> {
            timer?.cancel()
    }

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">afterTextChanged</span><span class="hljs-params">(s: <span class="hljs-type">Editable</span>)</span></span> {
        timer = Timer()
        timer!!.schedule(<span class="hljs-keyword">object</span> : TimerTask() {
            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span> {
                runOnUiThread { textView.setText(<span class="hljs-string">"Output : "</span> + editTextStop.getText()) }
            }
        }, <span class="hljs-number">1000</span>)
    }
})</code></pre>
<p><strong>Reactive Solution</strong></p>
<p>Reactive solution is very boilerplate-free. And there are only 3 steps to it.</p>
<ol>
<li>Create an observable</li>
<li>Add Debounce operator with 1000 Milliseconds (1 second) delay</li>
<li>Subscribe to it</li>
</ol>
<p>First the Java code</p>
<pre><code class="hljs language-java">   Observable.create(<span class="hljs-keyword">new</span> Observable.OnSubscribe&#x3C;String>() {
                    <span class="hljs-meta">@Override</span>
                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Subscriber&#x3C;? <span class="hljs-keyword">super</span> String> subscriber)</span> </span>{
                        editText.addTextChangedListener(<span class="hljs-keyword">new</span> TextWatcher() {
                            <span class="hljs-meta">@Override</span>
                            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforeTextChanged</span><span class="hljs-params">(<span class="hljs-keyword">final</span> CharSequence s, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> count, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> after)</span> </span>{
                            }

                            <span class="hljs-meta">@Override</span>
                            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onTextChanged</span><span class="hljs-params">(<span class="hljs-keyword">final</span> CharSequence s, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> before, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> count)</span> </span>{
                                subscriber.onNext(s.toString());
                            }

                            <span class="hljs-meta">@Override</span>
                            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterTextChanged</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Editable s)</span> </span>{
                            }
                        });
                    }
                })
                .debounce(<span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS)
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(<span class="hljs-keyword">new</span> Action1&#x3C;String>() {
                    <span class="hljs-meta">@Override</span>
                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String s)</span> </span>{
                        textView.setText(<span class="hljs-string">"Output : "</span> + s);
                    }
                });</code></pre>
<p>Now Kotlin ❤</p>
<pre><code class="hljs language-kotlin">        Observable.create(Observable.OnSubscribe&#x3C;String> { subscriber ->
            editText.addTextChangedListener(<span class="hljs-keyword">object</span> : TextWatcher {
                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">afterTextChanged</span><span class="hljs-params">(s: <span class="hljs-type">Editable</span>?)</span></span> = <span class="hljs-built_in">Unit</span>

                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">beforeTextChanged</span><span class="hljs-params">(s: <span class="hljs-type">CharSequence</span>?, start: <span class="hljs-type">Int</span>, count: <span class="hljs-type">Int</span>, after: <span class="hljs-type">Int</span>)</span></span> = <span class="hljs-built_in">Unit</span>

                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onTextChanged</span><span class="hljs-params">(s: <span class="hljs-type">CharSequence</span>, start: <span class="hljs-type">Int</span>, before: <span class="hljs-type">Int</span>, count: <span class="hljs-type">Int</span>)</span></span>
                        = subscriber.onNext(s.toString())
            })
        }).debounce(<span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS)
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe({
                    text ->
                    textView.text = <span class="hljs-string">"Output : "</span> + text
                })</code></pre>
<h4>Even Less Boilerplate →RxBindings!</h4>
<p>Now for almost no boilerplate, we can use <a href="https://github.com/JakeWharton/RxBinding"><strong>RxBindings</strong></a>which has many super-awesome bindings for UI widgets. And it works on both Java and Kotlin! Using bindings, the code becomes...</p>
<pre><code class="hljs language-java">    <span class="hljs-comment">//Java with Retrolambda and RxBinding</span>
    RxTextView.afterTextChangeEvents(editText)
              .debounce(<span class="hljs-number">1000</span>,TimeUnit.MILLISECONDS)
              .observeOn(AndroidSchedulers.mainThread())
              .subscribe(tvChangeEvent -> {
                 textView.setText(<span class="hljs-string">"Output : "</span> + tvChangeEvent.view()
                            .getText());
              });</code></pre>
<pre><code class="hljs language-kotlin">    <span class="hljs-comment">//Kotlin with RxBinding</span>
    RxTextView.afterTextChangeEvents(editText)
              .debounce(<span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS)
              .observeOn(AndroidSchedulers.mainThread())
              .subscribe { tvChangeEvent ->
                        textView.text = <span class="hljs-string">"Output : "</span> + tvChangeEvent.view().text
              }</code></pre>
<p>As you would’ve noticed, there’s very little boilerplate and the code is much more to-the-point. If I were to go back to this code in a few months, it would hardly take me a minute to figure out what’s going on. And that is... Priceless!</p>
<p>Here are some awesome resources for Rx that I recommend. Do check these out! I will further play around with Rx+(Kotlin &#x26; Java) and complete part 2, so stay tuned and happy coding!</p>
<ul>
<li><a href="http://reactivex.io">Official Rx Page</a></li>
<li><a href="http://blog.danlew.net/2014/09/15/grokking-rxjava-part-1/">Grokking RxJava Series by Dan Lew</a></li>
<li><a href="http://beust.com/weblog/2015/03/23/android-rx-and-kotlin-a-case-study/">Android Rx, and Kotlin : A case study</a></li>
<li><a href="http://stablekernel.com/blog/replace-asynctask-asynctaskloader-rx-observable-rxjava-android-patterns/">Replace AsyncTasks with Rx</a></li>
<li><a href="http://www.philosophicalhacker.com/2015/06/12/an-introduction-to-rxjava-for-android/">PhilosophicalHacker Blog on Rx</a></li>
<li><a href="http://nerds.weddingpartyapp.com/tech/2014/12/24/implementing-an-event-bus-with-rxjava-rxbus/">Implementing EventBus in Rx</a></li>
<li><a href="https://github.com/ReactiveX/RxKotlin">RxKotlin</a></li>
</ul>
]]></description><link>https://medium.com/@ahmedrizwan/rxandroid-and-kotlin-part-1-f0382dc26ed8#.bx3rgamfo</link><guid isPermaLink="true">https://medium.com/@ahmedrizwan/rxandroid-and-kotlin-part-1-f0382dc26ed8#.bx3rgamfo</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[RxAndroid]]></category><category><![CDATA[Android]]></category><dc:creator><![CDATA[Ahmed Rizwan]]></dc:creator><pubDate>Sat, 27 Jun 2015 11:16:00 GMT</pubDate></item><item><title><![CDATA[Quasar and Kotlin - a Powerful Match]]></title><description><![CDATA[<p>June 04, 2015</p>
<p>Following the release of <a href="http://blog.jetbrains.com/kotlin/2015/05/kotlin-m12-is-out/">Kotlin M12</a> and of <a href="http://blog.paralleluniverse.co/2015/05/29/quasar-pulsar-0-7-0/">Quasar 0.7.0</a> introducing support for it, let’s now have a closer look at how Kotlin and Quasar work together.</p>
<p><a href="http://kotlinlang.org/">Kotlin</a> is JetBrains’ fun, statically-typed, safe, interoperable and expressive language targeting the JVM, Android and JavaScript. Pragmatic and efficient, it also features an excellent <a href="https://www.jetbrains.com/idea/">IntelliJ Idea</a> integration from the start (which is my own and many other folks’ favourite IDE BTW). Finally our joint work with the Kotlin team has made Quasar on Kotlin smooth, natural and fast.</p>
<p>Enabling Quasar support for Kotlin in your project is as easy as adding <code>quasar-kotlin</code> as a dependency and using one of Kotlin plugins for build systems, for example <a href="http://kotlinlang.org/docs/reference/using-gradle.html">Gradle’s</a>. We’ll start from a bird’s-eye view of our <a href="https://github.com/puniverse/quasar/blob/master/quasar-kotlin/src/test/kotlin/co/paralleluniverse/kotlin/actors/PingPong.kt">ping-pong actor test</a> and then we’ll zoom in:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Msg</span></span>(<span class="hljs-keyword">val</span> txt: String, <span class="hljs-keyword">val</span> from: ActorRef&#x3C;Any?>)

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ping</span></span>(<span class="hljs-keyword">val</span> n: <span class="hljs-built_in">Int</span>) : Actor() {
    Suspendable <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doRun</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">val</span> pong = ActorRegistry.getActor&#x3C;Any?>(<span class="hljs-string">"pong"</span>)
        <span class="hljs-keyword">for</span>(i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span>.n) {
            pong.send(Msg(<span class="hljs-string">"ping"</span>, self()))          <span class="hljs-comment">// Fiber-blocking</span>
            receive {                               <span class="hljs-comment">// Fiber-blocking</span>
                <span class="hljs-keyword">when</span> (it) {
                    <span class="hljs-string">"pong"</span> -> println(<span class="hljs-string">"Ping received pong"</span>)
                    <span class="hljs-keyword">else</span> -> <span class="hljs-literal">null</span>                    <span class="hljs-comment">// Discard</span>
                }
            }
        }
        pong.send(<span class="hljs-string">"finished"</span>)                       <span class="hljs-comment">// Fiber-blocking</span>
        println(<span class="hljs-string">"Ping exiting"</span>)
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pong</span></span>() : Actor() {
    Suspendable <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doRun</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
            <span class="hljs-comment">// snippet Kotlin Actors example</span>
            receive(<span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS) {  <span class="hljs-comment">// Fiber-blocking</span>
                <span class="hljs-keyword">when</span> (it) {
                    <span class="hljs-keyword">is</span> Msg -> {
                        <span class="hljs-keyword">if</span> (it.txt == <span class="hljs-string">"ping"</span>)
                            it.from.send(<span class="hljs-string">"pong"</span>)    <span class="hljs-comment">// Fiber-blocking</span>
                    }
                    <span class="hljs-string">"finished"</span> -> {
                        println(<span class="hljs-string">"Pong received 'finished', exiting"</span>)
                        <span class="hljs-keyword">return</span>                      <span class="hljs-comment">// Non-local return, exit actor</span>
                    }
                    <span class="hljs-keyword">is</span> Timeout -> {
                        println(<span class="hljs-string">"Pong timeout in 'receive', exiting"</span>)
                        <span class="hljs-keyword">return</span>                      <span class="hljs-comment">// Non-local return, exit actor</span>
                    }
                    <span class="hljs-keyword">else</span> -> defer()
                }
            }
            <span class="hljs-comment">// end of snippet</span>
        }
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tests</span> </span>{
    Test <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">testActors</span><span class="hljs-params">()</span></span> {
        spawn(register(<span class="hljs-string">"pong"</span>, Pong()))
        spawn(Ping(<span class="hljs-number">3</span>))
    }
}</code></pre>
<h2>Data</h2>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Msg</span></span>(<span class="hljs-keyword">val</span> txt: String = <span class="hljs-string">"Hello"</span>, <span class="hljs-keyword">val</span> from: ActorRef&#x3C;Any?>)</code></pre>
<p>Yes, Kotlin supports <a href="http://kotlinlang.org/docs/reference/data-classes.html">data classes</a>. This means that when you need a one-liner to hold some info, it can be a one-liner for real. Kotlin will generate sensible <code>equals</code>, <code>hashCode</code>, <code>toString</code> as well as deconstruction support, so that you can easily write:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> myMsg = Msg(txt = <span class="hljs-string">"Hi"</span>, from = me)
<span class="hljs-comment">// ...</span>
<span class="hljs-keyword">val</span> (txt, from) = myMsg</code></pre>
<p>Add to that type inference, a shorter construction syntax for class instances (no <code>new</code> needed), default parameter values, invocation with named arguments and support for immutability with <code>val</code> declarations and you’ve got a full toolbox for your message-crafting actor needs (and more). Should you need to copy your message in full or in part:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> myNewMsg = myMsg.copy(txt = <span class="hljs-string">"Howdy"</span>)</code></pre>
<p><code>Pair</code> and <code>Triple</code> are included in the standard library, too <sup id="fnref:bigger-tuples"><a href="#fn:bigger-tuples">1</a></sup>.</p>
<p><code>ActorRef&#x3C;Any?></code> represents a reference to a Quasar actor whose <code>send</code> can accept values of any type, including <code>null</code>s. <code>Any</code> is the utmost super-type in Kotlin and the question mark specifies that it is <em>nullable</em> here (the default in Kotlin is non-nullable). If a value is of a non-nullable type, Kotlin will check against nulls at compile time for Kotlin code, and at runtime for values produced by Java invocations <sup id="fnref:java-interop"><a href="#fn:java-interop">2</a></sup>.</p>
<h2>Classes</h2>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ping</span></span>(<span class="hljs-keyword">val</span> n: <span class="hljs-built_in">Int</span>) : Actor()</code></pre>
<p><code>Ping</code> inherits from the base <code>Actor</code> Kotlin class <sup id="fnref:untyped-actors"><a href="#fn:untyped-actors">3</a></sup> and it is <em>final</em>. This is the default in Kotlin because designing for inheritance is difficult and control over class hierarchies is important, so inheritance support must be declared explicitly through the <code>open</code> class modifier.</p>
<p>In Kotlin you can define your primary constructor without specifying a body and declare its parameters as properties by prefixing <code>val</code> (immutable) or <code>var</code> (mutable), which you need to do if you plan to use them not only during initialization but in methods too. A parent class’ constructor invocation is inline with inheritance declaration, and a short <code>:</code> is enough to specify that.</p>
<p>We declare <code>n</code> as a property because our actor is going to use it in its <code>doRun</code> execution body:</p>
<pre><code class="hljs language-kotlin">Suspendable <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doRun</span><span class="hljs-params">()</span></span> {
      <span class="hljs-comment">// ...</span>
}</code></pre>
<p>The <code>override</code> modifier is mandatory and the <code>Suspendable</code> annotation allows our actor’s fiber to invoke fiber-blocking calls such as <code>send</code> and <code>receive</code>. <a href="http://kotlinlang.org/docs/reference/annotations.html">Kotlin annotations</a> don’t need to be preceded by <code>@</code> in most situations, which allow them to appear naturally as user-defined modifiers. Kotlin also supports <a href="http://blog.jetbrains.com/kotlin/2015/05/kapt-annotation-processing-for-kotlin/">JSR-269 annotation processing</a>.</p>
<h2>Fiber-blocking Kotlin actors</h2>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> pong = ActorRegistry.getActor&#x3C;Any?>(<span class="hljs-string">"pong"</span>)
<span class="hljs-keyword">for</span>(i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span>.n) {
    pong.send(Msg(<span class="hljs-string">"ping"</span>, self()))          <span class="hljs-comment">// Fiber-blocking</span>
    receive {                               <span class="hljs-comment">// Fiber-blocking</span>
        <span class="hljs-keyword">when</span> (it) {
            <span class="hljs-string">"pong"</span> -> println(<span class="hljs-string">"Ping received pong"</span>)
            <span class="hljs-keyword">else</span> -> <span class="hljs-literal">null</span>                    <span class="hljs-comment">// Discard</span>
        }
    }
}
pong.send(<span class="hljs-string">"finished"</span>)                       <span class="hljs-comment">// Fiber-blocking</span></code></pre>
<p><code>Ping</code> leads the game here: it gets a reference to <code>Pong</code> from the global registry, then <code>send</code>s and <code>receive</code>s ping pongs <code>n</code> times, after which it tells <code>Pong</code> to bail out before quitting itself. It’s once again as simple as it was with regular threads: just straightforward imperative constructs and blocking calls, only much more efficient thanks to fibers.</p>
<p>Kotlin makes it even sweeter though. Apart from the nice looping construct with <a href="http://kotlinlang.org/docs/reference/ranges.html">ranges</a>, let’s have a deeper look at the <a href="http://docs.paralleluniverse.co/quasar/#sending-and-receiving-messages-actorref"><em>selective receive</em></a> block:</p>
<pre><code class="hljs language-kotlin">receive {                               <span class="hljs-comment">// Fiber-blocking</span>
    <span class="hljs-keyword">when</span> (it) {
        <span class="hljs-string">"pong"</span> -> println(<span class="hljs-string">"Ping received pong"</span>)
        <span class="hljs-keyword">else</span> -> <span class="hljs-literal">null</span>                    <span class="hljs-comment">// Discard</span>
    }
}</code></pre>
<p>It feels like a new construct, doesn’t it? This neat small DSL employs no less than 3 advanced Kotlin features: <a href="http://kotlinlang.org/docs/reference/lambdas.html">lambdas</a> with <a href="http://kotlinlang.org/docs/reference/inline-functions.html">inline functions</a> and the type-safe <a href="http://kotlinlang.org/docs/reference/control-flow.html#when-expression">matching <code>when</code> expression</a>.</p>
<p>The block following <code>receive</code> is actually a single-argument <em>lambda</em> for which Kotlin provides an extremely compact syntax. You can even avoid naming the argument: it’ll be called <code>it</code> as in this case, and of course you can skip brackets along the way. This is <code>receive</code>’s Kotlin signature:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">receive</span><span class="hljs-params">(proc: (<span class="hljs-type">Any</span>)</span></span> -> Any?)</code></pre>
<p><code>proc</code> is a selection and transformation function: it can accept (and possibly transform), discard or delay an incoming message. If a message is accepted, it is returned by the <code>receive</code> call.</p>
<p>Here <code>proc</code> contains only a matching <code>when</code> expression, which is type-checked for matching exhaustiveness and, of course, type correctness <sup id="fnref:when"><a href="#fn:when">4</a></sup>. Yielding <code>null</code> in <code>proc</code> discards the value and <em>doesn’t</em> return from <code>receive</code>; calling <code>defer()</code> will skip the message in the current <code>receive</code> call, leaving it in the mailbox, while producing any other value (even <code>Unit</code> like the <code>println</code> statement in the <code>"pong"</code> branch) will make the <code>receive</code> call return and control flow will proceed to the next iteration in the <code>for</code> loop.</p>
<p>Let’s take a glance at <code>Pong</code>’s main loop:</p>
<pre><code class="hljs language-kotlin">receive(<span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS) {  <span class="hljs-comment">// Fiber-blocking</span>
    <span class="hljs-keyword">when</span> (it) {
        <span class="hljs-keyword">is</span> Msg -> {
            <span class="hljs-keyword">if</span> (it.txt == <span class="hljs-string">"ping"</span>)
                it.from.send(<span class="hljs-string">"pong"</span>)    <span class="hljs-comment">// Fiber-blocking</span>
        }
        <span class="hljs-string">"finished"</span> -> {
            println(<span class="hljs-string">"Pong received 'finished', exiting"</span>)
            <span class="hljs-keyword">return</span>                      <span class="hljs-comment">// Non-local return, exit actor</span>
        }
        <span class="hljs-keyword">is</span> Timeout -> {
            println(<span class="hljs-string">"Pong timeout in 'receive', exiting"</span>)
            <span class="hljs-keyword">return</span>                      <span class="hljs-comment">// Non-local return, exit actor</span>
        }
        <span class="hljs-keyword">else</span> -> defer()
    }
}</code></pre>
<p>In this case we’re calling a selective receive with a timeout <sup id="fnref:receive"><a href="#fn:receive">5</a></sup>. Two more notable Kotlin features and two API features work together here to make this code short, readable and powerful. As for Kotlin:</p>
<ul>
<li><code>is Msg</code> is a type check that performs a <em>smart cast</em>, so that <code>it</code> acquires the <code>Msg</code> type in its clause and properties can be accessed as simply as <code>it.txt</code> and <code>it.from</code>.</li>
<li><code>return</code> in the <em>inline lambda</em> performs a <em>non-local return</em>, that is it makes the <code>doRun</code> invocation return, after which the actor will quit <sup id="fnref:only-inline"><a href="#fn:only-inline">6</a></sup>.</li>
</ul>
<p>The Kotlin Actors API adds the following:</p>
<ul>
<li><code>defer()</code> implements <em>selective receive</em> by skipping messages in the current <code>receive</code> call.</li>
<li>A <code>Timeout</code> message can be used to handle timeouts directly in the processing lambda if you so wish, without even returning from the <code>receive</code> call.</li>
</ul>
<h2>Now with plain, healthy fibers</h2>
<p>There’s now a neat Kotlin port of the <code>quasar-gradle-template</code> in the <code>kotlin</code> branch. I built it very quickly by copying and pasting the previous Java source to a new Kotlin file in IntelliJ Idea and confirming Kotlin conversion! Of course then I polished it to my tastes and added the semantics that were missing in Java, and here’s the result:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">package</span> testgrp

<span class="hljs-comment">// ...</span>

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doAll</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span>? {
    <span class="hljs-keyword">val</span> increasingToEcho = Channels.newIntChannel(<span class="hljs-number">0</span>) <span class="hljs-comment">// Synchronizing channel (buffer = 0)</span>
    <span class="hljs-keyword">val</span> echoToIncreasing = Channels.newIntChannel(<span class="hljs-number">0</span>) <span class="hljs-comment">// Synchronizing channel (buffer = 0)</span>

    <span class="hljs-keyword">val</span> increasing = Fiber(SuspendableCallable(<span class="hljs-meta">@Suspendable</span> {
        <span class="hljs-keyword">var</span> curr = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span><span class="hljs-number">.9</span>) {
            Fiber.sleep(<span class="hljs-number">1000</span>)
            println(<span class="hljs-string">"INCREASER sending: "</span> + curr)
            increasingToEcho.send(curr)
            curr = echoToIncreasing.receive()
            println(<span class="hljs-string">"INCREASER received: "</span> + curr)
            curr++
            println(<span class="hljs-string">"INCREASER now: "</span> + curr)
        }
        println(<span class="hljs-string">"INCREASER closing channel and exiting"</span>)
        increasingToEcho.close()
        curr;
    })).start()

    <span class="hljs-keyword">val</span> echo = Fiber(SuspendableCallable(<span class="hljs-meta">@Suspendable</span> {
        <span class="hljs-keyword">val</span> curr: <span class="hljs-built_in">Int</span>?
        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
            Fiber.sleep(<span class="hljs-number">1000</span>)
            curr = increasingToEcho.receive()
            println(<span class="hljs-string">"ECHO received: "</span> + curr)

            <span class="hljs-keyword">if</span> (curr != <span class="hljs-literal">null</span>) {
                println(<span class="hljs-string">"ECHO sending: "</span> + curr)
                echoToIncreasing.send(curr)
            } <span class="hljs-keyword">else</span> {
                println(<span class="hljs-string">"ECHO detected closed channel, closing and exiting"</span>)
                echoToIncreasing.close()
                <span class="hljs-keyword">break</span>
            }
        }
    })).start()

    increasing.join()
    echo.join()

    <span class="hljs-keyword">return</span> increasing.<span class="hljs-keyword">get</span>()
}

<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&#x3C;<span class="hljs-type">String</span>>)</span></span> {
    doAll()
}</code></pre>
<p>Wait, where are the classes? Functions can be toplevel in Kotlin: a class is generated for each package with static methods corresponding to toplevel functions. We’re not doing real OOP here, so we won’t define classes and Kotlin allows us to skip them altogether if we don’t need them. That makes sense and eliminates boilerplate, doesn’t it?</p>
<p>As for the packages, they are completely <em>disjoint</em> from source files organization in directories and that allows freedom and convenience. Of course with great powers comes great responsibility but why should I bother creating directories only in order to use packages, when my project is made of a single source file (or a handful of them)? And since Kotlin is very concise, this situation will arise more often than you think.</p>
<p>Now, where are the types instead? This example is strongly typed but most of the types are inferred. There are only a handful of them:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doAll</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span>?</code></pre>
<p>In Kotlin, <code>public</code> and <code>protected</code> functions need to be <em>explicitly typed</em> both in the argument and return type because they <em>are public API</em> and we don’t want to alter it by mistake because we changed the body (and type inference has adjusted types consequently without us noticing) <sup id="fnref:public-api"><a href="#fn:public-api">7</a></sup>.</p>
<p>In this case though, this function has <em>module-level</em> access (“internal”). Why does it still need to be fully typed? Because it has a block body which can have complex control flow and type inference could easily confuse the reader (and hinder maintainability).</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> increasing = Fiber(SuspendableCallable(<span class="hljs-meta">@Suspendable</span> {</code></pre>
<p>What’s happening here? We’re passing a <code>Suspendable</code>-annotated lambda instead of a full blown object expression (which is more pleasant than Java’s anonymous classes anyway), similarly to what we’d do with Java 8 lambdas. The <code>SuspendableCallable</code> constructor helps Kotlin’s type inference engine to interoperate with Java functional interfaces (this will be simplified very soon so that there’ll be no need to explicitly mention <code>SuspendableCallable</code>). Finally we don’t need to declare actual type parameters for <code>Fiber</code> (no ugly <em>diamonds</em> either, sorry for people that like them) and of course not even for the <code>increasing</code> local.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">var</span> curr: <span class="hljs-built_in">Int</span>?</code></pre>
<p>Since we know that the value of the <code>curr</code> mutable local value will come from Java, we know it could become <code>null</code> (and at some point it actually needs to, in order to represent a closed Quasar channel). We’re telling Kotlin that in advance, so that it won’t emit fail-fast runtime checks that will trigger an exception when <code>curr</code> gets assigned a <code>null</code> value.</p>
<p>By contrast no type declaration is needed by the <code>curr</code> mutable local in the <code>increasing</code> fiber, because it will be inferred to be <code>Int</code> and since it will be managed completely within Kotlin code, the compiler will check statically that it will never become <code>null</code>:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">var</span> curr = <span class="hljs-number">0</span> <span class="hljs-comment">// Int</span></code></pre>
<h2>What else is there?</h2>
<p>Kotlin has loads of other advanced and convenient features that make it a pleasure to use not just with Quasar but in every occasion:</p>
<ul>
<li>Type-checking covers <a href="http://kotlinlang.org/docs/reference/null-safety.html">null safety</a> and allows <a href="http://kotlinlang.org/docs/reference/typecasts.html">smart type casts</a>; imperative programmers will enjoy <a href="http://kotlinlang.org/docs/reference/returns.html">returns and jumps</a> and <a href="http://kotlinlang.org/docs/reference/ranges.html">ranges</a> as well as <a href="http://kotlinlang.org/docs/reference/java-interop.html">excellent Java interoperability</a> and <a href="http://kotlinlang.org/docs/reference/exceptions.html#checked-exceptions">unchecked exceptions</a>.</li>
<li>Functional guys will appreciate <a href="http://kotlinlang.org/docs/reference/functions.html">higher-order functions and local functions</a> as well as <a href="http://kotlinlang.org/docs/reference/reflection.html#function-references">first-class method</a> and <a href="http://kotlinlang.org/docs/reference/reflection.html#property-references">property accessor</a> references.</li>
<li>DSL craftpeople will make good use of functional features, convenient syntax shortcuts and <a href="http://kotlinlang.org/docs/reference/type-safe-builders.html">type-safe builders</a>.</li>
<li>OOP has no shortage of tools either: <a href="http://kotlinlang.org/docs/reference/extensions.html">extension functions</a>, <a href="http://kotlinlang.org/docs/reference/interfaces.html">trait-like interfaces</a>, <a href="http://kotlinlang.org/docs/reference/classes.html">compact and common sense inheritance with sensible defaults</a>, <a href="http://kotlinlang.org/docs/reference/object-declarations.html#object-expressions">singleton objects</a>, <a href="http://kotlinlang.org/docs/reference/object-declarations.html#object-expressions">object expressions</a>, <a href="http://kotlinlang.org/docs/reference/generics.html">generics with declaration-site variance and type projections</a>, <a href="http://kotlinlang.org/docs/reference/enum-classes.html">feature-rich enums</a>, <a href="http://kotlinlang.org/docs/reference/delegation.html">delegation</a>, <a href="http://kotlinlang.org/docs/reference/properties.html#getters-and-setters">properties accessors</a> and <a href="http://kotlinlang.org/docs/reference/delegated-properties.html">delegated properties</a>.</li>
</ul>
<hr>
<ol>
<li>If you need bigger tuples it’s probably an hint that you’d better give them a more specific name for readability’s sake. <a href="#fnref:bigger-tuples">↩</a></li>
<li>See <a href="http://kotlinlang.org/docs/reference/java-interop.html">Java interoperability, platform types</a> and <a href="http://kotlinlang.org/docs/reference/null-safety.html">null safety</a>. <a href="#fnref:java-interop">↩</a></li>
<li>Kotlin actors are always untyped because typed actors are useful only in very simple cases, like short-lived transient actors, but not so much in more complex situations. <a href="#fnref:untyped-actors">↩</a></li>
<li><code>when</code> supports type maching, value matching against arbitrary expressions and range matching; see <a href="http://kotlinlang.org/docs/reference/control-flow.html">control flow</a>. <a href="#fnref:when">↩</a></li>
<li>The timeout overload is <code>inline protected fun receive(timeout: Long, unit: TimeUnit?, proc: (Any) -> Any?)</code> and it is non-blocking if the timeout is 0. <a href="#fnref:receive">↩</a></li>
<li>This is possible only with inline lambdas. <a href="#fnref:only-inline">↩</a></li>
<li>This is likely to become only a warning in the future. <a href="#fnref:public-api">↩</a></li>
</ol>
]]></description><link>http://blog.paralleluniverse.co/2015/06/04/quasar-kotlin/</link><guid isPermaLink="true">http://blog.paralleluniverse.co/2015/06/04/quasar-kotlin/</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Quasar]]></category><category><![CDATA[Fibers]]></category><dc:creator><![CDATA[Fabio]]></dc:creator><pubDate>Thu, 04 Jun 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[Kotlin: New Hope in a Java 6 Wasteland]]></title><description><![CDATA[<p><a href="https://speakerdeck.com/pardom/kotlin-new-hope-in-a-java-6-wasteland">Slides</a></p>
]]></description><link>https://speakerdeck.com/pardom/kotlin-new-hope-in-a-java-6-wasteland</link><guid isPermaLink="true">https://speakerdeck.com/pardom/kotlin-new-hope-in-a-java-6-wasteland</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[Android]]></category><dc:creator><![CDATA[Michael Pardo]]></dc:creator><pubDate>Sat, 09 May 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[Kotlin for Java developers]]></title><description><![CDATA[<iframe width="960" height="480" src="https://www.youtube.com/embed/vmjfIRsawlg" frameborder="0" allowfullscreen></iframe>
]]></description><link>https://www.youtube.com/watch?v=vmjfIRsawlg</link><guid isPermaLink="true">https://www.youtube.com/watch?v=vmjfIRsawlg</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Hadi Hariri]]></dc:creator><pubDate>Thu, 11 Dec 2014 21:54:00 GMT</pubDate></item><item><title><![CDATA[Non-trivial constructors in Kotlin]]></title><description><![CDATA[<p>Kotlin really simplifies things such as defining constructors and writing immutable objects for your application. For example, flexible Kotlin constructor definitions eliminate the need of <a href="http://en.wikipedia.org/wiki/Builder_pattern" title="Builder Pattern - Wikipedia">builder classes</a> (you simply don’t need them in 99% of all the possible use cases, if you use Kotlin), thus reducing overhead of having immutable objects in your application, while retaining full flexibility and expressiveness.</p>
<p>However, if you want to define non-trivial constructor (especially for <a href="http://kotlinlang.org/docs/reference/data-classes.html" title="Kotlin Data Classes">data classes</a>) it might not be as trivial as just writing a function.</p>
<p>For example, when I started playing with Kotlin, I decided to start with something as simple as defining a class that would represent a <a href="http://en.wikipedia.org/wiki/Rational_number" title="Rational Number - Wikipedia">rational number</a>.</p>
<p>My first brute force (or naive, if you like) attempt to define that class was as follows:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ratio</span> </span>(<span class="hljs-keyword">val</span> numerator : <span class="hljs-built_in">Int</span>, <span class="hljs-keyword">val</span> denominator : <span class="hljs-built_in">Int</span>)</code></pre>
<p>The problems with this class are obvious: you can create ratios like Ratio(1, 2) and Ratio(2, 4) and they won’t be equal to each other. And I wanted exact opposite – whenever the user of this class constructs a ratio it divides a numerator and denominator to their greatest common divisor – to have coprime numerator and denominator in the corresponding fields of the newly constructed instance of Ratio class. Also I wanted to retain nice-to-have features of the <a href="http://kotlinlang.org/docs/reference/data-classes.html" title="Kotlin Data Classes">data class</a> – I didn’t want to define copy, hashCode and equals myself.</p>
<p>So, at this point you’re welcome to play before reading my solution.</p>
<hr>
<p>OK, now if you came up with your approach or just would like to see the possible solution – here is the <a href="https://github.com/avshabanov/math/blob/master/approx/src/main/kotlin/ratio.kt" title="Ratio class definition in Kotlin">link to the full class definition</a> for those who interested.</p>
<p>In short: you can define custom class constructor (and yet retain call semantics) is to define <code>invoke</code> function in ‘class object’ section of your class that has special semantics: you can define static functions as well as factory function <code>invoke</code>. It may look as follows (simplified):</p>
<pre><code class="hljs language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ratio</span> <span class="hljs-keyword">private</span> </span>(<span class="hljs-keyword">val</span> numerator : <span class="hljs-built_in">Int</span>, <span class="hljs-keyword">val</span> denominator : <span class="hljs-built_in">Int</span>) {
  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">object</span> </span>{
    <span class="hljs-keyword">val</span> ZERO = Ratio(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// static member!</span>
    <span class="hljs-keyword">val</span> ONE = Ratio(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// static member!</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invoke</span><span class="hljs-params">(numerator : <span class="hljs-type">Int</span> = <span class="hljs-number">1</span>, denominator : <span class="hljs-type">Int</span> = <span class="hljs-number">1</span>)</span></span> : Ratio {
      <span class="hljs-keyword">if</span> (denominator == <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> IllegalArgumentException(<span class="hljs-string">"denominator can't be zero"</span>)
      <span class="hljs-keyword">if</span> (numerator == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ZERO
      <span class="hljs-keyword">if</span> (numerator == denominator) <span class="hljs-keyword">return</span> ONE

      <span class="hljs-keyword">val</span> d = gcd(numerator, denominator)
      <span class="hljs-keyword">return</span> Ratio(numerator / d, denominator / d)
    } <span class="hljs-comment">// &#x3C;-- end of static function invoke</span>

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">gcd</span><span class="hljs-params">(a : <span class="hljs-type">Int</span>, b : <span class="hljs-type">Int</span>)</span></span> : <span class="hljs-built_in">Int</span> { <span class="hljs-comment">/*omitted*/</span> } <span class="hljs-comment">// static function!</span>
  }

}</code></pre>
<p>The beauty of Kotlin here is that you'll still be able to use 'constructor' semantics whenever you need to create an instance of <code>Ratio</code>, i.e. you can write as follows as if you had ordinary constructor:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> r1 = Ratio(<span class="hljs-number">3</span>, <span class="hljs-number">7</span>) <span class="hljs-comment">// invoke will be called here</span>
<span class="hljs-keyword">val</span> r2 = Ratio(numerator = <span class="hljs-number">1</span>, denominator = <span class="hljs-number">4</span>) <span class="hljs-comment">// invoke will be called here</span></code></pre>
<p>This is it, I hope you find it useful.</p>
]]></description><link>http://alexshabanov.com/2014/12/01/non-trivial-constructors-in-kotlin/</link><guid isPermaLink="true">http://alexshabanov.com/2014/12/01/non-trivial-constructors-in-kotlin/</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Alex Shabanov]]></dc:creator><pubDate>Mon, 01 Dec 2014 00:00:00 GMT</pubDate></item><item><title><![CDATA[GeeCON Prague 2014: Andrey Cheptsov - A Reactive and Type-safe Kotlin DSL for NoSQL and SQL]]></title><description><![CDATA[<p><a href="https://vimeo.com/110781020">GeeCON Prague 2014: Andrey Cheptsov - A Reactive and Type-safe Kotlin DSL for NoSQL and SQL</a></p>
]]></description><link>https://vimeo.com/110781020</link><guid isPermaLink="true">https://vimeo.com/110781020</guid><category><![CDATA[Kotlin]]></category><category><![CDATA[SQL]]></category><dc:creator><![CDATA[Andrey Cheptsov]]></dc:creator><pubDate>Mon, 03 Nov 2014 09:11:00 GMT</pubDate></item><item><title><![CDATA[Kotlin vs Java puzzlers]]></title><description><![CDATA[<p><a href="https://vimeo.com/105758307">Kotlin vs Java puzzlers - Svetlana Isakova</a></p>
]]></description><link>https://vimeo.com/105758307</link><guid isPermaLink="true">https://vimeo.com/105758307</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Svetlana Isakova]]></dc:creator><pubDate>Wed, 10 Sep 2014 09:17:00 GMT</pubDate></item><item><title><![CDATA[The Advent of Kotlin: A Conversation with JetBrains' Andrey Breslav]]></title><description><![CDATA[<p><strong>Learn about Kotlin, a new statically typed language for the JVM.</strong></p>
<p><em>Among the important Java software developments in recent years is the advent of such alternative languages for the JVM as Groovy, Jython, and JRuby—and, more recently, the rise of Scala. A new statically typed language, Kotlin, named after a Russian island off the coast of St. Petersburg, where Kotlin's Andrey Breslav and the Kotlin team reside, has recently been getting attention. A brainchild of the highly lauded Czech software development company JetBrains, maker of the Java IDE IntelliJ IDEA, Kotlin was named Language of the Month in the</em> <a href="http://www.drdobbs.com/jvm/language-of-the-month-kotlin/232600836?pgno=2"><em>January 2012 issue of</em> Dr. Dobb's Journal</a>.</p>
<p><em>The primary purpose of Project Kotlin is to create for developers a general-purpose language that can serve as a useful tool that is safe, concise, flexible, and 100 percent Java-compatible. Both the compiler and the IntelliJ IDEA plug-in are open source under the Apache 2 license, with source code available through <a href="https://github.com/JetBrains/Kotlin">GitHub</a>.</em></p>
<p><em>Google software engineer Cedric Beust, creator of the Java testing framework TestNG, writing in <a href="http://java.dzone.com/articles/five-reasons-why-you-should-0">Javalobby</a> in July 2011, commented that Kotlin was a cause for rejoicing because of its syntactic innovations; its strong IDE; commercial support from JetBrains, which is building the compiler and the IDEA support together; and its reified generics.</em></p>
<p><em>Andrey Breslav, the lead language designer for Kotlin, began his career at Borland, where he worked on language implementations for MDA support. After spending a few years as a college teacher, he joined JetBrains in 2010 to lead Project Kotlin and currently serves as a member of the Java Community Process Expert Group for JSR 335, "Project Lambda." He is a frequent conference speaker at venues such as OSCON, JavaOne, Strange Loop, and Devoxx.</em></p>
<p><em>We met with him to see what's happening with Project Kotlin.</em></p>
<p><img src="http://www.oracle.com/ocom/groups/public/@otn/documents/digitalasset/1925119.jpg" alt="Andrey Breslav"></p>
<p><strong>Oracle Technology Network</strong>: You have written that your goal with Kotlin is "to create a language that is 100 percent Java-compatible, safer than Java, more concise and flexible, and not overly complex." Give us some details about this.</p>
<p><strong>Breslav:</strong> Every tool comes with a driving use case. We believe that for a new programming language, this use case is gradual migration, when the new language is being introduced little by little into a large code base written in the "old" language. In our case, we pay a lot of attention to making mixed Kotlin/Java projects work smoothly.</p>
<p>For example, IntelliJ IDEA is written in Java and we are willing to use Kotlin in this project. Of course, we are not going to rewrite the whole 10-year-old code base in another language. Most likely, we will start by writing tests in Kotlin, then new features, then maybe some existing subsystems that will be migrated to Kotlin while under refactoring.</p>
<blockquote>
<p>“Kotlin relies on Java libraries but makes them better, mostly through extensions but sometimes with compiler-supported techniques (collections, arrays, primitives).”</p>
<p><strong>- Andrey Breslav</strong> JetBrains</p>
</blockquote>
<p>All of this means that Kotlin has to behave very well in the existing Java ecosystem: use Java libraries, provide Java APIs, and integrate with Java frameworks. Some other new languages adopt a different approach and aim at abandoning the JDK and building their own better platform. Although this approach involves running on the JVM and is technically Java-compatible, it is practically impossible in the use case I just described.</p>
<p>As for Kotlin, a good example is our collection library. The experience of Scala shows that having your own collection library—all nice and shiny—gives you significant benefits but also has drawbacks when you need to interoperate with Java code: all the data needs to be converted/wrapped, so the code does not look nice and performance is sometimes compromised significantly. This is why Kotlin adopts another strategy: we use vanilla Java collections but make them behave nicely by extracting "virtual" read-only interfaces and introducing declaration-site variance. This way we get both compatibility and a nice library.</p>
<p>Kotlin relies on Java libraries but makes them better, mostly through extensions but sometimes with compiler-supported techniques (collections, arrays, primitives). This gets us compatibility while keeping the language clean.</p>
<h2>Kotlin and Scala</h2>
<p><strong>Oracle Technology Network:</strong> In what ways is Kotlin simpler than Scala?</p>
<p><strong>Breslav:</strong> It depends on the definition of <em>simpler</em>. Kotlin and Scala have very different approaches: Scala aims to give library designers as much power as possible and relies heavily on a rather elaborate type system, whereas Kotlin's goal is to be a good tool for the end user, so we put a lot of effort into keeping the list of features relatively short.</p>
<p>Here are a few things that Scala has and Kotlin does not:</p>
<ul>
<li>Implicit parameters and implicit conversions</li>
<li>(Path-)dependent types</li>
<li>Full-scale existential types</li>
<li>View bounds, context bounds, and all other exotic bounds</li>
<li>Macros</li>
</ul>
<p>This list is very far from complete.</p>
<blockquote>
<p>"Kotlin provides more-flexible abstractions than Java (including Java 8)."</p>
<p><strong>- Andrey Breslav</strong> JetBrains</p>
</blockquote>
<p><strong>Oracle Technology Network:</strong> In what ways is Kotlin more concise than Java?</p>
<p><strong>Breslav:</strong> The less important part is that Kotlin generally requires less ceremony. A few examples:</p>
<ul>
<li>Type inference is much stronger, so you don't have to repeat yourself, specifying the same types over and over again.</li>
<li>Class declarations are more concise, thanks to the concepts of properties and primary constructors.</li>
<li>Delegating overloads are not needed most of the time, thanks to default values for function parameters.</li>
<li>Static utility classes are not needed, because of top-level functions.</li>
</ul>
<p>Of greater importance, Kotlin provides more-flexible abstractions than Java (including Java 8). Here are some examples:</p>
<ul>
<li>Extension functions and properties in Kotlin can be added to any class/type without altering the definition of the class (as opposed to Java 8's ability to add methods to interfaces by changing their code). This enables us to beautify even existing Java libraries so that the good old JDK looks nice and shiny.</li>
<li>Higher-order functions (passing code around as values) are a lot more convenient, because Kotlin supports proper function types (as opposed to Java 8's SAM conversions that make you create a new interface every time you need a new function signature to be passed around).</li>
<li>Declaration-site variance, and variant collections in particular, make common data processing much more natural by eliminating the need for ubiquitous wildcards in generic types.</li>
</ul>
<p><strong>Oracle Technology Network:</strong> What is the most negative feedback you have received about Kotlin?</p>
<p><strong>Breslav:</strong> "It's not released yet."</p>
<p><strong>Oracle Technology Network:</strong> What is the most positive?</p>
<p><strong>Breslav:</strong> "One language finally got everything right!"</p>
<h2>The Release Status of Kotlin</h2>
<p><strong>Oracle Technology Network:</strong> What is the release status of Kotlin? How can developers get involved?</p>
<p><strong>Breslav:</strong> Kotlin reached the M5 milestone in early February 2013. As for big features, we are mostly stabilizing them and working on performance. Smaller features are being added, too. The project is open to contributions, and we do our best to process pull requests reasonably quickly.</p>
<p>We do not have a date for the 1.0 release. This is an important part of our philosophy. When the features planned for 1.0 are stable and the compiler is release-quality, we are not going to call it 1.0. It will be a beta, available to everyone to use but with no guarantee of backward compatibility for the updates. The point here is that at the "beta" stage, a language finally gets to be used in production (maybe other companies will refrain from doing so at first, but at least JetBrains will definitely use Kotlin), and extensive production use may reveal problems in the language design that need to be fixed.</p>
<p>Don't get me wrong: we are making all possible efforts to make the language really good. We rely on the experience of our best engineers and on the feedback we are constantly gathering from other companies and individuals. But we know that practice always brings surprises overlooked by theory, so we embrace the need to validate the design before releasing it and committing to keeping it unchanged. This is why we do not have a date for 1.0 and do not guarantee language design stability right after the beta: it's hard to predict what changes will be necessary.</p>
<p>When the design is properly validated and all the problems fixed, we will call it 1.0 and guarantee language stability from that point on.</p>
<p><strong>Oracle Technology Network:</strong> JetBrains is currently using Kotlin in the production of IntelliJ IDEA and in other projects. Tell us how Kotlin is doing with IntelliJ IDEA. What are some of the challenges?</p>
<p><strong>Breslav:</strong> First, only very brave souls are using Kotlin for production now. And the bravest among them use the less mature JavaScript back end that compiles Kotlin to run in the browser. There are very many challenges, but the result is awesome: <a href="http://blog.jetbrains.com/webide/2012/08/liveedit-plugin-features-in-detail/">IntelliJ IDEA's Live Edit</a>.</p>
<h2>Enhancing Java Libraries</h2>
<p><strong>Oracle Technology Network:</strong> Give us some examples of ways in which Kotlin can enhance Java libraries.</p>
<p><strong>Breslav:</strong> First, the way Kotlin treats collections: it uses standard JDK classes at runtime, but at compile time, it introduces "virtual" read-only interfaces that are covariant, so that a (read-only) <code>List&#x3C;String></code> can be passed where a (read-only) <code>List&#x3C;Object></code> is expected.</p>
<p>Also, Kotlin introduces many extension functions for collection classes. For example, the <code>map()</code> and <code>filter()</code> functions allow fluent manipulation with data:</p>
<pre><code class="hljs language-kotlin">users.filter {u -> u.age >= <span class="hljs-number">21</span>}.map {u -> u.name}</code></pre>
<p>Many other things are done through extensions: from <code>for</code>-loop support to operator overloading and tuplelike manipulations.</p>
<h2>Other Alternative Languages</h2>
<p><strong>Oracle Technology Network:</strong> Where does Kotlin fit in among the proliferated new languages for the JVM? How does it compare to Groovy, Jython, JRuby, Scala, and others? And with so many languages available to us, why do we need Kotlin?</p>
<p><strong>Breslav:</strong> Groovy, Jython, and Ruby are primarily dynamic, whereas Kotlin is statically typed, which means the ability to catch more errors at compile time (type safety), faster execution, and smarter tools.</p>
<p>Groovy 2.0's static-compilation feature makes the generated code perform comparably to Java, and this is a great improvement for Groovy. But the type system it supports is the one Java uses, meaning that all the abstraction mechanisms are exactly the same—for example, you get Java generics with all the inconveniences of use site variance and so on.</p>
<p>Scala is a different story—it is a statically typed language—and we've learned a lot from Scala's design. Compared to Kotlin, Scala is much more powerful and much harder for people as well as machines to really understand.</p>
<p><strong>Oracle Technology Network:</strong> Tell us about IDE support in Kotlin.</p>
<p><strong>Breslav:</strong> We started an IntelliJ IDEA plug-in for Kotlin simultaneously with the compiler, and we reuse a lot of code between the two. This guarantees very accurate analysis in the IDE on the one hand and makes it possible to use IntelliJ IDEA's existing infrastructure for Java.</p>
<p><strong>Oracle Technology Network</strong>: What are the most important features of Kotlin that Java lacks?</p>
<p><strong>Breslav:</strong> Assuming that by "Java" you mean Java 8, and with the biggest pain of the decade, lambdas (frequently called "closures"), being there already: the most important features are powerful type inference, extensions, declaration-site variance, and read-only interfaces for collections.</p>
<p>On the library side: type-safe builders are also important.</p>
<h2>Getting Set Up with Kotlin</h2>
<p><strong>Oracle Technology Network:</strong> How can developers get set up with Kotlin? What feedback do you want?</p>
<p><strong>Breslav:</strong> Download the compiler and/or a plug-in for IntelliJ IDEA, and write your cool application. We want feedback about what people like and dislike about Kotlin, what they find hard to understand, and how they use the features the language offers.</p>
<p><strong>Oracle Technology Network:</strong> What kind of Java developer will benefit most from Kotlin?</p>
<blockquote>
<p>"We want feedback about what people like and dislike about Kotlin, what they find hard to understand, and how they use the features the language offers."</p>
<p><strong>- Andrey Breslav</strong> JetBrains</p>
</blockquote>
<p><strong>Breslav:</strong> A Java developer who has reached the limits of the language (and I believe that many of us did that a long time ago) realizes the need for a new language with benefits such as cleaner abstractions, concise syntax, and type safety.</p>
<p><strong>Oracle Technology Network:</strong> In what ways is Kotlin safer than Java? What safety problems in Java does Kotlin address?</p>
<p><strong>Breslav:</strong> Kotlin promotes null safety, though nullable types. It also offers control over data modification through read-only collections and data classes and enables safer runtime checks through smart casts.</p>
<p><strong>Oracle Technology Network:</strong> What are some Java use problems that Kotlin fixes?</p>
<p><strong>Breslav:</strong> It fixes half of the issues covered in Joshua Bloch's _Java Puzzler_s books: from quirks of implicit conversions of primitives, through problems with static members and their inheritance, all the way to properly variant generics and null safety.</p>
<p><strong>Oracle Technology Network:</strong> What are the greatest misconceptions you encounter about languages for the JVM and Kotlin in particular?</p>
<p><strong>Breslav:</strong> We come across the term <em>functional programming</em> all the time, and people often mean different things by this, if anything at all.</p>
<p>Bigger functional languages such as ML and Haskell impose a certain discipline and beauty that are highly appreciated by some people, but this is clearly not the reason why your coworker in a nearby cubicle will be talking to you about functional programming over lunch.</p>
<p>The main selling point of "functional programming for the masses" is its usefulness for concurrency that everybody is struggling with today, and the argument for this usefulness usually boils down to "no side effects equals no problems" or "no shared memory equals no problems."</p>
<p>By this reasoning, all we need is immutable data or isolation (or both), but that does not necessarily bring any of the beauty and rigor of functional languages. Other things widely used in functional languages would be great to adopt in mainstream programming—this applies mostly to means of type-safe abstraction, such as higher-order functions (functions that take other functions as arguments) and parametric polymorphism (generics). But these features, again, do not define functional languages.</p>
<p>My point is: a good language does not need to be functional like Haskell, although it needs some features that are popular in the "functional world."</p>
<h2>See Also</h2>
<ul>
<li><a href="http://www.drdobbs.com/jvm/language-of-the-month-kotlin/232600836?pgno=2">January 2012 issue of <em>Dr. Dobb's Journal</em></a></li>
<li><a href="https://github.com/JetBrains/Kotlin">GitHub</a></li>
<li><a href="http://java.dzone.com/articles/five-reasons-why-you-should-0">Javalobby</a></li>
<li><a href="http://blog.jetbrains.com/webide/2012/08/liveedit-plugin-features-in-detail/">IntelliJ IDEA's Live Edit</a></li>
<li><a href="http://kotlin.jetbrains.org/">Kotlin</a></li>
<li><a href="http://www.jetbrains.com/">JetBrains</a></li>
</ul>
<h2>About the Author</h2>
<p>Janice J. Heiss is the Java acquisitions editor at Oracle and a technology editor at <em>Java Magazine</em>.</p>
<h2>Join the Conversation</h2>
<p>Join the Java community conversation on <a href="https://www.facebook.com/ilovejava">Facebook</a>, <a href="https://twitter.com/#!/java">Twitter</a>, and the <a href="https://blogs.oracle.com/java/">Java Source Blog</a>!</p>
]]></description><link>http://www.oracle.com/technetwork/articles/java/breslav-1932170.html</link><guid isPermaLink="true">http://www.oracle.com/technetwork/articles/java/breslav-1932170.html</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Janice J. Heiss]]></dc:creator><pubDate>Tue, 02 Apr 2013 00:00:00 GMT</pubDate></item><item><title><![CDATA[Exploring the Kotlin Standard Library - Part 3]]></title><description><![CDATA[<p>In <a href="http://jamie.mccrindle.org/2013/01/exploring-kotlin-standard-library-part-1.html">Part 1</a> and <a href="http://jamie.mccrindle.org/2013/01/exploring-kotlin-standard-library-part-2.html">Part 2</a> of this series, I went through the default Kotlin namespace and kotlin.io. In Part 3 I'll be going over kotlin.concurrent.</p>
<p>The public functions in kotlin.concurrent are all utilities for creating timers, threads or timer tasks e.g.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">// create a fixed rate timer that prints hello world every 100ms</span>
<span class="hljs-comment">// after a 100ms delay</span>
<span class="hljs-keyword">val</span> fixedRateTimer = fixedRateTimer(name = <span class="hljs-string">"hello-timer"</span>,
        initialDelay = <span class="hljs-number">100</span>, period = <span class="hljs-number">100</span>) {
    println(<span class="hljs-string">"hello world!"</span>)
}
<span class="hljs-keyword">try</span> {
    Thread.sleep(<span class="hljs-number">1000</span>)
} <span class="hljs-keyword">finally</span> {
    fixedRateTimer.cancel();
}</code></pre>
<p>Note: by default the timers are not daemon timers. Without the cancel the timer would run indefinitely. This can often cause issues if you have a timer deployed in a container (like Tomcat). Naming them is always helpful in finding rogue non-daemon timers.</p>
<p>The thread() method creates a new thread</p>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">// run in a different thread</span>
thread() {
    println(<span class="hljs-string">"async"</span>)
}
println(<span class="hljs-string">"sync"</span>)</code></pre>
<p>although I would usually use an ExecutorService rather than managing threads directly. Fortunately the Kotlin standard library provides a number of extension methods on Executor and ExecutorService too.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">// create a single thread executor</span>
<span class="hljs-keyword">val</span> singleThreadPool = Executors.newSingleThreadExecutor();
<span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// Executor and ExecutorService are extended with an</span>
    <span class="hljs-comment">// invoke method</span>
    <span class="hljs-keyword">val</span> future = singleThreadPool&#x3C;String>{
        <span class="hljs-string">"async"</span>
    }
    println(<span class="hljs-string">"sync"</span>)
    println(future.<span class="hljs-keyword">get</span>(<span class="hljs-number">10</span>, TimeUnit.SECONDS))
} <span class="hljs-keyword">finally</span> {
    singleThreadPool.shutdown();</code></pre>
<p>java.util.Timer also gets a couple of extension methods: schedule and scheduleAtFixedRate</p>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">// create a daemon thread</span>
<span class="hljs-keyword">val</span> timer = Timer(<span class="hljs-string">"schedule"</span>, <span class="hljs-literal">true</span>);

<span class="hljs-comment">// schedule a single event</span>
timer.schedule(<span class="hljs-number">1000</span>) {
    println(<span class="hljs-string">"hello world!"</span>)
}
<span class="hljs-comment">// schedule at a fixed rate</span>
timer.scheduleAtFixedRate(<span class="hljs-number">1000</span>, <span class="hljs-number">1000</span>) {
    println(<span class="hljs-string">"hello world!"</span>)
}</code></pre>
<p>Once again, I'd normally use a ScheduledExecutorService in preference. The standard library doesn't provide extension methods on ScheduledExecutorService but it is easy enough to add our own:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">/**
 * Extension method on implementations of ScheduledExecutorService to schedule
 * an action
 */</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&#x3C;V, T: ScheduledExecutorService></span> T.<span class="hljs-title">schedule</span><span class="hljs-params">(
        delay: <span class="hljs-type">Long</span>,
        unit: <span class="hljs-type">TimeUnit</span> = TimeUnit.MILLISECONDS,
        action: ()</span></span> -> V): ScheduledFuture&#x3C;V> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.schedule(
            callable { action() },
            delay, unit);
}</code></pre>
<p>Which can be used as follows:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> scheduledExecutor = Executors.newScheduledThreadPool(<span class="hljs-number">1</span>)
<span class="hljs-keyword">try</span> {
    scheduledExecutor.schedule(<span class="hljs-number">1000</span>) {
        println(<span class="hljs-string">"hello world"</span>)
    }
} <span class="hljs-keyword">finally</span> {
    scheduledExecutor.shutdown()
}</code></pre>
<p>The kotlin.concurrent package also provides additional methods for using locks e.g.:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> lock = ReentrantLock();
<span class="hljs-keyword">val</span> result = lock.withLock {
    <span class="hljs-comment">// access a locked resource</span>
}
<span class="hljs-keyword">val</span> readWriteLock = ReentrantReadWriteLock()
readWriteLock.read {
    <span class="hljs-comment">// execute an action with a read lock</span>
}
readWriteLock.write {
    <span class="hljs-comment">// execute an action with a write lock</span>
}</code></pre>
<p>If instead of locking, our code needs to try the lock and do one thing if the resource is available, and another if it is locked, we could extend Lock as follows:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">/**
 * Only run if you can acquire a lock
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&#x3C;T></span> Lock.<span class="hljs-title">tryLock</span><span class="hljs-params">(action: ()</span></span>->T, alternative: ()->T): T {
    <span class="hljs-keyword">if</span>(tryLock()) {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">return</span> action()
        }
        <span class="hljs-keyword">finally</span> {
            unlock();
        }
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> alternative();
    }
}</code></pre>
<p>Which could be used like this:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> tryLock = ReentrantLock();
<span class="hljs-keyword">val</span> tryLockResult = tryLock.tryLock({
    <span class="hljs-comment">// run if we can get a lock</span>
}, {
    <span class="hljs-comment">// run if we couldn't get a lock</span>
});</code></pre>
]]></description><link>http://jamie.mccrindle.org/2013/02/exploring-kotlin-standard-library-part-3.html</link><guid isPermaLink="true">http://jamie.mccrindle.org/2013/02/exploring-kotlin-standard-library-part-3.html</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Jamie McCrindle]]></dc:creator><pubDate>Thu, 07 Feb 2013 09:04:00 GMT</pubDate></item><item><title><![CDATA[Exploring the Kotlin Standard Library - Part 2]]></title><description><![CDATA[<p>In <a href="http://jamie.mccrindle.org/2013/01/exploring-kotlin-standard-library-part-1.html">Part 1</a> of this series, I went through the default Kotlin namespace. In Part 2 I'll be going over <a href="http://jetbrains.github.com/kotlin/versions/snapshot/apidocs/kotlin/io/package-summary.html">kotlin.io</a>.</p>
<p>Most of the public function in kotlin.io are overloaded versions of print and println, which all delegate to System.out.</p>
<p>kotlin.io also introduces readLine for reading lines from stdin and the use method. The use method is a great example of a general purpose extension method. The signature illustrates how to create an extension method that will apply to every class that implements Closeable:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&#x3C;T: Closeable, R></span> T.<span class="hljs-title">use</span><span class="hljs-params">(block: (<span class="hljs-type">T</span>)</span></span>-> R) : R</code></pre>
<p>The iterate method from the default namespace works very well with the readLine method. A function to count the number of lines from stdin would look as follows:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&#x3C;<span class="hljs-type">String</span>>)</span></span> = iterate{ readLine() }.count({ <span class="hljs-literal">true</span> })</code></pre>
<p>The following example uses the 'use' method to read the text from a reader while managing its lifecycle:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">// gets the contents fo the reader and then closes it</span>
<span class="hljs-keyword">var</span> contents = reader.use { it.readText() }</code></pre>
<p>The use method will return whatever the closure returns (in this case, the contents of the reader as a String).</p>
<p>kotlin.io extends java.io.File, java.io.InputStream, java.io.OutputStream, java.io.Reader, java.io.Writer, java.io.BufferedReader and java.net.URL.</p>
<p>For reading files or streams, the API docs distinguish between those methods that can be used on huge amounts of data and those that can't. Those that can't are the ones that wait for the entire file to be read before returning a result e.g. readLines, whereas the those that use a closure or iterator pull data lazily. The following calls should not be used with huge amounts of data</p>
<ul>
<li>readBytes</li>
<li>readLines</li>
<li>readText</li>
</ul>
<p>The following can be used for huge amounts of data:</p>
<ul>
<li>copyTo</li>
<li>forEachBlock</li>
<li>forEachLine</li>
</ul>
<p>For InputStreams, Readers and Writers, the caller is typically responsible for closing the various streams, the exception being the useLines method.</p>
<p>The Kotlin stdlib enhances with java.io.File with a number of useful methods: copyTo, forEachBlock, forEachLine, isDescendant, listFiles, readBytes, readLines, readText, reader, recurse, relativePath, writeBytes, writeText</p>
<p>The following is an example of copyTo being used:</p>
<pre><code class="hljs language-kotlin">File(<span class="hljs-string">"/tmp/from.txt"</span>).copyTo(File(<span class="hljs-string">"/tmp/to.txt"</span>))</code></pre>
<p>Note the following:</p>
<ul>
<li>copyTo only works on files (not directories)</li>
<li>copyTo will create the target directory</li>
<li>copyTo will overwrite the target file</li>
<li>if the source file can't be found a FileNotFoundException will be thrown</li>
<li>copyTo will block until the file is written</li>
</ul>
<p>As an example, the forEachBlock method could be used to provide a version of copyTo that reports progress as the target file is written as follows:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">/**
 * Copies a file and calls the closure with the current number of bytes read as each block is read
 * to indicate progress
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> File.<span class="hljs-title">copyToWithProgress</span><span class="hljs-params">(file: <span class="hljs-type">File</span>, closure : (<span class="hljs-type">Long</span>)</span></span> -> <span class="hljs-built_in">Unit</span>) {
    file.directory.mkdirs()
    <span class="hljs-keyword">val</span> output = FileOutputStream(file)
    output.use{
        <span class="hljs-keyword">var</span> length = <span class="hljs-number">0.</span>toLong()
        <span class="hljs-keyword">this</span>.forEachBlock { bytes, size ->
            length += size
            output.write(bytes, <span class="hljs-number">0</span>, size)
            closure(length)
        }
    }
}</code></pre>
<p>Here are a few more examples of what can be done with kotlin.io</p>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">// forEachLine</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// reads all the lines from a file and prints them out</span>
File(<span class="hljs-string">"/tmp/from.txt"</span>).forEachLine { println(it) }

<span class="hljs-comment">// isDescendent</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Confirms that from.txt is a descendant of /tmp</span>
<span class="hljs-keyword">val</span> isDescendent = File(<span class="hljs-string">"/tmp/from.txt"</span>).isDescendant(File(<span class="hljs-string">"/tmp"</span>))

<span class="hljs-comment">// listFiles</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Lists all the subdirectories in /tmp</span>
<span class="hljs-keyword">val</span> files = File(<span class="hljs-string">"/tmp"</span>).listFiles{ it.isDirectory() }

<span class="hljs-comment">// readBytes</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// reads all the bytes from /tmp/from.bin</span>
<span class="hljs-keyword">val</span> bytes = File(<span class="hljs-string">"/tmp/from.bin"</span>).readBytes()

<span class="hljs-comment">// readLines</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// reads all the lines from /tmp/from.txt into a list</span>
<span class="hljs-comment">// and then runs through each line in the list and prints it out</span>
<span class="hljs-keyword">val</span> lines = File(<span class="hljs-string">"/tmp/from.txt"</span>).readLines()
lines.forEach { println(it) }

<span class="hljs-comment">// readText</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// reads all the text from /tmp/from.txt into a string</span>
<span class="hljs-comment">// and then checks if it contains a multiline string</span>
<span class="hljs-keyword">val</span> text = File(<span class="hljs-string">"/tmp/from.txt"</span>).readText()
<span class="hljs-keyword">val</span> found = text.contains(<span class="hljs-string">"hello\nworld\n!"</span>)

<span class="hljs-comment">// reader</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// creates a reader and calls useLines on it</span>
<span class="hljs-keyword">val</span> fileReader = File(<span class="hljs-string">"/tmp/from.txt"</span>).reader().useLines {
    <span class="hljs-comment">// same as calling forEachLine</span>
}

<span class="hljs-comment">// recurse</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// recurse through all the files in /tmp and print out their names</span>
File(<span class="hljs-string">"/tmp"</span>).recurse { println(it.name) }

<span class="hljs-comment">// relativePath</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// returns nested/directory/file.txt</span>
File(<span class="hljs-string">"/tmp"</span>).relativePath(File(<span class="hljs-string">"/tmp/nested/directory/file.txt"</span>))

<span class="hljs-comment">// writeBytes</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// write Hello World as bytes to /tmp/helloworld.bin</span>
File(<span class="hljs-string">"/tmp/helloworld.bin"</span>).writeBytes(<span class="hljs-string">"Hello World!"</span>.getBytes())

<span class="hljs-comment">// writeText</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// write Hello World as bytes to /tmp/helloworld.txt</span>
File(<span class="hljs-string">"/tmp/helloworld.txt"</span>).writeText(<span class="hljs-string">"Hello World!"</span>)</code></pre>
]]></description><link>http://jamie.mccrindle.org/2013/01/exploring-kotlin-standard-library-part-2.html</link><guid isPermaLink="true">http://jamie.mccrindle.org/2013/01/exploring-kotlin-standard-library-part-2.html</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Jamie McCrindle]]></dc:creator><pubDate>Fri, 25 Jan 2013 07:58:00 GMT</pubDate></item><item><title><![CDATA[The Adventurous Developer’s Guide to JVM languages – Kotlin]]></title><description><![CDATA[<p>In this post we will focus on <a href="http://kotlin.jetbrains.org/">Kotlin</a>, with a simple <a href="https://github.com/sjmaple/Kotlin-HTTP-Server">HTTP Server coding example</a> to showcase the language features and coding syntax.</p>
<p><a href="http://devnet.jetbrains.net/servlet/JiveServlet/showImage/2-5456865-25537/KotlinLogo.png"><img src="http://devnet.jetbrains.net/servlet/JiveServlet/showImage/2-5456865-25537/KotlinLogo.png"></a></p>
<p>The Kotlin HTTP Server example we coded can be found on <a href="https://github.com/sjmaple/Kotlin-HTTP-Server">github</a>. Kotlin is a fairly young, statically-typed language, created by JetBrains and first announced at the JVM language summit in July 2011. The smart folks at JetBrains, creators of IntelliJ IDEA, have integrated many languages into their IDE and are pretty clued up on which requirements a modern-day developer is looking for, as well as the capabilities of the existing JVM languages.</p>
<p>The IDE support was the first ‘challenge’ I was faced with. As an Eclipse user, switching to the IntelliJ IDEA environment is always difficult, but it’s a necessary step if you want to code in a rich Kotlin environment. It’s fairly easy to install the Kotlin plugin, and create Kotlin artifacts, but just a shame the support isn’t also being pushed to other IDEs. Maybe we can subtly hint this to the JetBrains team? ;)</p>
<p><img src="http://zeroturnaround.com/wp-content/uploads/2013/01/kotlin-ide.png" alt="kotlin-ide"></p>
<h3>Elegant coding</h3>
<p>Coding in Kotlin really does provide some very elegant code. It removes the need for null checks, uses primary constructors, smart casts, range expressions... the list goes on. Let’s take a look at an example.</p>
<p>From my Java background I did like the combination of the <code>is</code>/<code>as</code> casting with the <code>when</code> structure. In Java terms, consider them as <code>instance of</code>, cast – <code>(A) obj</code> and <code>case</code> respectively. The <code>is</code> usage will also infer a cast if you go ahead and use the object straight away. E.g: <code>if (stream is Reader) stream.close()</code> In this example, the <code>stream.close()</code> is being called via the <code>Reader</code> interface. This would be the same as saying <code>if (stream is Reader) (stream as Reader).close()</code> but the extra code is not needed. This in combination with when allows you to switch over a variable, but not just using its value as you can get a richer involvement. Consider the following:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">when</span> (stream) {
    <span class="hljs-keyword">is</span> Reader -> stream.close()
    <span class="hljs-keyword">is</span> Writer -> stream.close()
    <span class="hljs-keyword">is</span> InputStream -> stream.close()
    <span class="hljs-keyword">is</span> OutputStream -> stream.close()
    <span class="hljs-keyword">is</span> Socket -> stream.close()
    <span class="hljs-keyword">else</span> -> System.err.println(<span class="hljs-string">"Unable to close object: "</span> + stream)
}</code></pre>
<p>This is really clean, elegant code if you consider how you might want to implement this in Java. C# interestingly has a very similar usage of <code>is</code> and <code>as</code>, and also implements nullable types.</p>
<p>Method calls make use of parameter naming as well as defaults. It can be such a headache when a method takes in 5 booleans as you have to call the method very carefully so you pass <code>true</code> and <code>false</code> in the right order. Parameter naming gets round the confusion by qualifying the parameter name with the parameter itself on the method invocation. Nice. Again, this has been done in the past by other languages and scripting frameworks, but it’s a welcome addition to any language, particularly with parameter defaults, which allow the method invocation to omit certain parameters if the user is happy to accept default values. Lets take a look at an example:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">out</span> : <span class="hljs-type">PrintWriter</span>, pre : <span class="hljs-type">String</span>, contentType: <span class="hljs-type">String</span> = <span class="hljs-string">"text/html"</span>,
                  contentLength : <span class="hljs-type">Long</span> = <span class="hljs-number">-1.</span>toLong()</span></span>, title : String, body : () -> <span class="hljs-built_in">Unit</span>)</code></pre>
<p>Here we have a method with several <code>String</code> parameters as well as a function as input. It is invoked using the following call. Notice that <code>contentType</code> and <code>contentLength</code> are both omitted from the invocation meaning the defaults in the declaration are used.</p>
<pre><code class="hljs language-kotlin">print(<span class="hljs-keyword">out</span> = <span class="hljs-keyword">out</span>,
      pre = <span class="hljs-string">"HTTP/1.0 404 Not Found"</span>,
      title = <span class="hljs-string">"File Not Found"</span>,
      body = {<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"&#x3C;H2>404 File Not Found: "</span> + file.getPath() + <span class="hljs-string">"&#x3C;/H2>"</span>)})</code></pre>
<p>So what does this mean? Well, there will be much less method overloading! Result! :D Seriously though, it’s amazing to think Java gone over 20 years without additions like this? Sometimes it does feel like you’re coding in the dark a little. Come on Java, catch up!</p>
<h3>Kotlin will help you write safe code, unless you don’t want to!</h3>
<p>Let’s get geeky. Firstly you can say goodbye to NPEs! Kotlin uses ‘nullable types’ and ‘non-nullable types’ to differentiate between vars which could be null, and those which will never be null. Consider the following code:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">var</span> a : String = <span class="hljs-string">"a"</span>
a = <span class="hljs-literal">null</span> <span class="hljs-comment">// compilation error</span></code></pre>
<p>To allow nulls, the var must be declared as nullable, in this case, written <code>String?</code>:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">var</span> b : String? = <span class="hljs-string">"b"</span>
b = <span class="hljs-literal">null</span> <span class="hljs-comment">// valid null assignment</span></code></pre>
<p>Now, if you call a method on a, it’s guaranteed not to cause an NPE, so you can safely say</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> l = a.length()</code></pre>
<p>But if you want to call the same method on b, that would not be safe, and the compiler reports an error:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> l = b.length() <span class="hljs-comment">// error: variable 'b' can be null</span></code></pre>
<p>By knowing which vars can be null, the Kotlin compiler mandates that when you dereference a nullable type, you do so using one of the following methods:</p>
<p>Hmmm, I’m half way through writing this blog post and I’ve not mentioned anything that’s strikingly new or innovative... let’s continue and see how we go.</p>
<p>Safe calls in Kotlin are very similar to those in Groovy, including the notation. By dereferencing a nullable type using ‘<code>.?</code>‘ like in the example below, tells the compiler to call length on object b, unless it is null, in which case do nothing.</p>
<pre><code class="hljs language-kotlin">b?.length()</code></pre>
<p>Those of you who are thinking ‘What? Get rid of null? Where’s the fun in that?”, there is the <code>!!</code> operator which allows for the potential of a NPE to be thrown, if you so wish.</p>
<p>You can also use the <code>?</code> notation with <code>as</code> to avoid exceptions being thrown if the cast is not possible. This is called a safe cast.</p>
<h3>Functions</h3>
<p>Functions can be created inside (member functions) or outside of a class. A function can contain other functions (local functions) and you can use functions to extend existing classes such as the following:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">abs</span><span class="hljs-params">()</span></span> : <span class="hljs-built_in">Int</span> = <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> >= <span class="hljs-number">0</span>) <span class="hljs-keyword">this</span> <span class="hljs-keyword">else</span> -<span class="hljs-keyword">this</span></code></pre>
<p>This example extends the <code>Int</code> class to return the absolute value it contains.</p>
<p>Functions are very powerful and are well used on the JVM in many languages (Still not in Java, until Java 8). Kotlin also allows the use of higher order functions which means you can pass a function as an argument to a method call (function literal).</p>
<p>Almost at the end now, and still nothing that I would call really stand out, knee smackingly amazing. Don’t misunderstand my point, I think Kotlin is a very nice language but so far it’s been getting that way by extracting pieces of existing languages and putting a new spin on it. Maybe this is to be expected given the exposure the JetBrains team have had to all the existing languages they support, and maybe this is what they intended to produce. Do we need extra languages to please every persons development style in the development community? Maybe... Maybe not.</p>
<h3>Documentation/Help</h3>
<p>I found that the documentation for Kotlin was all in the same place. All Google searches led back to the <a href="http://confluence.jetbrains.net/display/Kotlin/Welcome">community site</a>. I think this is a shame, as it would be great to go somewhere else with other examples and resources with which to play around with, but I guess it’s still quite young. It would be nice to see more code in github and the like, for others to follow.</p>
<h3>Summary</h3>
<p>Overall I really enjoyed using Kotlin. Nothing about Kotlin is particularly groundbreaking, but what makes it great is that it cherry picks some of the best parts of other languages.</p>
<p><strong>The parts I really liked about the language:</strong></p>
<ul>
<li>The use of functions really gives the developer extra options in designing code.</li>
<li>Parameter names should be mandatory in every language as they’re so great! Kotlin uses them well with default values.</li>
<li>Extending classes is very easy and very useful.</li>
<li>The documentation is good and there are very interesting discussions in the comments.</li>
<li>It’s a pretty language! The keyword and fluff to useful code ratio is much better in Kotlin using constructs such as <code>when</code>, <code>is</code> and <code>as</code></li>
<li>Kotlin is enjoyable to write and very easy to readand I would expect maintain, particularly because it’s a safe language.</li>
</ul>
<p><strong>There were a couple of pain points though:</strong></p>
<ul>
<li>
<p>The error flags in IntelliJ popping up all over the place if there is a single error, because of the knock on effect of the error. It can be hard to find the root cause.</p>
</li>
<li>
<p>I also had a few problems with try-finally for my stream closes, which I didn’t have time to resolve. When I added the close in the finally block, it seemed to use the result as part of the return by the look of the exception received:</p>
<p><em>Exception in thread “main” java.lang.VerifyError: (class: HttpServer, method: run signature: ()V) Register 9 contains wrong type
at namespace.main(HTTPServer.kt:169)</em></p>
</li>
</ul>
<p>With milestone releases every 2-3 months, Kotlin may soon be a language which many Scala beginners may turn to, although I don’t think the happy Scala users will be too bothered about it. From what I’ve read online, some look down on it, but you’d expect that from opinionated techies wouldn’t you? :) (Not to divert you, but for more on Scala, feel free to check out our super popular <a href="http://zeroturnaround.com/labs/scala-2013-a-pragmatic-guide-to-scala-adoption-in-your-java-organization/">Scala report</a>, featuring an in-depth interview with Martin Odersky)</p>
<p>I’d like to look back in 6 months or a year to see how Kotlin has evolved, and with the JetBrains team driving it, we’re certain to be in for a fun ride. My initial impression is that Kotlin is going on a route quite similar to Scala, today. I wouldn’t expect anyone who is happy with Scala to migrate across to Kotlin, as the Kotlin folks have also mentioned, but for people who have been frustrated with Scala, it may be worth looking at some time in the future. I think it is sharing a busy market of developers with other languages that are too similar in features and syntax may not help them survive longer term. If you want to have a go yourself you can also play with <a href="http://kotlin-demo.jetbrains.com">Kotlin in a browser</a>. I’d love to hear your experiences in the comments!</p>
<p><strong>Don’t forget to check out the <a href="https://github.com/sjmaple/Kotlin-HTTP-Server">HTTP Server sample Kotlin code on Github</a>.</strong></p>
<p><em>Psst! If you liked this post, <a href="http://zeroturnaround.com/rebellabs/devs/the-adventurous-developers-guide-to-jvm-languages/">we wrote a 50-page RebelLabs report</a> on Java 8, Scala, Groovy, Fantom, Clojure, Ceylon, Kotlin &#x26; Xtend.</em></p>
]]></description><link>http://zeroturnaround.com/rebellabs/the-adventurous-developers-guide-to-jvm-languages-kotlin/</link><guid isPermaLink="true">http://zeroturnaround.com/rebellabs/the-adventurous-developers-guide-to-jvm-languages-kotlin/</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Simon Maple]]></dc:creator><pubDate>Wed, 23 Jan 2013 00:00:00 GMT</pubDate></item><item><title><![CDATA[Exploring the Kotlin Standard Library - Part 1]]></title><description><![CDATA[<p>Exploring the API docs and source code for a language's standard library is usually illuminating and Kotlin is no different. In this series, I thought I'd look at some of the highlights of the Kotlin stdlib. In Part 1, I'll be going over the default Kotlin namespace.</p>
<p>Both the <a href="http://jetbrains.github.com/kotlin/versions/snapshot/apidocs/index.html">API docs</a> and the <a href="https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib">source code</a> for the stdlib are available on github.</p>
<p>First up, the iterate method creates an iterator from a stateful function that returns either a value if it has more data or a null if not. For infinite iterators, just never return null. The following code will create an infinite iterator over the integers 0, 1, 2, 3...:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;
<span class="hljs-keyword">var</span> iterator = iterate { i++ }</code></pre>
<p>To do something useful with the iterator, we can use some of the other methods from the standard library e.g. filter, take, forEach etc. The following code will print all the integers between 0 and 100 that are divisible by 3 and 5.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;
iterate { i++ } filter { it % <span class="hljs-number">3</span> == <span class="hljs-number">0</span> || it % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>} take <span class="hljs-number">100</span> forEach { println(it) }</code></pre>
<p>Next up, the stdlib makes it easy to construct read only collections as follows:</p>
<pre><code class="hljs language-kotlin">listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>) <span class="hljs-comment">// constructs a read only list of Int's</span>
mapOf(<span class="hljs-number">1</span> to <span class="hljs-string">"A"</span>, <span class="hljs-number">2</span> to <span class="hljs-string">"B"</span>) <span class="hljs-comment">// constructs a read only map of Int to String</span>
setOf(<span class="hljs-string">"Hello"</span>, <span class="hljs-string">"World"</span>) <span class="hljs-comment">// constructs a read only map of Int to String</span></code></pre>
<p>Or more specific / mutable collections like this:</p>
<pre><code class="hljs language-kotlin">arrayListOf(<span class="hljs-string">"Hello"</span>, <span class="hljs-string">"World"</span>) <span class="hljs-comment">// constructs an array list of Strings</span>
linkedListOf(<span class="hljs-string">"Hello"</span>, <span class="hljs-string">"World"</span>) <span class="hljs-comment">// constructs a linked list of Strings</span>
hashMapOf(<span class="hljs-number">1</span> to <span class="hljs-string">"A"</span>, <span class="hljs-number">2</span> to <span class="hljs-string">"B"</span>) <span class="hljs-comment">// constructs a hash map of Ints to Strings</span>
linkedMapOf(<span class="hljs-number">1</span> to <span class="hljs-string">"A"</span>, <span class="hljs-number">2</span> to <span class="hljs-string">"B"</span>) <span class="hljs-comment">// constructs a linked map</span>
sortedMapOf(<span class="hljs-number">1</span> to <span class="hljs-string">"A"</span>, <span class="hljs-number">2</span> to <span class="hljs-string">"B"</span>) <span class="hljs-comment">// constructs a sorted map</span>
sortedSetOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// constructs a sorted set</span></code></pre>
<p>All of the arrays, collections, lists and iterators share a similar set of methods: all, any, appendString, contains, count, drop, dropWhile, dropWhileTo, filter, filterNot, filterNotNull, filterNotNullTo, filterNotTo, filterTo, find, flatMap, flatMapTo, fold, foldRight, forEach, groupBy, groupByTo, makeString, map, mapTo, partition, plus, reduce, reduceRight, requireNoNulls, reverse, sort, sortBy, take, takeWhile, takeWhileTo, toArray, toCollection, toLinkedList, toList, toSet, toSortedList, toSortedSet.
Here are examples of using most of the above methods:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">// all</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// check that all values from 0 to 100 are positive</span>
assertTrue((<span class="hljs-number">1.</span><span class="hljs-number">.100</span>).all{ it > <span class="hljs-number">0</span> })

<span class="hljs-comment">// any</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// check that any of the words hello and world contain the letter h</span>
assertTrue(array(<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>).any{ it.contains(<span class="hljs-string">"h"</span>) })

<span class="hljs-comment">// contains</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// check that the list of hello and world contains world</span>
assertTrue(listOf(<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>).contains(<span class="hljs-string">"world"</span>))

<span class="hljs-comment">// count</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// check that the number of values between 1 and 100 inclusive is 100</span>
assertTrue((<span class="hljs-number">1.</span><span class="hljs-number">.100</span>).count() == <span class="hljs-number">100</span>)

<span class="hljs-comment">// drop</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// check that dropping the first string results in only the second</span>
assertEquals(listOf(<span class="hljs-string">"world"</span>), listOf(<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>).drop(<span class="hljs-number">1</span>))

<span class="hljs-comment">// dropWhile</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// check that dropping values from the range 1 to 100 while</span>
<span class="hljs-comment">// the value is less than 90 results in the values 90 to 100</span>
<span class="hljs-comment">// remaining</span>
assertEquals((<span class="hljs-number">90.</span><span class="hljs-number">.100</span>).toList(), (<span class="hljs-number">1.</span><span class="hljs-number">.100</span>).dropWhile{ it &#x3C; <span class="hljs-number">90</span> })

<span class="hljs-comment">// dropWhileTo</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// check that dropping values from the range 1 to 100 while</span>
<span class="hljs-comment">// the value is less than 90 results in the values 90 to 100</span>
<span class="hljs-comment">// remaining, using an existing, mutable list</span>
<span class="hljs-keyword">val</span> dropWhileToList = arrayListOf&#x3C;<span class="hljs-built_in">Int</span>>()
assertEquals((<span class="hljs-number">90.</span><span class="hljs-number">.100</span>).toList(), (<span class="hljs-number">1.</span><span class="hljs-number">.100</span>).dropWhileTo(dropWhileToList) { it &#x3C; <span class="hljs-number">90</span> })

<span class="hljs-comment">// filter</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// filter the values 0 to 10 to a list containing only even numbers</span>
assertEquals(listOf(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>), (<span class="hljs-number">0.</span><span class="hljs-number">.10</span>).filter { it % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> })

<span class="hljs-comment">// filterTo</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// filter the values 0 to 10 to a list containing only even numbers</span>
<span class="hljs-keyword">val</span> filterToList = arrayListOf&#x3C;<span class="hljs-built_in">Int</span>>()
assertEquals(listOf(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>), (<span class="hljs-number">0.</span><span class="hljs-number">.10</span>).filterTo(filterToList) { it % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> })

<span class="hljs-comment">// filterNot</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// filter the values 0 to 10 to a list containing only odd numbers</span>
assertEquals(listOf(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>), (<span class="hljs-number">0.</span><span class="hljs-number">.10</span>).filterNot { it % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> })

<span class="hljs-comment">// filterNot</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// filter the values 0 to 10 to a list containing only odd numbers</span>
<span class="hljs-keyword">val</span> filterNotToList = arrayListOf&#x3C;<span class="hljs-built_in">Int</span>>()
assertEquals(listOf(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>), (<span class="hljs-number">0.</span><span class="hljs-number">.10</span>).filterNotTo(filterNotToList) { it % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> })

<span class="hljs-comment">// filterNotNull</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// filter out null values</span>
assertEquals(listOf(<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>), array(<span class="hljs-literal">null</span>, <span class="hljs-string">"hello"</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">"world"</span>).filterNotNull())

<span class="hljs-comment">// filterNotNullTo</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// filter out null values</span>
<span class="hljs-keyword">val</span> filterNotNullTo = arrayListOf&#x3C;String>()
assertEquals(listOf(<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>), array(<span class="hljs-literal">null</span>, <span class="hljs-string">"hello"</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">"world"</span>).filterNotNullTo(filterNotNullTo))

<span class="hljs-comment">// find</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// find the first element in hello world that starts with "h"</span>
assertEquals(<span class="hljs-string">"hello"</span>, array(<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>).find{ it.startsWith(<span class="hljs-string">"h"</span>) })

<span class="hljs-comment">// first</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// get the first element of hello and world</span>
assertEquals(<span class="hljs-string">"hello"</span>, listOf(<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>).first())

<span class="hljs-comment">// flatMap</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// map over the values 1, 2 and 3, creating a list of lists of it and it + 1</span>
<span class="hljs-comment">// for each element and then flatten them into a single list</span>
assertEquals(listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>), listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).flatMap{ listOf(it, it + <span class="hljs-number">1</span>) })

<span class="hljs-comment">// flatMapTo</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// map over the values 1, 2 and 3, creating a list of lists of it and it + 1</span>
<span class="hljs-comment">// for each element and then flatten them into a single list</span>
<span class="hljs-keyword">val</span> flatMapToList = arrayListOf&#x3C;<span class="hljs-built_in">Int</span>>()
assertEquals(listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).flatMapTo(flatMapToList) { listOf(it, it + <span class="hljs-number">1</span>) }, listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>))

<span class="hljs-comment">// fold</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// take the numbers 1 to 4. start with 0 and add each number to a running total and</span>
<span class="hljs-comment">// return the result</span>
assertEquals(<span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-number">3</span> + <span class="hljs-number">4</span>, listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>).fold(<span class="hljs-number">0</span>) { total, next -> total + next })

<span class="hljs-comment">// foldRight</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// take the numbers 1 to 4. add each of them together in turn from the right</span>
assertEquals(<span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-number">3</span> + <span class="hljs-number">4</span>, listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>).foldRight(<span class="hljs-number">0</span>) { a, b -> a + b })

<span class="hljs-comment">// forEach</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// for each of the values in the range 1..10, print out the value on a new line</span>
(<span class="hljs-number">1.</span><span class="hljs-number">.10</span>) forEach { println(it) }

<span class="hljs-comment">// groupBy</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// take the values 0, 1 and 2 and turn them into a map of the characters to lists of integers</span>
<span class="hljs-comment">// where A = 0, B = 1, C = 3 etc.</span>
assertEquals(mapOf(<span class="hljs-string">'A'</span> to listOf(<span class="hljs-number">0</span>), <span class="hljs-string">'B'</span> to listOf(<span class="hljs-number">1</span>), <span class="hljs-string">'C'</span> to listOf(<span class="hljs-number">2</span>)),
        array(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>).groupBy{ (it + <span class="hljs-string">'A'</span>.toInt()).toChar() })

<span class="hljs-comment">// groupByTo</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// take the values 0, 1 and 2 and turn them into a map of the characters to lists of integers</span>
<span class="hljs-comment">// where A = 0, B = 1, C = 3 etc.</span>
<span class="hljs-keyword">val</span> groupByToMap = hashMapOf&#x3C;<span class="hljs-built_in">Char</span>, MutableList&#x3C;<span class="hljs-built_in">Int</span>>>()
assertEquals(mapOf(<span class="hljs-string">'A'</span> to listOf(<span class="hljs-number">0</span>), <span class="hljs-string">'B'</span> to listOf(<span class="hljs-number">1</span>), <span class="hljs-string">'C'</span> to listOf(<span class="hljs-number">2</span>)),
        array(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>).groupByTo(groupByToMap) { (it + <span class="hljs-string">'A'</span>.toInt()).toChar() })

<span class="hljs-comment">// last</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// get the last element of hello and world</span>
assertEquals(<span class="hljs-string">"world"</span>, listOf(<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>).last())

<span class="hljs-comment">// makeString</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// turn a list into a string using a space as a separator</span>
assertEquals(<span class="hljs-string">"hello world"</span>, listOf(<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>).makeString(separator = <span class="hljs-string">" "</span>))

<span class="hljs-comment">// map</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// go through the range of integers from 1 to 5 and multiply each one by 2</span>
assertEquals(listOf(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>), (<span class="hljs-number">1.</span><span class="hljs-number">.5</span>).map{ it * <span class="hljs-number">2</span> })

<span class="hljs-comment">// mapTo</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// go through the range of integers from 1 to 5 and multiply each one by 2</span>
<span class="hljs-keyword">val</span> mapToList = arrayListOf&#x3C;<span class="hljs-built_in">Int</span>>()
assertEquals(listOf(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>), (<span class="hljs-number">1.</span><span class="hljs-number">.5</span>).mapTo(mapToList) { it * <span class="hljs-number">2</span> })

<span class="hljs-comment">// partition</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// partition the values 1 to 10 into a pair of lists of even and odd numbers</span>
assertEquals(Pair(listOf(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>), listOf(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>)), (<span class="hljs-number">1.</span><span class="hljs-number">.10</span>).partition{ it % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> })

<span class="hljs-comment">// plus</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// add 4 onto the end of an array</span>
assertEquals(listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>), array(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).plus(<span class="hljs-number">4</span>))

<span class="hljs-comment">// reduce</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// take the values 1 to 4 and add them together using a running total</span>
assertEquals(<span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-number">3</span> + <span class="hljs-number">4</span>, (<span class="hljs-number">1.</span><span class="hljs-number">.4</span>) reduce { total, next -> total + next })

<span class="hljs-comment">// reduceRight</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// take the values 1 to 4 and add them together using a running total</span>
assertEquals(<span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-number">3</span> + <span class="hljs-number">4</span>, (<span class="hljs-number">1.</span><span class="hljs-number">.4</span>) reduceRight { a, b -> a + b })

<span class="hljs-comment">// requireNoNulls</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// require that a collection doesn't contain nulls</span>
array&#x3C;String?>(<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>, <span class="hljs-string">"three"</span>).requireNoNulls()

<span class="hljs-comment">// reverse</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// reverse a collection</span>
assertEquals(array(<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">1.</span><span class="hljs-number">.4</span>).reverse())

<span class="hljs-comment">// sort</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// sort a mutable collection</span>
assertEquals(array(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>), linkedListOf(<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>).sort())

<span class="hljs-comment">// sortBy</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// sort a mutable collection in reverse</span>
assertEquals(array(<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>), linkedListOf(<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>).sortBy{ -it })

<span class="hljs-comment">// take</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// take 5 numbers from the front of a range of 1 to a 100</span>
assertEquals(listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>), (<span class="hljs-number">1.</span><span class="hljs-number">.100</span>) take <span class="hljs-number">5</span>)

<span class="hljs-comment">// takeWhile</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// take numbers while they're less then 5 from a range of 1 to a 100</span>
assertEquals(listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>), (<span class="hljs-number">1.</span><span class="hljs-number">.100</span>) takeWhile { it &#x3C;= <span class="hljs-number">5</span> })

<span class="hljs-comment">// takeWhileTo</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// take numbers while they're less then 5 from a range of 1 to a 100</span>
<span class="hljs-keyword">val</span> takeWhileToList = arrayListOf&#x3C;<span class="hljs-built_in">Int</span>>()
assertEquals(listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>), (<span class="hljs-number">1.</span><span class="hljs-number">.100</span>).takeWhileTo(takeWhileToList) { it &#x3C;= <span class="hljs-number">5</span> })</code></pre>
]]></description><link>http://jamie.mccrindle.org/2013/01/exploring-kotlin-standard-library-part-1.html</link><guid isPermaLink="true">http://jamie.mccrindle.org/2013/01/exploring-kotlin-standard-library-part-1.html</guid><category><![CDATA[Kotlin]]></category><dc:creator><![CDATA[Jamie McCrindle]]></dc:creator><pubDate>Tue, 22 Jan 2013 05:01:00 GMT</pubDate></item></channel></rss>